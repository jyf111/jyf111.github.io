<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode 162/1901. 寻找峰值I/II</title>
      <link href="/2023/12/21/Leetcode-162-1901-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BCI-II/"/>
      <url>/2023/12/21/Leetcode-162-1901-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BCI-II/</url>
      
        <content type="html"><![CDATA[<h2 id="I"><a class="header-anchor" href="#I">¶</a>I</h2><p>一个元素<strong>互不相同</strong>的一维数组，要求$O(\log n)$找到一个峰值，即大于左右两边值的位置。a[-1]和a[n]是$-\infty$</p><p>考虑二分答案mid，如果a[mid] &gt; a[mid + 1]，在[l, mid - 1]间肯定存在答案，因为可以把mid+1视作n这个角色；同理a[mid] &lt; a[mid + 1]，在[mid + 1, r - 1]间肯定有答案。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">find_peak_element</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">n</span> = nums.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">l</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r</span> = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ans</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">mid</span> = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">left</span> = <span class="keyword">if</span> mid == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="literal">true</span>   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[mid] &gt; nums[mid - <span class="number">1</span>]</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">right</span> = <span class="keyword">if</span> mid == n - <span class="number">1</span> &#123;</span><br><span class="line">                <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[mid] &gt; nums[mid + <span class="number">1</span>]</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> left &amp;&amp; right &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> left &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> right &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans <span class="keyword">as</span> <span class="type">i32</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="II"><a class="header-anchor" href="#II">¶</a>II</h2><p>二维版本，要求$O(n \log m)$。没做出来0.0，好菜</p><p>考虑二分行mid，再考虑这一行中的最大值a[mid][j]，如果a[mid][j] &lt; a[mid + 1][j]，则行[mid + 1, r - 1]肯定有答案，因为a[mid + 1][j]大于mid行的所有元素，而由于不断往比自己大的邻居移动一定能找到解，按这种方案一定不会穿越mid行；同理a[mid][j] &lt; a[mid - 1][j]，则行[l, mid - 1]肯定有答案。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">find_peak_grid</span>(mat: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">l</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r</span> = mat.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">mid</span> = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">index</span> = mat[mid].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>()</span><br><span class="line">            .<span class="title function_ invoke__">max_by</span>(|(_, a), (_, b)| a.<span class="title function_ invoke__">partial_cmp</span>(b).<span class="title function_ invoke__">unwrap_or</span>(std::cmp::Ordering::Equal))</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|(index, _)| index).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">if</span> mid &gt;= <span class="number">1</span> &amp;&amp; mat[mid][index] &lt; mat[mid - <span class="number">1</span>][index] &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> mid + <span class="number">1</span> &lt; mat.<span class="title function_ invoke__">len</span>() &amp;&amp; mat[mid][index] &lt; mat[mid + <span class="number">1</span>][index] &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vec!</span>[mid <span class="keyword">as</span> <span class="type">i32</span>, index <span class="keyword">as</span> <span class="type">i32</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vec!</span>[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode</title>
      <link href="/2023/12/21/VSCode/"/>
      <url>/2023/12/21/VSCode/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷键"><a class="header-anchor" href="#快捷键">¶</a>快捷键</h2><ul><li>Ctrl-Shift-P：命令面板</li><li>Alt：多光标</li><li>Ctrl：跳转</li><li>-&gt;：返回</li><li>Ctrl-F：搜索</li><li>Ctrl-H：替换</li><li>Ctrl-/：单行注释</li><li>Alt-Shift-A：多行注释</li><li>Ctrl-~：切换终端显示</li><li>Ctrl-=/-：放大/缩小</li></ul><p>font size = 14</p><h2 id="插件"><a class="header-anchor" href="#插件">¶</a>插件</h2><ul><li>Error Lens</li><li>Eva Theme：Eva Light Bold</li><li>Remote</li><li>Dev Containers</li><li>Material Icon Theme</li><li>Output Colorizer：高亮日志文本</li><li>Project Manager</li><li>TODO Highlight</li><li>WSL</li><li>Docker</li><li>Clang-Format</li><li>clangd/C/C++</li><li>CMake</li><li>Color Highlight</li><li>CommentAnchors</li><li>Cpp Reference</li><li>Doxygen Documentation</li><li>EditorConfig for VS Code</li><li>filesize</li><li>Git History</li><li>GitLens</li><li>GitHub Markdown Preview</li><li>Image preview</li><li>JSON</li><li>Live Server</li><li>Makefile Tools</li><li>Path Intellisense</li><li>Rainbow CSV</li><li>Syntax Highlighter</li><li>Trailing Spaces</li><li>YAML</li><li>Code Spell Checker</li><li>indent-rainbow：Light Style</li><li>Hex Editor</li><li>Shell Check</li><li>Markdown Lint</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conan包管理</title>
      <link href="/2023/12/13/Conan%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2023/12/13/Conan%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程</title>
      <link href="/2023/12/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/12/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp笔记</title>
      <link href="/2023/12/01/cpp%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/01/cpp%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="std-ref"><a class="header-anchor" href="#std-ref">¶</a>std::ref</h2><p>在传参时默认是拷贝，通过添加<code>std::ref</code>来使用引用。这在<code>std::bind</code>、<code>std::thread</code>以及模板（<code>std::make_pair</code>、<code>std::make_tuple</code>）等间接进行函数调用的地方有用。</p><h2 id="std-reference-wrapper"><a class="header-anchor" href="#std-reference-wrapper">¶</a>std::reference_wrapper</h2><p><code>std::ref</code>产生的就是一个包含引用的<code>std::reference_wrapper</code>的对象。从而能够声明一个引用数组。</p><p><code>reference_wrapper&lt;int&gt; arr[] &#123;x,y,z&#125;;</code></p><h2 id="this-nullptr"><a class="header-anchor" href="#this-nullptr">¶</a>this = nullptr</h2><p>这里类函数中没有使用任何类成员和类函数，也即与this的取值无关，通常会正常运行，但这仍然是未定义行为。</p><p>编译器其实会将类函数<code>ABC::print()</code>转化为一个全局的函数<code>void _ABC_print(ABC *this)</code>。</p><p>编译器优化会假设程序不包含UB，因此会假设<code>this != nullptr</code>，从而进行某些优化，导致不符合预期。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ABC</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ABC *ptr = <span class="literal">NULL</span>:</span><br><span class="line">        ptr-&gt;<span class="built_in">print</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delete this</code>是合法的，只要该对象时动态分配的，并且之后不再使用</p><h2 id="严格别名"><a class="header-anchor" href="#严格别名">¶</a>严格别名</h2><p><code>-fstrict-aliasing</code></p><p>严格别名规则指编译器在看到多个别名时，如果它们不满足严格别名要求，就认为它们指向不同的内存区域，从而进行优化，导致产生与我们预期不符的代码。</p><p>严格别名要求（这是C语言的定义，相对简单一些）：对象的值只能通过与该对象类型（1）兼容的类型及其CV限定、（2）有无符号版本及其CV限定、（3）成员中有该类型的union和聚合结构体、（4）字符类型访问。</p><p>这里的类型兼容是C语言的概念， 就是考虑typedef，数组退化指针后类型需要一致。</p><p><code>restrict</code>是C语言的一个关键字，表明两个指针不会指向相同区域，但C++没有这个关键字。C++可以使用<code>__restrict</code>。</p><p>正因为这个，<code>reinterpret_cast&lt;double*&gt;(char*)</code>在标准中其实是未定义的，但当前的编译器都保证生成的代码是正确的。标准做法则只能用memcpy来进行，所以C++20引入了constexpr的<code>byte_cast</code>。</p><p>同样地，C语言的宏<code>offset</code>在C++里其实也是个未定义行为。</p><p><code>static_cast</code>对指针类型的转换是很严格的，只能是相同类型的CV限定。</p><p><a data-fancybox="gallery" data-src="/post-images/cpp-argument-passing.png" data-caption="cpp-argument-passing"><img src="/post-images/cpp-argument-passing.png" alt="cpp-argument-passing"></a></p><p><a data-fancybox="gallery" data-src="/post-images/cpp-argument-passing.png" data-caption="cpp-performace"><img src="/post-images/cpp-argument-passing.png" alt="cpp-performace"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer语句</title>
      <link href="/2023/11/30/defer%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/11/30/defer%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>GO和Zig都自带了<code>defer</code>语句，在涉及到资源管理时，可以在下一行立即加上对应的<code>defer 释放资源</code>语句。这样在每次<strong>return后</strong>都会反向调用各个<code>defer</code></p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>要在C语言里实现defer，只能通过<code>setjmp</code>或者<code>goto</code>这种跳转，并且只能在<strong>return前</strong>进行。</p><h2 id="C-s2"><a class="header-anchor" href="#C-s2">¶</a>C++</h2><p>可以用<code>std::unique_ptr</code>包装资源，需要自行实现<code>deleter</code>。</p><p><code>defer</code>或<a href="https://github.com/Neargye/scope_guard/blob/master/include/scope_guard.hpp"><code>scope_exit</code></a>的实现就是利用RAII，在当前位置创建一个类，析构的时候执行。</p><p><code>SCOPE_EXIT&#123; file.close(); &#125;;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPool</title>
      <link href="/2023/11/22/ThreadPool/"/>
      <url>/2023/11/22/ThreadPool/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="/2023/11/22/%E5%93%88%E5%B8%8C/"/>
      <url>/2023/11/22/%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<p>$O(1)$单点插入、删除、查询。在数据库里主要用在<code>join</code>和<code>group by</code>中。</p><h2 id="静态哈希表"><a class="header-anchor" href="#静态哈希表">¶</a>静态哈希表</h2><p><a href="https://martin.ankerl.com/2022/08/27/hashmap-bench-01/">benchmark1</a></p><p><a href="https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/">benchmark2</a></p><p>有些哈希表是不稳定的（<code>flat_map</code>），存储在其中的value的地址可能因为插入和删除而失效（因为发生了rehash）。稳定的方法通常需要通过间接寻址（<code>node_map</code>）。</p><p><code>node_map</code>和<code>flat_map</code>的区别是<code>flat_map</code>将value直接存到数组中，因此在rehash时地址会改变，而<code>node_map</code>将value存在另一个保持不变的数组中，其优点是提供了稳定性，并且可以存储不可移动或不可复制的元素，并且也更适合大value对象（因为把大对象直接存到数组中会破坏cache），但也导致了额外开销。</p><p>关键点：哈希函数、冲突解决方法。</p><p>MurmurHash、Facebook XXHash</p><h3 id="开放寻址"><a class="header-anchor" href="#开放寻址">¶</a>开放寻址</h3><ul><li>线性探测：如果映射位置已经被占用，就检查紧接着的下一个位置，不断重复</li><li>二次探测：如果被占用，则检查+1^2, -1^2, +2^2, -2^2…</li></ul><p>删除的时候一种是所有元素都重hash，另一种是用tombstome标记。</p><h3 id="布谷鸟哈希"><a class="header-anchor" href="#布谷鸟哈希">¶</a>布谷鸟哈希</h3><p>布谷鸟在孵化时会将一些蛋/幼鸟推出巢外，布谷鸟哈希在插入新key时，可能把旧key移动到其它位置。</p><p>通用的讲：布谷鸟哈希使用n个哈希函数，然后将key插入到其中第一个空闲的哈希位置，如果都非空，就选择踢掉一个冲突的key，并重新插入这个冲突的key。</p><p>这里介绍使用两个哈希表$T_1$和$T_2$，以及两个哈希函数$h_1$和$h_2$的版本。</p><h4 id="查找"><a class="header-anchor" href="#查找">¶</a>查找</h4><p>查找$T_1[h_1(x)]$和$T_2[h_2(x)]$即可。</p><h4 id="删除"><a class="header-anchor" href="#删除">¶</a>删除</h4><p>同理。</p><h4 id="插入"><a class="header-anchor" href="#插入">¶</a>插入</h4><p>如果$T_1[h_1(x)]$为空，就插入；否则替换为$x$（踢掉旧值$x’$），并将原有的$x’$插入到$T_2$，不断重复至多MAX_LOOP次（这个过程中可能发生死循环）。超过固定阈值，就扩展两个哈希表，进行重哈希。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> lookup(x):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAX_LOOP):</span><br><span class="line">        <span class="keyword">if</span> T1[h1(x)] <span class="keyword">is</span> empty:</span><br><span class="line">            T1[h1(x)] = x</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        swap(x, T1[h1(x)])</span><br><span class="line">        <span class="keyword">if</span> T2[h2(x)] <span class="keyword">is</span> empty:</span><br><span class="line">            T2[h2(x)] = x</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        swap(x, T2[h2(x)])</span><br><span class="line">    rehash()</span><br><span class="line">    insert(x)</span><br></pre></td></tr></table></figure><p>如果将$T_1[h_1(x)]$和$T_2[h_2(x)]$看作一条边，就构成一张图。</p><p>其优点是最坏复杂度有保证，并且查找过程可以完全向量化，适用于大量单点查询的场景。</p><p>其缺点是缓存不友好。rocksdb的一个优化方案是在某个哈希映射冲突时，进一步尝试连续的若干位置（+1,+2,…），这被称作布谷鸟块，这样可以通过预取这个块来加速（85%的key都在第一个布谷鸟块中）。</p><h4 id="布谷鸟过滤器"><a class="header-anchor" href="#布谷鸟过滤器">¶</a>布谷鸟过滤器</h4><p>相比于布隆过滤器，能够支持删除操作。</p><h3 id="std-unordered-map"><a class="header-anchor" href="#std-unordered-map">¶</a>std::unordered_map</h3><p>使用拉链法实现，有多个桶，每个桶都是一个链表。<code>max_load_factor</code>是元素个数除以桶个数的上限（默认为1），当超过这个上限时，说明桶的个数过少了，就会将<code>bucket_size</code>扩大2倍，然后重新进行hash。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">unordered_map</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; *buckets;</span><br><span class="line">    <span class="type">int</span> bucket_size;</span><br><span class="line">    <span class="type">int</span> total_elements;</span><br><span class="line">    <span class="type">float</span> max_load_factor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式是很慢的，因为数据局部性很差，cache不友好。但因为C++标准规定在插入或删除元素时其他元素必须有效，因此选择了拉链法，但更现代的hashmap通常采用线性探测或其变种。</p><h3 id="robin-hood-unordered-flat-map"><a class="header-anchor" href="#robin-hood-unordered-flat-map">¶</a>robin_hood::unordered_flat_map</h3><p>robin hood是线性探测的变种。通过劫富济贫来优化每个元素的实际位置与其哈希位置的距离。在插入时，如果当前元素的距离已经比占用元素的距离大（占用元素更富有），那就取代这个占用元素，让占用元素继续找下一个空的位置。避免了线性探测中某些元素极度贫困的问题，需要连续多次探测。</p><h3 id="slotmap"><a class="header-anchor" href="#slotmap">¶</a>slotmap</h3><p>与常规的hashmap需要自己提供key和value不同，slotmap只在插入时只需要提供value，然后会自动返回一个唯一且永久有效的key。</p><h3 id="优化"><a class="header-anchor" href="#优化">¶</a>优化</h3><ul><li>通常会根据键值的类型、大小以及取值分布选择合适的哈希函数和解决冲突方式</li><li>使用版本号实现快速的清空操作</li></ul><h2 id="动态哈希表"><a class="header-anchor" href="#动态哈希表">¶</a>动态哈希表</h2><h3 id="拉链法"><a class="header-anchor" href="#拉链法">¶</a>拉链法</h3><p>拉链法可以算作一种动态哈希表的类型。因为线性探测中元素的个数只能固定在预设的N个，要扩大只能rehash，而拉链法中链表没有大小限制，但实际会通过负载因子来进行平衡。</p><p>可以套上布隆过滤器避免无用的查找。</p><h3 id="可扩展哈希"><a class="header-anchor" href="#可扩展哈希">¶</a>可扩展哈希</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股记录</title>
      <link href="/2023/11/20/%E5%85%AB%E8%82%A1%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/11/20/%E5%85%AB%E8%82%A1%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="C-C"><a class="header-anchor" href="#C-C">¶</a>C/C++</h2><h3 id="编译过程"><a class="header-anchor" href="#编译过程">¶</a>编译过程</h3><ul><li>预处理：<code>-E</code></li><li>编译：生成汇编代码 <code>-S</code></li><li>汇编：生成包含机器码的目标文件 <code>-c</code></li><li>链接：将多个目标文件和库文件组合成可执行文件（需要进行符号解析和重定位）<ul><li>静态链接：在编译阶段将静态库直接加入到目标文件中（静态库其实就是一组目标文件）</li><li>动态链接：只是加入一些描述性信息，在运行时（程序入口函数执行之前）才真正定位符号运行时才加载共享库到程序的虚拟地址空间中，利用PLT间接调用</li></ul></li></ul><h3 id="字节序"><a class="header-anchor" href="#字节序">¶</a>字节序</h3><ul><li>大端序：高位在低地址</li><li>小端序：高位在高地址</li></ul><p>x86采用小端序。网络字节序统一为大端序。</p><h3 id="lambda"><a class="header-anchor" href="#lambda">¶</a>lambda</h3><p>lambda是一个匿名函数，对应一个仿函数（重载了<code>operator()</code>的类）。</p><ul><li>简化了编写</li><li>方便传入函数类型参数</li><li>可以捕获上下文变量，可以写在函数体内</li></ul><p>lambda生成的<code>operator()</code>永远带有const限定（从而保证每次调用的结果都是一样的），如果需要修改拷贝捕获的变量，应该添加<code>mutable</code>，此时修改的影响是永久的。</p><p>C++14泛型lambda，参数类型写成<code>auto</code>即可。不过每个<code>auto</code>都对应一个模板参数（可以理解成是通过auto推导的参数类型）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x, U y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br></pre></td></tr></table></figure><p>递归lambda</p><ul><li>C++11，使用<code>std::function</code>，这样每次都要先经过<code>std::function</code>，性能很差</li><li>C++14，使用一个额外的右值引用自身的参数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fib = [](<span class="keyword">auto</span> &amp;&amp;fib, <span class="type">int</span> n)  -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">fib</span>(fib, n - <span class="number">1</span>) + <span class="built_in">fib</span>(fib, n - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">fib</span>(fib, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="volatile"><a class="header-anchor" href="#volatile">¶</a>volatile</h3><p>volatile关键字用于表明对应变量的值可能被不经意的修改（硬件、多线程、信号），因此让编译器不要做出该变量不会被自己修改的假设，从而不进行过度的优化（不会优化掉任何一次读写，不会缓存到寄存器中，也不会对指令顺序进行重排）</p><p>避免编译器指令重排，处理器乱序执行。</p><h3 id="static"><a class="header-anchor" href="#static">¶</a>static</h3><ul><li>在全局是设置静态生命周期和内部链接</li><li>在局部是设置静态生命周期和初始化一次</li><li>在类内是设置属于整个类，所有类共享，而不是绑定到具体的对象实例</li></ul><h3 id="inline"><a class="header-anchor" href="#inline">¶</a>inline</h3><p>inline最初用于提示编译器将函数内联优先于函数调用，可以用<code>__attribute__((always_inline))</code>。</p><p>现在inline用于表明修饰的变量和函数只有一个实例，由编译器保证这一点主要用在头文件中（类比之间的<code>extern</code>声明和定义分开的方式）。</p><p>在类内定义的函数都会隐式内联。constexpr函数会隐式内联。</p><h3 id="explicit"><a class="header-anchor" href="#explicit">¶</a>explicit</h3><p>作用在单参数构造函数是避免隐式转换。也可以作用在多参数构造函数上，表示禁止使用<code>&#123;&#125;</code>进行初始化。</p><p><code>()</code>在空时为值初始化，非空时为直接初始化（即通过构造函数）。<code>&#123;&#125;</code>使用列表初始化，在空时即值初始化，非空时为聚合初始化。</p><h3 id="std-function"><a class="header-anchor" href="#std-function">¶</a>std::function</h3><p>包装任意可调用对象，包括函数指针、lambda和functors。</p><p><code>std::any</code>和<code>std::function</code>的一种实现方式是利用一个基类指针，然后子类是一个模板类，不管传入什么，都构造一个模板类，然后用基类指针指向它，要操作的时候再向下转型即可。</p><p>本质还是用一个模板类容纳一切，只不过<code>std::any</code>和<code>std::function</code>有自己的模板参数要求，所以只能把这个模板类包装在里面，然后利用基类指针起到一个void*的作用。</p><p>这里也有点Pimpl范式的意思，<code>std::any</code>和<code>std::function</code>只提供接口和包含一个指向具体实现类的指针。</p><p>对于<code>std::function</code>会涉及到虚函数调用，对于lambda还会涉及到动态内存分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Any</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(<span class="type">const</span> T&amp; t)</span> : ptr&#123;</span> <span class="keyword">new</span> <span class="built_in">Data</span>&lt;T&gt;(t) &#125; &#123;&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Data</span> : Base &#123;</span><br><span class="line">        T data;</span><br><span class="line">        <span class="built_in">Data</span>(<span class="type">const</span> T&amp; t) : <span class="built_in">data</span>(t) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Base *ptr;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T&amp; <span class="title">get_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Data&lt;T&gt;*)ptr)-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="std-vector"><a class="header-anchor" href="#std-vector">¶</a>std::vector</h3><p>2倍扩容效率更高，因为只需要进行位运算。1.5倍扩容可以减少内存碎片。</p><p>只有以倍率扩容才能使得复杂度均摊$O(1)$，而2倍扩容的问题是无法复用已经释放的空间，因为前面加起来的空间都比当前需要的空间小，而1.5倍扩容则可能可以服用之前的空间。</p><h3 id="面向对象"><a class="header-anchor" href="#面向对象">¶</a>面向对象</h3><ul><li>封装：将数据和操作数据的函数组合在一起，隐藏实现细节，只暴露行为，减少耦合</li><li>继承：可以继承已有类的数据和函数，还可以重写，提高代码重用</li><li>多态：主要指的是子类型多态，即可以用基类指针和引用使用派生类的函数。此外还包括参数多态，即泛型，以及特设多态，即重载，相同函数对不同类型执行不同操作。</li></ul><p>模板、类型擦除、虚函数表、字典</p><h3 id="类的内存布局"><a class="header-anchor" href="#类的内存布局">¶</a>类的内存布局</h3><p>静态成员不占用类对象的内存。成员函数不占用类对象的内存。数据成员访问级别不影响内存排布，均按照声明顺序，并进行适当对齐。</p><p>当有虚函数时，会有虚函数指针，且永远位于起始位置。（一个类向上转型之后，但是虚函数指针还是指向自己的那份虚函数表）</p><p>虚函数表在常量区。</p><p>当有继承关系时，起始位置是基类。</p><p>当有多个继承关系时，会从起始位置开始依次存放各个基类（此时向上转型可能存在偏移，<code>static_cast</code>会自动处理这一点，但<code>reinterpret_cast</code>不会）。</p><h3 id="多态的实现"><a class="header-anchor" href="#多态的实现">¶</a>多态的实现</h3><ul><li>运行时多态</li></ul><p>虚函数表包含了一个类的所有虚函数的地址。当派生类重写了基类的虚函数时，派生类的虚函数表会使用自己的函数地址，否则继承函数地址。</p><p>每个包含虚函数的类的对象都有一个虚函数指针。</p><p>显然构造函数不能是虚函数，因为此时对象还没有实例化，还没有虚函数指针。</p><p>对于指向final类型的指针，因为不存在指向的子类可能，所以编译器很容易进行去虚函数。</p><ul><li>编译时多态</li></ul><p>CRTP</p><p>本质上就是把类型信息存在模板里了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> specific_animal&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">who</span><span class="params">()</span> </span>&#123; <span class="built_in">static_cast</span>&lt;specific_animal*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">who</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数重写不会考虑访问控制是否不同，子类可以修改父类的访问控制，并且虚函数仍然起作用，编译器会根据调用函数的类型判断是否符合访问控制，不会去考虑多态问题。</p><h3 id="RTTI-运行时类型识别"><a class="header-anchor" href="#RTTI-运行时类型识别">¶</a>RTTI 运行时类型识别</h3><ul><li>typeid操作符：返回唯一标识对应类型的类型信息对象<code>type_info</code>（<code>typeid(A).name()</code>）</li><li>异常处理catch匹配</li><li>动态类型转换dynamic_cast</li></ul><p>为了解决虚函数多态，会在虚函数表的起始位置的前一项保存一个指向<code>type_info</code>对象的指针。</p><h3 id="new和malloc"><a class="header-anchor" href="#new和malloc">¶</a>new和malloc</h3><ul><li>new会返回对应类型的指针，并且会调用构造函数进行初始化，而malloc只会返回void*</li><li>new是C++中的一个关键字，而malloc是一个库函数</li><li>new只需要传入类型信息，会自动计算需要分配的内存大小</li><li>失败时new会抛出<code>bad_alloc</code>的异常，而malloc返回NULL</li></ul><p>new调用了<code>operator new()</code>，其中大概率会调用<code>malloc()</code>，最后调用构造函数进行初始化。</p><p>placement new：在已分配内存上初始化一个对象（<code>std::vector</code>就需要这个）<code>new(address)A()</code></p><p><code>new[n]</code>会额外存储数组大小，然后调用n次构造函数，<code>delete[]</code>时调用n次析构。</p><h3 id="main函数启动"><a class="header-anchor" href="#main函数启动">¶</a>main函数启动</h3><ul><li>将argc、argv参数入栈</li><li>调用<code>_start</code>函数</li><li>调用<code>__libc_start_main</code></li><li>调用<code>__libc_csu_init</code></li><li>调用<code>_init</code>函数</li></ul><h3 id="std-swap"><a class="header-anchor" href="#std-swap">¶</a>std::swap</h3><p>可以把swap当成一个永远不会失败且不会抛出异常的操作。主要用于实现拷贝赋值函数。如果不用<code>std::swap</code>就需要分步进行<code>new</code>一个新的，<code>delete</code>旧的，这会涉及异常失败的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T &amp;a,T &amp;b)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = std::<span class="built_in">move</span>(a);</span><br><span class="line">    a = std::<span class="built_in">move</span>(b);</span><br><span class="line">    b = std::<span class="built_in">move</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">dumb_array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> dumb_array&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) <span class="comment">// (1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get the new data ready before we replace the old</span></span><br><span class="line">        std::<span class="type">size_t</span> newSize = other.mSize;</span><br><span class="line">        <span class="type">int</span>* newArray = newSize ? <span class="keyword">new</span> <span class="type">int</span>[newSize]() : <span class="literal">nullptr</span>; <span class="comment">// (3)</span></span><br><span class="line">        std::<span class="built_in">copy</span>(other.mArray, other.mArray + newSienze, newArray); <span class="comment">// (3)</span></span><br><span class="line">        <span class="comment">// replace the old data (all are non-throwing)</span></span><br><span class="line">        <span class="keyword">delete</span> [] mArray;</span><br><span class="line">        mSize = newSize;</span><br><span class="line">        mArray = newArray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意参数改成传值了</span></span><br><span class="line">dumb_array&amp; <span class="keyword">operator</span>=(dumb_array other) <span class="comment">// (1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, other); <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移动构造也很简单</span></span><br><span class="line"><span class="built_in">dumb_array</span>(dumb_array&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">    : <span class="built_in">dumb_array</span>() <span class="comment">// initialize via default constructor, C++11 only</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元运算符"><a class="header-anchor" href="#友元运算符">¶</a>友元运算符</h3><p>对于流运算符等，第一个参数不是该类，因此只能通过友元来实现。</p><p>友元是单向的，且不具有传递性。</p><h3 id="空类大小"><a class="header-anchor" href="#空类大小">¶</a>空类大小</h3><p>在C++中不为0，因为C++标准要求每个对象都有独一无二的地址。</p><p>空基类优化：如果基类是空的（即不包含非静态的成员），那么在子类的内存布局中不会包含该基类，而如果使用组合而不是继承，则会额外多1个字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">sizeof</span>(Derived) == <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>编译器自动为空类生成以下函数，如果需要被使用到：</p><ul><li>无参构造</li><li>拷贝构造</li><li>移动构造</li><li>拷贝赋值</li><li>移动赋值</li><li>析构</li></ul><p>虽然构造函数和析构函数都可以抛出异常，但最好不要这么做。如果在构造函数中抛出异常，说明该对象没有构造成功，就不会调用对应的析构函数。</p><h3 id="命名空间"><a class="header-anchor" href="#命名空间">¶</a>命名空间</h3><ul><li>避免名称冲突</li><li>组织代码</li><li>匿名命名空间具有内部链接，其效果等价于static的全局变量和函数，并且还可以作用在类上。匿名命名空间相当于生成一个全局唯一的名字，并在当前文件下添加using指示，从而只有在当前文件中可以访问这些变量、函数和类。显然这用在头文件里是没用的。</li><li>内联命名空间，这个命名空间可存在也可不存在</li></ul><h3 id="类型转换"><a class="header-anchor" href="#类型转换">¶</a>类型转换</h3><ul><li>static_cast</li></ul><p>用来处理常规转型，包括类的向上转型（会添加偏移），添加const。</p><p>相比于C风格转换，static_cast会做一些检查，并且在代码中更容易被注意到。</p><p><code>error: invalid ‘static_cast’ from type ‘char*’ to type ‘int*’</code></p><ul><li>const_cast</li></ul><p>用来移除CV限定符。把const的变量变成非const是未定义的，去掉const主要用在指针和引用上。</p><ul><li>dynamic_cast</li></ul><p>用来处理指针与引用引起的多态，向下转型。</p><ul><li>reinterpret_cast</li></ul><p>用来处理比特级别的转型，按照另一种类型重新解释这段比特。在指针之间转化不会改变地址，在指针与数值间转换。</p><ul><li>bit_cast</li></ul><p>遵守强制别名规则，更加安全，且是constexpr的，同时也有更多限制（必须是相同大小，trivially copy等）。</p><h3 id="指针和引用的区别"><a class="header-anchor" href="#指针和引用的区别">¶</a>指针和引用的区别</h3><p>这里默认说的是左值引用，可以认为是指针常量（顶层const）的语法糖。虽然底层默认通过指针、地址实现，但应该把引用视作别名，它不占用空间。</p><ul><li><p>指针存储地址，引用是别名</p></li><li><p>指针可以为空，引用必须被初始化且不能为空</p></li><li><p>指针可以被重新赋值，引用不可以</p></li><li><p>指针有自己的地址，可以用sizeof计算大小</p></li><li><p>指针可以有多级，引用只有一级</p></li><li><p>有指向指针的指针，但是没有指向引用的指针</p></li><li><p>有指针数组，但没有引用数组</p></li><li><p>const引用可以绑定到常量</p></li><li><p>野指针：未经初始化的指针，可能指向任何地方</p></li><li><p>空指针</p></li><li><p>悬挂指针：指向已销毁的对象</p></li><li><p>指针常量：指针本身是一个常量</p></li><li><p>常量指针：指向常量的指针</p></li></ul><h3 id="单例模式"><a class="header-anchor" href="#单例模式">¶</a>单例模式</h3><p>保证一个类只有一个实例。用局部静态变量即可，静态变量的初始化是会加锁的，并且自带了懒初始化特性。</p><p>在某些场景下，套一层<code>shared_ptr</code>可以更好地避免提前析构的问题。</p><p>饿汉：在程序加载时就实例化对象。懒汉：仅在第一次使用时才实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton INSTANCE;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Singleton&gt; <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::shared_ptr&lt;Singleton&gt; s&#123;<span class="keyword">new</span> Singleton&#125;;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="智能指针"><a class="header-anchor" href="#智能指针">¶</a>智能指针</h3><ul><li><code>shared_ptr</code></li><li><code>unique_ptr</code></li><li><code>weak_ptr</code></li></ul><p><code>unique_ptr&lt;T&gt;</code>要求在遇到析构函数时T是完整类型，但不要求构造函数；而<code>shared_ptr&lt;T&gt;</code>要求在遇到构造函数时T是完整类型，但不要求析构函数。</p><p><code>shared_ptr</code>的引用计数是在堆上上，这样才能被多个<code>shared_ptr</code>共享。</p><p>手写<code>shared_ptr</code>。</p><p>关键就是拷贝构造、拷贝赋值、移动构造、移动赋值这个函数的写法。</p><p>因为移动通常只窃取资源，不涉及资源分配，所以一般不涉及异常。显示标记<code>noexcept</code>的好处是性能的提升。特别地，在<code>std::vector</code>的扩容中，如果其移动构造会抛出异常，则<code>std::vector</code>会转而选择拷贝构造，以保证它的强异常安全性。因为移动构造如果失败，会出现vector中部分对象无效的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SharedPtr</span><span class="params">(T *ptr)</span> : ptr_(ptr), ref_count_(new std::atomic&lt;uint32_t&gt;(<span class="number">1</span>)) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr &amp;rhs) &#123;</span><br><span class="line">    ptr_ = rhs.ptr_;</span><br><span class="line">    ref_count_ = rhs.ref_count_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      (*ref_count_)++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SharedPtr</span>(SharedPtr &amp;&amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    ptr_ = rhs.ptr_;</span><br><span class="line">    ref_count_ = rhs.ref_count_;</span><br><span class="line">    rhs.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    rhs.ref_count_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SharedPtr&amp; <span class="keyword">operator</span>=(SharedPtr rhs) &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(rhs, *<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SharedPtr&amp; <span class="keyword">operator</span>=(SharedPtr &amp;&amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cleanup</span>();</span><br><span class="line">    ptr_ = rhs.ptr_;</span><br><span class="line">    ref_count_ = rhs.ref_count_;</span><br><span class="line">    rhs.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    rhs.ref_count_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">SharedPtr</span>() &#123;</span><br><span class="line">    <span class="built_in">cleanup</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">ref_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ref_count_-&gt;<span class="built_in">load</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ref_count_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      (*ref_count_)--;</span><br><span class="line">      <span class="keyword">if</span> ((*ref_count_) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">delete</span> ptr_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> ref_count_;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T *ptr_;</span><br><span class="line">  std::atomic&lt;<span class="type">uint32_t</span>&gt; *ref_count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="并发编程"><a class="header-anchor" href="#并发编程">¶</a>并发编程</h3><p>并发、并行</p><p>线程：</p><p><code>std::thread</code></p><ul><li><p><code>join</code></p></li><li><p><code>detach</code></p></li><li><p><code>yield</code></p></li><li><p><code>get_id</code></p></li><li><p><code>sleep_for</code>, <code>sleep_until</code></p></li><li><p><code>call_once</code></p></li><li><p><code>once_flag</code></p></li><li><p><code>thread::hardware_concurrency</code></p></li></ul><p><a data-fancybox="gallery" data-src="/post-images/cpu-cache.png" data-caption="cpu-cache"><img src="/post-images/cpu-cache.png" alt="cpu-cache"></a></p><p>互斥锁：</p><ul><li><p><code>mutex</code></p></li><li><p><code>lock</code>：以无死锁的方式加多个锁</p></li><li><p><code>unique_lock</code>：在需要自行加锁和解锁时使用</p></li><li><p><code>shared_lock</code></p></li><li><p><code>lock_guard</code>：RAII，在构造时锁定，在析构时解锁，用于单个锁，比unique_lock的接口更少，性能更好一些</p></li><li><p><code>scoped_lock</code>：RAII，以无死锁的方式加多个锁</p></li><li><p><code>std::defer_lock</code></p></li><li><p><code>std::adopt_lock</code></p></li></ul><p>条件变量：</p><ul><li><code>condition_variable</code><ul><li><code>wait</code>, <code>notify_one</code>, <code>notify_all</code></li></ul></li></ul><p>由于存在虚假唤醒问题，必须使用while来检查条件是否真的满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">    cond.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步</p><ul><li><code>async</code></li><li><code>future</code></li><li><code>packaged_task</code></li><li><code>promise</code></li></ul><h3 id="内存模型"><a class="header-anchor" href="#内存模型">¶</a>内存模型</h3><p>主要是为了实现无锁编程。</p><ul><li>原子操作</li><li>操作的顺序</li><li>操作的可见性</li></ul><p>编译器乱序、处理器乱序，这些乱序都只保证<strong>不会修改单线程的行为</strong>。</p><p><code>asm volatile(&quot;&quot; ::: &quot;memory&quot;);</code>用于阻止编译器乱序。</p><p><a data-fancybox="gallery" data-src="/post-images/cache.png" data-caption="cache"><img src="/post-images/cache.png" alt="cache"></a></p><p>缓存一致性。</p><p>当多个线程访问同一个内存位置，并且其中只要有一个线程包含了写操作，如果这些访问没有一致的修改顺序，那么结果就是未定义的。</p><h3 id="内存泄露"><a class="header-anchor" href="#内存泄露">¶</a>内存泄露</h3><p><code>malloc</code>和<code>new</code>没有配对<code>free</code>和<code>delete</code>。</p><p><code>shared_ptr</code>循环引用。</p><h3 id="C-和C的区别"><a class="header-anchor" href="#C-和C的区别">¶</a>C++和C的区别</h3><p>C++是C的扩展，总体上兼容C，还提供了更多的编程范式（面向对象、重载、泛型、异常等等），但它们之间也存在分歧（ABI）。</p><h3 id="堆和栈"><a class="header-anchor" href="#堆和栈">¶</a>堆和栈</h3><ul><li>栈：每次进入函数时开辟栈帧，离开时释放栈帧，自动管理，速度快，但是空间比较小</li><li>堆：在运行时动态分配和释放，需要手动管理，速度慢，但是空间大</li></ul><p>栈连续，堆不一定连续（内部碎片、外部碎片）。申请方式一个自动一个手动。生长方向不同。</p><h3 id="容器适配器"><a class="header-anchor" href="#容器适配器">¶</a>容器适配器</h3><p>容器适配器在一般容器的基础上提供了不同的功能（限制了一些接口）。</p><p><code>queue</code>、<code>stack</code>都是基于<code>deque</code>实现的。<code>priority_queue</code>是基于<code>vector</code>实现的。</p><p><code>shrink_to_fit()</code>请求将<code>capcity</code>缩小为<code>size()</code>，可能触发reallocation。这是实现定义的，不一定保证会做。</p><p>一种可行的方法是用<code>swap</code>：<code>vector&lt;Person&gt;(persons).swap(persons);</code></p><h3 id="前置和后置递增"><a class="header-anchor" href="#前置和后置递增">¶</a>前置和后置递增</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>++() &#123;&#125; <span class="comment">// ++A</span></span><br><span class="line"><span class="type">const</span> A <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;&#125; <span class="comment">// A++</span></span><br></pre></td></tr></table></figure><h3 id="设计原则"><a class="header-anchor" href="#设计原则">¶</a>设计原则</h3><ul><li>开闭原则：对扩展开放，对修改关闭。在不修改已有代码的情况下，通过增加新功能进行扩展</li><li>单一职责：每个类只负责一件事，高内聚低耦合</li><li>依赖倒置：高层模块不依赖底层模块。通过依赖抽象进行解耦</li><li>里氏替换：子类应该能够替代父类，即需要完全继承和遵循父类的规定和约束</li></ul><h3 id="设计模式"><a class="header-anchor" href="#设计模式">¶</a>设计模式</h3><ul><li>单例</li><li>工厂</li><li>迭代器</li><li>适配器</li></ul><h3 id="测试"><a class="header-anchor" href="#测试">¶</a>测试</h3><ul><li>黑盒测试：检查外部功能是否正常（系统测试）</li><li>灰盒测试：检查多个模块组合是否正常（集成测试）</li><li>白盒测试：检查内部实现是否正确（单元测试）</li></ul><h2 id="操作系统"><a class="header-anchor" href="#操作系统">¶</a>操作系统</h2><h3 id="内存布局"><a class="header-anchor" href="#内存布局">¶</a>内存布局</h3><ul><li>代码段（text）<ul><li>只读</li><li>指令</li></ul></li><li>初始化数据段（data）<ul><li>手动初始化的全局变量和静态变量</li></ul></li><li>未初始化数据段（bss）<ul><li>未手动初始化的全局变量和静态变量</li></ul></li><li>堆（heap）</li><li>栈（stack）</li></ul><p>代码段和数据段统称为静态存储区，栈和堆则是动态存储区。此外还有只读数据段。</p><h3 id="Buffer和Cache"><a class="header-anchor" href="#Buffer和Cache">¶</a>Buffer和Cache</h3><p>Buffer（缓冲区）是系统两端处理速度平衡（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到流量整形的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。</p><p>Cache（缓存）则是系统两端处理速度不匹配时的一种折衷策略。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。</p><h3 id="原子操作"><a class="header-anchor" href="#原子操作">¶</a>原子操作</h3><p>Cache以Cache Line（64 bytes）为单位进行读写操作。</p><p>写回：写到缓存，标记为脏写直达：写到缓存和内存</p><p>多核存在缓存一致性问题。</p><p>总线嗅探广播写操作，代价较高。</p><p>MESI：缓存一致性协议。</p><p>在单核上原子操作只需要临时禁用中断来避免打断。</p><p>在多核上需要借助特殊的硬件机制或者同步原语。</p><ul><li>硬件原子指令：CAS</li><li>锁和同步源于：总线锁、缓存锁</li></ul><h3 id="进程、线程、协程的区别"><a class="header-anchor" href="#进程、线程、协程的区别">¶</a>进程、线程、协程的区别</h3><ul><li>进程：一个程序运行时的实体，有独立的地址空间、堆、栈、寄存器、系统资源</li><li>线程：执行任务和调度的最小单元，包含在进程之中，共享的资源比进程多，包括指令指针、寄存器、栈</li><li>协程：一个可以自行暂停执行和恢复执行的函数</li></ul><p>在Linux中，用户态线程被表示为轻量级进程，与进程的区别是资源共享的程度不同，线程共享了地址空间和系统资源，但在内核调度上没有区别。</p><p>多进程相比多线程更安全，因为隔离的资源多，互相的影响程度小。</p><h3 id="进程的状态"><a class="header-anchor" href="#进程的状态">¶</a>进程的状态</h3><ul><li>R：可执行状态（包括正在运行和可被调度运行）</li><li>S：可中断睡眠，因等待而挂起，如I/O、网络请求、以及手动的sleep</li><li>D：不可中断睡眠，很少见，通常在进行不可打断的原子操作</li><li>T：暂停或被跟踪</li><li>Z：退出，成为僵尸进程</li><li>X：退出，即将被销毁。当线程被detach，就不会像僵尸进程那样在进程描述表中保留元信息</li></ul><h3 id="进程优先级"><a class="header-anchor" href="#进程优先级">¶</a>进程优先级</h3><p>影响调度的。</p><p><code>ps</code>, <code>top</code>, <code>nice</code></p><h3 id="进程通信方式"><a class="header-anchor" href="#进程通信方式">¶</a>进程通信方式</h3><p>消息传递：</p><ul><li>管道（pipe，内核会在内存中维护一个有限容量的缓冲器）、命名管道（FIFO）</li><li>套接字（socket）</li><li>消息队列</li><li>信号（signal）</li><li>文件</li></ul><p>共享内存：</p><ul><li>共享内存（shmem）</li><li>内存映射（mmap）</li></ul><p>进程间同步：</p><ul><li>信号量</li><li>文件锁</li></ul><h3 id="线程通信方式"><a class="header-anchor" href="#线程通信方式">¶</a>线程通信方式</h3><ul><li>信号</li><li>互斥锁、自旋锁<ul><li>自旋锁会不断忙等待，而互斥锁由内核完成，在失败时会挂起，从而允许被调度走，因此如果明确锁的时间比较短，可以用自旋锁，因为互斥锁需要切换到内核</li></ul></li><li>条件变量</li><li>信号量<ul><li>就是一个计数器，可以原子加1和减1，二元信号量其实就可以作为互斥锁</li></ul></li><li>屏障</li></ul><h3 id="悲观锁与乐观锁"><a class="header-anchor" href="#悲观锁与乐观锁">¶</a>悲观锁与乐观锁</h3><p>悲观锁认为多线程同时修改共享资源的概率很高，所以每次访问资源都会上锁。</p><p>乐观锁则认为概率很低，先修改资源，再检查是否发生冲突，发生冲突则放弃本次操作。Git其实也可以算，利用版本号检查是否冲突。</p><h3 id="死锁"><a class="header-anchor" href="#死锁">¶</a>死锁</h3><p>多个线程互相等待对面释放资源，但都不会释放资源。</p><p>还有可能是对一个不可重入的互斥锁多次加锁。</p><p>四个必要条件：</p><ul><li><p>互斥：一个进程请求资源，其它进程只能等待</p></li><li><p>不可剥夺：不能强行夺走其它进程未释放的资源</p></li><li><p>请求和保持：其它进程请求时继续占有</p></li><li><p>循环等待：形成环等待</p></li><li><p>鸵鸟策略</p></li><li><p>死锁检测与恢复</p></li><li><p>死锁预防</p></li><li><p>死锁避免</p></li></ul><p>注意加锁和解锁的顺序。</p><p>查看offcpu，采样（定期pstack）</p><h3 id="I-O模型"><a class="header-anchor" href="#I-O模型">¶</a>I/O模型</h3><ul><li>同步阻塞</li><li>同步非阻塞</li><li>IO多路复用<ul><li>多个请求复用一个进程，类比CPU并发执行多个进程，这里一个进程处理多个请求</li><li><code>select/poll</code>：文件描述符集合（select用一个bitmap，poll用一个链表）</li><li><code>epoll</code>：使用红黑树</li></ul></li><li>信号驱动</li><li>异步：发起请求后立即返回，等内核完成后以信号的方式进行通知</li></ul><h3 id="用户态和内核态"><a class="header-anchor" href="#用户态和内核态">¶</a>用户态和内核态</h3><p>进行权限控制而设计的两种CPU运行级别。</p><p>内核态可以执行所有指令、访问所有空间和资源。而内核态不能访问内核地址空间或执行特权指令。内核态主要执行操作系统的内核代码，而用户态主要执行用户的应用程序。</p><p>切换过程：</p><ol><li>设置CPU状态为内核态</li><li>保存寄存器</li><li>设置栈指针为内核栈</li><li>设置程序计数器</li></ol><p>系统调用、异常、外部中断</p><p>中断是系统用来响应硬件设备请求的一种机制。</p><p>在执行中断处理程序时，无法响应其它中断。</p><p>改成程序的执行流。</p><p>陷阱（trap）：执行指令有意造成的异常</p><p>中断</p><ul><li>硬件中断：由外部硬件异步发起</li><li>软件中断：由软件执行中自行发起</li></ul><p>异常：执行指令产生错误（除0，缺页）</p><p>信号：通知进程发生了某个系统事件</p><h3 id="MMU"><a class="header-anchor" href="#MMU">¶</a>MMU</h3><p>内存管理单元，将用户访问的虚拟地址翻译为实际的物理地址。</p><h3 id="进程类别"><a class="header-anchor" href="#进程类别">¶</a>进程类别</h3><ul><li>守护进程：在后台运行，提供某种服务或长期执行任务</li><li>孤儿进程：父进程比子进程先结束，子进程由init进程接管</li><li>僵尸进程：子进程已经结束，但父进程还没有执行wait()获取其终止状态。为了让父进程能通过wait()获取其子进程的状态，子进程结束后会释放大部分资源，但仍然会在内核进程表中保留一条记录，其中包括子进程ID、终止状态等信息。无法通过信号杀死僵尸进程。当父进程退出后，会由init进程接管进行清理</li></ul><h3 id="回收线程"><a class="header-anchor" href="#回收线程">¶</a>回收线程</h3><p><code>pthread_join</code>、<code>pthread_exit</code>、<code>pthread_detach</code></p><p>线程池：每个线程不断查看工作队列，提取工作然后执行即可</p><h3 id="文件"><a class="header-anchor" href="#文件">¶</a>文件</h3><p>硬链接（指向同一个inode，不可跨文件系统）、软链接（一个新文件，文件内容是链接文件的路径）</p><p>删除正在使用的文件：inode会维护链接计数，还会维护打开的文件描述符个数。在删除最后一个链接时，如果还有打开的文件描述符，就不会删除该文件。</p><h2 id="计算机网络"><a class="header-anchor" href="#计算机网络">¶</a>计算机网络</h2><h3 id="网络模型"><a class="header-anchor" href="#网络模型">¶</a>网络模型</h3><p>物理层、数据链路层（以太网）、网络层（IP）、传输层（TCP、UDP）、应用层（HTTP）</p><p>七层网络模型在传输层之上还有会话层和表示层。</p><h3 id="TCP和UDP"><a class="header-anchor" href="#TCP和UDP">¶</a>TCP和UDP</h3><p>TCP是面向连接的可靠流式协议，而UDP是面向无连接的不可靠报文协议。TCP会通过确认和重传等机制保证数据被准确收到。</p><p>源端口和目的端口记录在TCP报文中，而源IP和目的IP记录在IP数据包中。</p><p>MTU：网络层最大传输单源MSS：TCP最大分段大小</p><p>TCP会进行分段，而UDP不会进行分段。</p><p>TCP通过分段来避免下层IP分片的发生，避免在接收端进行IP重组。同时避免重传大份数据。</p><h3 id="三次握手和四次挥手"><a class="header-anchor" href="#三次握手和四次挥手">¶</a>三次握手和四次挥手</h3><p>三次握手：</p><ul><li>客户端随机初始化一个seq，发送SYN</li><li>服务端回应ACK、SYN，以及一个随机的seq</li><li>客户端回应ACK，ackno为服务端seq+1，这里是可以携带数据的</li></ul><p>如果只进行两次连接，服务端可能会错误的建立一个历史连接。三次连接则可以给发起连接的客户端进行判断过滤的机会。</p><p>四次挥手：</p><ul><li>客户端发送带有FIN标志的报文（表示自己不再发送数据）</li><li>服务端回应ACK</li><li>服务端再发送带有FIN标志的报文（表示服务端也不再发送数据）</li><li>客户端再回应ACK</li></ul><p>被动断开方可以直接关闭。而主动断开方需要等待一段时间后关闭，等待时间一般是2MSL，其中MSL是最大报文段生存时间，主动断开方无法判断对方是否收到ACK，如果没有收到，会重新发送第三次挥手的FIN。</p><p>这里第二个和第三个报文可以合在一起，此时就变成了三次挥手。</p><ul><li><p>使用滑动窗口进行流量控制，避免发送者发送数据过快</p></li><li><p>超时重传：超时重传时间RTO，肯定要大于往返时间，一般取RTO=2RTT</p></li><li><p>拥塞控制：避免网络负载过大</p></li><li><p>慢启动：窗口大小从1开始，逐渐翻倍，避免瞬时的大量数据</p></li><li><p>拥塞避免</p></li><li><p>快重传</p></li><li><p>快恢复</p></li></ul><p>SYN随机的原因：避免旧的报文被错误接收、避免被伪造攻击</p><p>TCP SYN攻击：攻击者伪造大量不同IP的SYN报文发起连接，服务器应答ACK+SYN后，攻击者不继续回应，会占满服务器的半连接队列。</p><p>接收到SYN，就会将客户端放到半连接队列中（在Linux中称作incomplete connection，需要在虚拟文件中设置）；接收到应答，就放到Accept队列中（在Linux中称作completely established sockets waiting to be accepted，可以在<code>listen()</code>中的<code>backlog</code>参数设置）。调用<code>accpet()</code>从Accept队列中取出连接对象。</p><p>RTT (Round-Trip Time)：往返时延，数据从发送端到接收端再返回到发送端所需的时间。一定程度上反映了网络的拥塞程度。</p><p>KCP和QUIC是基于UDP的可靠协议。</p><h3 id="粘包"><a class="header-anchor" href="#粘包">¶</a>粘包</h3><p>字节流是没有边界的.Nagle算法用于改善网络传输效率，会将多个小消息组合起来一起发送。</p><h3 id="HTTP和HTTPS"><a class="header-anchor" href="#HTTP和HTTPS">¶</a>HTTP和HTTPS</h3><p>HTTP是明文传输的网络协议，而HTTPS增加了数据加密，还需要验证身份，更加安全。HTTPS的端口时443，而HTTP是80。</p><p>中间人攻击：攻击者与通讯双方分别创建独立的连接，并控制通讯双方的交互，但通讯双方以为是在直接通信。</p><p>SSL劫持</p><p>TLS：传输层安全协议，是SSL的升级版</p><h3 id="NAT-DNS-ARP"><a class="header-anchor" href="#NAT-DNS-ARP">¶</a>NAT DNS ARP</h3><ul><li>NAT：将内部私网IP映射为外部公网IP</li><li>DNS：IP到域名的映射（DNS服务器）</li><li>ARP：IP到MAC的映射（ARP广播）</li></ul><h3 id="浏览器输入URL"><a class="header-anchor" href="#浏览器输入URL">¶</a>浏览器输入URL</h3><ul><li>将URL，即域名解析为IP地址</li><li>与该IP对应的服务器通过三次握手建立TCP连接</li><li>发送请求</li><li>接收到响应</li><li>解析收到的HTML文件</li></ul><h2 id="算法"><a class="header-anchor" href="#算法">¶</a>算法</h2><h3 id="链表判环"><a class="header-anchor" href="#链表判环">¶</a>链表判环</h3><p>快慢指针如果相遇则有环。</p><p>找入环点：一个指针从头节点开始，另一个指针从相遇点开始，则它们会在入环点相遇。</p><p>2L + 2x = L + x + n * c</p><p>L = (n - 1) * c + c - x</p><h3 id="链表反转"><a class="header-anchor" href="#链表反转">¶</a>链表反转</h3><p>递归的写法最直白。</p><h3 id="最长回文子串"><a class="header-anchor" href="#最长回文子串">¶</a>最长回文子串</h3><h3 id="下一个排列"><a class="header-anchor" href="#下一个排列">¶</a>下一个排列</h3><p>以3,7,6,2,5,4,3,1为例，从后往前找到第一个升序对(2, 5)，然后将2用后面最小的大于它的数(3)替换，后面的数再升序排列即可。</p><h3 id="中位数"><a class="header-anchor" href="#中位数">¶</a>中位数</h3><p>对顶堆，一个大顶堆和一个小顶堆，主要处理动态中位数问题。</p><p>根据最高位划分，显然最高位为0的都小于最高位为1的，根据数量可以确定中位数在哪一堆里，不断分治即可（这个trick挺有用的）。</p><h2 id="智力-杂题"><a class="header-anchor" href="#智力-杂题">¶</a>智力/杂题</h2><h3 id="随机洗牌算法"><a class="header-anchor" href="#随机洗牌算法">¶</a>随机洗牌算法</h3><p>$O(n)$</p><p>从后往前是knuth算法，从前往后是inside-out算法，都是正确的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    j = random.randint(<span class="number">0</span>, i)</span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br></pre></td></tr></table></figure><p>正确的洗牌算法应该产生$n!$种结果。进一步再通过蒙特卡洛模拟每种结果的概率是否一样。</p><p><code>std::random_shuffle</code>使用<code>std::rand()</code>进行随机打乱，而<code>std::shuffle</code>使用更好的随机数生成器<code>urng</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> URNG &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuffle</span><span class="params">( RandomIt first, RandomIt last, URNG&amp;&amp; g )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> RandomFunc &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">random_shuffle</span><span class="params">( RandomIt first, RandomIt last, RandomFunc&amp;&amp; r )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="随机红包算法"><a class="header-anchor" href="#随机红包算法">¶</a>随机红包算法</h3><p>二倍均值法：每个人的金额在0.01到剩余均值（剩余钱数/剩余人数）的两倍之间随机</p><h3 id="25匹马5个赛道找出前3快"><a class="header-anchor" href="#25匹马5个赛道找出前3快">¶</a>25匹马5个赛道找出前3快</h3><p>需要比赛7次。</p><p>首先随便分成5组各比1次。然后每组最快的一起比1次，这样就知道最快的了。接着，第2名和第3名只有5种可能，所以再比1次即可。</p><h3 id="10只老鼠在1000瓶水里找出毒药"><a class="header-anchor" href="#10只老鼠在1000瓶水里找出毒药">¶</a>10只老鼠在1000瓶水里找出毒药</h3><p>显然用二进制，第i号的二进制表示中的第j位为1，就给第j只老鼠喝，最后根据死亡情况就知道了。</p><h3 id="高楼扔鸡蛋，只有2枚鸡蛋"><a class="header-anchor" href="#高楼扔鸡蛋，只有2枚鸡蛋">¶</a>高楼扔鸡蛋，只有2枚鸡蛋</h3><p>整体方案是间隔着尝试，因为一旦第一枚鸡蛋碎了，后面就只能一层一层来了。</p><p>设第一次在X楼扔，如果碎了需要X次；否则，应该在X+X-1楼扔，如果碎了仍然是X次，同理。。。</p><p>也就是1+…+(X-1)+X&gt;=100，X&gt;=14。</p><h3 id="用rand-7-生成rand-10"><a class="header-anchor" href="#用rand-7-生成rand-10">¶</a>用rand(7)生成rand(10)</h3><p>拒绝采样法。</p><p>只要能构造足够多的结果，然后选择其中10个概率相同的结果即可。比如<code>rand(7) * rand(7)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> first, second;</span><br><span class="line"><span class="keyword">while</span> ((first = <span class="built_in">rand7</span>()) &gt; <span class="number">6</span>);</span><br><span class="line"><span class="keyword">while</span> ((second = <span class="built_in">rand7</span>()) &gt; <span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> (first&amp;<span class="number">1</span>) == <span class="number">1</span> ? second : <span class="number">5</span>+second;</span><br></pre></td></tr></table></figure><h3 id="猴子搬香蕉"><a class="header-anchor" href="#猴子搬香蕉">¶</a>猴子搬香蕉</h3><p>100根香蕉，搬到50米远的家，每走一米就必须吃一根，问最后最多剩几根。</p><p>策略是先搬50根香蕉走x米，然后返回到原处，再搬50根香蕉到刚才的位置，然后合并一起搬回去。</p><p>50 - 2x + 50 - x &lt;= 50, x &gt;= 17</p><p>答案是100-50-2x = 16。</p><h3 id="N个强盗分M个金币"><a class="header-anchor" href="#N个强盗分M个金币">¶</a>N个强盗分M个金币</h3><p>每个强盗依次提出一种分配方案，如果超过半数的人同意就执行，否则杀死这个强盗。</p><p>从后前推。</p><p>最后一个强盗永远都是反对。倒数第二个强盗只有死的可能。倒数第三个强盗可以选择(M, 0, 0)，这样倒数第二个强盗不用死，肯定会同意。倒数第四个强盗可以选择(M - 2, 0, 1, 1)，这样最后两个强盗可以多得到1块钱，肯定会同意。倒数第五个强盗可以选择(M - 3, 0, 1, 2, 0)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性hash</title>
      <link href="/2023/11/19/%E4%B8%80%E8%87%B4%E6%80%A7hash/"/>
      <url>/2023/11/19/%E4%B8%80%E8%87%B4%E6%80%A7hash/</url>
      
        <content type="html"><![CDATA[<p>将大量请求均匀分配到分布式系统中对应的机器上。</p><p>需要解决机器扩容缩容的问题。</p><p>用$2^{32}$作为模数。</p><p>机器用IP地址进行哈希，数据也进行哈希，构成一个哈希环。</p><p>每个数据按照顺时针找到第一个机器。这样插入和删除机器只会影响到逆时针的一部分数据。</p><p>通过虚拟节点来提升平衡性。</p><p>每个机器对应多个逻辑上的位于哈希环上不同位置的虚拟节点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>doxygen</title>
      <link href="/2023/11/18/doxygen/"/>
      <url>/2023/11/18/doxygen/</url>
      
        <content type="html"><![CDATA[<p><code>doxygen -s -g</code> # 生成默认配置文件 Doxyfile</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@file</span><br><span class="line">@author</span><br><span class="line">@brief</span><br><span class="line">@param[in/out]</span><br><span class="line">@return</span><br><span class="line">@retval</span><br><span class="line">@details</span><br><span class="line">@see</span><br><span class="line">@note</span><br><span class="line">@warning</span><br><span class="line"></span><br><span class="line">多行注释：</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">单行注释：</span><br><span class="line">/** */</span><br><span class="line"></span><br><span class="line">与代码同在一行的注释:</span><br><span class="line">/**&lt; */</span><br></pre></td></tr></table></figure><p><code>doxygen Doxyfile</code>生成文档</p><p>Doxyfile中有用的设置</p><ul><li><code>OUTPUT_DIRECTORY</code></li><li><code>OUTPUT_LANGUAGE</code></li><li><code>EXTRACT_ALL</code></li><li><code>HAVE_DOT</code></li><li><code>CALL_GRAPH</code></li><li><code>RECURSIVE</code></li><li><code>INPUT</code></li><li><code>EXCLUDE</code></li><li><code>EXCLUDE_PATTERNS = */doc/* \</code></li><li><code>                   */benchmarks/*</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MessagePack</title>
      <link href="/2023/11/17/MessagePack/"/>
      <url>/2023/11/17/MessagePack/</url>
      
        <content type="html"><![CDATA[<p>一个二进制对象序列化库，类似于JSON，但是更快、更紧凑。</p><p>对小整数、小字符串、小数组的存储作了优化。</p><p>首先会有若干bit表示类型信息，对于变长数据，再用若干bit表示长度信息，最后是值信息。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Zsh配置</title>
      <link href="/2023/11/15/Zsh%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/11/15/Zsh%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh -y</span><br><span class="line">chsh -s $(which zsh)</span><br><span class="line"></span><br><span class="line">curl -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh</span><br></pre></td></tr></table></figure><h2 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h2><p>选择zimfw作为框架，而不是oh-my-zsh，速度更快，也更简单。</p><p>在<code>.zshrc</code>中添加以下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ZIM_HOME=$&#123;ZDOTDIR:-$&#123;HOME&#125;&#125;/.zim</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Download zimfw plugin manager <span class="keyword">if</span> missing.</span></span><br><span class="line">if [[ ! -e $&#123;ZIM_HOME&#125;/zimfw.zsh ]]; then</span><br><span class="line">  if (( $&#123;+commands[curl]&#125; )); then</span><br><span class="line">    curl -fsSL --create-dirs -o $&#123;ZIM_HOME&#125;/zimfw.zsh \</span><br><span class="line">        https://github.com/zimfw/zimfw/releases/latest/download/zimfw.zsh</span><br><span class="line">  else</span><br><span class="line">    mkdir -p $&#123;ZIM_HOME&#125; &amp;&amp; wget -nv -O $&#123;ZIM_HOME&#125;/zimfw.zsh \</span><br><span class="line">        https://github.com/zimfw/zimfw/releases/latest/download/zimfw.zsh</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Install missing modules, and update <span class="variable">$&#123;ZIM_HOME&#125;</span>/init.zsh <span class="keyword">if</span> missing or outdated.</span></span><br><span class="line">if [[ ! $&#123;ZIM_HOME&#125;/init.zsh -nt $&#123;ZDOTDIR:-$&#123;HOME&#125;&#125;/.zimrc ]]; then</span><br><span class="line">  source $&#123;ZIM_HOME&#125;/zimfw.zsh init -q</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Initialize modules.</span></span><br><span class="line">source $&#123;ZIM_HOME&#125;/init.zsh</span><br></pre></td></tr></table></figure><p>再创建<code>.zimrc</code>，该文件每行是一个zmodule，即一个插件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start configuration added by Zim install &#123;&#123;&#123;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This is not sourced during shell startup, and it&#x27;s only used to configure the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zimfw plugin manager.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Modules</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sets sane Zsh built-in environment options.</span></span><br><span class="line">zmodule environment</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Provides handy git aliases and <span class="built_in">functions</span>.</span></span><br><span class="line">zmodule git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Applies correct bindkeys <span class="keyword">for</span> input events.</span></span><br><span class="line">zmodule input</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sets a custom terminal title.</span></span><br><span class="line">zmodule termtitle</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Utility aliases and <span class="built_in">functions</span>. Adds colour to <span class="built_in">ls</span>, grep and less.</span></span><br><span class="line">zmodule utility</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Prompt</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Exposes to prompts how long the last <span class="built_in">command</span> took to execute, used by asciiship.</span></span><br><span class="line">zmodule duration-info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Exposes git repository status information to prompts, used by asciiship.</span></span><br><span class="line">zmodule git-info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A heavily reduced, ASCII-only version of the Spaceship and Starship prompts.</span></span><br><span class="line">zmodule asciiship</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Completion</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Additional completion definitions <span class="keyword">for</span> Zsh.</span></span><br><span class="line">zmodule zsh-users/zsh-completions --fpath src</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enables and configures smart and extensive tab completion.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">completion must be sourced after all modules that add completion definitions.</span></span><br><span class="line">zmodule completion</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Modules that must be initialized last</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fish-like syntax highlighting <span class="keyword">for</span> Zsh.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh-users/zsh-syntax-highlighting must be sourced after completion</span></span><br><span class="line">zmodule zsh-users/zsh-syntax-highlighting</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fish-like <span class="built_in">history</span> search (up arrow) <span class="keyword">for</span> Zsh.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh-users/zsh-history-substring-search must be sourced after zsh-users/zsh-syntax-highlighting</span></span><br><span class="line">zmodule zsh-users/zsh-history-substring-search</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fish-like autosuggestions <span class="keyword">for</span> Zsh.</span></span><br><span class="line">zmodule zsh-users/zsh-autosuggestions</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&#125;&#125;&#125; End configuration added by Zim install</span></span><br><span class="line"></span><br><span class="line">zmodule romkatv/powerlevel10k</span><br><span class="line">zmodule fzf</span><br></pre></td></tr></table></figure><p>大部分插件是默认就添加的。我只额外加了一些。</p><ul><li><p><code>powerlevel10k</code>：一个高度自定义的主题<code>p10k configure</code></p></li><li><p><code>fzf</code></p></li><li><p><code>zimfw install/uninstall</code></p></li><li><p><code>zimfw update</code></p></li><li><p><code>zimfw upgrade</code>：更新zimfw自己</p></li></ul><p>最近，在WSL2上如果不启动Docker Desktop会报一个关于docker命令补全文件找不到的错，解决方法如下：需要先打开Docker Desktop</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /usr/share/zsh/vendor-completions/_docker</span><br><span class="line">sudo cp /mnt/wsl/docker-desktop/cli-tools/usr/share/zsh/vendor-completions/_docker /usr/share/zsh/vendor-completions/</span><br><span class="line">sudo chattr +i /usr/share/zsh/vendor-completions/_docker</span><br></pre></td></tr></table></figure><h2 id="快捷键"><a class="header-anchor" href="#快捷键">¶</a>快捷键</h2><ul><li><code>C-a</code>：移动到行首</li><li><code>C-e</code>：移动到行尾</li><li><code>C-r</code>：搜索历史命令</li><li><code>C-u</code>：剪切当前行</li><li><code>C-k</code>：剪切光标到行尾的内容</li><li><code>C-y</code>：粘贴剪贴的内容</li></ul><h2 id="卸载"><a class="header-anchor" href="#卸载">¶</a>卸载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf $HOME/.zim</span><br><span class="line">rm $HOME/.zimrc</span><br></pre></td></tr></table></figure><p>并移除在<code>.zshrc</code>中添加的行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144</title>
      <link href="/2023/11/14/CS144/"/>
      <url>/2023/11/14/CS144/</url>
      
        <content type="html"><![CDATA[<h2 id="check0"><a class="header-anchor" href="#check0">¶</a>check0</h2><h3 id="webget"><a class="header-anchor" href="#webget">¶</a>webget</h3><p>熟悉Socket、FileDescriptor、Address这几个类及其接口即可，主要是connect，write、read、eof、shutdown这几个函数。</p><p>作为客户端，即连接的发起方，先创建一个socket，然后调用connect，再通过read和write读写，最后shutdown关闭。注意，客户端不需要显式地bind地址，在connect内部会进行bind操作，客户端的IP地址和端口设置由内核完成，显然它知道哪个端口是不被占用的，也知道哪个IP会更好（根据路由表）。</p><p>webget还是值得看一下源码的，了解一下Linux下TCP socket用modern C++怎么写。</p><ul><li>用<code>CheckSystemCall</code>把所有系统调用都包装了起来，统一进行错误处理</li><li>用<code>std::unique_ptr&lt;T, deleter&gt;</code>包装了所有需要自行free空间的函数调用</li></ul><h4 id="span"><a class="header-anchor" href="#span">¶</a>span</h4><p>一段连续数组上的视图（<code>std::string_view</code>只能是char*上的）。当Extend为static时，在模板中存储数组的大小，此时只需要一个指向数组开头的指针；而当Extend为dynamic时，还需要存储数组的大小。</p><h4 id="address"><a class="header-anchor" href="#address">¶</a>address</h4><p><code>getaddrinfo</code>返回一个<code>addrinfo</code>的结构体，包含IP地址和端口信息。<code>getnameinfo</code>与<code>getaddrinfo</code>相反，通过<code>addrinfo</code>结构体得到对应的host（即node）和serv（即service）信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">struct</span> addrinfo **res)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">char</span> *host, <span class="type">socklen_t</span> hostlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">char</span> *serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="file-descriptor"><a class="header-anchor" href="#file-descriptor">¶</a>file_descriptor</h4><p>包装了一下fd上的操作，如<code>read</code>、<code>write</code>、<code>close</code>，设置阻塞，查看是否关闭，是否EOF。</p><h5 id="readv-writev"><a class="header-anchor" href="#readv-writev">¶</a>readv/writev</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> &#123;</span><br><span class="line">    <span class="type">ptr_t</span> iov_base; <span class="comment">/* Starting address */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len; <span class="comment">/* Length in bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span></span>;</span><br></pre></td></tr></table></figure><p>结构体iovec代表一个缓冲区（可以类比string_view）。readv和writev用于读写多段非连续的缓冲区。</p><h4 id="socket"><a class="header-anchor" href="#socket">¶</a>socket</h4><p>构造socket。获取当前socket的地址信息。获取对端socket的地址信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>创建TCPSocket：<code>AF_INET</code>表示IPV4协议，<code>AF_UNIX</code>和<code>AF_LOCAL</code>表示本地通信</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h5 id="bind"><a class="header-anchor" href="#bind">¶</a>bind</h5><p>为socket绑定一个地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="connect"><a class="header-anchor" href="#connect">¶</a>connect</h5><p>向addr对应的socket发起连接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="shutdown"><a class="header-anchor" href="#shutdown">¶</a>shutdown</h5><p>关闭连接。how分为<code>SHUT_RD</code>、<code>SHUT_WR</code>、<code>SHUT_RDWR</code>，分别表示不允许进一步读、写、读/写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="listen"><a class="header-anchor" href="#listen">¶</a>listen</h5><p>让socket被动监听。<code>backlog</code>用于指定等待队列中请求连接的socket的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="accept"><a class="header-anchor" href="#accept">¶</a>accept</h5><p>与等待队列中第一个socket建立连接。如果等待队列为空，且socket的属性为阻塞，则会一直等待。非阻塞则可以使用<code>select</code>、<code>poll</code>、<code>epoll</code>来获取请求连接事件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="in-memory-byte-stream"><a class="header-anchor" href="#in-memory-byte-stream">¶</a>in-memory byte stream</h3><p>实现一个定长的buffer，其实就是经典的ring buffer。</p><p>如果写入过多，buffer放不下，直接丢弃。</p><p>最简单的写法是用<code>std::deque&lt;char&gt;</code>，但更好的写法应该是用一个char*数组（或<code>std::string</code>）加两个头尾指针实现。</p><p>如果只使用头尾指针，难点是如何区分空和满状态，可以留一个空位，也可以引入一个<code>size_</code>来表示当前的大小。</p><p>在写入的时候选择<code>std::string::copy</code>，而<code>std::string::replace</code>更适合处理src和dst长度不一样的情况。</p><p>在最新版本的实验代码中追加函数的参数改为了<code>std::string data</code>，而不是引用类型，因此应该充分利用移动语义。一种更高效的写法是使用<code>std::queue&lt;std::string&gt;</code>加<code>std::queue&lt;std::string_view&gt;</code>实现。新版本的<code>peek</code>函数只会查看首字符，而不是多个字符，因此用<code>std::queue</code>即可。</p><p>一个细节是处于错误状态时<code>Writer::is_closed</code>和<code>Reader::is_finished</code>的判断，根据测试用例，应该不考虑错误。</p><h4 id="buffer"><a class="header-anchor" href="#buffer">¶</a>buffer</h4><p>Buffer是一个指向std::string的共享智能指针，这样多个Buffer底层可以是同一个string。在旧版代码中，传入的参数是引用类型的，所以不好直接使用string_view，可以借助这个Buffer，来避免底层的string提前被释放。</p><p>旧版代码还提供了一个<code>BufferViewList</code>，本意应该是用这个来实现ring buffer的。这是一个<code>std::deque&lt;std::string_view&gt;</code>，其核心是<code>remove_prefix</code>操作。</p><h2 id="check1"><a class="header-anchor" href="#check1">¶</a>check1</h2><h3 id="reassembler"><a class="header-anchor" href="#reassembler">¶</a>reassembler</h3><p>让可能乱序、重叠（这里不考虑修改）的data按正确顺序加入到ring buffer中。</p><p>主要是实现以下接口，插入一个在<code>first_idnex</code>位置开始的data。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">( <span class="type">uint64_t</span> first_index, std::string data,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> is_last_substring, Writer&amp; output )</span></span>;</span><br></pre></td></tr></table></figure><p>需要维护下一个加入到ring buffer中的index（<code>next_index_</code>），以及正在等待的暂存字符序列（<code>pending_</code>，只考虑后续ring buffer的available capacity个字符，以控制吞吐量）。</p><p>每次加入一个data：</p><ul><li>计算出需要考虑的区间</li><li>如果该区间从<code>next_index_</code>开始，不断将连续的暂存字符序列的队首写入到ring buffer中（一种写法是把data先放到暂存字符序列里，然后再不断弹出，另一种是先删掉暂存字符序列里和data重合的，然后再不断弹出，正常情况下顺序的data还是占大多数，因此后一种可以利用移动语义，更好）</li><li>否则存到字符序列的对应位置</li></ul><p>难点应该是字符序列用什么数据结构，要求能够从首部删除，最好能支持随机访问。</p><p>一开始我用的是<code>std::deque&lt;std::optional&lt;char&gt;&gt;</code>，后来改成了<code>std::unordered_map&lt;uint64_t, char&gt;</code>，感觉更合适一些，但实际测出来还是deque更快，unordered_map甚至直接TLE了，在大数据下性能还是太不稳定了。我也尝试了<code>std::list&lt;char&gt;</code>，但感觉也一般，因为添加到字符序列时每次都要完整扫一遍。我认为最合适的应该是类似块状数组（<code>std::deque</code>就属于这种）或块状链表的形式。</p><p>如果用的是<code>std::deque&lt;std::optional&lt;char&gt;&gt;</code>，还需要实时维护<code>unassembled_bytes</code>，这个函数最好能<code>O(1)</code>回答。这在新版本里体会不到，但是在旧版的<code>TCPConnection</code>中检查连接是否active会频繁调用，很影响性能。</p><p>一个细节是<code>is_last_substring</code>被设置，但由于available capacity过小，data没写完，此时<code>is_last_</code>仍然应保持false（这在最新版实验的测试用例里没有覆盖到）。</p><h2 id="check2"><a class="header-anchor" href="#check2">¶</a>check2</h2><p><code>next_index_</code>其实就是TCP中的术语ackno，而<code>available capacity</code>其实就是window size。</p><h3 id="64-bit-index-to-32-bit-ackno"><a class="header-anchor" href="#64-bit-index-to-32-bit-ackno">¶</a>64-bit index to 32-bit ackno</h3><p>在TCP中ackno只有32位，但是bytestream的下标是64位的，而且ackno从一个随机值开始。</p><ul><li>ISN：initial sequence number</li><li>SYN：beginning of stream</li><li>FIN：end of strea</li></ul><p>SYN和FIN分别会占用一个序列号，表示字符流的开始和结束。</p><p>sequence number就是从ISN开始的32位数，absolute number是从0开始的64位数，而stream index则是在absolute number的基础上忽略SYN和FIN。</p><p>难点主要是前两个的互相转化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Wrap32 <span class="title">Wrap32::wrap</span><span class="params">( uint64 t n, Wrap32 zero point )</span></span>;</span><br><span class="line"><span class="function">uint64 t <span class="title">unwrap</span><span class="params">( Wrap32 zero point, uint64 t checkpoint )</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>Wrap32是uint32的包装类，无符号数的溢出就是取模，是正常行为。</p><p>一个sequence number会对应多个absolute number（若x满足，则x+2^32也满足），因此checkpoint用于找到距离它最近的那个absolute number。</p><p>我的做法是先加足够多的2^32，让其大于等于checkpoint，然后再检查减掉一个2^32会不会更接近。</p><h3 id="TCP-receiver"><a class="header-anchor" href="#TCP-receiver">¶</a>TCP receiver</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TCPSenderMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    Wrap32 seqno &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">bool</span> SYN &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    Buffer payload &#123;&#125;;</span><br><span class="line">    <span class="type">bool</span> FIN &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="comment">// How many sequence numbers does this segment use?</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">sequence_length</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> SYN + payload.<span class="built_in">size</span>() + FIN; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TCPReceiverMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    std::optional&lt;Wrap32&gt; ackno &#123;&#125;;</span><br><span class="line">    <span class="type">uint16_t</span> window_size &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPReceiver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* The TCPReceiver receives TCPSenderMessages, inserting their payload</span></span><br><span class="line"><span class="comment">    * into the Reassemble at the correct stream index. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">( TCPSenderMessage message, Reassembler&amp; reassembler, Writer&amp; inbound_stream )</span></span>;</span><br><span class="line">    <span class="comment">/* The TCPReceiver sends TCPReceiverMessages back to the TCPSender. */</span></span><br><span class="line">    <span class="function">TCPReceiverMessage <span class="title">send</span><span class="params">( <span class="type">const</span> Writer&amp; inbound_stream )</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TCP receiver接收一个TCP消息，需要维护ISN（即带有SYN标志的TCP消息的seqno；从而可以在SN和ASN之间转换），然后放到Reassembler里重组到ring buffer中的正确位置。如果该TCP段带有FIN标志，则关闭buffer。</p><p>发送者需要维护ackno（这里采用的是累计确认，已经重组完加入到byte_stream的字节数+1，还要考虑SYN和FIN）和window_size（byte_stream的availabel_capacity）。</p><p>一个细节是TCP中window_size只有16位，所以最大只能是65536。（旧版的实验代码中，receiver返回的window_size是<code>size_t</code>的，而截断逻辑丢给了<code>TCPConnect</code>处理，有点坑）</p><h2 id="check3"><a class="header-anchor" href="#check3">¶</a>check3</h2><h3 id="TCP-sender"><a class="header-anchor" href="#TCP-sender">¶</a>TCP sender</h3><p>TCP sender不断发送TCP消息（分成一个个segment，确保每个segment不超过接收方的window_size，并且paylod的长度不超过给定的MTU（文档写的是1492，但代码里是1000）），然后根据接收方回应的ackno追踪哪些segment被正确收到，哪些segment需要超时重传。</p><p>如果某个segment被部分收到，此时需要分割该segment。类似地，某些连续的segment可以合并起来重传。但是本实验不考虑这些。</p><p>在还未收到接收方的window_size时，默认windows_size为1。</p><p>需要维护等待发送的segments（<code>pending_segments_</code>，一个队列）和正在发送（尚未确认送达）的segments（<code>in_flight_segments_</code>，一个按照seqno升序的优先队列）当前的接收窗口为<code>[ackno_, ackno_ + window_size_)</code></p><p>难点主要是很多细节问题。</p><ul><li>将buffer分割为若干segment<ul><li>先根据已发送的seqno和接收窗口的右侧计算还可以发送的大小<code>window_space</code></li><li>根据<code>window_space</code>和<code>TCPConfig::MAX_PAYLOAD_SIZE</code>计算当前segment的长度</li><li><code>window_space</code>需要考虑SYN和FIN的占用，而<code>TCPConfig::MAX_PAYLOAD_SIZE</code>只是限制payload的大小</li><li>当<code>window_space</code>为0时，如果没有在发送中的段，并且buffer还不为空或者buffer已经结束（buffer为空且已经关闭）但还没发送FIN（换句话说就是当前还有要发送的东西），则应将window_space设为1，否则就得不到接收方的ackno反馈，无法更新了</li><li>如果buffer已经结束，此时需要设置FIN，但还要考虑window_space的限制</li><li>如何判断是否还有要发送的segment<ul><li>buffer为空，但是还没发SYN。SYN是一定要发送的</li><li>buffer已经结束，但是还没发FIN，这种情况是因为<code>window_space</code>的限制，没能在前一个segment设置FIN</li><li>buffer非空，肯定还得发</li></ul></li></ul></li><li>发送segment<ul><li>取出seqno最小的那个segment，如果重传计时未开始，就初始化计时</li></ul></li><li>接收到TCPReceiverMessage<ul><li>ackno可能大于已经发送的最大的seqno+1，即该ackno是异常的，此时应该忽略</li><li>ackno可能为空，但已经收到过非空的ackno，说明是重传过的延迟段，忽略</li><li>否则更新window_size和ackno</li><li>删掉正在发送队列中确认被收到的segments</li><li>如果存在成功接收的segments，则重置超时重传，如果没有正在发送的segments了，还应该关闭计时器</li></ul></li><li>增加时间<ul><li>在达到重传时间时，仅重传序列号最小的那个segment（从<code>in_flight</code>移动到<code>pending</code>里），并重置计时</li><li>仅在<code>window_size</code>大于0时，才翻倍重传时间</li></ul></li></ul><h2 id="TCP-Connection"><a class="header-anchor" href="#TCP-Connection">¶</a>TCP Connection</h2><p>封装了前面的<code>TCPReceiver</code>和<code>TCPSender</code>。</p><p>虽然是实现了TCP的状态机，但我在写的时候完全没有用任何<code>state</code>，不过还是总结一下TCP的状态以及转换。</p><ul><li>LISTEN：等待对方连接</li><li>SYN_RCVD：收到对方的SYN</li><li>SYN_SENT：本方发送了SYN</li><li>ESTABLISHED：完成三次握手</li><li>CLOSE_WAIT：对方发送了FIN</li><li>LAST_ACK：CLOSE_WAIT后，本方发送了FIN</li><li>FIN_WAIT_1：本方发送了FIN，还未收到ACK</li><li>FIN_WAIT_2：收到了之前发送的FIN的ACK</li><li>CLOSING：在本方发送了FIN后，也收到了对方的FIN</li><li>TIME_WAIT：双方都发送了FIN和ACK，等待2 MSL</li><li>CLOSED：连接正常关闭</li><li>RESET：连接异常关闭</li></ul><p>在sponge中Receiver和Sender是分开实现的，因此各自有独立的状态：</p><p>Receiver：</p><ul><li>ERROR：buffer被设为error</li><li>LISTEN：还未收到ackno</li><li>SYN_RECV：收到ackno，但buffer还没结束</li><li>FIN_RECV：收到ackno，buffer已经结束</li></ul><p>Sender：</p><ul><li>ERROR：buffer被设为error</li><li>CLOSED：next_seq为0</li><li>SYN_SENT：next_seq &gt; 0，next_seq = bytes_in_flight，即还没有应答</li><li>SYN_ACKED：buffer还没空或还没结束，或者buffer的大小+2小于next_seq（由于窗口大小还有没发的TCP段），说明还有没收到的ack</li><li>FIN_SENT：还有bytes_in_flight</li><li>FIN_ACKED：没有bytes_in_flight</li></ul><p>Sender和Receiver各自的状态组合对应了TCP整体的状态。</p><p><a data-fancybox="gallery" data-src="/post-images/receiver-state.png" data-caption="receiver-state"><img src="/post-images/receiver-state.png" alt="receiver-state"></a><a data-fancybox="gallery" data-src="/post-images/sender-state.png" data-caption="sender-state"><img src="/post-images/sender-state.png" alt="sender-state"></a><a data-fancybox="gallery" data-src="/post-images/tcp-state.png" data-caption="tcp-state"><img src="/post-images/tcp-state.png" alt="tcp-state"></a></p><p>这里的难点主要是判断连接是否活跃上。</p><ul><li>发起连接<ul><li>发送一个带SYN标记的TCP段，因为是主动发起方，没有ack，但仍需要设置window_size</li></ul></li><li>发送数据<ul><li>写到sender的buffer里，如果有发送的段，则<ul><li>补充ackno和window_size</li></ul></li></ul></li><li>接收TCP段<ul><li>收到的带有RST标记，设置不活跃即可</li><li>带有ACK标记，需要通知receiver更新ackno和window_size，此时如果已经发送过SYN，则可能有新的段可以发送，所以调用<code>write(&quot;&quot;)</code></li><li>发给receiver进行重组</li><li>如果该段占有数据，则需要回复一个ack表示收到，如果不占数据就不需要回了，否则会无限pingpong<ul><li>如果该段带有FIN，并且本方还未发送FIN，这说明本法是被动关闭连接的，此时不再需要linger，只有主动方需要</li><li>如果还没发送过SYN，则需要设置SYN，此时处于三次握手的第二步</li><li>设置ackno和window_size</li></ul></li></ul></li><li>连接是否活跃<ul><li>如果收发过RST标记的段，此时已经设置为不活跃了</li><li>如果还有未重组的字节，或者输入还没有结束，说明活跃</li><li>如果还没发送FIN，说明活跃</li><li>如果有正在发送的字节，说明活跃</li><li>如果需要linger，则在10倍的初始重传时间后不活跃</li><li>不需要linger，则直接不活跃</li></ul></li><li>增加时间<ul><li>给sender增加时间，如果有重传的段，则<ul><li>设置它的ackno和window_size</li><li>如果重传时间超过8次，设置RST标记，并设置连接不活跃</li></ul></li></ul></li><li>关闭输入<ul><li>关闭后还需要发送FIN标记的TCP段，调用write(“”)即可</li></ul></li><li>关闭连接<ul><li>如果析构的时候连接还处于活跃状态，则发送一个RST标记的TCP段，并设置连接不活跃。</li></ul></li></ul><h3 id="TCPPeer"><a class="header-anchor" href="#TCPPeer">¶</a>TCPPeer</h3><p>新版实验没有这部分内容，但是提供了一个<code>TCPPeer</code>的类。</p><h2 id="CS144TCPSocket"><a class="header-anchor" href="#CS144TCPSocket">¶</a>CS144TCPSocket</h2><p>学习怎么把前面的东西包装为一个真正可用的socket的。</p><h3 id="tcp-over-ip"><a class="header-anchor" href="#tcp-over-ip">¶</a>tcp_over_ip</h3><p>负责在TCP段和IP数据包之间转换。</p><p>TCP段通过添加IP头变成IP数据包，IP头包括源IP、和目的IP。源端口和目的端口则在TCP段头中设置。</p><p>将IP数据包拆解为TCP段时，需要检查源和目的地址，如果不符合就丢弃。</p><h3 id="tun"><a class="header-anchor" href="#tun">¶</a>tun</h3><p>TUN/TAP是操作系统内核提供的完全由软件实现的虚拟网络设备，其中TAP等同于一个以太网设备，操作以太网数据帧；TUN是网络层设备，操作IP数据包。</p><p>TUN设备可以通过<code>ioctl</code>创建，后续只要用<code>read</code>/<code>write</code>读写即可。</p><h3 id="tuntap-adapter"><a class="header-anchor" href="#tuntap-adapter">¶</a>tuntap_adapter</h3><p>包装了对TUN设备的读写操作。</p><p>读取的时候是读到一个IP数据包，把他拆解成TCP段返回。</p><p>写入的时候是在把TCP段封装成IP数据包。</p><h3 id="LocalStreamSocket"><a class="header-anchor" href="#LocalStreamSocket">¶</a>LocalStreamSocket</h3><p>是<code>socket(AF_UNIX, SOCK_STREAM, 0)</code>的一个包装。</p><h3 id="eventloop"><a class="header-anchor" href="#eventloop">¶</a>eventloop</h3><p>对<code>poll</code>的包装，每次产生事件就执行注册的回调函数。</p><h3 id="TCPSpongeSocket"><a class="header-anchor" href="#TCPSpongeSocket">¶</a>TCPSpongeSocket</h3><p>可以看到，在用户态TCPSocket实现中，只能自己在connect函数里设置源IP和端口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TCPOverIPv4SpongeSocket = TCPSpongeSocket&lt;TCPOverIPv4OverTunFdAdapter&gt;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CS144TCPSocket</span> : <span class="keyword">public</span> TCPOverIPv4SpongeSocket;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CS144TCPSocket::connect</span><span class="params">(<span class="type">const</span> Address &amp;address)</span> </span>&#123;</span><br><span class="line">    TCPConfig tcp_config;</span><br><span class="line">    tcp_config.rt_timeout = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    FdAdapterConfig multiplexer_config;</span><br><span class="line">    multiplexer_config.source = &#123;<span class="string">&quot;169.254.144.9&quot;</span>, <span class="built_in">to_string</span>(<span class="built_in">uint16_t</span>(<span class="built_in">random_device</span>()()))&#125;;</span><br><span class="line">    multiplexer_config.destination = address;</span><br><span class="line"></span><br><span class="line">    TCPOverIPv4SpongeSocket::<span class="built_in">connect</span>(tcp_config, multiplexer_config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="check4"><a class="header-anchor" href="#check4">¶</a>check4</h2><h3 id="ARP"><a class="header-anchor" href="#ARP">¶</a>ARP</h3><p>NetworkInterface负责将IP数据包封装成以太网数据帧发送到下一跳，并在接收到以太网数据帧时拆封为底层的IP数据包。</p><p>关键是需要知道一个IP地址对应的MAC地址，这需要用到ARP协议。</p><ul><li>如果不知道下一跳IP的映射，就广播一条ARP请求，ARP请求的目的IP为下一跳IP，源IP和源MAC为自己的IP和MAC；封装的以太网帧的源MAC为自己的MAC，目的MAC为广播MAC。并将要发送的IP数据包放到待发送队列中（<code>pending_dgrams_</code>）</li><li>忽略目的MAC不属于自己的以太网帧</li><li>如果收到的是IP数据包，就解封返回</li><li>如果收到的是ARP请求且目的IP与自己IP相同，就回复一条ARP应答，将自己的IP地址和MAC地址填入源IP和源MAC中，目的IP和MAC则是发送请求者的IP和MAC</li><li>同时，对于收到的ARP请求，可以学习它的源IP和MAC映射，存到一个cache中，并将对应IP等待的IP数据包发送出去</li><li>IP和MAC映射可能发生变化，因此cache有一个时限（30s），为了避免ARP请求泛洪，在一定时间内（5s）不重复广播</li></ul><p>ARP请求可能永远得不到回复，对应发送的IP数据包就永远发不出去，在本实验中不需要考虑该问题。</p><p>cache可以用<code>std::unordered_map</code>，用两个<code>std::queue</code>存等待发送的以太网帧和等待ARP回复后封装的数据包，再用两个<code>std::map</code>记录每次ARP请求的时间以及保存cache的时间。</p><h2 id="check5"><a class="header-anchor" href="#check5">¶</a>check5</h2><h3 id="IP路由表"><a class="header-anchor" href="#IP路由表">¶</a>IP路由表</h3><p>添加一条路由信息，包括IP前缀，前缀长度，下一跳地址（如果没有，则是直连地址），对应的NetworkInterface。</p><p>路由表用<code>std::array&lt;std::unordered_map&lt;uint32_t, std::pair&lt;std::optional&lt;Address&gt;, uint32_t&gt;&gt;, 33&gt;</code>实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_route</span><span class="params">(<span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">    optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> interface_num)</span></span>;</span><br></pre></td></tr></table></figure><p>根据最长匹配原则查找对应的路由，将IP数据包转交给对应的NetworkInterface发送。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">route</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>一个细节是prefix_length为0需要特殊考虑，因为位移32位是未定义行为。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WAL预写日志</title>
      <link href="/2023/11/13/WAL%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97/"/>
      <url>/2023/11/13/WAL%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>minidb</title>
      <link href="/2023/11/13/minidb/"/>
      <url>/2023/11/13/minidb/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>smallchat</title>
      <link href="/2023/11/13/smallchat/"/>
      <url>/2023/11/13/smallchat/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp模板</title>
      <link href="/2023/11/11/cpp%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/11/11/cpp%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="decltype"><a class="header-anchor" href="#decltype">¶</a>decltype</h2><p><code>decltype(x)</code>和<code>decltype((x))</code>是有区别的。</p><p>第一个其实是<code>decltype(identifier)</code>，第二个则是<code>decltype(expression)</code>。</p><h2 id="std-decay"><a class="header-anchor" href="#std-decay">¶</a>std::decay</h2><p>执行与函数参数值传递时相同的类型退化。</p><ul><li>数组和数组的引用退化为指针</li><li>函数和函数的引用会添加指针</li><li>否则执行<code>std::remove_cvref</code>（即<code>std::remove_cv&lt;std::remove_reference&lt;T&gt;&gt;</code>，先移除引用，再移除顶层CV）</li></ul><h2 id="void-t"><a class="header-anchor" href="#void-t">¶</a>void_t</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span>... &gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">void_t</span> = <span class="type">void</span>;</span><br></pre></td></tr></table></figure><h2 id="constant"><a class="header-anchor" href="#constant">¶</a>constant</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>, T v &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="type">bool</span> B &gt;</span><br><span class="line"><span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="type">bool</span>, B&gt;;</span><br></pre></td></tr></table></figure><h2 id="type-identity"><a class="header-anchor" href="#type-identity">¶</a>type_identity</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type_identity</span>;</span><br></pre></td></tr></table></figure><h2 id="is-aggregate"><a class="header-anchor" href="#is-aggregate">¶</a>is_aggregate</h2><p>聚合类型是：</p><ul><li>数组</li><li>类<ul><li>没有用户定义或集成的构造函数</li><li>没有私有或保护的非静态成员</li><li>没有虚函数</li></ul></li></ul><p>聚合类型可以通过聚合初始化（即大括号）。此外嵌套的大括号可以省略。</p><h2 id="declval"><a class="header-anchor" href="#declval">¶</a>declval</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">typename</span> std::add_rvalue_reference&lt;T&gt;::<span class="function">type <span class="title">declval</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>将类型转为引用类型，从而可以使用它的类成员函数，而不需要经过构造。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈回溯</title>
      <link href="/2023/11/05/%E6%A0%88%E5%9B%9E%E6%BA%AF/"/>
      <url>/2023/11/05/%E6%A0%88%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="x86-64常用寄存器"><a class="header-anchor" href="#x86-64常用寄存器">¶</a>x86-64常用寄存器</h2><ul><li><code>%rax</code>（累加）：函数返回值</li><li><code>%rsp</code>：栈指针寄存器（指向栈顶）</li><li><code>%rbp</code>：栈基址寄存器（指向栈底）</li><li><code>%rip</code>：指令寄存器，指向要读取指令的地址</li><li><code>%rdi</code>（目的索引）、<code>%rsi</code>（源索引）、<code>%rdx</code>（数据）、<code>%rcx</code>（计数）、<code>%r8</code>、<code>%r9</code>：分别对应1、2…个函数参数</li><li><code>%rbx</code>（基址）、<code>%rbp</code>、<code>%r12</code>、<code>%r13</code>、<code>%r14</code>、<code>%r15</code>：数据存储，遵守被调用者保存归约</li><li><code>%r10</code>、<code>%r11</code>：数据存储，遵守调用者保存归约</li></ul><p>其中<code>%rxx</code>的低32位可以用相应的<code>%exx</code>访问，<code>%rx</code>的低32位可以用<code>%rxd</code>访问。</p><h2 id="函数调用过程"><a class="header-anchor" href="#函数调用过程">¶</a>函数调用过程</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 421. 数组中两个数的最大异或值</title>
      <link href="/2023/11/04/Leetcode-421-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/"/>
      <url>/2023/11/04/Leetcode-421-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h2><p>求数组<code>num</code>中任意两个数异或的最大值。</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>显然可以用01字典树。</p><p>Leetcode题一般不需要考虑delete问题，这种题还是定义一个全局的数据结构和一个全局的内存池比较方便。</p><p>但是Leetcode有一个坑是所有测例是在一份代码里一起运行的，因此还需要考虑清空问题，当时发现全局零初始化的<code>nxt</code>数组的值非零，debug了好久才意识到是这个原因，还以为是什么奇奇怪怪的未定义行为。</p><p>还有一点是字典树的大小应该是<code>N * BIT_NUM</code>的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">7e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node* nxt[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">static</span> Node* <span class="title">newNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = (v &gt;&gt; b) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nxt[x]) nxt[x] = Node::<span class="built_in">newNode</span>();</span><br><span class="line">        <span class="keyword">if</span> (b) nxt[x]-&gt;<span class="built_in">insert</span>(v, b - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> x = (v &gt;&gt; b) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nxt[!x]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; b) | nxt[!x]-&gt;<span class="built_in">ask</span>(v, b - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nxt[x]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nxt[x]-&gt;<span class="built_in">ask</span>(v, b - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[N];</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">Node::newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nodes + (++tot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaximumXOR</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        Node* root = nodes;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, root-&gt;<span class="built_in">ask</span>(num, <span class="number">30</span>));</span><br><span class="line">            root-&gt;<span class="built_in">insert</span>(num, <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">            nodes[i].nxt[<span class="number">0</span>] = nodes[i].nxt[<span class="number">1</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这题还有更简单的做法，从高位往低位枚举，忽略低位，然后看当前位能不能取1（用unordered_set检查即可），其实和二分差不多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速字符串压缩</title>
      <link href="/2023/11/04/%E5%BF%AB%E9%80%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
      <url>/2023/11/04/%E5%BF%AB%E9%80%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压缩位图</title>
      <link href="/2023/11/04/%E5%8E%8B%E7%BC%A9%E4%BD%8D%E5%9B%BE/"/>
      <url>/2023/11/04/%E5%8E%8B%E7%BC%A9%E4%BD%8D%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>普通位图的大小是固定的，在面对稀疏存储时会浪费很多空间。，因此产生了压缩位图</p><p>布隆过滤器（判重）和hyperloglog（基数）都是近似算法，并且只支持增加，不支持删除。</p><h2 id="roaring-bit-map"><a class="header-anchor" href="#roaring-bit-map">¶</a>roaring bit map</h2><p>roaring bit map由一个roaring array组成，其包括三个成员：</p><ul><li><code>short[] keys</code></li><li><code>Container[] values</code></li><li><code>int size</code></li></ul><p>一个插入的32位int会被分为高16位和低16位，高16位用于索引keys（保持有序，通过二分查找），低16位用于在Container中索引（类似地，64位会分为高32位和低32位）。</p><p>Container分为ArrayContainer（有序数组，数据量小于4096时使用）、BitMapContainer（未压缩的位图）和RunContainer（使用行程长度压缩算法，对连续数据有较好的压缩效果，如果连续性差，反而可能需要更多的空间）。</p><p><code>11,12,13,14,15,21,22</code>会压缩为<code>11,4,21,1</code>。</p><p>ArrayContainer和RunContainer在索引时需要再二分一次。</p><p>显然，在数据少时选择ArrayContainer，之后选择BitMapContainer和RunContainer中更优的那个。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="/2023/11/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2023/11/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序"><a class="header-anchor" href="#插入排序">¶</a>插入排序</h2><p>从前往后依次把当前元素插入到前缀的有序序列的相应位置即可。</p><p>$O(n^2)$，稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> key = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; key; j--) &#123;</span><br><span class="line">        a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    a[j + <span class="number">1</span>] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a class="header-anchor" href="#希尔排序">¶</a>希尔排序</h2><p>对插入排序的优化，直观思想是当数组基本有序时，插入排序是很快的。</p><p>将一定间隔的元素组成一组进行插入排序，然后每一轮缩小间隔，直至间隔为1。（前期，乱序的元素可以大跨步地归位）。</p><p>通常增量序列选择$n/2, n/4, \dots, 1$（最坏仍然是$O(n^2)$），$2^k+1$/$3^k+1$（最坏是$O(n^{3/2}$），$2^p3^q$（最坏时$O(n\log^2 n$）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">    gap = <span class="number">3</span> * gap + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (gap &gt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; key; j -= gap) &#123;</span><br><span class="line">            a[j + gap] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + gap] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    gap /= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a class="header-anchor" href="#选择排序">¶</a>选择排序</h2><p>按照数值从小到大依次归位。$O(n^2)$，稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> mn = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; a[mn])</span><br><span class="line">                mn = j;</span><br><span class="line">    std::<span class="built_in">swap</span>(a[i], a[mn]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a class="header-anchor" href="#冒泡排序">¶</a>冒泡排序</h2><p>扫描n-1轮，在每一轮中，如果前一个数大于后一个数（即逆序），就进行交换，这样第i轮，第i大的数就归位了。 $O(n^2)$，稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++)</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])</span><br><span class="line">            std::<span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a class="header-anchor" href="#堆排序">¶</a>堆排序</h2><p>升序需要先构建大顶堆，然后不断把堆顶移动数组的末尾，并维持大顶堆。$O(n\log n)$，不稳定</p><p>关键是堆的一些操作。</p><p>位置<code>i</code>的左儿子和右儿子分别是<code>i&lt;&lt;1</code>和<code>i&lt;&lt;1|1</code></p><h3 id="原地建堆"><a class="header-anchor" href="#原地建堆">¶</a>原地建堆</h3><p>从最后一个非叶子节点开始往前调整，把当前点和儿子节点中最大的那个交换上来。$O(n)$</p><h3 id="追加元素"><a class="header-anchor" href="#追加元素">¶</a>追加元素</h3><p>先放在数组末尾，然后从下往上交换调整即可。$O(\log n)$</p><h3 id="删除堆顶"><a class="header-anchor" href="#删除堆顶">¶</a>删除堆顶</h3><p>从上往下交换调整即可。$O(\log n)$</p><h2 id="快速排序"><a class="header-anchor" href="#快速排序">¶</a>快速排序</h2><p>选择一个pivot，将小于pivot的元素移到前面，大于pivot的元素移到后面，然后递归分治即可。</p><p>关键点是pivot的选择，最坏可能导致$O(n^2)$，一般会用随机的方式选择。</p><p>一个细节是所有数字都相同，这时候不管怎么选都会是$O(n^2)$的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[pos]);</span><br><span class="line">    <span class="type">int</span> pivot = nums[l];</span><br><span class="line">    <span class="type">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[++j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[j], nums[l]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">    <span class="keyword">while</span> (p - <span class="number">1</span> &gt;= l &amp;&amp; nums[p - <span class="number">1</span>] == nums[p]) --p;</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, l, p - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p + <span class="number">1</span> &lt;= r &amp;&amp; nums[p + <span class="number">1</span>] == nums[p]) ++p;</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-sort"><a class="header-anchor" href="#std-sort">¶</a>std::sort</h2><p>使用一种混合的introsort。</p><p>如果规模小于16，直接插入排序。</p><p>在快排深度大于一个阈值时，切换为堆排序，来避免快排最坏$O(N^2)$复杂度的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">procedure <span class="title">sort</span><span class="params">(A : array)</span>:</span></span><br><span class="line"><span class="function">    maxdepth ← ⌊log2(length(A))⌋ × <span class="number">2</span></span></span><br><span class="line"><span class="function">    introsort(A, maxdepth)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">procedure introsort(A, maxdepth):</span></span><br><span class="line"><span class="function">    n ← length(A)</span></span><br><span class="line"><span class="function">    if n &lt; <span class="number">16</span>:</span></span><br><span class="line"><span class="function">        insertionsort(A)</span></span><br><span class="line"><span class="function">    else if maxdepth =</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">heapsort</span>(A)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p ← <span class="built_in">partition</span>(A)  <span class="comment">// assume this function does pivot selection, p is the final position of the pivot</span></span><br><span class="line">        <span class="built_in">introsort</span>(A[<span class="number">1</span>:p<span class="number">-1</span>], maxdepth - <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">introsort</span>(A[p+<span class="number">1</span>:n], maxdepth - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2127. 参加会议的最多员工数</title>
      <link href="/2023/11/02/Leetcode-2127-%E5%8F%82%E5%8A%A0%E4%BC%9A%E8%AE%AE%E7%9A%84%E6%9C%80%E5%A4%9A%E5%91%98%E5%B7%A5%E6%95%B0/"/>
      <url>/2023/11/02/Leetcode-2127-%E5%8F%82%E5%8A%A0%E4%BC%9A%E8%AE%AE%E7%9A%84%E6%9C%80%E5%A4%9A%E5%91%98%E5%B7%A5%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h2><p>有n个人，每个人有另外一个喜欢的人，现在有一个圆桌，要求座位上的每个人都和他喜欢的人相邻，问座位上最多能有几个人。</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>每个节点都有一条出边，构成若干棵内向基环树。</p><p>现在考虑每棵基环树，显然可以让环上的所有人都坐下。</p><p>但是从样例1就可以看出一种特殊的case，如果环的大小为2，此时是可以继续加人的。设环上的两个点为x和y，那么可以再塞进x子树内的最长链以及y子树内的最长链，而且可以继续把其它大小为2的环以及对应的链拼接进来。</p><p>因此这道题只需要找出每棵基环树的环的大小，如果大于2，取max；否则再找出这两个点各自子树内的最长链，取sum。最后两种情况再去max即可。</p><p>做的时候看到样例就意识到环的大小为2是个特殊点，但是没想到可以拼接，而且也没确定每个联通块都是基环树这一点，所以写的很乱（完全在瞎写），也WA了好几次。。😭我一开始以为大小为2的环最多只能多带1个人，为了判断这个环还有其他点，我从一个非环上的点开始爬，最后再处理纯环（如果知道每个连通块都是基环树这一点，完全没必要分成两块代码写）。后来发现结论不对之后，这个代码框架其实不太好，但也懒得改了，所以调试起来也很烦，手画了好几个错的样例。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumInvitations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; favorite)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = favorite.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n)</span>, <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">G</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; favorite.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cnt[favorite[i]]++;</span><br><span class="line">            G[i].<span class="built_in">push_back</span>(favorite[i]);</span><br><span class="line">            G[favorite[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; get = [&amp;](<span class="type">int</span> u, <span class="type">int</span> u2) &#123;</span><br><span class="line">            <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">            tmp[u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v != u2 &amp;&amp; !tmp[v]) &#123;</span><br><span class="line">                    d = <span class="built_in">max</span>(d, <span class="built_in">get</span>(v, u2) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cnt[i]) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; loop;</span><br><span class="line">                <span class="type">int</span> j = i;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; ; j = favorite[j]) &#123;</span><br><span class="line">                    loop.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">if</span> (!vis[j]) &#123;</span><br><span class="line">                        vis[j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> sz = loop.<span class="built_in">size</span>();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) cnt[loop[i]]--;</span><br><span class="line">                            vis[loop[i]] = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> (j == loop[i] &amp;&amp; i != sz - <span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="type">int</span> x = i, y = sz - x - <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (y == <span class="number">2</span>) &#123;</span><br><span class="line">                                    <span class="type">int</span> cur = <span class="built_in">get</span>(j, loop[i + <span class="number">1</span>]) + <span class="built_in">get</span>(loop[i + <span class="number">1</span>], j);</span><br><span class="line">                                    ans2 = <span class="built_in">max</span>(ans2, cur);</span><br><span class="line">                                    two += cur;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    ans = <span class="built_in">max</span>(ans, y);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[j] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> sz = loop.<span class="built_in">size</span>();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                            cnt[loop[i]]--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis.<span class="built_in">data</span>(), <span class="number">0</span>, n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt[i]) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; loop;</span><br><span class="line">                <span class="type">int</span> j = i;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; ; j = favorite[j]) &#123;</span><br><span class="line">                    loop.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">if</span> (!vis[j]) &#123;</span><br><span class="line">                        vis[j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> sz = loop.<span class="built_in">size</span>();</span><br><span class="line">                        <span class="keyword">if</span> (sz == <span class="number">3</span>) &#123;</span><br><span class="line">                            two += <span class="number">2</span>;</span><br><span class="line">                            ans2 = <span class="built_in">max</span>(ans2, <span class="number">2</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ans = <span class="built_in">max</span>(ans, sz - <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                            vis[loop[i]] = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) cnt[loop[i]]--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, two);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基环树找环可以把所有非环上的边用拓扑排序去掉。</p><p>下面代码的<code>rg</code>包含了所有非环边，而环边用<code>favorite</code>数组就可以拿到。此外，其实可以直接在拓扑排序的时候算出最长链，也就不需要建<code>rg</code>了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumInvitations</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;favorite)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = favorite.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deg</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> f: favorite) &#123;</span><br><span class="line">            deg[f]++; <span class="comment">// 统计基环树每个节点的入度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">rg</span>(n); <span class="comment">// 反图</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123; <span class="comment">// 拓扑排序，剪掉图上所有树枝</span></span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> y = favorite[x]; <span class="comment">// x 只有一条出边</span></span><br><span class="line">            rg[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (--deg[y] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反图 rg 寻找树枝上最深的链</span></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; rdfs = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span> max_depth = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> son: rg[x]) &#123;</span><br><span class="line">                max_depth = <span class="built_in">max</span>(max_depth, <span class="built_in">rdfs</span>(son) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max_depth;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max_ring_size = <span class="number">0</span>, sum_chain_size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历基环上的点</span></span><br><span class="line">            deg[i] = <span class="number">0</span>; <span class="comment">// 将基环上的点的入度标记为 0，避免重复访问</span></span><br><span class="line">            <span class="type">int</span> ring_size = <span class="number">1</span>; <span class="comment">// 基环长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = favorite[i]; x != i; x = favorite[x]) &#123;</span><br><span class="line">                deg[x] = <span class="number">0</span>; <span class="comment">// 将基环上的点的入度标记为 0，避免重复访问</span></span><br><span class="line">                ring_size++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ring_size == <span class="number">2</span>) &#123; <span class="comment">// 基环长度为 2</span></span><br><span class="line">                sum_chain_size += <span class="built_in">rdfs</span>(i) + <span class="built_in">rdfs</span>(favorite[i]); <span class="comment">// 累加两条最长链的长度</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max_ring_size = <span class="built_in">max</span>(max_ring_size, ring_size); <span class="comment">// 取所有基环长度的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(max_ring_size, sum_chain_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态分析工具总结</title>
      <link href="/2023/11/02/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
      <url>/2023/11/02/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2003. 每棵子树内缺失的最小值</title>
      <link href="/2023/11/01/Leetcode-2003-%E6%AF%8F%E6%A3%B5%E5%AD%90%E6%A0%91%E5%86%85%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
      <url>/2023/11/01/Leetcode-2003-%E6%AF%8F%E6%A3%B5%E5%AD%90%E6%A0%91%E5%86%85%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h2><p>给定一棵n个节点，以0为根的无向树，每个节点有一个值num，问对于每个点u，u及其子树的所有值的mex。</p><p>$n \le 10^5, 1\le num \le 10 ^ 5$</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>对于每个节点，我们维护一个桶数组和一个mex指针，然后从下往上转移即可（每次加一个点，就更新桶，然后尝试移动mex指针）。</p><p>但是我们不可能每个节点都开一个桶数组，时间和空间都受不了。</p><p>显然可以用dsu on tree来解决（常用与静态子树查询问题）。思路就是只用一个全局的桶数组和mex指针，先处理所有轻儿子的答案，然后清空贡献；再处理唯一的重儿子，但是<strong>保留</strong>贡献；最后再把所有轻儿子的贡献再统计一遍即可。</p><p>因为一个点往上最多分成log段重链，也就是这里每个轻儿子最多额外统计log次，因此只乘了个log的复杂度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestMissingValueSubtree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = parents.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">G</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            G[parents[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sz</span><span class="params">(n)</span>, <span class="title">big_son</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; get = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">get</span>(v, u);</span><br><span class="line">                sz[u] += sz[v];</span><br><span class="line">                <span class="keyword">if</span> (big_son[u] == <span class="number">-1</span> || sz[v] &gt; sz[big_son[u]]) &#123;</span><br><span class="line">                    big_son[u] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">get</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucket</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, pending</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; add = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[u] - <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                bucket[nums[u] - <span class="number">1</span>]++;</span><br><span class="line">                pending.<span class="built_in">push_back</span>(nums[u]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">add</span>(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>)&gt; dfs = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">bool</span> del) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (v == big_son[u]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(v, u, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (big_son[u] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(big_son[u], u, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (v == big_son[u]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">add</span>(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[u] - <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                bucket[nums[u] - <span class="number">1</span>]++;</span><br><span class="line">                pending.<span class="built_in">push_back</span>(nums[u]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (bucket[cur]) ++cur;</span><br><span class="line">            ans[u] = cur + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (del) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> num : pending) bucket[num - <span class="number">1</span>]--;</span><br><span class="line">                pending.<span class="built_in">clear</span>();</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外也可以每个点维护一个哈希集合（而不是桶数组），然后从下往上启发式合并（小的集合插入到大的集合）。</p><p>以上做法是通用的，但是这道题有一个特性是每个点的numm互不相同，也就意味着只有一个点的num为1，只有这个点往上的链的mex &gt; 1，所以一遍dfs即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终端复用器</title>
      <link href="/2023/10/30/%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E5%99%A8/"/>
      <url>/2023/10/30/%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="tmux"><a class="header-anchor" href="#tmux">¶</a>tmux</h2><h3 id="基本概念"><a class="header-anchor" href="#基本概念">¶</a>基本概念</h3><p>通常，终端窗口和会话是绑定的，打开和关闭终端就意味着会话的开始和结束。</p><p>tmux则可以解绑终端和会话，这样每个会话可以拥有多个终端，终端也可以和会话分离以及重新接入。</p><p><a href="/post-images/tmux.png">tmux</a></p><ul><li>服务器：一个tmux服务器可以管理多个会话</li><li>会话：一个会话可以有多个窗口，但同时只能显示一个窗口（可以类比成多桌面，不同的桌面干不同的事情）</li><li>窗口：一个窗口可以分割成多个窗格</li><li>窗格：即之前的一个终端窗口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install</span></span><br><span class="line">sudo apt install tmux</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uninstall</span></span><br><span class="line">sudo apt remove tmux</span><br></pre></td></tr></table></figure><p>注：还是建议从源码编译，apt安装的版本太旧，导致每次启动tmux的时候都会更新一遍tpm。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install</span></span><br><span class="line">git clone https://github.com/tmux/tmux.git</span><br><span class="line">cd tmux</span><br><span class="line">sh autogen.sh</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line">sudo cp tmux /usr/local/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uninstall</span></span><br><span class="line">sudo rm /usr/local/bin/tmux</span><br></pre></td></tr></table></figure><p>tmux的默认键位不太友好，选择<code>oh my tmux</code>的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br><span class="line">git clone https://github.com/gpakosz/.tmux.git</span><br><span class="line">ln -s -f .tmux/.tmux.conf</span><br><span class="line">cp .tmux/.tmux.conf.local .</span><br></pre></td></tr></table></figure><p>在<code>.tmux.conf.local</code>中添加下面配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set -g mouse on</span><br><span class="line">set -g mouse-select-pane on</span><br><span class="line">set -g @plugin &#x27;catppuccin/tmux&#x27;</span><br></pre></td></tr></table></figure><h3 id="会话操作"><a class="header-anchor" href="#会话操作">¶</a>会话操作</h3><ul><li><code>tmux</code>：打开一个tmux服务器</li><li><code>exit</code>：退出</li><li><code>tmux new -s name</code>, <code>alias tnew=&quot;tmux new -s&quot;</code>：新建一个名为name的会话</li><li><code>tmux ls</code>：列出所有会话</li><li><code>tmux attach -t id/name</code>：恢复会话（只有一个会话可以不用输入<code>-t</code>）</li><li><code>tmux kill-session -t id/name</code>：关闭会话</li><li><code>tmux switch -t id/name</code>：切换会话</li></ul><h3 id="窗格操作"><a class="header-anchor" href="#窗格操作">¶</a>窗格操作</h3><ul><li><code>C-a</code>：前缀键（也可以是默认的<code>C-b</code>；注意是先按下<prefix>，然后松开，再按后面的键）</li><li><code>-</code>：上下分窗格</li><li><code>_</code>：左右分窗格</li><li><code>x</code>, <code>C-d</code>：关闭当前窗格</li><li><code>z</code>：最大化/恢复窗格</li><li><code>hjkl</code>：窗格移动</li><li><code>HJKL</code>：窗格大小调整</li><li><code>&lt;</code>/<code>&gt;</code>：交换窗格位置</li><li><code>d</code>：分离，后续可以再attach回来</li></ul><h3 id="窗口操作"><a class="header-anchor" href="#窗口操作">¶</a>窗口操作</h3><ul><li><code>c</code>：新建窗口</li><li><code>C-h</code>/<code>C-l</code>：浏览窗口</li><li><code>&lt;number&gt;</code>：跳转到该窗口</li><li><code>,</code>：窗口重命名</li></ul><h3 id="工作流"><a class="header-anchor" href="#工作流">¶</a>工作流</h3><p>通常开一个tmux，然后用<code>&lt;prefix&gt;-</code>/<code>&lt;prefix&gt;_</code>分割多个窗格即可。</p><p>有时候要跑一些长任务，可以运行之后<code>&lt;prefix&gt;d</code>进行detach。</p><h2 id="zellij"><a class="header-anchor" href="#zellij">¶</a>zellij</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install</span></span><br><span class="line">wget https://github.com/zellij-org/zellij/releases/download/v0.38.2/zellij-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line">tar -xvf zellij-x86_64-unknown-linux-musl.tar.gz</span><br><span class="line">sudo mv zellij /usr/local/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uninstall</span></span><br><span class="line">sudo rm /usr/local/bin/zellij</span><br></pre></td></tr></table></figure><p>这里窗口被叫作标签（tab；感觉更清晰），窗格仍然是pane。</p><h3 id="标签操作"><a class="header-anchor" href="#标签操作">¶</a>标签操作</h3><ul><li><code>C-t</code>起始<ul><li><code>n</code>：新建标签</li><li><code>x</code>：关闭当前标签</li></ul></li><li><code>C-o</code>：分离当前标签（和tmux一样，可以<code>zellij attach &lt;name&gt;</code>回来）</li></ul><h3 id="窗格操作-s2"><a class="header-anchor" href="#窗格操作-s2">¶</a>窗格操作</h3><ul><li><code>C-p</code>起始<ul><li><code>n</code>：新建窗格（会自动选择垂直还是水平划分）</li><li><code>x</code>：关闭当前窗格</li></ul></li><li><code>C-n-&lt;+|-&gt;</code>：改变当前窗格大小（这个不能用鼠标操作）</li><li><code>C-h-&lt;h|j|k|l&gt;/方向键</code>：浏览窗格</li></ul><p>总体感觉一般般，默认的配色我也不太喜欢，不如tmux好用。</p><ul><li><code>C-q</code>：退出</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clippy静态分析工具</title>
      <link href="/2023/10/24/Clippy%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/10/24/Clippy%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git hook</title>
      <link href="/2023/10/21/Git-hook/"/>
      <url>/2023/10/21/Git-hook/</url>
      
        <content type="html"><![CDATA[<p>在特定动作发生前后触发自定义的脚本构造，分为两类：</p><ul><li>客户端钩子：<code>pre-commit</code>, <code>commit-msg</code>, <code>post-commit</code>等</li><li>服务端钩子：<code>pre-receive</code>, <code>post-receive</code>, <code>update</code>等</li></ul><h2 id="pre-commit"><a class="header-anchor" href="#pre-commit">¶</a>pre-commit</h2><p>在每次git commit前触发，通常用于代码规范检查，可以通过<code>--no-verify</code>跳过。</p><p>使用<a href="https://pre-commit.com/">pre-commit</a>框架。</p><p><code>pip install pre-commit</code>安装，可能还需要<code>source ~/.profile</code>。</p><p><code>pre-commit --version</code>确认安装成功。</p><p><code>pre-commit sample-config &gt; .pre-commit-config.yaml</code>在根目录下生成默认配置。</p><p><code>pre-commit install</code>自动将当前目录下的所有钩子脚本安装到.git/hooks/中。</p><p><code>pre-commit run --all-files</code>可自行检查git管理的所有文件，而git commit只会检查变更的文件。</p><h3 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h3><p><a href="https://github.com/pre-commit/pre-commit-hooks">pre-commit/pre-commit-hooks</a>提供了一些钩子（如去除行尾空格），直接指定id即可。</p><p><a href="https://github.com/doublify/pre-commit-rust">doublify/pre-commit-rust</a>提供了rust相关的钩子（格式化，静态检查等）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cargo包管理工具</title>
      <link href="/2023/10/21/Cargo%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/10/21/Cargo%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="命令"><a class="header-anchor" href="#命令">¶</a>命令</h2><ul><li><code>cargo new &#123;&#123;project&#125;&#125; [--bin/--lib]</code></li><li><code>cargo check</code></li><li><code>cargo run</code></li><li><code>cargo build [--release]</code></li><li><code>cargo clean</code></li><li><code>cargo update [-p &#123;&#123;lib&#125;&#125;]</code>：更新依赖</li></ul><h2 id="Cargo-lock"><a class="header-anchor" href="#Cargo-lock">¶</a>Cargo.lock</h2><p>包含依赖项的准确信息，自动生成。</p><p>在构建二进制文件时应该包含lock文件，而在构建库时，应该放在.gitignore中。</p><h2 id="Cargo-toml"><a class="header-anchor" href="#Cargo-toml">¶</a>Cargo.toml</h2><p>包含Cargo编译的所有元数据。</p><h3 id="package"><a class="header-anchor" href="#package">¶</a>package</h3><ul><li>name：包名（必要）</li><li>version：包版本（必要）</li><li>authors</li><li>edition：Rust版本</li><li>rust-version：支持的最低Rust版本</li><li>description</li><li>documentation：文档链接</li><li>readme</li><li>homepage</li><li>repository</li><li>license</li><li>license-file</li><li>keywords</li><li>categories</li></ul><h3 id="dependencies"><a class="header-anchor" href="#dependencies">¶</a>dependencies</h3><ul><li><code>target.'cfg(target_arch = &quot;x86_64&quot;)'.dependencies</code>：平台特定的依赖项</li><li><code>dev-dependencies</code>：开发依赖</li><li><code>build-dependencies</code>：构建依赖</li></ul><h3 id="features"><a class="header-anchor" href="#features">¶</a>features</h3><p>表达条件编译和可选依赖项。</p><h3 id="profile"><a class="header-anchor" href="#profile">¶</a>profile</h3><p>更改编译器设置，改变优化、调试符号等，分为dev、release、test、bench四个。</p><h2 id="rustfmt"><a class="header-anchor" href="#rustfmt">¶</a>rustfmt</h2><p>乱入一下rust的格式化工具。</p><ul><li><code>rustfmt &#123;&#123;filename&#125;&#125;</code>：格式化单个文件</li><li><code>cargo fmt</code>：格式化整个项目</li></ul><p><code>rustfmt.toml</code>为配置文件，rustfmt默认是四个空格，可以用<code>tab_spaces=2</code>修改。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EditorConfig</title>
      <link href="/2023/10/21/EditorConfig/"/>
      <url>/2023/10/21/EditorConfig/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h2><p>帮助开发者定义一致的编码样式。不同的编辑器都可以读取和遵守该定义（VSCode需要安装插件）。</p><h2 id="常用属性"><a class="header-anchor" href="#常用属性">¶</a>常用属性</h2><ul><li><code>indent_style</code>：<code>space</code>软缩进，<code>tab</code>硬缩进</li><li><code>indent_size</code>：缩进大小</li><li><code>end_of_line</code>：设置换行符，<code>lf</code>为换行，即*nix风格</li><li><code>charset</code>：设置编码</li><li><code>trim_trailing_whitespace</code>：去除末尾空白符</li><li><code>insert_final_newline</code>：以空白行结尾</li><li><code>root</code>：表示最顶层的配置文件。EditorConfig会不断向上层目录查找配置，遇到root会停止</li></ul><h2 id="模板"><a class="header-anchor" href="#模板">¶</a>模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># EditorConfig helps developers define and maintain consistent</span><br><span class="line"># coding styles between different editors or IDEs</span><br><span class="line"># http://editorconfig.org</span><br><span class="line">root = true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">end_of_line = lf</span><br><span class="line">charset = utf-8</span><br><span class="line">trim_trailing_whitespace = true</span><br><span class="line">insert_final_newline = false</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 2</span><br><span class="line"></span><br><span class="line">[*.py]</span><br><span class="line">indent_size = 4</span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace = false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree-sitter</title>
      <link href="/2023/10/20/Tree-sitter/"/>
      <url>/2023/10/20/Tree-sitter/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>源码阅读</title>
      <link href="/2023/10/19/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2023/10/19/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="静态分析"><a class="header-anchor" href="#静态分析">¶</a>静态分析</h2><h3 id="cloc"><a class="header-anchor" href="#cloc">¶</a>cloc</h3><p>统计代码行数，由perl实现。</p><ul><li><code>cloc &#123;&#123;file/directory&#125;&#125;</code></li><li><code>--by-file</code>：按文件统计，而不是按语言</li><li><code>--exclude-list-file=&lt;file&gt;</code></li><li><code>--exclude-dir=&lt;D1&gt;[,D2,]</code></li></ul><h3 id="fd"><a class="header-anchor" href="#fd">¶</a>fd</h3><p>查找文件，由rust实现，是find的替代品。</p><ul><li><code>fd &#123;&#123;pattern&#125;&#125; [directory]</code>：默认为正则匹配，可以指定目录，不指定则搜索当前目前</li><li><code>--extension</code>：查找扩展名</li><li><code>--exclude</code>：排除某些文件或目录</li><li><code>--no-ignore</code>：默认会遵守目录下的<code>.gitignore</code>，指定该选项则不遵守</li></ul><h3 id="rg"><a class="header-anchor" href="#rg">¶</a>rg</h3><p>查找文件内容，由rust实现，是grep的替代品。</p><ul><li><code>rg &#123;&#123;pattern&#125;&#125; [path ...]</code>：搜索文本为正则匹配</li><li><code>--type &#123;&#123;filetype&#125;&#125;</code>：指定要查找的文件类型</li><li><code>-i</code>：大小写不敏感</li><li><code>--glob &#123;&#123;pattern&#125;&#125;</code>：仅查找匹配glob模式的文件</li><li><code>--files-with-matches</code>：只列出存在匹配的文件名</li><li><code>-A/-B/-C N</code>：打印匹配行以及后/前/前后N行</li><li><code>--files</code>：查找文件名</li></ul><h3 id="ast-grep"><a class="header-anchor" href="#ast-grep">¶</a>ast-grep</h3><p>基于Tree-sitter进行代码搜索、替换，由rust实现。它基于AST节点（其实是CST，AST是抽象语法树，而Ts生成的CST是具体语法树，它为每个token都存储了一个对应的节点，即使是逗号、括号等字符串字面量，而AST则会去掉这些无意义的节点；这里称作命名节点和匿名节点）进行结构匹配，而不是简单的文本匹配。</p><ul><li><code>ast-grep [OPTIONS] --p &lt;PATTERN&gt; [PATHS]...</code>：</li><li>PATTERN：AST模式<ul><li>元变量：<code>$</code>开头后跟大写字母、下划线或数字1-9，匹配单个AST节点（类比正则中的<code>.</code>）</li><li>多元变量：<code>$$$</code>来匹配零个或多个AST节点（类比正则中的<code>*</code>）</li><li>元变量捕获：可以重复使用同名变量，此时它们被要求匹配相同的内容，可以用下划线开头来抑制该行为</li><li>匿名节点：<code>$$</code>开头，即CST中直接用字符串字面量定义的，比如<code>+/,/;</code>等</li></ul></li><li><code>-l</code>：指定语言</li><li><code>--rewrite</code>：改写替换</li><li><code>--interactive</code>：交互模式</li><li><code>-A/-B/-C</code></li></ul><h2 id="运行时分析"><a class="header-anchor" href="#运行时分析">¶</a>运行时分析</h2><h3 id="strace"><a class="header-anchor" href="#strace">¶</a>strace</h3><h3 id="uftrace"><a class="header-anchor" href="#uftrace">¶</a>uftrace</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试</title>
      <link href="/2023/10/17/GDB%E8%B0%83%E8%AF%95/"/>
      <url>/2023/10/17/GDB%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>help</code>, <code>help command</code>：查看帮助</li></ul><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>gdb启动时会先应用.gdbinit文件中的所有命令，<br>可以把本次调试前需要重复输入的命令写进去。</p><ul><li><code>set disable-randomization off</code>：关闭程序的虚拟地址空间随机化</li><li><code>set print pretty on</code>：优化结构体打印</li><li><code>set history save on</code>：保留历史命令</li><li><code>set pagination off</code>：关闭分页显示</li><li><code>set confirm off</code>：关闭确认请求</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul><li><code>set args xxx</code>, <code>--args program xxx</code>：设置程序启动时的参数</li><li><code>show args</code>：显示设置的参数</li><li><code>ulimit -c unlimited</code>, <code>gdb program core</code>：调试coredump文件</li><li><code>attach pid</code>, <code>gdb program pid</code>：附加到已运行的进程（<code>ps aux | grep program</code>查看pid）</li><li><code>file xxx</code>：指定要调试的程序</li><li><code>symbol-file xxx</code>：单独加载分离的调试信息</li><li><code>r</code>, <code>run</code>：开始运行</li><li><code>start</code>：开始运行并暂停在main函数入口</li><li><code>!command</code>：执行shell命令</li><li><code>source xxx</code>, <code>-x xxx</code>：执行脚本</li></ul><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><ul><li><code>info breakpoints</code>：查看已设置的断点</li><li><code>b linenumber</code></li><li><code>b filename:linenumber</code></li><li><code>b function</code></li><li><code>b test.c:23 if b==0</code>：条件断点</li><li><code>condition 1 b==0</code>：设置1号断点的条件</li><li><code>rbreak regex</code>：作用于所有匹配regex的函数名</li><li><code>tbreak</code>：设置临时断点，只生效一次</li><li><code>watch cond</code>：观察某个变量或表达式的取值，每次发生变化时暂停（有硬件观察点和软件观察点，<br>硬件观察点的数量有限）</li><li><code>disable</code>：禁用断点</li><li><code>enable</code>：启用断点</li><li><code>delete</code>, <code>delete number</code>：删除断点</li><li><code>command number</code>：设置在达到number号断点时自动执行的命令</li></ul><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><ul><li><code>p</code>, <code>print</code>：打印变量<ul><li><code>p *d</code>：打印指针指向的值</li><li><code>p *d@10</code>：打印指针指向地址处10个值</li><li><code>p $sp</code>：打印寄存器中的值</li><li><code>p/x</code>：十六进制打印</li><li><code>p/t</code>：二进制打印</li><li><code>p/c</code>：字符打印</li><li><code>p/f</code>：浮点数打印</li></ul></li><li><code>x</code>, <code>examine</code>：查看内存地址的值<ul><li><code>x/nfu addr</code>：n是单元数，f是打印格式，u是单元大小，addr是内存地址</li><li><code>u</code>包括b（字节）、h（双字节）、w（四字节）、g（八字节）</li><li><code>x/4tb &amp;e</code>：查看变量e所在地址开始的4个字节的值</li></ul></li><li><code>bt</code>：查看调用栈<ul><li><code>bt n</code>：只显示前n层栈帧</li></ul></li><li><code>frame number</code>：切换到number号栈帧，通常用来查看父函数中的局部变量</li><li><code>info frame</code>：查看当前栈帧信息</li><li><code>info args</code>：查看当前函数参数</li><li><code>info locals</code>：查看当前函数内的局部变量值</li><li><code>info registers</code>：查看寄存器的值</li><li><code>info function</code>：查看函数</li><li><code>info classes</code>：查看类</li><li><code>info proc mappings</code>：查看内存区域映射</li><li><code>call func(arg)</code>：调用函数；比如调用程序内提供的打印函数</li><li><code>ptype</code>：打印变量类型</li><li><code>set $a=xxx</code>：自定义变量，需要以<code>$</code>开头，用来简化一些长变量</li><li><code>dprintf location, formatting-string, expr1, expr2, ...</code>：在程序的某行插入printf命令</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul><li><code>l</code>, <code>list</code>：显示当前所在行及之后的10行源代码</li><li><code>n</code>, <code>next</code>：单步执行</li><li><code>s</code>, <code>step</code>：单步执行，函数调用则会进入函数内（step into）</li><li><code>ni</code>, <code>nexti</code>：执行一条机器指令</li><li><code>si</code>, <code>stepi</code></li><li><code>c</code>, <code>continue</code>：继续执行到下一个断点</li><li><code>u</code>, <code>until</code>：继续运行到指定位置或者运行完当前的循环体</li><li><code>finish</code>：继续运行直至当前函数结束</li></ul><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><ul><li><code>set follow-fork-mode child</code>：在fork后跟踪调试子进程</li><li><code>info inferiors</code>：查看调试的所有进程的信息（gdb称被调试进程为inferior）</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li><code>info threads</code>：查看所有线程信息</li><li><code>thread id</code>：切换到id号线程</li><li><code>thread apply all bt</code>：将命令作用到所有线程上 </li><li><code>set scheduler-locking off/on</code>：默认关闭调度器锁，此时运行调试的线程，其它线程也会运行。<br>在开启时，则只有调试的线程会执行，其它线程暂停执行。此外还有<code>step</code>选项，它保证在单步执行时，<br>永远保持在当前调试的线程下，但其它线程仍然会继续执行；<br>而默认的<code>off</code>下，如果其它线程遇到断点，会自动切换到其它线程中。</li></ul><h2 id="tui"><a href="#tui" class="headerlink" title="tui"></a>tui</h2><ul><li><code>layout src</code>：显示源代码窗口（<code>Ctrl-x-a</code>切换）</li><li><code>layout asm</code>：显示汇编代码窗口</li><li><code>layout reg</code>：显示寄存器窗口</li><li><code>Ctrl-l</code>：刷新窗口</li></ul><h2 id="pretty-printer"><a href="#pretty-printer" class="headerlink" title="pretty-printer"></a>pretty-printer</h2><ul><li><code>python/shell command</code>：运行python/shell命令</li><li><code>define</code>：自定义命令</li></ul><h2 id="反向调试"><a href="#反向调试" class="headerlink" title="反向调试"></a>反向调试</h2><ul><li><code>record</code>：开始记录当前调试程序的状态</li><li><code>reverse-step</code>：反向单步执行</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2023/10/17/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/10/17/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="du"><a class="header-anchor" href="#du">¶</a>du</h2><p>显示目录或文件的大小。</p><ul><li><code>-b/-k/-m</code> 以bytes/kb/mb为单位</li><li><code>-h</code> 以K、M、G为单位，提高可读性</li><li><code>-s</code> 只显示总和，也就是&quot;.&quot;目录的大小</li><li><code>--exclude</code> 略过指定目录或文件</li></ul><p><code>dust</code>（du+rust）以树型结构展示，并显示大小占比，最下面是内存占用最大的文件或目录。</p><p><code>ncdu</code>是<code>du</code>的tui版本，从大到小列出所有目录或文件的大小，按<code>?</code>查看快捷键，其中<code>d</code>删除，<code>q</code>退出。</p><h2 id="tldr"><a class="header-anchor" href="#tldr">¶</a>tldr</h2><p>man的言简意赅版本。</p><h2 id="md5sum"><a class="header-anchor" href="#md5sum">¶</a>md5sum</h2><p>在传输大文件时，数据可能出现不一致问题，可以用md5值简单校验文件内容是否正确。</p><ul><li><code>md5sum &#123;&#123;path/to/file&#125;&#125;</code>：计算一个文件的md5h值</li><li><code>md5sum --check &#123;&#123;path/to/file.md5&#125;&#125;</code>：检查该文件中罗列的每个文件与对应的md5值是否一致（每行是文件名和md5值）</li></ul><h2 id="pstack"><a class="header-anchor" href="#pstack">¶</a>pstack</h2><p>唯一的用法就是<code>pstack &lt;PID&gt;</code>，用于打印正在运行的进程PID的堆栈信息。</p><p>用于了解一个进程当前正在做什么，帮助死锁检测、性能分析、问题排查等。</p><h2 id="pmap"><a class="header-anchor" href="#pmap">¶</a>pmap</h2><ul><li><code>pmap &lt;PID&gt;</code>：显示进程PID的地址空间</li><li><code>-p</code>：显示完整路径</li></ul><h2 id="lsof"><a class="header-anchor" href="#lsof">¶</a>lsof</h2><p>list open files（列出当前系统打开的文件）。</p><ul><li><code>lsof</code></li><li><code>lsof &#123;&#123;path/to/file&#125;&#125;</code>：输出打开该文件的所有进程</li><li><code>lsof -c &#123;&#123;command&#125;&#125;</code>：输出该命令会打开的所有文件</li><li><code>lsof -p &#123;&#123;PID&#125;&#125;</code>：输出进程PID打开的所有文件</li></ul><h2 id="vmstat"><a class="header-anchor" href="#vmstat">¶</a>vmstat</h2><p>virtual memory statistics（虚拟内存统计）</p><ul><li><code>vmstat</code></li><li><code>vmstat 2 3</code>：每隔2秒采集一次状态，共采集3次</li></ul><h2 id="df"><a class="header-anchor" href="#df">¶</a>df</h2><p>列出文件系统的磁盘使用情况。</p><h2 id="cut"><a class="header-anchor" href="#cut">¶</a>cut</h2><h2 id="sed"><a class="header-anchor" href="#sed">¶</a>sed</h2><h2 id="iostat"><a class="header-anchor" href="#iostat">¶</a>iostat</h2><h2 id="pldd"><a class="header-anchor" href="#pldd">¶</a>pldd</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 260. 只出现一次的数字III</title>
      <link href="/2023/10/16/Leetcode-260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/"/>
      <url>/2023/10/16/Leetcode-260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h2><p>有一个数组<code>nums</code>，其中有两个数字只出现了1次，其余数字都出现了恰好2次，问只出现1次的那两个数字。</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>除了异或外想不到能再获取什么有用的信息，最后看了眼题解才会🤡。。</p><p>首先把所有数异或起来可以知道这两个数字<code>x</code>和<code>y</code>的异或值。</p><p>下面就是关键了，由于<code>x != y</code>，<code>x ^ y</code>一定有某一位是1，且<code>x</code>和<code>y</code>在该位上一个是1，一个是0。于是把数组按照该位的取值分成两份，就退化为问题《只出现一次的数字I》了，分别异或即可。</p><p>计算某一位可以用<code>x &amp; (-x)</code>得到最低位即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">single_number</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">xor</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            xor ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">low_bit</span> = xor &amp; (-xor);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> num &amp; low_bit != <span class="number">0</span> &#123;</span><br><span class="line">                x ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                y ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vec!</span>[x, y]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 137. 只出现一次的数字II</title>
      <link href="/2023/10/15/Leetcode-137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/"/>
      <url>/2023/10/15/Leetcode-137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h2><p>一个数组中有一个数字只出现了1次， 其余数字都出现了K次 (K &gt; 1)，问出现1次的数字是什么</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>按照二进制逐位确定即可，如果该位1的个数出现的次数为nk + 1，说明出现1次的数字包含该位。</p><p>遇到的一个坑是Go语言中的int的大小是和操作系统的位数有关的，在64位上是8字节（类似于C++中的size_t）。</p><p>当时用默认的int WA了之后，我以为是有符号数位移，以及有符号数溢出未定义导致的问题。</p><p>记录一下：</p><ul><li>左移低位补0即可，逻辑移位和算术移位一样</li><li>有符号数右移是算术移位，高位补符号位</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i++ &#123;</span><br><span class="line">        cnt := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            cnt += (num &gt;&gt; i) &amp; <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt % <span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(ans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果var用默认的int类型取值可能大于等于$2^{31}$，此时再转int32也是未定义行为。</p><p>当k很小时，可以自行构造位运算。比如k=2时用异或，k=3时为(0, 0)-&gt;(0, 1)-&gt;(1, 0)-&gt;(0, 0)…，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = (a ^ x) &amp; (a | b), (b ^ x) &amp; ~a </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID生成算法</title>
      <link href="/2023/10/13/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/13/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>分布式ID生成一般要求唯一性、递增型、高可用性和高性能。</p><h2 id="UUID"><a class="header-anchor" href="#UUID">¶</a>UUID</h2><p>Universally Unique Identifier，即通用唯一标识码，有128位，通常用32位16进制数表示，并以连字号分为五段，形式为8-4-4-4-12。</p><h2 id="snowflake"><a class="header-anchor" href="#snowflake">¶</a>snowflake</h2><p>雪花算法由Twitter开源，它生成的每个ID有64位，其中：</p><ul><li>第1位始终为0</li><li>第2~42位为毫秒级时间戳，可用69年，$2^41$约为$2.2\times 10^{13}$</li><li>第43~52位为机器ID，可表示1024台；这里可以自行分配，比如前5位表示数据中心ID，后5位再表示某个数据中心内的机器ID</li><li>第53~64位是自增序列，可表示4096个数</li></ul><p>这样，每一毫秒在每一台机器上都能产生4096个有序递增且不重复的ID。</p><p><a data-fancybox="gallery" data-src="/post-images/snowflake-id.png" data-caption="ID构成"><img src="/post-images/snowflake-id.png" alt="ID构成"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InvalidSystemClock</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    时钟回拨异常</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64位ID的划分</span></span><br><span class="line">WORKER_ID_BITS = <span class="number">5</span></span><br><span class="line">DATACENTER_ID_BITS = <span class="number">5</span></span><br><span class="line">SEQUENCE_BITS = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大取值计算</span></span><br><span class="line">MAX_WORKER_ID = -<span class="number">1</span> ^ (-<span class="number">1</span> &lt;&lt; WORKER_ID_BITS)  <span class="comment"># 2**5-1 0b11111</span></span><br><span class="line">MAX_DATACENTER_ID = -<span class="number">1</span> ^ (-<span class="number">1</span> &lt;&lt; DATACENTER_ID_BITS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移位偏移计算</span></span><br><span class="line">WOKER_ID_SHIFT = SEQUENCE_BITS</span><br><span class="line">DATACENTER_ID_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS</span><br><span class="line">TIMESTAMP_LEFT_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS + DATACENTER_ID_BITS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序号循环掩码</span></span><br><span class="line">SEQUENCE_MASK = -<span class="number">1</span> ^ (-<span class="number">1</span> &lt;&lt; SEQUENCE_BITS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始时间截 (2015-01-01)</span></span><br><span class="line">TWEPOCH = <span class="number">1420041600000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IdWorker</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用于生成IDs</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, datacenter_id, worker_id, sequence=<span class="number">0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化</span></span><br><span class="line"><span class="string">        :param datacenter_id: 数据中心（机器区域）ID</span></span><br><span class="line"><span class="string">        :param worker_id: 机器ID</span></span><br><span class="line"><span class="string">        :param sequence: 其实序号</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># sanity check</span></span><br><span class="line">        <span class="keyword">if</span> worker_id &gt; MAX_WORKER_ID <span class="keyword">or</span> worker_id &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;worker_id值越界&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> datacenter_id &gt; MAX_DATACENTER_ID <span class="keyword">or</span> datacenter_id &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;datacenter_id值越界&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.worker_id = worker_id</span><br><span class="line">        self.datacenter_id = datacenter_id</span><br><span class="line">        self.sequence = sequence</span><br><span class="line"></span><br><span class="line">        self.last_timestamp = -<span class="number">1</span>  <span class="comment"># 上次计算的时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_gen_timestamp</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成整数时间戳</span></span><br><span class="line"><span class="string">        :return:int timestamp</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">        <span class="comment"># 其实应返回当前的毫秒数，但这里返回的是秒数*1000，time.time()的返回值是xxxxxxxxxx.xxxxxx</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_id</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取新ID</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        timestamp = self._gen_timestamp()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 时钟回拨</span></span><br><span class="line">        <span class="keyword">if</span> timestamp &lt; self.last_timestamp:</span><br><span class="line">            <span class="keyword">raise</span> InvalidSystemClock</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> timestamp == self.last_timestamp:</span><br><span class="line">            self.sequence = (self.sequence + <span class="number">1</span>) &amp; SEQUENCE_MASK</span><br><span class="line">            <span class="keyword">if</span> self.sequence == <span class="number">0</span>:</span><br><span class="line">                timestamp = self._til_next_millis(self.last_timestamp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.sequence = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.last_timestamp = timestamp</span><br><span class="line"></span><br><span class="line">        new_id = ((timestamp - TWEPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT) | (self.datacenter_id &lt;&lt; DATACENTER_ID_SHIFT) | \</span><br><span class="line">                 (self.worker_id &lt;&lt; WOKER_ID_SHIFT) | self.sequence</span><br><span class="line">        <span class="keyword">return</span> new_id</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_til_next_millis</span>(<span class="params">self, last_timestamp</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        等到下一毫秒</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        timestamp = self._gen_timestamp()</span><br><span class="line">        <span class="keyword">while</span> timestamp &lt;= last_timestamp:</span><br><span class="line">            timestamp = self._gen_timestamp()</span><br><span class="line">        <span class="keyword">return</span> timestamp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    worker = IdWorker(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(worker.get_id())</span><br></pre></td></tr></table></figure><p>算法实现其实很简单，在同一毫秒内，递增最后的序列号即可。如果序列号超过4096，就等待下一毫秒。</p><p>显然该算法强依赖于机器时钟，如果出现时钟回拨（即当前获得的时间戳小于之前记录的时间戳），就可能生成重复的ID。</p><p>解决方案：</p><ul><li>默认是直接抛出异常</li><li>可以完全不依赖于机器时钟，自行从0开始维护“时间戳”，每次序列号达到4096时再自行加1</li><li>发生时间回拨时阻塞等待直至正常</li><li>缓存之前时间戳中没用的序列号，在时间回拨时使用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2731. 移动机器人</title>
      <link href="/2023/10/10/Leetcode-2731-%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2023/10/10/Leetcode-2731-%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h2><p>有n个机器人位于一个无限长横轴，每个机器人每秒会向左或向右移动一格，特别地，如果两个机器人位于同一格，就发生相撞，并各自转为反向移动。现在问$d$秒后，所有机器人两两距离之和。</p><p>$n \le 10^5, d \le 10^9$</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>关键点是机器人相撞后反向应该理解成穿透。</p><p>现在考虑任意两个机器人，如果方向为<code>LL</code>或<code>RR</code>则距离保持不变，如果为<code>LR</code>则距离每秒加2，而如果为<code>RL</code>，在相撞前每秒减2（[1, dis / 2]），相撞后每秒加2 ([dis / 2 + 1, d]，其中dis为奇数时，dis/2+1秒的距离不变)。</p><p>显然可以$O(n^2)$计算。然后我就想着优化成$O(n)$。</p><p>难点在<code>LR</code>的贡献计算，考虑一个<code>L</code>，现在要$O(1)$的统计后面所有的<code>R</code>。进一步地，可以将这些<code>R</code>分为两类，一类是一直减2，一类在减2后会加2。只需要计算加2的总时间即可。由于这里需要向下取整，以及涉及到一个dis为奇数时的特殊case（这里想了很久怎么处理这种棘手的情况），所以还需要分奇偶维护两个后缀和来算。</p><p>另一个恶心的地方是输入的机器人位置不是有序的。</p><p>于是我就写了1个多小时，还wa了2发。。🤧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, string s, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">id</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">iota</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[x] &lt; nums[y];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> pres = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pres += nums[id[i]];</span><br><span class="line">            <span class="built_in">Add</span>(ans, (<span class="number">1ll</span> * nums[id[i]] * (i + <span class="number">1</span>) - pres) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cntl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[id[i]] == <span class="string">&#x27;L&#x27;</span>) ++cntl;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">Add</span>(ans, <span class="number">2ll</span> * cntl * d % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sodd = <span class="number">0</span>, seven = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, codd = <span class="number">0</span>, ceven = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[id[i]] == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                --cntl;</span><br><span class="line">                <span class="keyword">if</span> (nums[id[i]] &amp; <span class="number">1</span>) --codd, sodd -= nums[id[i]];</span><br><span class="line">                <span class="keyword">else</span> --ceven, seven -= nums[id[i]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">Sub</span>(ans, <span class="number">2ll</span> * cntl * d % MOD);</span><br><span class="line">                <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[id[j]] == <span class="string">&#x27;R&#x27;</span>) ++j;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> t = nums[id[j]] - nums[id[i]];</span><br><span class="line">                        <span class="keyword">if</span> (d &gt;= t / <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (nums[id[j]] &amp; <span class="number">1</span>) ++codd, sodd += nums[id[j]];</span><br><span class="line">                            <span class="keyword">else</span> ++ceven, seven += nums[id[j]];</span><br><span class="line">                            ++j;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[id[i]] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="built_in">Sub</span>(ans, <span class="number">2</span> * ceven);</span><br><span class="line">                        <span class="built_in">Add</span>(ans, <span class="number">4ll</span> * (codd + ceven) * d % MOD);</span><br><span class="line">                        <span class="built_in">Sub</span>(ans, <span class="number">2ll</span> * (sodd - <span class="number">1ll</span> * codd * nums[id[i]]) % MOD);</span><br><span class="line">                        <span class="built_in">Sub</span>(ans, <span class="number">2ll</span> * (seven - ceven - <span class="number">1ll</span> * ceven * nums[id[i]]) % MOD);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">Sub</span>(ans, <span class="number">2</span> * codd);</span><br><span class="line">                        <span class="built_in">Add</span>(ans, <span class="number">4ll</span> * (codd + ceven) * d % MOD);</span><br><span class="line">                        <span class="built_in">Sub</span>(ans, <span class="number">2ll</span> * (sodd - codd - <span class="number">1ll</span> * codd * nums[id[i]]) % MOD);</span><br><span class="line">                        <span class="built_in">Sub</span>(ans, <span class="number">2ll</span> * (seven - <span class="number">1ll</span> * ceven * nums[id[i]]) % MOD);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x += y;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= MOD) x -= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x += MOD - y;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= MOD) x -= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="正解"><a class="header-anchor" href="#正解">¶</a>正解</h2><p>理解到穿透这一点后，我们直接算出$d$秒后每个小车的距离，然后一个前缀和算答案不就完事了。。（看到题解发现我傻了）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust-snippets</title>
      <link href="/2023/10/08/rust-snippets/"/>
      <url>/2023/10/08/rust-snippets/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>do benchmark</title>
      <link href="/2023/09/26/do-benchmark/"/>
      <url>/2023/09/26/do-benchmark/</url>
      
        <content type="html"><![CDATA[<p><a href="https://quick-bench.com">quick-bench</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译选项</title>
      <link href="/2023/09/26/%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/"/>
      <url>/2023/09/26/%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<ul><li><code>-Wall</code> <code>-Wextra</code></li><li><code>-Wshadow</code></li><li><code>-Wundef</code></li><li><code>-Wconversion</code></li><li><code>-fno-common</code>：避免全局变量</li><li><code>-Wfloat-equal</code></li><li><code>-Wunreachable-code</code></li><li><code>-Wformat=2</code>：检查<code>printf</code>和<code>scanf</code>的格式控制符</li><li><code>-fmudflap</code>：在运行时检查指针操作以捕获未定义行为</li><li><code>-fno-exceptions</code>：在代码中使用异常时，报错</li><li><code>-ffast-math</code>；要求高性能，但不要求精度</li><li><code>-fomit-frame-pointer</code>：省略栈帧</li><li><code>-fno-plt</code></li><li><code>-no-pie</code>：关闭位置无关</li><li><code>-fPIE</code></li><li><code>-fPIC</code>：生成位置无关代码，用于生成共享库</li><li><code>-m32</code>：编译32位程序</li><li><code>-pedantic</code>：对非C++标准的扩展发出警告</li><li><code>-fanalyzer</code>：启用静态分析，以报告更多问题（有更高的overhead）</li><li><code>-fstack-protector</code>：检查缓冲区溢出</li><li><code>-flto</code>：开启链接时优化，通常编译器只会在单个翻译单元内进行优化，这样可以在整个程序上优化</li><li><code>-rdynamic</code>：指示链接器将所有符号（不仅是已经使用的）都添加到动态符号表中</li><li><code>-march=native</code> <code>-mtune=native</code>：根据CPU进行特定优化</li><li><code>-I</code> <code>-L</code>：指定链接时查找的include文件夹和共享库文件夹，环境变量<code>$LD_LIBRARY_PATH</code>为运行时查找的共享库文件夹</li><li><code>-save-temps</code>：保留所有编译的中间文件（<code>.c</code>, <code>.i</code>, <code>.s</code>, <code>.o</code>）</li><li><code>-v</code>：输出详细信息</li><li><code>-E</code>：只进行编译预处理</li><li><code>-S</code>：生成汇编（一般产生的汇编以<code>.s</code>为后缀，而自己写的以<code>.S</code>为后缀，也是为了避免被覆盖）</li><li><code>-l</code>：链接</li><li><code>-Os</code>：优化文件大小，<code>-Oz</code>更激进</li><li><code>-g</code>：添加debug信息（dwarf）</li><li><code>-Og</code>：一定程度的优化，但保证debug体验</li><li><code>-s</code>：移除符号表和重定位信息</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>检测内存问题</title>
      <link href="/2023/09/26/%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
      <url>/2023/09/26/%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="AddressSanitizer"><a class="header-anchor" href="#AddressSanitizer">¶</a>AddressSanitizer</h2><p>相比Valgrind快，主要就是替换了程序中的<code>malloc()</code>和<code>free()</code>。</p><p>在编译时添加以下选项为编译参数（CFLAGS/CXXFLAGS）以及链接参数（LDFLAGS）：</p><ul><li><code>-fsanitize=address</code>：内存错误（通过替换malloc，在每次申请内存块的前后都设置guard）</li><li><code>-fsanitize=leak</code>：内存泄露</li><li><code>-fsanitize=thread</code>：多线程竞争</li><li><code>-fsanitize=undefined</code>：未定义操作</li><li><code>-fsanitize=memory</code>：未初始化内存读取（与address冲突）</li><li><code>-fno-sanitize-recover</code>：在检测到第一个错误后就退出，否则会继续运行（在指定检测<code>undefined</code>时可选启用）</li><li><code>-fsanitize=pointer-compare</code>：确保没有不同对象的指针比较（需要结合<code>address</code>使用，且不能与<code>thread</code>一起使用）</li></ul><p>可以使用<code>__attribute__((no_sanitize_address)</code>跳过分析某个函数。</p><h2 id="Valgrind-Memcheck"><a class="header-anchor" href="#Valgrind-Memcheck">¶</a>Valgrind Memcheck</h2><p><code>valgrind --log-file=valgrind.log --tool=memcheck --leak-check=full ./prog</code></p><p>valgrind在检测BPF CO-RE程序时会出现<code>FATAL: unhandled eBPF command 22</code>的问题。</p><h2 id="内存踩踏"><a class="header-anchor" href="#内存踩踏">¶</a>内存踩踏</h2><p>Memory stomp：对不属于你的内存进行读写。</p><p>有时候特指访问越界，但恰好无意识地操作到了其它的合法地址，如另一个数据结构。</p><p>一段经典代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>],i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;=<span class="number">10</span> ; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">array</span>[i]=<span class="number">0</span>; <span class="comment">/*code should never terminate*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能$i$恰好在array的下一个位置，每次<code>array[10]=0</code>等价于<code>i=0</code>，从而导致了死循环。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2603. 收集树中的金币</title>
      <link href="/2023/09/22/Leetcode-2603-%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%AD%E7%9A%84%E9%87%91%E5%B8%81/"/>
      <url>/2023/09/22/Leetcode-2603-%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%AD%E7%9A%84%E9%87%91%E5%B8%81/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h2><p>给定一棵$n$个点的无向无根树，每个点有或没有金币。</p><p>现在让你从某个节点出发，每次可以收集距离当前点2以内的所有金币，或者移动到一个相邻节点。</p><p>问你收集所有金币并返回到出发点最少的步数。</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>首先考虑固定出发点的情况，答案是什么。显然就是去掉所有叶子节点距离小于等于2的边后剩余边的个数乘以2。</p><p>换根DP明显可以解决。</p><p>然后我写了1个小时，调了30分钟（实在想不到问题在哪，手画了一下十几个点的错误数据才意识到问题）。</p><p>代码写的也是异常丑陋，懒得在递归函数里传一堆参数，所以全改成类的私有变量了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">collectTheCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        n = coins.<span class="built_in">size</span>();</span><br><span class="line">        dp.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        dp.<span class="built_in">resize</span>(n);</span><br><span class="line">        dp2.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        dp2.<span class="built_in">resize</span>(n);</span><br><span class="line">        G.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        G.<span class="built_in">resize</span>(n);</span><br><span class="line">        c = coins;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            G[e[<span class="number">0</span>]].<span class="built_in">push_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            G[e[<span class="number">1</span>]].<span class="built_in">push_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">2</span> * n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans = <span class="built_in">min</span>(ans, dp[i][<span class="number">3</span>] + dp2[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            <span class="keyword">if</span> (c[v]) dp[u][<span class="number">0</span>]++;</span><br><span class="line">            dp[u][<span class="number">1</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">            dp[u][<span class="number">2</span>] += dp[v][<span class="number">1</span>] + dp[v][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (dp[v][<span class="number">1</span>] || dp[v][<span class="number">2</span>]) &#123;</span><br><span class="line">                dp[u][<span class="number">3</span>] += dp[v][<span class="number">3</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (c[u]) dp2[v][<span class="number">0</span>]++;</span><br><span class="line">            dp2[v][<span class="number">1</span>] += dp2[u][<span class="number">0</span>] + dp[u][<span class="number">0</span>] - c[v];</span><br><span class="line">            dp2[v][<span class="number">2</span>] += dp2[u][<span class="number">1</span>] + dp2[u][<span class="number">2</span>] + dp[u][<span class="number">1</span>] + dp[u][<span class="number">2</span>] - dp[v][<span class="number">0</span>] - dp[v][<span class="number">1</span>] - dp[v][<span class="number">2</span>]; </span><br><span class="line">            <span class="comment">// 一开始错就是因为没加父节点u的子树内的部分，比如父节点有一个有金币的儿子，它只被统计在dp[u][0]中，</span></span><br><span class="line">            <span class="comment">// 但正是由于这个金币，父节点的另一个儿子的儿子就需要往父亲走了</span></span><br><span class="line">            <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (dp2[u][<span class="number">1</span>] || dp2[u][<span class="number">2</span>] || dp2[u][<span class="number">3</span>]) &#123;</span><br><span class="line">                dp2[v][<span class="number">3</span>] += dp2[u][<span class="number">3</span>];</span><br><span class="line">                ok = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[u][<span class="number">1</span>] + dp[u][<span class="number">2</span>] - dp[v][<span class="number">0</span>] - dp[v][<span class="number">1</span>] - dp[v][<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp2[v][<span class="number">3</span>] += dp[u][<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">if</span> (dp[v][<span class="number">1</span>] || dp[v][<span class="number">2</span>]) &#123;</span><br><span class="line">                    dp2[v][<span class="number">3</span>] -= dp[v][<span class="number">3</span>] - <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ok = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ok) dp2[v][<span class="number">3</span>] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 4&gt;&gt; dp, dp2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; G;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="正解"><a class="header-anchor" href="#正解">¶</a>正解</h2><p>拓扑排序。</p><p>对于树中的叶子节点，如果没有金币，直接删除即可。</p><p>不断删除后，现在的树的所有叶子节点都有金币，显然我们可以继续删掉两层叶子节点。</p><p>答案就是剩下的边数乘以2了。其实就是贪心，并不需要算出从每个点出发的答案具体是什么。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程</title>
      <link href="/2023/09/21/%E5%8D%8F%E7%A8%8B/"/>
      <url>/2023/09/21/%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp snippets</title>
      <link href="/2023/09/21/cpp-snippets/"/>
      <url>/2023/09/21/cpp-snippets/</url>
      
        <content type="html"><![CDATA[<p><code>std::monostate</code>用于模拟空值的状态（就是一个空的结构体）。</p><p><code>std::variant</code>会默认调用第一个类型的默认构造函数，如果第一个类型没有默认构造函数，就会编译错误。</p><p>在从一种状态转换到另一种状态时出现异常会罕见的变为<code>valueless_by_exception</code>，并且在<code>index()</code>时会返回<code>variant_npos</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> T&amp; <span class="title">clamp</span><span class="params">( <span class="type">const</span> T&amp; v, <span class="type">const</span> T&amp; lo, <span class="type">const</span> T&amp; hi )</span></span>;</span><br><span class="line"><span class="comment">// if v &lt; lo return lo</span></span><br><span class="line"><span class="comment">// else if v &gt; hi return hi</span></span><br><span class="line"><span class="comment">// else return v</span></span><br><span class="line"><span class="comment">// 如果lo大于hi，是未定义行为</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">midpoint</span><span class="params">( T a, T b )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 在a+b为奇数时，向a取整</span></span><br></pre></td></tr></table></figure><p><code>std::piecewise_construct</code>是空结构体<code>std::piecewise_construct_t</code>的一个实例，用于对一个<code>std::pair</code>的构造进行消歧。</p><p>使用<code>std::piecewise_construct</code>，会对<code>pair</code>的first和second分别进行原地构造；否则会先生成两个临时对象，再进行拷贝构造。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, big&gt; map;</span><br><span class="line">map.<span class="built_in">emplace</span>(std::piecewise_construct, <span class="comment">/*key*/</span>std::forward_as_tuple(<span class="number">1</span>), <span class="comment">/*value*/</span>std::forward_as_tuple(<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>实际原理就是<code>pair</code>有一个特化的构造函数，<code>piecewise_construct</code>就是起到一个标签作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span>... Args1, <span class="keyword">class</span>... Args2 &gt;</span></span><br><span class="line"><span class="function"><span class="title">pair</span><span class="params">( std::<span class="type">piecewise_construct_t</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::tuple&lt;Args1...&gt; first_args,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::tuple&lt;Args2...&gt; second_args )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="vector的特化"><a class="header-anchor" href="#vector的特化">¶</a>vector的特化</h2><ul><li><p>SmallVector：在size小于某个阈值时，使用对象内置的栈上分配的buffer存储，而在大于阈值后再转为动态分配。<code>std::string</code>也有类似的优化，在比较短时使用<code>char [N]</code>来存储。</p></li><li><p>FixedCapacityVector：类似于array，但是初始容量为0，在增加和删除元素时进行构造和析构，array则在实例化时就要对所有元素进行初始化。在增加元素超过固定的容量时报错。</p></li><li><p>PODVector: vector在扩容时会对元素进行默认初始化，但有时候我们希望省略这个步骤，比如我们只是想resize一个足够大的buffer用来read。</p><p>解决方案：可以包装一个构造函数为空的类。（另见<a href="https://stackoverflow.com/a/61346609">https://stackoverflow.com/a/61346609</a>和<a href="https://www.bilibili.com/video/BV1gu411m7kN">https://www.bilibili.com/video/BV1gu411m7kN</a>的1:24:00处）</p></li></ul><h2 id="std-weak-ptr"><a class="header-anchor" href="#std-weak-ptr">¶</a>std::weak_ptr</h2><p>指向一个由shared_ptr管理的对象，但不实际拥有它，也就不会影响引用计数。</p><p><code>expired()</code>检查对应的对象是否已被消除。</p><p><code>lock()</code>创建一个实际拥有对应对象的shared_ptr。</p><p>用于解决循环引用（引用计数永远不为0导致内存泄露），悬挂空指针（可以利用<code>expired</code>判断对象是否还存在，如果存在，再用<code>lock</code>来操作该对象）。</p><h2 id="std-enable-shared-from-this"><a class="header-anchor" href="#std-enable-shared-from-this">¶</a>std::enable_shared_from_this</h2><p>用于在类内拿到this的shared_ptr对象（有一个用处时用在回调函数中以使对象保活）。</p><p>对于指向同一个对象的多个shared_ptr，只能有一个是通过持有对象的指针构造的，其余的都是通过这个shared_ptr构造的。</p><p>而如果在类内使用<code>auto local = std::make_shared(this);</code>，就又产生了一个独立的shared_ptr。</p><p>正确的做法是<code>: public std::enable_shared_from_this&lt;T&gt;</code>，然后在类内使用<code>shared_from_this()</code>。</p><p>原理：利用了CRTP和<code>weak_ptr</code>。在shared_ptr的传入指针（<code>T* ptr</code>）的构造函数中，会判断T是不是继承自<code>enable_shared_from_this&lt;T&gt;</code>，如果是就将<code>enable_shared_from_this&lt;T&gt;</code>中的weak_ptr成员指向自身。这样每次<code>shared_from_this()</code>只需要调用该weak_ptr成员的<code>lock()</code>来得到一个共享的<code>shared_ptr</code>了。</p><p>在调用shared_from_this()之前，必须得有一个shared_ptr了，否则weak_ptr还没有被初始化。因此最好的方法是去掉该类的构造函数，只暴露一个工厂函数（create），返回一个独立的shared_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::numeric_limits&lt;T&gt;::<span class="built_in">min</span>();</span><br><span class="line">std::numeric_limits&lt;T&gt;::<span class="built_in">lowest</span>();</span><br><span class="line"><span class="comment">// 对于浮点数，min返回的是以标准形式表示的最小正浮点数，最小表示值应使用lowest</span></span><br><span class="line">std::numeric_limits&lt;T&gt;::<span class="built_in">infinity</span>();</span><br></pre></td></tr></table></figure><h2 id="deque"><a class="header-anchor" href="#deque">¶</a>deque</h2><p><code>std::deque</code>的实现是一个块状数组，每个块有固定的大小<code>block_size</code>（8或16），每次随机访问需要先算出块(<code>index / block_size</code>)，再找到块内偏移（<code>index % block_size</code>）。显然不同块的存储可能不连续。这样的好处是在不断<code>push_back</code>扩容时不需要移动数据，因此可以更快，且迭代器不会失效。</p><p><strong>仅供参考</strong>：相比<code>std::vector</code>，迭代器在扩容时不会失效；相比<code>std::list</code>，缓存更友好；相比<code>std::array</code>，可以动态扩容。因此可以作为全局的内存池使用（见<a href="https://codeforces.com/blog/entry/60321">https://codeforces.com/blog/entry/60321</a>）。</p><p><code>stack</code>和<code>queue</code>的底层默认是<code>deque</code>（只是禁用了某些接口）。</p><p><code>template&lt;class T, class Container = std::deque&lt;T&gt;&gt; class stack</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;elem*&gt; recycleBin;</span><br><span class="line">deque&lt;elem&gt; elemCache;</span><br><span class="line"></span><br><span class="line"><span class="function">elem *<span class="title">fetchElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!recycleBin.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    elem *temp = recycleBin.<span class="built_in">top</span>();</span><br><span class="line">    recycleBin.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line">  elemCache.<span class="built_in">push_back</span>(<span class="built_in">elem</span>());</span><br><span class="line">  <span class="keyword">return</span> &amp;elemCache.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteElement</span><span class="params">(elem *e)</span> </span>&#123;</span><br><span class="line">  recycleBin.<span class="built_in">push</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Shmoopty/veque"><code>veque</code></a>的实现方式就是在前面也有一段预留的buffer，即底层的buffer分成[front][data][back]三部分。类似地，在<code>push_front</code>时，如果没有空间，就对[front]进行扩容，也可以选择shift_back，需要对front和back的buffer进行平衡。front和data的边界用一个额外的变量<code>offset</code>指示，data和back的边界是<code>size</code></p><h2 id="ring-buffer"><a class="header-anchor" href="#ring-buffer">¶</a>ring_buffer</h2><p>环形缓冲区，或环形队列。容量是固定的。</p><p>每次读取数据返回的是<strong>当前</strong>最老的数据。</p><p>需要一个头指针（写索引）、尾指针（读索引）。由于可能出现缓冲区满发生覆盖的情况，判断当前是空还是满是重点。</p><ol><li>可以用一个<code>size</code>变量记录当前的大小。</li><li>留空一个位置，这样满的时候就是<code>max_size - 1</code>。</li><li>RT-Thread使用的是镜像指示位。每个索引的范围是<code>[0, 2 * max_size - 1]</code>，真实指针需要<code>% max_size</code>。同时为了效率，还用两个bool变量指示索引在逻辑地址空间（<code>[0, max_size - 1]</code>）还是镜像逻辑地址空间（<code>[max_size, 2 * max_size - 1]</code>）。</li><li>Linux2.6对镜像指示位进行了扩展，索引范围是<code>[0, 2^32 - 1]</code>，也就是让其自然溢出。本质上让索引能大于等于<code>max_size</code>，就可以通过差值等于<code>max_size</code>来判断满了，但这就强制要求<code>max_size</code>是2的幂次。</li></ol><p>要求ring_buffer的<code>max_size</code>为2的幂次会方便一些，取模可以用<code>&amp; (max_size - 1)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RT_Thread</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_ringbuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">rt_uint8_t</span> *buffer_ptr;</span><br><span class="line">  <span class="type">rt_uint16_t</span> read_mirror : <span class="number">1</span>;</span><br><span class="line">  <span class="type">rt_uint16_t</span> read_index : <span class="number">15</span>;</span><br><span class="line">  <span class="type">rt_uint16_t</span> write_mirror : <span class="number">1</span>;</span><br><span class="line">  <span class="type">rt_uint16_t</span> write_index : <span class="number">15</span>;</span><br><span class="line">  <span class="type">rt_int16_t</span> buffer_size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Linux2.6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *buffer; <span class="comment">/* the buffer holding the data */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">/* the size of the allocated buffer */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> in; <span class="comment">/* data is added at offset (in % size) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> out; <span class="comment">/* data is extracted from off. (out % size) */</span></span><br><span class="line">  <span class="type">spinlock_t</span> *lock; <span class="comment">/* protects concurrent modifications */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Linux5.17</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">kfifo</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> in;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> out;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> mask; <span class="comment">// max_size - 1</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> esize;</span><br><span class="line">  <span class="type">void</span>  *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="hyperloglog"><a class="header-anchor" href="#hyperloglog">¶</a>hyperloglog</h2><p><strong>估计</strong>一个很大的集合的基数。</p><p>基本思想：如果一个均匀分布的随机数集合中二进制前导零个数最大为$n$，则估计集合大小为$2^n$。</p><p>对每个数进行hash（hash得到的值就可以认为构成一个均匀分布的随机数集合），高14位作为桶编号，低50位在每个桶内统计前导零个数的最大值，最后对所有桶求加权平均。</p><h2 id="ordered-map"><a class="header-anchor" href="#ordered-map">¶</a>ordered map</h2><p>这里的order指的是保持插入时的顺序，对ordered map进行迭代会遵循插入的顺序。显然<code>std::map</code>和<code>std::unordered_map</code>都不满足要求。</p><p>实现方式：</p><ol><li>list存迭代器，map维护键值对</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;K, V&gt; map;</span><br><span class="line">std::list&lt;<span class="keyword">decltype</span>(map.begin())&gt; order;</span><br></pre></td></tr></table></figure><ol start="2"><li>一个deque/vector <code>values</code>维护value序列，另一个vector <code>buckets</code>维护桶序列，每个桶包含一个key的hash值以及其value在<code>values</code>中的下标（也就是一个map）。</li></ol><p><a href="https://github.com/Tessil/ordered-map%3E">tsl::ordered_map</a></p><p>有更快的插入和遍历速度，但是保持有序的删除是$O(N)$的。</p><ol start="3"><li>python3.6后的字典就是有序的。vector&lt;pair&lt;K,V&gt;&gt; <code>entries</code>存键值对，另一个vector <code>indices</code>存下标。每次查找，对键哈希找到在<code>indices</code>中的位置，然后得到在<code>entries</code>中的位置。</li></ol><p>显然删除也是$O(N)$的，但实际用了懒惰标记，在删除个数达到一定阈值时，再统一进行一次删除。</p><h2 id="placement-new"><a class="header-anchor" href="#placement-new">¶</a>placement new</h2><p><code>A* a = new(buf) A</code>，自己指定位置（给定<code>buf</code>，既可以是已分配的堆上空间，也可以是栈上的），然后调用对象的构造函数进行构造。</p><p>但注意用完对象后需要显示调用析构函数<code>a.~A()</code>。</p><p>类似于内存池，对内存复用。</p><p>还有一种情况是创建一个构造函数有参数的类数组，可以先申请空间，然后对每一项利用placement new构造对应的对象（这其实就是<code>vector</code>的做法）。</p><h2 id="algorithm"><a class="header-anchor" href="#algorithm">¶</a>algorithm</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>) <span class="comment">// range(0, n)</span></span><br><span class="line">std::<span class="built_in">fill</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), value)</span><br><span class="line">std::<span class="built_in">adjacent_difference</span>(in.<span class="built_in">begin</span>(), in.<span class="built_in">end</span>(), out.<span class="built_in">begin</span>()); <span class="comment">// 差分，out可以等于in</span></span><br><span class="line">std::<span class="built_in">partial_sum</span>(in.<span class="built_in">begin</span>(), in.<span class="built_in">end</span>(), out.<span class="built_in">begin</span>()) <span class="comment">// 前缀和</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">std::lexigraphical_compare</span><span class="params">(a.begin(), a.end(), b.begin(), b.end())</span> <span class="comment">// O(n)</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">std::is_sorted</span><span class="params">(a.begin(), a.end())</span></span></span><br><span class="line"><span class="function">iterator std::min/<span class="title">max_element</span><span class="params">(a.begin(), a.end())</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">std::binary_search</span><span class="params">(a.begin(), a.end(), target)</span> <span class="comment">// O(log n) </span></span></span><br><span class="line"><span class="function">T <span class="title">std::accumulate</span><span class="params">(a.begin(), a.end(), <span class="number">0LL</span>)</span></span>; <span class="comment">// 求区间和，注意返回类型和最后一个参数的类型相同</span></span><br><span class="line"><span class="type">bool</span> std::any/all/<span class="built_in">none_of</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), func);</span><br><span class="line">std::for_each(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), func); <span class="comment">// 很多时候可能不如range-based for</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">std::count</span><span class="params">(a.begin(), a.end(), value)</span></span>;</span><br><span class="line">std::<span class="built_in">nth_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k, a.<span class="built_in">end</span>()); <span class="comment">// 第k + 1大将位于a[k]，且前面的都不小于后面的 O(n)</span></span><br><span class="line">std::<span class="built_in">merge</span>(in1.<span class="built_in">begin</span>(), in1.<span class="built_in">end</span>(), in2.<span class="built_in">begin</span>(), in2.<span class="built_in">end</span>(), out.<span class="built_in">begin</span>()) <span class="comment">// 归并排序， out和in不能有重叠</span></span><br><span class="line">std::<span class="built_in">rotate</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k, a.<span class="built_in">end</span>()) <span class="comment">// a[k]成为第一个元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">std::is_permutation</span><span class="params">(a.begin(), a.end(), b.begin())</span> <span class="comment">// a是否是b的一个排列 O(n^2) 排序比较即可</span></span></span><br></pre></td></tr></table></figure><p><code>std::end(container)[-1]</code>像python一样得到最后一个元素</p><p><code>ssize(v)</code>返回有符号类型的大小</p><h2 id="std-byte"><a class="header-anchor" href="#std-byte">¶</a>std::byte</h2><p><code>enum class byte : unsigned char &#123;&#125;;</code></p><p>char/signed char/unsigned char被用于表示字节、字符以及执行计算。引入<code>std::byte</code>，专门让其用于表示一个字节的内容，只能进行位运算和比较运算，以提高程序的安全性和可读性。</p><p>注意：一个字节通常是8个比特，但也可能更多（如16比特），确切数值定义在<code>CHAR_BIT</code>中。</p><h2 id="std-call-once"><a class="header-anchor" href="#std-call-once">¶</a>std::call_once</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args )</span></span>;`</span><br></pre></td></tr></table></figure><p>确保一个函数只会被正常调用一次（如果调用时发生了异常，则不算正常调用）。用于全局变量的按需初始化一级单例模式。</p><p><code>std::once_flag</code>是专门用于<code>std::call_once</code>的一个结构体标记。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Singleton&amp; <span class="title">Singleton::get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::once_flag flag;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, [&amp;]()&#123; instance.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">SingletonDataBase</span>()); &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="built_in">get_interface</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-using"><a class="header-anchor" href="#std-using">¶</a>std::using</h2><p><code>typedef</code>可以通过声明+右左法则来理解，类型别名位于声明语句中变量名和函数名所在的位置。在C语言中与<code>static</code>、<code>register</code>等同属于storage class specifiers，即存储类型说明符。</p><p><code>std::using</code>中类型别名永远位于等号左侧，而<code>typedef</code>则会混杂在里面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*func_ptr)</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> func_ptr1 = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">double</span>);</span><br></pre></td></tr></table></figure><p>在右左法则中，我们会从未定义的变量名开始从右向左螺旋解释类型，但是在C++中，有些类型（模板、别名）是不包含名称的，这被称作<code>type-id</code>，这时应该从最左侧的最内层括号开始（当然C语言其实也是这样，只是有些人会从未定义变量开始，但在这里就不适用了）。</p><p><code>std::using</code>还可以用于模板别名。</p><h2 id="类成员函数指针"><a class="header-anchor" href="#类成员函数指针">¶</a>类成员函数指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (A::*fp)(<span class="type">int</span>) = &amp;(A::f);</span><br><span class="line"><span class="built_in">void</span> (*gp)(<span class="type">int</span>) = A::g;</span><br><span class="line">A a;</span><br><span class="line">a.*<span class="built_in">fp</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">gp</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>静态成员函数和普通的函数一样。而非静态成员函数在声明时需要附加类名称（<code>A::</code>），并且在调用时传入对象（<code>a.</code>），而且<code>&amp;</code>和<code>*</code>不能省略。</p><p>虚函数的指针值是一个偏移量，而不是实际地址。</p><h2 id="函数级try-catch"><a class="header-anchor" href="#函数级try-catch">¶</a>函数级try catch</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">int</span> x) <span class="keyword">try</span> : <span class="built_in">x_</span>(x) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n = <span class="number">2</span>)</span> <span class="keyword">try</span> </span>&#123;</span><br><span class="line">    ++n; <span class="comment">// increments the function parameter</span></span><br><span class="line">    <span class="keyword">throw</span> n;</span><br><span class="line">&#125; <span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    ++n; <span class="comment">// n is in scope and still refers to the function parameter</span></span><br><span class="line">    <span class="built_in">assert</span>(n == <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个try块包裹了函数体（对于构造函数，还可以包裹成员初始化），但不包括函数参数的赋值。</p><p>特别地，对于构造函数上的try catch，如果发生异常，虽然会执行catch块，但由于对象构造失败，唯一能做的就是<strong>重新抛出一次异常</strong>。因此构造函数上的try catch的作用仅仅是清理或者抛出另一个异常，它并不能阻止异常的传播。</p><h2 id="类模板参数推导"><a class="header-anchor" href="#类模板参数推导">¶</a>类模板参数推导</h2><p>C++17起有CTAD，此时不必写出模板参数列表，编译器会根据上下文进行推导（有点类似rust）。</p><p>所以可以写出下面的简化代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair <span class="title">p</span><span class="params">(<span class="number">2</span>, <span class="number">4.5</span>)</span></span>; <span class="comment">// std::pair&lt;int, double&gt;</span></span><br><span class="line"><span class="function">std::vector <span class="title">dp</span><span class="params">(N, std::vector&lt;<span class="type">int</span>&gt;(M))</span></span>; <span class="comment">// 多维vector的声明会方便很多</span></span><br><span class="line">std::<span class="built_in">lock_guard</span>(mutex); <span class="comment">// std::lock_guard(std::mutex) 函数也是可以的</span></span><br></pre></td></tr></table></figure><h3 id="推导指示"><a class="header-anchor" href="#推导指示">¶</a>推导指示</h3><p>用于指示编译器如何正确推导模板参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span></span><br><span class="line">&#123;</span><br><span class="line">    T first&#123;&#125;;</span><br><span class="line">    U second&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here&#x27;s a deduction guide for our Pair (needed in C++17)</span></span><br><span class="line"><span class="comment">// Pair objects initialized with arguments of type T and U should deduce to Pair&lt;T, U&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">Pair</span>(T, U) -&gt; Pair&lt;T, U&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1&#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">// explicitly specify class template Pair&lt;int, int&gt; (C++11 onward)</span></span><br><span class="line">    Pair p2&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;           <span class="comment">// CTAD used to deduce Pair&lt;int, int&gt; from the initializers (C++17)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Y-Combinator"><a class="header-anchor" href="#Y-Combinator">¶</a>Y Combinator</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html</a></p><p>C++不支持递归的lambda，只能通过std::function解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> gcd = std::<span class="built_in">y_combinator</span>([](<span class="keyword">auto</span> gcd, <span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一种示例实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Fun</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">y_combinator_result</span> &#123;</span><br><span class="line">    Fun fun_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">y_combinator_result</span><span class="params">(T &amp;&amp;fun)</span>: fun_(std::forward&lt;T&gt;(fun)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ...Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">operator</span><span class="params">()</span><span class="params">(Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fun_</span>(std::<span class="built_in">ref</span>(*<span class="keyword">this</span>), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Fun&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">y_combinator</span><span class="params">(Fun &amp;&amp;fun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y_combinator_result&lt;std::<span class="type">decay_t</span>&lt;Fun&gt;&gt;(std::forward&lt;Fun&gt;(fun));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace std</span></span><br></pre></td></tr></table></figure><h2 id="new-int-0"><a class="header-anchor" href="#new-int-0">¶</a>new int[0]</h2><p>这被允许，但是返回的指针没有意义，对其解引用是未定义行为，但是你仍然需要使用<code>delete[]</code>（没有规定应该怎么实现，但猜测会像非零值时一样再前面有一块meta data，并不会特殊处理）。</p><p>这是为了和malloc一致，不过<code>malloc(0)</code>会返回NULL，而<code>new int[0]</code>不一定。</p><p>和<code>free(NULL)</code>类似，<code>delete nullptr</code>什么也不会做，是合法行为。</p><h2 id="std-clog"><a class="header-anchor" href="#std-clog">¶</a>std::clog</h2><p>除了常见的<code>std::cout</code>和<code>std::cerr</code>外，还有<code>std::clog</code>，它也输出到stderr中。区别是<code>std::cerr</code>不像其它两个那样会缓冲。</p><h2 id="std-string-c-str-vs-data"><a class="header-anchor" href="#std-string-c-str-vs-data">¶</a>std::string c_str() vs. data()</h2><p>在C++11之后，std::string和C风格字符串一样，会额外存储一个’\0’作为null terminate。因此，c_str()和data()都保证返回的是null terminate的字符数组，它们的行为一样。</p><p>在C++17之后，data()有const和非const的重载，而c_str()一定返回const。</p><h2 id="三向比较"><a class="header-anchor" href="#三向比较">¶</a>三向比较</h2><p>C++20之前可以重载<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>==</code>、<code>!=</code>这6种比较运算符。</p><p>一般会遵循以下原则：</p><ul><li>同类型用成员函数实现</li><li>不同类型用非成员函数实现</li><li>优先实现<code>&gt;</code>、<code>&lt;</code>、<code>==</code></li><li>其余的用以上三种实现</li></ul><h3 id="默认比较"><a class="header-anchor" href="#默认比较">¶</a>默认比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Point&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><p>编译器会按固定的规则生成所有的6种比较运算符。</p><h3 id="自定义比较"><a class="header-anchor" href="#自定义比较">¶</a>自定义比较</h3><p><code>&lt;=&gt;</code>的返回类型有三种：</p><ul><li><code>std::strong_ordering</code>：必须严格比较所有成员，但是可以按不同的顺序。严格的意思是说，如果<code>a==b</code>，则<code>f(a)==f(b)</code>，其中<code>f</code>是任意只读函数</li><li><code>std::weak_ordering</code>：必须比较所有成员，但是可以按不同的顺序。可以是不严格的，比如字符串可以按照大小写不敏感的方式比较。</li><li><code>std::partial_ordering</code>：允许只比较部分成员，可以按不同的顺序，也可以是不严格的。</li></ul><p>如果类包含容器类型，应该再写一个默认的等于运算符，因为三向比较生成的会比较容器中的每一个元素，而等于运算符生成的会优先比较容器的大小，性能会更好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><h2 id="format"><a class="header-anchor" href="#format">¶</a>format</h2><p>用法类似Python3的fstring：<code>std::format(&quot;Hello &#123;&#125;&quot;, world_str)</code>。</p><p><code>std::format</code>相比于<code>sprintf</code>和<code>std::stringstream</code>的优势是速度更快，更安全（不需要写具体的格式控制符，用大括号即可），在浮点数精度方面也更优。</p><p>不过自定义类型要想使用<code>std::format</code>还是比较麻烦的，需要写一个特化的<code>std::formatter&lt;T&gt;</code>，实现其中的<code>parse</code>函数和<code>format</code>函数。</p><p>此外，<code>std::format_to</code>将结果写入到一个迭代器中，用于追加写，<code>std::format_to_n</code>限制最多写入n个字符，<code>std::formatted_size</code>则返回构成的字符串的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">format</span><span class="params">( std::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> OutputIt, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">format_to</span><span class="params">( OutputIt out, std::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> OutputIt, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">std::format_to_n_result&lt;OutputIt&gt;</span></span><br><span class="line"><span class="function">    <span class="title">format_to_n</span><span class="params">( OutputIt out, std::<span class="type">iter_difference_t</span>&lt;OutputIt&gt; n,</span></span></span><br><span class="line"><span class="params"><span class="function">                 std::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">formatted_size</span><span class="params">( std::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="optional"><a class="header-anchor" href="#optional">¶</a>optional</h2><ul><li><code>std::make_optional()</code></li><li><code>*</code>, <code>has_value()</code></li><li><code>-&gt;</code>, <code>value()</code></li><li><code>value_or(default_value)</code>：为空就返回传入的default_value</li><li><code>reset()</code>：如果有value，就销毁包含的value（这和<code>=&#123;&#125;</code>,<code>=std::nullopt</code>没什么区别）</li><li><code>emplace()</code>：optional也有emplace函数，在原地构造</li></ul><h2 id="extern-“C”"><a class="header-anchor" href="#extern-“C”">¶</a>extern “C”</h2><p>C++有函数重载、命名空间、模板等，因此需要对名称进行mangle，而C语言不会。</p><p>使用<code>extern &quot;C&quot;</code>表明符号不会被mangle，从而能够与C文件链接，实现在C文件中调用C++函数以及在C++文件中调用C函数。显然，在<code>extern &quot;C&quot;</code>就不能使用C++那些必须mangle的功能了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">double</span> b;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">char</span> c;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>extern &quot;C&quot; &#123;...&#125;</code>作用到其中所有具有外部链接的函数和变量上。</p><p>注意，不带大括号时，extern直接作用到后续的语句上，因此这只是一个声明。而在带大括号时，则是声明加定义，除非写成<code>extern &quot;C&quot; &#123; extern int a; &#125;</code>。当然，这个细微差别仅在定义变量时存在，而在更常见的定义函数时不存在。</p><p>除了<code>static</code>，在C++中<code>const</code>变量也会变成内部链接。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c snippets</title>
      <link href="/2023/09/19/c-snippets/"/>
      <url>/2023/09/19/c-snippets/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> die(msg)                                      \</span></span><br><span class="line"><span class="meta">do &#123;                                                  \</span></span><br><span class="line"><span class="meta">    perror(msg);                                      \</span></span><br><span class="line"><span class="meta">    exit(EXIT_FAILURE);                               \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))</span></span><br><span class="line"><span class="comment">// 在sizeof中数组类型是不会退化的</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(<span class="literal">NULL</span>); <span class="comment">// 在C标准中，这是合法的，不会发生任何操作</span></span><br></pre></td></tr></table></figure><blockquote><p>If ptr is a null pointer, no action occurs.</p></blockquote><p>So, no need to check for NULL before <code>free</code>, it only adds more dummy code to read and is thus a bad practice.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((int)&amp;(((TYPE *)0)-&gt;MEMBER))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;                      \</span></span><br><span class="line"><span class="meta">        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">        (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br></pre></td></tr></table></figure><p><code>offsetof</code>在给定结构体类型和一个成员名时，计算结构体中该成员相对于首地址的偏移量。这里加了取地址，从而不会解引用<code>0-&gt;MEMBER</code>。<code>container_of</code>在给定结构体类型，以及其中一个成员的名称及其地址时，得到结构体的首地址。这里<code>(&#123;x;y;&#125;)</code>是GNU的扩展，它会计算每个表达式并返回最后一个表达式的值。此外第一行只是用于类型检查，其中<code>typeof</code>也是GNU的扩展，类似C++中的<code>decltype</code>。以上宏可以用于实现无侵入式的链表。</p><h2 id="匿名枚举"><a class="header-anchor" href="#匿名枚举">¶</a>匿名枚举</h2><p><a href="https://stackoverflow.com/questions/7147008/the-usage-of-anonymous-enums">https://stackoverflow.com/questions/7147008/the-usage-of-anonymous-enums</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> color = <span class="number">1</span> &#125;; </span><br></pre></td></tr></table></figure><p>相比于<code>#define</code>更安全，相比于<code>const int</code>，则不会占用空间，并且是编译期求值，可以放在类的内部（即等价于<code>static const int</code>）。</p><h2 id="jmp"><a class="header-anchor" href="#jmp">¶</a>jmp</h2><ul><li><code>setjmp(jmp_buf buf)</code>：在buf中保存当前的执行上下文，并返回0。</li><li><code>longjmp(jmp_buf buf, i)</code>：加载buf保存的上下文，即恢复到上次<code>setjmp</code>的位置，并使下次<code>setjmp</code>返回i。</li></ul><p>在C语言中实现错误处理（try catch）、协程等。</p><h2 id="零长数组"><a class="header-anchor" href="#零长数组">¶</a>零长数组</h2><p>也叫柔性数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">char</span> contents[<span class="number">0</span>]; <span class="comment">// or char contents[]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> *<span class="title">thisline</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> line) + this_length);</span><br><span class="line">thisline-&gt;length = this_length;</span><br><span class="line">assert(<span class="keyword">sizeof</span>(contents) == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 在结构体外也能声明int a[0]，但是不能int a[]，其实类似于一个label</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIKELY(x) __builtin_expect(!!(x), 1) <span class="comment">// x很可能为真</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNLIKELY(x) __builtin_expect(!!(x), 0) <span class="comment">// x很可能为假</span></span></span><br><span class="line"><span class="comment">// __builtin_expect(exp, c)表示exp等于c的概率很大，用于引导CPU的分支预测</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/prefetch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prefetch(x) __builtin_prefetch(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prefetchw(x) __builtin_prefetch(x,1)</span></span><br><span class="line">__builtin_prefetch(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">int</span> rw, <span class="type">int</span> locality) <span class="comment">// 主动将数据读取到addr中，rw=1表示可写，0表示只读</span></span><br></pre></td></tr></table></figure><h2 id="位域"><a class="header-anchor" href="#位域">¶</a>位域</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// will usually occupy 2 bytes:</span></span><br><span class="line">    <span class="comment">// 3 bits: value of b1</span></span><br><span class="line">    <span class="comment">// 5 bits: unused</span></span><br><span class="line">    <span class="comment">// 2 bits: value of b2</span></span><br><span class="line">    <span class="comment">// 6 bits: unused</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b1 : <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> :<span class="number">0</span>; <span class="comment">// start a new byte; 0只能作用在匿名的变量上，用于后续的强制对齐</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b2 : <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(S) == <span class="number">2</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="comment">// Unsigned integer member x</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="comment">// Bit-field member y with 33 bits</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y : <span class="number">33</span>;</span><br><span class="line">    <span class="comment">// Unsigned integer member z</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(test) = <span class="number">16</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="type">uint8_t</span> b : <span class="number">1000</span>; <span class="comment">// 当指定的大小大于类型的大小时，值域会被类型限制，</span></span><br><span class="line"><span class="comment">// 多余的位数仅仅充当padding</span></span><br></pre></td></tr></table></figure><p>位域成员不能取地址，也就不能用指针指向它，因为它可能不是起始于某个字节。常量引用可以绑定到位域成员。此外也不能使用<code>sizeof</code>。</p><p>只有integral和enumeration类型可以指定位域。</p><h2 id="restrict"><a class="header-anchor" href="#restrict">¶</a>restrict</h2><p>类似于const和volatile的类型限定符，仅可作用于指针类型（在C++中没有类似的关键字），向编译器承诺仅能通过该指针访问指向的变量，从而进行更多优化。</p><p>比如在memmove中，<code>src</code>和<code>dst</code>指向的区域可能重叠，此时就不能加<code>restrict</code>。而memcpy如果不考虑重叠问题，可以加<code>restrict</code>关键字进行更多优化</p><p>由于在C++中，<code>restrict</code>怎么处理类不好解决，所以C++标准没有添加。但主流编译器都支持<code>__restrict</code>扩展，但显然不同编译器的语义可能不同。</p><p>注意<code>getchar()</code>的返回值是int，要么是unsigned char，要么是EOF（通常是-1），因此应该写<code>int c = getchar()</code>。</p><h2 id="alloc"><a class="header-anchor" href="#alloc">¶</a>*alloc</h2><p><code>void* calloc( std::size_t num, std::size_t size )</code>用于分配num个大小为size的元素，并且保证零初始化。而<code>malloc</code>不会对分配的内存进行任何初始化。另一个<code>calloc</code>的优点是它可以避免<code>num * size</code>发生溢出的情况。通常<code>calloc</code>会比<code>malloc</code>慢。TODO：mmap会返回全零的页面。</p><p><code>void* alloc(size_t size)</code>在当前函数的栈帧内分配少量内存，并在函数返回时释放。使用场景是可变数组（以变量为长度）和可边长参数列表（va_list）。</p><h2 id="I-O缓冲"><a class="header-anchor" href="#I-O缓冲">¶</a>I/O缓冲</h2><ul><li>全缓冲：仅在缓冲区满时才进行实际I/O操作</li><li>行缓冲：在遇到换行符时才进行实际I/O操作</li><li>无缓冲：不进行缓冲</li></ul><p><code>stdint</code>和<code>stdout</code>在非交互设备下是全缓冲的，而<code>stderr</code>是无缓冲或行缓冲的。所以像日志这种输出到<code>stderr</code>的没必要在每次输出后再刷新一下缓冲区（如果输出会换行的话）。</p><p>文本文件和二进制文件的区别是文本文件会对诸如换行符等进行处理（在windows下应为<code>\r\n</code>，即回车+换行），而二进制文件只是当做普通的字节（因此，在*nix下两者没有区别）。</p><h2 id="信号"><a class="header-anchor" href="#信号">¶</a>信号</h2><p><code>int raise(int sig)</code>产生一个信号，成功时返回0。</p><p><code>void (*signal(int sig, void (*handler)(int)))(int)</code>对一个信号注册一个回调函数。特别地，<code>SIG_DFL</code>会采用实现定义的默认行为，<code>SIG_IGN</code>会忽略信号。</p><ul><li><code>SIGABRT</code>：异常退出，如<code>abort</code></li><li><code>SIGFPE</code>：算术异常，如除0和溢出</li><li><code>SIGINT</code>：中断 (<code>CTRL+C</code>；<code>CTRL+D</code>表示EOF，用于交互程序；<code>CTRL+Z</code>发送<code>TSTP</code>，让程序在后台运行，可以用<code>fg</code>恢复)</li><li><code>SIGTERM</code>：终止请求 (<code>kill [15]</code>)</li><li><code>SIGSEGV</code>：段错误</li></ul><h2 id="可变参数列表"><a class="header-anchor" href="#可变参数列表">¶</a>可变参数列表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;</span><br><span class="line">va_start(ap, arg); <span class="comment">// 使ap指向最后一个命名参数arg</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">va_arg</span><span class="params">(ap, <span class="type">int</span>)</span>; <span class="comment">// 移动到下一个参数，并用指定的type类型解释</span></span><br><span class="line">va_end(ap);</span><br></pre></td></tr></table></figure><h2 id="div"><a class="header-anchor" href="#div">¶</a>div</h2><p><code>div_t div(int x, int y)</code>返回的<code>div_t</code>是有成员<code>quot</code>和<code>rem</code>的结构体。</p><p><code>double fmod(double x, double y)</code>计算浮点数模数。</p><p><code>double modf(double arg, double* ap)</code>返回小数部分，并在<code>ap</code>中存储整数部分。</p><p><code>size_t strspn( const char *dest, const char *src )</code>返回以<code>dest</code>起始的最长前缀，其只包含<code>src</code>中的字符。</p><p><code>char *strpbrk( const char *dest, const char *breakset )</code>返回第一个在<code>breakset</code>中出现的字符的位置</p><p><code>char *strtok( char *str, const char *delim )</code>根据<code>delim</code>对<code>str</code>进行split。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *token = strtok(input, <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(token) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(token);</span><br><span class="line">    token = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>); <span class="comment">// 传入NULL以继续处理第一次调用时的input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用会从上个<code>token</code>结束的位置开始查找不包含<code>delim</code>的<code>token</code>，并将结束位置永久置为’\0’后返回（因此传入的参数不是const的），每次<code>strtok</code>的<code>delim</code>可以不同。</p><h2 id="sizeof"><a class="header-anchor" href="#sizeof">¶</a>sizeof</h2><p><code>sizeof(type)</code>或<code>sizeof expression</code>，表达式是可以不加括号的，但由于优先级问题以及保持一致性原则，建议永远加括号。如<code>sizeof a + b</code>其实是<code>sizeof(a) + b</code>。</p><h2 id="函数指针"><a class="header-anchor" href="#函数指针">¶</a>函数指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*fp)(<span class="type">int</span>) = &amp;f;</span><br><span class="line">(*fp)(<span class="number">10</span>);</span><br><span class="line"><span class="type">void</span> (*fp)(<span class="type">int</span>) = f;</span><br><span class="line">fp(<span class="number">10</span>);</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">void</span> fp(<span class="type">int</span>))</span>; <span class="comment">// 在函数参数中函数类型会隐式转为指针（就像数组名会退化为指针一样）</span></span><br></pre></td></tr></table></figure><p>这两种写法都是可以的，函数名称（可以认为是函数指针常量，类比数组）和指针混用可以理解为一种语法糖，函数指针与其它指针的区别是它指向代码而不是数据。</p><p><code>void *__builtin_return_address(unsigned int level)</code>：返回当前函数或其调用者之一的返回地址<code>void *__builtin_frame_address(unsigned int level)</code>： 返回函数栈帧地址（帧是堆栈上保存局部变量和寄存器的区域，帧地址是函数对应堆栈区域的起始地址）</p><p>分别在main执行前和main执行后运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">__attribute__((destructor))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python snippets</title>
      <link href="/2023/09/16/python-snippets/"/>
      <url>/2023/09/16/python-snippets/</url>
      
        <content type="html"><![CDATA[<h2 id="无穷大"><a class="header-anchor" href="#无穷大">¶</a>无穷大</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"><span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">math.inf</span><br><span class="line">-math.inf</span><br><span class="line"><span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) == math.inf <span class="comment"># True</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)) == <span class="built_in">float</span></span><br><span class="line"><span class="built_in">type</span>(math.inf) == <span class="built_in">float</span></span><br></pre></td></tr></table></figure><h2 id="map"><a class="header-anchor" href="#map">¶</a>map</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;&#123;&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;[&#x27;</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义比较"><a class="header-anchor" href="#自定义比较">¶</a>自定义比较</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lst.sort(<span class="keyword">lambda</span> x: <span class="number">10</span> * x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">i, j</span>):</span><br><span class="line">    <span class="keyword">if</span> a[i] &lt; a[j]: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> a[i] &gt; a[j]: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">lst.sort(functools.cmp_to_key(cmp))</span><br><span class="line"><span class="comment"># list.sort()和sorted都保证是stable的</span></span><br></pre></td></tr></table></figure><p><code>for i, x in enumerate(lst):</code></p><h2 id="多维列表"><a class="header-anchor" href="#多维列表">¶</a>多维列表</h2><p><code>lst * n</code>会创建n个浅拷贝的列表，所以应该使用列表推导</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cppquiz</title>
      <link href="/2023/09/11/cppquiz/"/>
      <url>/2023/09/11/cppquiz/</url>
      
        <content type="html"><![CDATA[<ul><li>Undefined behaviour：未定义行为。标准没有规定程序在该状态下的行为，也就是可以发生任何事情。这是不行的。</li><li>Unspecified behavior：未指定行为。这是可以的，但是可能有多种有效的结果。</li><li>Implementation-defined behavior：实现定义行为。与未指定行为类似，但是需要在编译手册中记录。</li><li>Ill-formed, no diagnostic required：错误且无需诊断。等价于未定义行为，只是这种说法更侧重于编译期（代码层面），而未定义行为更侧重于运行期。</li></ul><h2 id="值类别"><a class="header-anchor" href="#值类别">¶</a>值类别</h2><p>参考<a href="https://paul.pub/cpp-value-category/">https://paul.pub/cpp-value-category/</a></p><p>每个表达式有两个属性：类型（type）和值类别（value category）。</p><p>左值（lvalue）常常出现在等号左边，而右值（rvalue）常常出现在等号右边。（考虑<code>const int</code>，在初始化时能出现在左边，之后只能出现在右边，无法分类）</p><p>更准确地说，左值代表了具有内存地址的对象（locator value），而右值代表临时值。</p><p>在C++11后，值类别分为lvalue、prvalue、xvalue以及glvalue和rvalue五种。</p><ul><li>lvalue：拥有身份且不可被移动的表达式。</li><li>xvalue (eXpiring value)：拥有身份且可被移动的表达式。</li><li>prvalue (pure rvalue)：不拥有身份且可被移动的表达式。</li><li>glvalue (generalized lvalue)：拥有身份的表达式，lvalue和xvalue都是glvalue。</li><li>rvalue：可被移动的表达式。prvalue和xvalue都是rvalue。</li></ul><p>身份：即是否可以判断两个表达式对应于同一个实体，如根据地址。</p><ul><li>左值引用（&amp;）：非const版本只能绑定到左值，const版本还可以绑定到右值。</li><li>右值引用（&amp;&amp;）：只能绑定到右值。</li></ul><p><a data-fancybox="gallery" data-src="/post-images/value-catogory.png" data-caption="值类别分类"><img src="/post-images/value-catogory.png" alt="值类别分类"></a></p><h3 id="移动语义"><a class="header-anchor" href="#移动语义">¶</a>移动语义</h3><p>在定义了拷贝构造和拷贝赋值函数时，通常还需要定义析构函数，此时一般涉及到拥有所有权的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">X</span>(<span class="type">const</span> X&amp; other); <span class="comment">// copy constructor</span></span><br><span class="line">X&amp; <span class="keyword">operator</span>=(X other); <span class="comment">// copy assignment</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">X</span>(X&amp;&amp;) <span class="comment">// move constructor</span></span><br><span class="line">X&amp; <span class="keyword">operator</span>=(X&amp;&amp;); <span class="comment">// move assignment</span></span><br></pre></td></tr></table></figure><p>简单来说，在拷贝中我们会new一段新的内存空间，并根据给定对象构造一份相同的。而在移动中我们只是将给定对象内部的指针拷贝过来。（类似深拷贝、浅拷贝）</p><p>Rule of Three：每当需要显式定义析构、拷贝构造和拷贝赋值之一，就应该考虑显式定义全部。</p><p>补充：通常该类需要手动管理资源，但是如果涉及多个资源，且在构造函数中发生异常，对应的析构函数不会被调用，因为这个对象就没有存在过（非异常安全）。解决方法是使用一个RAII类来包装每一个资源。而此时通常不再需要显示定义析构函数，可以直接使用默认的版本，因为资源的释放转而在RAII类的析构函数中进行，这也被称作Rule of two。</p><p>RAII表示资源获取即初始化，其将资源与对象的生命联系起来，在构造函数中<strong>申请或获取</strong>资源，在析构函数中释放资源RAII并不是指资源一定要在构造函数中自行申请，而是资源的获取和释放与对象的生命周期相关联。在不同情况下，资源的获取可以通过构造函数参数传递，也可以通过对象的构造函数自行申请。关键是确保资源的正确管理与对象的生命周期一致，以避免资源泄漏和不正确的资源使用。</p><p>Rule of Five：在C++11及以后，还要再加上移动构造和移动赋值。</p><p>Rule of Zero：与此同时，一个类除非与资源管理有关，否则不应该自定义任何特殊函数。单一职责原理。因为一个特殊的成员就去自行编写这几个特殊函数很容易产生问题和麻烦。</p><p><code>std::move()</code>无条件地将实参强制转换为右值引用（作用类似<code>static_cast</code>）</p><h3 id="完美转发"><a class="header-anchor" href="#完美转发">¶</a>完美转发</h3><p><code>emplace_back</code>就是用的这个技术，避免了一个临时对象的构造（难点是怎么在函数调用间保持参数的正确类型）。</p><p>引用折叠规则：只有右值+右值（即A&amp;&amp; &amp;&amp;）仍然为右值，否则都将变为左值。</p><p>Universal Referense：<code>template&lt;typename T&gt; T&amp;&amp;</code>，T会被正确地推导为对应的左值引用或右值引用类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(T1&amp;&amp; e1, T2&amp;&amp; e2)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">func</span>(forward&lt;T1&gt;(e1), forward&lt;T2&gt;(e2)); </span><br><span class="line">    <span class="comment">// forward将e1转为std::remove_reference&lt;T1&gt;::type&amp;&amp;类型，</span></span><br><span class="line">    <span class="comment">// 也就是正确的右值引用类型 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个部分，首先是参数中的<code>T1&amp;&amp; e1</code>，这利用Uref的特性来保持类型。然后是调用func中的<code>forward&lt;T1&gt;(e1)</code>，forward为T1叠加了一个&amp;&amp;，基于引用叠加规则，也能继续保持类型。</p><h2 id="右左法则"><a class="header-anchor" href="#右左法则">¶</a>右左法则</h2><p>用于解读变量的声明类型，也叫螺旋修饰规则。</p><p>从未定义的变量名（最左侧的最内层括号）开始，先往右再往左（顺时针顺序），遇到</p><ul><li><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">一个有x个元素的数组，元素类型为…</label></li><li>[] 一个元素个数未知的数组，元素类型为…</li><li>(type1, type2) 一个函数，第一个参数类型为type1，第二个参数类型为type2，返回类型为…</li><li>* 一个指针，指向类型为…</li><li>冗余的左括号只能在向上的时候碰到，冗余的右括号只能在向下的时候碰到，否则语法错误</li><li>特别注意穿插的cv限定符</li></ul><h3 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h3><p><code>int (*func)( int *p, int (*f)(int*) );</code></p><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><ol><li>func是指针<code>*</code>，指向类型为</li><li>一个函数，第一个参数类型为<code>int *p</code>，第二个参数类型为<code>int (*f)(int*)</code>，返回类型为</li><li>int</li></ol></details><p><code>int ( *(*func)(int *p) )[5];</code></p><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><ol><li>func是指针<code>*</code>，指向类型为</li><li>一个函数，第一个参数类型为<code>int *p</code>，返回类型为</li><li>一个指针，指向类型为</li><li>一个有5个元素的数组，元素类型为</li><li>int</li></ol></details><p><code>int (*)p[2]</code></p><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>语法错误。这里在向上的时候碰到了冗余的右括号。</p></details><p><code>int const *p</code></p><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>p是一个指针，指向一个指针，指向一个const修饰的int。可见const写在右侧用右左法则更容易解释。</p><p>const作用到它<strong>左侧</strong>的元素，仅当它是最左侧时，才作用到右侧的元素。</p></details><p>可以用<a href="https://cdecl.org/">https://cdecl.org/</a>检查。</p><h2 id="整数提升"><a class="header-anchor" href="#整数提升">¶</a>整数提升</h2><p>整数类型有一个排名（<code>bool</code>&lt;<code>signed char</code>&lt;<code>short</code>&lt;<code>int</code>&lt;<code>long</code>&lt;<code>long long</code>，unsigned与对应的一致）。</p><p>大致是按照大小排名的，但不同类型的大小允许存在等于的情况，但排名不存在。</p><ol><li>所有低于int的整数类型在计算时都会隐式提升为int（如果int能够表示所有取值）或unsigned int。</li><li>当有类型高于int，另一个小类型会隐式提升为该大类型（比如int和unsigned int计算会统一为unsigned int类型）。</li></ol><h2 id="105"><a class="header-anchor" href="#105">¶</a>105</h2><h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;a&quot;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">label:</span><br><span class="line">  A a;</span><br><span class="line">  <span class="keyword">if</span> (i--)</span><br><span class="line">    <span class="keyword">goto</span> label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出"><a class="header-anchor" href="#输出">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>aAaA</code></p></details><h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>goto</code>本质就是跳转，可以把label标签到goto间当作一个作用域，因此和循环语句类似，类a是会在goto时进行销毁的。</p><ul><li><p>在退出一个作用域，具有自动存储期的对象会按照构造的<strong>相反</strong>顺序销毁。</p></li><li><p>以跳转方式离开作用域时会在跳转<strong>前</strong>进行销毁。</p></li></ul><p>自动存储期：函数中不使用<code>static</code>定义出来的变量。</p><ol><li><p>程序在执行到对象声明时构造相应的对象 (<code>int a = 1</code>)，在执行到包含该声明的程序块的结尾时析构该对象 (<code>&#125;</code>)。</p></li><li><p>如果不显式地进行初始化，则该对象的初始值不确定。</p></li></ol></details><h2 id="217"><a class="header-anchor" href="#217">¶</a>217</h2><h3 id="代码-s2"><a class="header-anchor" href="#代码-s2">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span>&amp; a = i &gt; <span class="number">0</span> ? i : <span class="number">1</span>;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s2"><a class="header-anchor" href="#输出-s2">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>21</code></p></details><h3 id="分析-s2"><a class="header-anchor" href="#分析-s2">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>这里变量a不是i的引用，而是三元表达式返回的临时变量的引用（因为1是临时值）。</p><p><code>int const&amp;</code>等价于<code>const int&amp;</code>，这里的const都是底层const（与指针不同），因为引用本身就具有const语义：必须被初始化且不能被再次赋值（即使是相同值；准确地说引用可以被赋值，但语义是修改引用的对象的值）。</p></details><h2 id="295"><a class="header-anchor" href="#295">¶</a>295</h2><h3 id="代码-s3"><a class="header-anchor" href="#代码-s3">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">2</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">a_string</span> &#123;</span><br><span class="line">   <span class="built_in">a_string</span>() &#123; *a=<span class="string">&#x27;1&#x27;</span>; &#125;</span><br><span class="line">   ~<span class="built_in">a_string</span>() &#123; *a=<span class="string">&#x27;0&#x27;</span>; &#125;</span><br><span class="line">   <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> </span>&#123; std::cout &lt;&lt; s; &#125;</span><br><span class="line"><span class="function">a_string <span class="title">make_string</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a_string&#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   a_string s1 = <span class="built_in">make_string</span>();</span><br><span class="line">   <span class="built_in">print</span>(s1.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* s2 = <span class="built_in">make_string</span>().<span class="built_in">c_str</span>();</span><br><span class="line">   <span class="built_in">print</span>(s2);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">make_string</span>().<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s3"><a class="header-anchor" href="#输出-s3">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>101</code></p></details><h3 id="分析-s3"><a class="header-anchor" href="#分析-s3">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>临时变量的销毁作为求值包含它的<strong>完整表达式</strong>的最后一步。</p><p>s1不是临时变量，在main结束前才销毁。</p><p>第二个make_string()产生的临时变量在赋值后销毁。</p><p>第三个make_string()在打印后销毁。</p></details><h2 id="49"><a class="header-anchor" href="#49">¶</a>49</h2><h3 id="代码-s4"><a class="header-anchor" href="#代码-s4">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span>(<span class="type">int</span> i) : <span class="built_in">i</span>(i) &#123; std::cout &lt;&lt; i; &#125;</span><br><span class="line">  ~<span class="built_in">C</span>() &#123; std::cout &lt;&lt; i + <span class="number">5</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> C &amp;c = <span class="built_in">C</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">C</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">C</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s4"><a class="header-anchor" href="#输出-s4">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>127386</code></p></details><h3 id="分析-s4"><a class="header-anchor" href="#分析-s4">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>和上一题一样，临时变量会在用完后立即销毁。除了C(1)被绑定到const引用上，延长了生命周期。</p></details><h2 id="14"><a class="header-anchor" href="#14">¶</a>14</h2><h3 id="代码-s5"><a class="header-anchor" href="#代码-s5">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;a&quot;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;b&quot;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;c&quot;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">C</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="type">static</span> C c; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s5"><a class="header-anchor" href="#输出-s5">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>abcBCA</code></p></details><h3 id="分析-s5"><a class="header-anchor" href="#分析-s5">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>变量a在全局空间声明，是静态的。其动态初始化可能在main之前完成，也可能在main中调用任何函数前或者被第一次使用时完成（这是实现定义的）。</p><p>局部自动变量在定义域结束前销毁（注意和临时变量的区别）。</p><p>函数内的静态变量则在第一次经过它是被构造。</p><p>最后所有静态变量按照初始化的<strong>相反</strong>顺序进行销毁。</p></details><h2 id="148"><a class="header-anchor" href="#148">¶</a>148</h2><h3 id="代码-s6"><a class="header-anchor" href="#代码-s6">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; (a + a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s6"><a class="header-anchor" href="#输出-s6">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>未定义行为</p></details><h3 id="分析-s6"><a class="header-anchor" href="#分析-s6">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>在读取volatile变量时，它的值可能发生改变。</p><p>在计算表达式时，如果没有明确指定（逻辑运算符的短路），运算顺序是未定义的。</p><p>修改的写法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tmp = a;</span><br><span class="line">  <span class="comment">// do stuff with tmp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="252"><a class="header-anchor" href="#252">¶</a>252</h2><h3 id="代码-s7"><a class="header-anchor" href="#代码-s7">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="string">&#x27;3&#x27;</span> - <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s7"><a class="header-anchor" href="#输出-s7">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>1</code></p></details><h3 id="分析-s7"><a class="header-anchor" href="#分析-s7">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>basic source character set：基本源字符集，C++编程语言中允许在源代码中使用的最基本的字符集</p><p>basic execution character set：基本执行字符集，C++编程语言中用于执行程序时，计算机系统必须支持的最基本的字符集</p><p>虽然大部分情况采用ASCII编码，但C++也允许其它编码，也就是说’A’、‘1’这些字符的取值都是不确定的，但是数字字符间的差值是标准定义，但字母字符间的差值并没有定义，也就是说’B’-'A’不一定等于1。</p></details><h2 id="107"><a class="header-anchor" href="#107">¶</a>107</h2><h3 id="代码-s8"><a class="header-anchor" href="#代码-s8">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;f&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;g&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; v)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">h</span>(&#123;<span class="built_in">f</span>(), <span class="built_in">g</span>()&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s8"><a class="header-anchor" href="#输出-s8">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>fg</code></p></details><h3 id="分析-s8"><a class="header-anchor" href="#分析-s8">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>初始化列表的求值顺序按照出现顺序（即从左到右）。</p><p>但是函数参数的求值顺序是未指定的，依实现定义的，比如<code>h(f(), g())</code>可能是<code>fg</code>，也可能是<code>gf</code>，甚至可以第一次调用是<code>fg</code>，第二次调用是<code>gf</code>（<a href="https://cppquiz.org/quiz/question/192">#192</a>）。</p></details><h2 id="229"><a class="header-anchor" href="#229">¶</a>229</h2><h3 id="代码-s9"><a class="header-anchor" href="#代码-s9">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s9"><a class="header-anchor" href="#输出-s9">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>5</code></p></details><h3 id="分析-s9"><a class="header-anchor" href="#分析-s9">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>lambda表达式可以在不捕获的情况下使用一个非局部变量、静态变量、线程局部变量或被常量表达式初始化过的引用。</p><p>只有自动变量和this指针需要在捕获列表中声明。</p></details><h2 id="38"><a class="header-anchor" href="#38">¶</a>38</h2><h3 id="代码-s10"><a class="header-anchor" href="#代码-s10">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">decltype</span>((a)) b = a;</span><br><span class="line">  b++;</span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s10"><a class="header-anchor" href="#输出-s10">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>11</code></p></details><h3 id="分析-s10"><a class="header-anchor" href="#分析-s10">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>这里的参数被括号包裹，且是左值，所以返回其引用类型。</p></details><h2 id="283"><a class="header-anchor" href="#283">¶</a>283</h2><h3 id="代码-s11"><a class="header-anchor" href="#代码-s11">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">show_id</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">show_id</span>() &#123; std::cout &lt;&lt; id; &#125;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="keyword">new</span> show_id[<span class="number">3</span>]&#123; &#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s11"><a class="header-anchor" href="#输出-s11">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>210</code></p></details><h3 id="分析-s11"><a class="header-anchor" href="#分析-s11">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>在C++中，对象的销毁按照构造时的<strong>相反</strong>顺序进行，<code>delete[]</code>也不例外。</p></details><h2 id="18"><a class="header-anchor" href="#18">¶</a>18</h2><h3 id="代码-s12"><a class="header-anchor" href="#代码-s12">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(A &amp;a)</span> </span>&#123; a.<span class="built_in">f</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  <span class="built_in">g</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s12"><a class="header-anchor" href="#输出-s12">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>B</code></p></details><h3 id="分析-s12"><a class="header-anchor" href="#分析-s12">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>多态。</p><p>注意到虽然类B的函数f()是私有的，但是仍然可以被调用，因为访问权限在调用点处被检查。</p></details><h2 id="225"><a class="header-anchor" href="#225">¶</a>225</h2><h3 id="代码-s13"><a class="header-anchor" href="#代码-s13">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">const</span> X &amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;3&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;4&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125; object;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">X</span>(object);</span><br><span class="line">    object.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s13"><a class="header-anchor" href="#输出-s13">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>11422</code></p></details><h3 id="分析-s13"><a class="header-anchor" href="#分析-s13">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>这里的关键是<code>X(object)</code>，这可以看作是产生了一个临时变量，也可以看作是声明了一个变量object（等价于<code>X object</code>）。语法规定当作声明语句，也就是说此时创建了一个局部变量object，掩盖了全局变量object。</p></details><h2 id="187"><a class="header-anchor" href="#187">¶</a>187</h2><h3 id="代码-s14"><a class="header-anchor" href="#代码-s14">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="built_in">C</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">C</span>(<span class="type">const</span> C&amp; other) &#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span>; &#125;</span><br><span class="line">  C&amp; <span class="keyword">operator</span>=(<span class="type">const</span> C&amp; other) &#123; std::cout &lt;&lt; <span class="string">&quot;3&quot;</span>; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C c1;</span><br><span class="line">  C c2 = c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s14"><a class="header-anchor" href="#输出-s14">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>12</code></p></details><h3 id="分析-s14"><a class="header-anchor" href="#分析-s14">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>初始化只会选择构造函数。</p></details><h2 id="254"><a class="header-anchor" href="#254">¶</a>254</h2><h3 id="代码-s15"><a class="header-anchor" href="#代码-s15">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::is_same_v&lt;</span><br><span class="line">        <span class="built_in">void</span>(<span class="type">int</span>),</span><br><span class="line">        <span class="built_in">void</span>(<span class="type">const</span> <span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::is_same_v&lt;</span><br><span class="line">        <span class="built_in">void</span>(<span class="type">int</span>*),</span><br><span class="line">        <span class="built_in">void</span>(<span class="type">const</span> <span class="type">int</span>*)&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s15"><a class="header-anchor" href="#输出-s15">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>10</code></p></details><h3 id="分析-s15"><a class="header-anchor" href="#分析-s15">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>函数参数的顶层cv限定符在函数类型上会被移除，因为传参会发生拷贝，一定不会修改原来的变量（const与否没有区别）。</p></details><h2 id="244"><a class="header-anchor" href="#244">¶</a>244</h2><h3 id="代码-s16"><a class="header-anchor" href="#代码-s16">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s16"><a class="header-anchor" href="#输出-s16">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>未定义行为</p></details><h3 id="分析-s16"><a class="header-anchor" href="#分析-s16">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>static_assert</code>在第一个参数为常量0时，永远是错误的，且无需诊断（“ill-formed, no diagnostic required”，编译器可以不发出任何诊断和错误消息，因为这还会使得编译时间变长），也就是未定义行为（“undefine behavior”），即使是在没有实例化的模板函数中。</p><p>但事实上，最新的gcc、clang、msvc都会报告编译错误。</p></details><h2 id="354"><a class="header-anchor" href="#354">¶</a>354</h2><h3 id="代码-s17"><a class="header-anchor" href="#代码-s17">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">char</span> s;</span><br><span class="line">    <span class="built_in">S</span>(<span class="type">char</span> s): s&#123;s&#125; &#123;&#125;</span><br><span class="line">    ~<span class="built_in">S</span>() &#123; std::cout &lt;&lt; s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">S <span class="title">a</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">S <span class="title">b</span><span class="params">(<span class="string">&#x27;b&#x27;</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s17"><a class="header-anchor" href="#输出-s17">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>a</code></p></details><h3 id="分析-s17"><a class="header-anchor" href="#分析-s17">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>std::exit</code>只会为具有静态存储期的对象调用析构，而不会为局部变量调用析构。</p><p>也就是说，在main中，使用exit和return是有区别的，通常return更好（首先更加直观，其次它会正确地析构局部变量（但<code>exit</code>似乎会正确关闭文件指针和流；另见<a href="https://stackoverflow.com/a/461528">https://stackoverflow.com/a/461528</a>）。</p><p>此外，在<code>exit</code>中还会逆序调用通过<code>atexit(void (*fcn)(void))</code>注册的函数。</p></details><h2 id="16"><a class="header-anchor" href="#16">¶</a>16</h2><h3 id="代码-s18"><a class="header-anchor" href="#代码-s18">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;a&#x27;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;A&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;b&#x27;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;B&#x27;</span>; &#125;</span><br><span class="line">  A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; B b; &#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s18"><a class="header-anchor" href="#输出-s18">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>abBA</code></p></details><h3 id="分析-s18"><a class="header-anchor" href="#分析-s18">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>先构造类成员变量，再调用构造函数。</p><p>先调用析构函数，再析构类成员变量。</p><p>同样遵循析构和构造顺序相反这一特征。</p></details><h2 id="281"><a class="header-anchor" href="#281">¶</a>281</h2><h3 id="代码-s19"><a class="header-anchor" href="#代码-s19">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">const</span> C&amp;)&#123;&#125; <span class="comment">//User-declared, disables move constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="function">C <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s19"><a class="header-anchor" href="#输出-s19">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>ok</code></p></details><h3 id="分析-s19"><a class="header-anchor" href="#分析-s19">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>如果类X没有显示定义移动构造函数，且X不包含一个用户自定义的拷贝构造函数，则会隐式定义一个默认的版本。</p><p>会在所有构造函数中进行重载决策，当然在这里，移动构造肯定优于拷贝构造。</p><p>在没有移动构造的情况下，拷贝构造也是可以选择的。</p></details><h2 id="minmax"><a class="header-anchor" href="#minmax">¶</a>minmax</h2><h3 id="代码-s20"><a class="header-anchor" href="#代码-s20">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [mn, mx] = std::<span class="built_in">minmax</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="输出-s20"><a class="header-anchor" href="#输出-s20">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>未定义行为</p></details><h3 id="分析-s20"><a class="header-anchor" href="#分析-s20">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>这里mn和mx都是悬挂引用。</p><p>首先minmax的函数原型是<code>std::pair&lt;const T&amp;, const T&amp;&gt; std::minmax(const T&amp;, const T&amp;)</code>，由于pair的原因，在自动推导后，mn和mx的类型都是<code>const int&amp;</code>，但是传入的1和2被分别绑定到函数的两个参数上之后，会在函数结束时销毁。</p><p>这里涉及到生命周期延长的概念（lifetime extesion）：</p><blockquote><ol><li>The lifetime of a temporary object may be extended by binding to a reference.</li><li>A temporary bound to a return value of a function in a return statement is <strong>not</strong> extended: it is destroyed immediately at the end of the return expression. Such return statement always returns a dangling reference.</li><li>A temporary bound to a reference parameter in a function call exists until the end of the full expression containing that function call: if the function returns a reference, which outlives the full expression, it becomes a dangling reference.</li></ol></blockquote><p>同理，<code>const int&amp; x = std::min(1, 2)</code>也是未定义的，不过<code>auto x</code>是正确的，因为此时会推导为<code>const int</code>。</p><p>另见<a href="https://stackoverflow.com/questions/17362673/temporary-lifetime-extension">https://stackoverflow.com/questions/17362673/temporary-lifetime-extension</a>。</p></details><h2 id="132"><a class="header-anchor" href="#132">¶</a>132</h2><h3 id="代码-s21"><a class="header-anchor" href="#代码-s21">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> i = foo())</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bar</span>();</span><br><span class="line">  <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s21"><a class="header-anchor" href="#输出-s21">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>11</code></p></details><h3 id="分析-s21"><a class="header-anchor" href="#分析-s21">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>默认参数会在每次调用时且不提供该参数的情况下计算一遍。</p></details><h2 id="264"><a class="header-anchor" href="#264">¶</a>264</h2><h3 id="代码-s22"><a class="header-anchor" href="#代码-s22">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="built_in">C</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> C c;</span><br><span class="line">    std::cout &lt;&lt; c.i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s22"><a class="header-anchor" href="#输出-s22">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>编译错误</p></details><h3 id="分析-s22"><a class="header-anchor" href="#分析-s22">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>类C必须满足常量可构造性。</p><ol><li>会调用用户提供的构造函数（user-provided）</li><li>每个非variant，非静态的成员会默认初始化或者对于类，则是常量可构造的</li><li>…</li></ol><p><code>C::C() = default</code>是user-provided，<code>C() = default</code>是user-declared，而<code>C() = default</code>则会是默认的构造函数</p></details><h2 id="284"><a class="header-anchor" href="#284">¶</a>284</h2><h3 id="代码-s23"><a class="header-anchor" href="#代码-s23">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">  std::string out&#123;<span class="string">&quot;Hello world&quot;</span>&#125;;</span><br><span class="line">  std::cout &lt;&lt; (out[out.<span class="built_in">size</span>()] == <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s23"><a class="header-anchor" href="#输出-s23">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>1</code></p></details><h3 id="分析-s23"><a class="header-anchor" href="#分析-s23">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>标准明确规定了在<code>pos=size()</code>时返回一个charT()（值初始化为0，等于<code>'\0'</code>），但修改该对象显然是未定义行为。</p></details><h2 id="195"><a class="header-anchor" href="#195">¶</a>195</h2><h3 id="代码-s24"><a class="header-anchor" href="#代码-s24">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; std::is_pointer_v&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s24"><a class="header-anchor" href="#输出-s24">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>0</code></p></details><h3 id="分析-s24"><a class="header-anchor" href="#分析-s24">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>nullptr是<code>std::nullptr_t</code>类型，这不是指针类型，而是空指针常量，可以转化为指针。</p><p><code>(int*)nullptr</code>是一个空指针值，<code>(int some_class::*)nullptr</code>是一个空成员指针值。</p></details><h2 id="236"><a class="header-anchor" href="#236">¶</a>236</h2><h3 id="代码-s25"><a class="header-anchor" href="#代码-s25">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">auto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">Foo</span>();</span><br><span class="line">  std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s25"><a class="header-anchor" href="#输出-s25">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>A1</code></p></details><h3 id="分析-s25"><a class="header-anchor" href="#分析-s25">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>转换函数不需要写返回类型（因为它的名字就是），但也可以通过<code>auto</code>的方式进行推导，这并不是一个名为auto的转化函数，而是会被推到为<code>operator int()</code>。</p></details><h2 id="118"><a class="header-anchor" href="#118">¶</a>118</h2><h3 id="代码-s26"><a class="header-anchor" href="#代码-s26">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *str)</span> </span>&#123; std::cout &lt;&lt; str; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">short</span> num)</span> </span>&#123; std::cout &lt;&lt; num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s26"><a class="header-anchor" href="#输出-s26">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>编译错误</p></details><h3 id="分析-s26"><a class="header-anchor" href="#分析-s26">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>0可以被视为一个空指针常量，然后被转换为一个指针类型。</p><p>0默认是int类型，也需要转换为short类型。</p><p>因此对于<code>print(0)</code>，重载决策无法判断哪个函数更优。</p><p>空指针常量是值为0的整数或者std::nullptr。</p></details><h2 id="307"><a class="header-anchor" href="#307">¶</a>307</h2><h3 id="代码-s27"><a class="header-anchor" href="#代码-s27">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">S</span>() = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> s = S&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; s.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s27"><a class="header-anchor" href="#输出-s27">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>0</p></details><h3 id="分析-s27"><a class="header-anchor" href="#分析-s27">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>一个函数是user-provided，如果它是user-declared，且没有在它<strong>第一次声明</strong>时显示地default或delete。</p><p>S是一个聚合类型（aggregate），<code>S&#123;&#125;</code>使用的是聚合初始化，而不是构造函数，并且初始化列表中没有对应的元素会被值初始化。</p><p>注：在C++20中，aggregate的概念从no user-provided改为no user-declared，S不再是聚合类型，会导致编译错误。</p></details><h2 id="25"><a class="header-anchor" href="#25">¶</a>25</h2><h3 id="代码-s28"><a class="header-anchor" href="#代码-s28">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">  std::cout &lt;&lt; ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s28"><a class="header-anchor" href="#输出-s28">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>未定义行为</p></details><h3 id="分析-s28"><a class="header-anchor" href="#分析-s28">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>有符号整数溢出是未定义行为。</p><p>只是很多实现会选择wrap around（如gcc），此时会得到<code>std::numeric_limits&lt;int&gt;::min()</code></p></details><h2 id="178"><a class="header-anchor" href="#178">¶</a>178</h2><h3 id="代码-s29"><a class="header-anchor" href="#代码-s29">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">5</span>,b = <span class="number">2</span>;</span><br><span class="line"> std::cout &lt;&lt; a+++++b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s29"><a class="header-anchor" href="#输出-s29">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>编译错误</p></details><h3 id="分析-s29"><a class="header-anchor" href="#分析-s29">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>根据最长匹配（最大咀嚼）原则（maximal munch principle），词法分析器会选择最长的字符序列组成下一个token，即使会造成后续的失败。</p><p>注：这其实是为了解决正则表达式固有的歧义问题（如<code>[a-z]+</code>）</p><p>这里会分解为<code>a ++ ++ + b</code>，<code>a++</code>会产生一个临时的右值，不再能被继续后置递增。</p><p>同理<code>x=y/*z</code>也会编译错误，这里会分解出<code>/*</code>，认为是块注释的起始。</p><p>这也是为什么在c++11之前，<code>&gt; &gt;</code>尖括号之间要加空格。解决方法不是对此进行特判，而是将右移<code>&gt;&gt;</code>视为<strong>一对</strong>尖括号（同java），这样<code>&gt;&gt;</code>会分成两个token，从而能继续使用最长匹配原则。</p></details><h2 id="42"><a class="header-anchor" href="#42">¶</a>42</h2><h3 id="代码-s30"><a class="header-anchor" href="#代码-s30">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>(std::initializer_list&lt;<span class="type">int</span>&gt;) &#123; std::cout &lt;&lt; <span class="string">&quot;3&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  A a1;</span><br><span class="line">  A a2&#123;&#125;;</span><br><span class="line">  A a3&#123; <span class="number">1</span> &#125;;</span><br><span class="line">  A a4&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s30"><a class="header-anchor" href="#输出-s30">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>1133</code></p></details><h3 id="分析-s30"><a class="header-anchor" href="#分析-s30">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>a1默认初始化。</p><p>在初始化列表为空，且有默认构造函数（即可以在无参数的情况下调用）时，使用默认构造函数。</p><p>在其余情况下，初始化列表的构造函数总是最先被选择，在没有时才会考虑其它的。</p></details><h2 id="30"><a class="header-anchor" href="#30">¶</a>30</h2><h3 id="代码-s31"><a class="header-anchor" href="#代码-s31">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;X&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="function">X <span class="title">x</span><span class="params">()</span></span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s31"><a class="header-anchor" href="#输出-s31">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>no output</p></details><h3 id="分析-s31"><a class="header-anchor" href="#分析-s31">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>X x()</code>是一个函数声明（Empty parenthese interpreted as a function declaration）。</p></details><h2 id="29"><a class="header-anchor" href="#29">¶</a>29</h2><h3 id="代码-s32"><a class="header-anchor" href="#代码-s32">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="built_in">A</span>() &#123; <span class="built_in">foo</span>(); &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123; <span class="built_in">foo</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="built_in">foo</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.<span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s32"><a class="header-anchor" href="#输出-s32">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>121</code></p></details><h3 id="分析-s32"><a class="header-anchor" href="#分析-s32">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>在A的构造函数中，B的部分还没有被构造，因此不会调用B的<code>foo</code>。</p><p>同理，在析构函数，B的部分先被析构，因此在A的析构函数中也不会调用B的<code>foo</code>。</p><p>总结，构造和析构函数中不会考虑虚函数。</p></details><h2 id="130"><a class="header-anchor" href="#130">¶</a>130</h2><h3 id="代码-s33"><a class="header-anchor" href="#代码-s33">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adl</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;T&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_adl</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">adl</span>(<span class="built_in">S</span>());</span><br><span class="line">  <span class="built_in">adl</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adl</span><span class="params">(S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;S&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">call_adl</span>(<span class="built_in">S</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s33"><a class="header-anchor" href="#输出-s33">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>TS</code></p></details><h3 id="分析-s33"><a class="header-anchor" href="#分析-s33">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>第一次调用<code>adl(S())</code>不依赖于模板参数，因此在定义时就进行名称查找。</p><p>而第二次调用<code>adl(t)</code>依赖于模板参数，会延迟到模板实例化时才进行名称查找。</p></details><h2 id="158"><a class="header-anchor" href="#158">¶</a>158</h2><h3 id="代码-s34"><a class="header-anchor" href="#代码-s34">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout&lt;&lt;<span class="string">&quot;a&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;) &#123; std::cout&lt;&lt;<span class="string">&quot;b&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;Foo&gt; <span class="title">bar</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s34"><a class="header-anchor" href="#输出-s34">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>aaaaa</code></p></details><h3 id="分析-s34"><a class="header-anchor" href="#分析-s34">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>在C++11之前会输出<code>bbbbb</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">( size_type count,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> T&amp; value = T(),</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> Allocator&amp; alloc = Allocator() )</span></span>; <span class="comment">// until C++11</span></span><br><span class="line"><span class="built_in">vector</span>( size_type count,</span><br><span class="line">                 <span class="type">const</span> T&amp; value,</span><br><span class="line">                 <span class="type">const</span> Allocator&amp; alloc = <span class="built_in">Allocator</span>() ); <span class="comment">// since C++11</span></span><br></pre></td></tr></table></figure></details><h2 id="193"><a class="header-anchor" href="#193">¶</a>193</h2><h3 id="代码-s35"><a class="header-anchor" href="#代码-s35">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &lt;%<span class="number">1</span>%&gt;;</span><br><span class="line">    std::cout &lt;&lt; a&lt;:<span class="number">0</span>:&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s35"><a class="header-anchor" href="#输出-s35">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>1</code></p></details><h3 id="分析-s35"><a class="header-anchor" href="#分析-s35">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>等价于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>C++提供为一些标点符号提供了替代的tokens，<code>&lt;%</code>和<code>%&gt;</code>分别等价于<code>&#123;</code>和<code>&#125;</code>，<code>&lt;:</code>和<code>:&gt;</code>分别等价于<code>[</code>和<code>]</code>。</p><p>见<a href="https://timsong-cpp.github.io/cppwp/n4659/lex.digraph#1">https://timsong-cpp.github.io/cppwp/n4659/lex.digraph#1</a>。</p><p>其实C++11及以后<code>and</code>等价于<code>&amp;&amp;</code>，就属于一种alternative token。</p></details><h2 id="228"><a class="header-anchor" href="#228">¶</a>228</h2><h3 id="代码-s36"><a class="header-anchor" href="#代码-s36">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="built_in">X</span>(Ts ...args) : <span class="built_in">Var</span>(<span class="number">0</span>, args...) &#123;&#125;</span><br><span class="line">  <span class="type">int</span> Var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X&lt;&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s36"><a class="header-anchor" href="#输出-s36">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>未定义行为</p></details><h3 id="分析-s36"><a class="header-anchor" href="#分析-s36">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>如果一个可变参数模板只在空参数时也是合法的，这是ill-formed, no diagnostic required，且在运行时的行为未定义。</p></details><h2 id="133"><a class="header-anchor" href="#133">¶</a>133</h2><h3 id="代码-s37"><a class="header-anchor" href="#代码-s37">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;) &#123; cout &lt;&lt; <span class="string">&quot;a&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B &amp;) &#123; cout&lt;&lt; <span class="string">&quot;b&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123; cout&lt;&lt; <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">const</span> C &amp;) &#123; cout &lt;&lt; <span class="string">&quot;c&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:B,C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123; cout&lt;&lt; <span class="string">&quot;D&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">const</span> D &amp;) &#123; cout &lt;&lt; <span class="string">&quot;d&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d1;</span><br><span class="line">    <span class="function">D <span class="title">d2</span><span class="params">(d1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s37"><a class="header-anchor" href="#输出-s37">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>ABCDABCd</code></p></details><h3 id="分析-s37"><a class="header-anchor" href="#分析-s37">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>对于<code>D d1</code>，顺序是<code>ABCD</code>，从基类开始，首先是虚继承的类按照从左往右深度优先的顺序进行，然后是普通继承的类按照从左往右的顺序（从左往右即代码出出现的顺序）。</p><p>对于<code>D d2(d1)</code>，隐式定义的拷贝构造函数会调用基类的拷贝构造函数，但是自定义的拷贝构造函数不会。在<code>D</code>的拷贝构造函数中没有显示写出，所以转而调用的是基类的构造函数。</p><p>虚继承：为解决多重继承而出现（避免菱形继承时基类的变量和函数重复出现）。</p><p>istream和ostream虚继承自base_io，iostream继承了istream和ostream。</p><p><code>virtual public A</code>声明了A是一个被共享的虚基类。</p></details><h2 id="109"><a class="header-anchor" href="#109">¶</a>109</h2><h3 id="代码-s38"><a class="header-anchor" href="#代码-s38">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_with</span><span class="params">(std::function&lt;<span class="type">void</span>(T)&gt; f, T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> print = [] (<span class="type">int</span> x) &#123; std::cout &lt;&lt; x; &#125;;</span><br><span class="line">    <span class="built_in">call_with</span>(print, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s38"><a class="header-anchor" href="#输出-s38">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>编译错误</p></details><h3 id="分析-s38"><a class="header-anchor" href="#分析-s38">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>注意lambda是一种完全不同的类型，与std::function&lt;void<int>&gt;不匹配。</p><p>编译器会为每个参数都推导T，并检查是否匹配。虽然<code>T val</code>显然会确定地将T推导为int，但是仍然需要检查<code>std::function&lt;void(int)&gt;</code>与实参的匹配性。</p><p><code>typename type_identity&lt;std::function&lt;void(T)&gt;&gt;::type</code>可以将T转化为非推导。</p></details><h2 id="122"><a class="header-anchor" href="#122">¶</a>122</h2><h3 id="代码-s39"><a class="header-anchor" href="#代码-s39">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">unsigned</span> ll)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">2ull</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s39"><a class="header-anchor" href="#输出-s39">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>2</code></p></details><h3 id="分析-s39"><a class="header-anchor" href="#分析-s39">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>unsigned ll</code>会被认为是unsigned int类型的变量ll。</p></details><h2 id="5"><a class="header-anchor" href="#5">¶</a>5</h2><h3 id="代码-s40"><a class="header-anchor" href="#代码-s40">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span>() : <span class="built_in">a</span>(), <span class="built_in">b</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  B b;</span><br><span class="line">  A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">C</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s40"><a class="header-anchor" href="#输出-s40">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>BA</code></p></details><h3 id="分析-s40"><a class="header-anchor" href="#分析-s40">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>成员变量的初始化顺序取决于声明顺序，而不是初始化列表中的顺序。</p></details><h2 id="249"><a class="header-anchor" href="#249">¶</a>249</h2><h3 id="代码-s41"><a class="header-anchor" href="#代码-s41">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> &amp;b = a;</span><br><span class="line">    cout &lt;&lt; b;</span><br><span class="line">    a++;</span><br><span class="line">    cout &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s41"><a class="header-anchor" href="#输出-s41">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>00</code></p></details><h3 id="分析-s41"><a class="header-anchor" href="#分析-s41">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>和#217类似，由于b和a的类型不同，b会绑定到一个临时变量上，而不是a。</p></details><h2 id="251"><a class="header-anchor" href="#251">¶</a>251</h2><h3 id="代码-s42"><a class="header-anchor" href="#代码-s42">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123; std::cout &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> f&lt;&gt;(<span class="type">int</span>*) &#123; std::cout &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T*)</span> </span>&#123; std::cout &lt;&lt; <span class="number">3</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">nullptr</span>; </span><br><span class="line">    <span class="built_in">f</span>( p );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s42"><a class="header-anchor" href="#输出-s42">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>3</code></p></details><h3 id="分析-s42"><a class="header-anchor" href="#分析-s42">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>先在模板函数中进行重载决策，然后才考虑选择的函数的模板特化。</p></details><h2 id="332"><a class="header-anchor" href="#332">¶</a>332</h2><h3 id="代码-s43"><a class="header-anchor" href="#代码-s43">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callable&gt;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>[](Callable f) &#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> caller = S&#123;&#125;;</span><br><span class="line">    caller[ []&#123; std::cout &lt;&lt; <span class="string">&quot;C&quot;</span>;&#125; ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s43"><a class="header-anchor" href="#输出-s43">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>编译错误</p></details><h3 id="分析-s43"><a class="header-anchor" href="#分析-s43">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>连续的左方括号只允许出现在<code>[[attributes]]</code>中。</p></details><h2 id="121"><a class="header-anchor" href="#121">¶</a>121</h2><h3 id="代码-s44"><a class="header-anchor" href="#代码-s44">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  x = (a, b);</span><br><span class="line">  std::cout &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s44"><a class="header-anchor" href="#输出-s44">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>20</code></p></details><h3 id="分析-s44"><a class="header-anchor" href="#分析-s44">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>逗号操作符应用到的两个表达式，保证从左到右计算，并返回第二个操作数的结果和类型。</p></details><h2 id="157"><a class="header-anchor" href="#157">¶</a>157</h2><h3 id="代码-s45"><a class="header-anchor" href="#代码-s45">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; (&amp;<span class="built_in">typeid</span>(A) == &amp;<span class="built_in">typeid</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s45"><a class="header-anchor" href="#输出-s45">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>未指定行为</p></details><h3 id="分析-s45"><a class="header-anchor" href="#分析-s45">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>不应该通过取地址的方式确定两种类型是否相等，这是无法保证的。</p><p>应该借助<code>hash_code</code>和<code>type_index</code>。</p></details><h2 id="261"><a class="header-anchor" href="#261">¶</a>261</h2><h3 id="代码-s46"><a class="header-anchor" href="#代码-s46">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::stringstream <span class="title">ss</span><span class="params">(<span class="string">&quot;a&quot;</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">  ss &lt;&lt; <span class="string">&quot;b&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s46"><a class="header-anchor" href="#输出-s46">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>ab</code></p></details><h3 id="分析-s46"><a class="header-anchor" href="#分析-s46">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>stringstream会先初始化一个buffer，而<code>operator&lt;&lt;</code>会写到buffer中的下一个位置，而这里是起始位置，导致覆盖了<code>a</code>。</p><p>会避免这种情况，可以声明ss为<code>std::stringstream ss(&quot;a&quot;, std::ios_base::out|std::ios_base::ate);</code></p></details><h2 id="287"><a class="header-anchor" href="#287">¶</a>287</h2><h3 id="代码-s47"><a class="header-anchor" href="#代码-s47">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line">  <span class="function">std::string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>,<span class="number">5</span>)</span></span>; </span><br><span class="line">  <span class="function">std::string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello world&quot;</span>s,<span class="number">5</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; s1 &lt;&lt; s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s47"><a class="header-anchor" href="#输出-s47">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>hello world</code></p></details><h3 id="分析-s47"><a class="header-anchor" href="#分析-s47">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>以<code>s</code>为后缀为声明一个<code>std::string</code>类型的字面量，而默认则是<code>const char[]</code>类型，从而可以包含<code>\0</code>。</p><ul><li><code>basic_string(const charT* s, size_type n, const Allocator&amp; a = Allocator());</code></li><li><code>basic_string(const basic_string&amp; str, size_type pos, const Allocator&amp; a = Allocator());</code></li><li><code>basic_string( size_type count, CharT ch, const Allocator&amp; alloc = Allocator() );</code> （count个ch字符）</li></ul><p>通过<code>const char*</code>构造，表示起始的n个字符。而通过<code>std::string</code>构造，则表示从<code>pos</code>起始到结束的字符。</p></details><h2 id="116"><a class="header-anchor" href="#116">¶</a>116</h2><h3 id="代码-s48"><a class="header-anchor" href="#代码-s48">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">(<span class="type">int</span> &amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">(<span class="type">int</span> &amp;&amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(T &amp;&amp;x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">y</span>(x); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(T &amp;&amp;x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">y</span>(std::<span class="built_in">move</span>(x)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">int</span> <span class="title">h</span><span class="params">(T &amp;&amp;x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">y</span>(std::forward&lt;T&gt;(x)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">f</span>(i) &lt;&lt; <span class="built_in">f</span>(<span class="number">20</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">g</span>(i) &lt;&lt; <span class="built_in">g</span>(<span class="number">20</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">h</span>(i) &lt;&lt; <span class="built_in">h</span>(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s48"><a class="header-anchor" href="#输出-s48">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>112212</code></p></details><h3 id="分析-s48"><a class="header-anchor" href="#分析-s48">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>T&amp;&amp;</code>是一个universal reference。</p><p>用左值调用时，<code>T&amp;&amp; &amp;</code>会折叠为<code>T&amp;</code>，而用右值调用时，会折叠为<code>T&amp;&amp; &amp;&amp;</code>。</p></details><h2 id="287-s2"><a class="header-anchor" href="#287-s2">¶</a>287</h2><h3 id="代码-s49"><a class="header-anchor" href="#代码-s49">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line">  <span class="function">std::string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>,<span class="number">5</span>)</span></span>; </span><br><span class="line">  <span class="function">std::string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello world&quot;</span>s,<span class="number">5</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; s1 &lt;&lt; s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s49"><a class="header-anchor" href="#输出-s49">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>hello world</code></p></details><h3 id="分析-s49"><a class="header-anchor" href="#分析-s49">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>以<code>s</code>为后缀为声明一个<code>std::string</code>类型的字面量，而默认则是<code>const char[n]</code>类型，从而可以包含<code>\0</code>。</p><ul><li><code>basic_string(const charT* s, size_type n, const Allocator&amp; a = Allocator());</code></li><li><code>basic_string(const basic_string&amp; str, size_type pos, const Allocator&amp; a = Allocator());</code></li><li><code>basic_string( size_type count, CharT ch, const Allocator&amp; alloc = Allocator() );</code> （count个ch字符）</li></ul><p>通过<code>const char*</code>构造，表示起始的n个字符。而通过<code>std::string</code>构造，则表示从<code>pos</code>起始到结束的字符。</p></details><h2 id="161"><a class="header-anchor" href="#161">¶</a>161</h2><h3 id="代码-s50"><a class="header-anchor" href="#代码-s50">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: ++i;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--n &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s50"><a class="header-anchor" href="#输出-s50">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>5</code></p></details><h3 id="分析-s50"><a class="header-anchor" href="#分析-s50">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>case</code>和<code>default</code>只是label，这也就是为什么不加break，会默认继续执行（fall through）</p></details><h2 id="335"><a class="header-anchor" href="#335">¶</a>335</h2><h3 id="代码-s51"><a class="header-anchor" href="#代码-s51">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">nullptr_t</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* a&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s51"><a class="header-anchor" href="#输出-s51">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>未指定行为</p></details><h3 id="分析-s51"><a class="header-anchor" href="#分析-s51">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>NULL可以是<code>0</code>，也可以是<code>std::nullptr_t</code>。GCC和Clang都是long类型的0，而MSVC是int类型的0。</p><p>如果NULL是0，则<code>f(NULL)</code>是有歧义的，因为<code>f(void*)</code>和<code>f(std::nullptr_t)</code>一样好，都需要经过一次转化。</p></details><h2 id="31"><a class="header-anchor" href="#31">¶</a>31</h2><h3 id="代码-s52"><a class="header-anchor" href="#代码-s52">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;X&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">  <span class="built_in">Y</span>(<span class="type">const</span> X &amp;x) &#123; std::cout &lt;&lt; <span class="string">&quot;Y&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;f&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Y <span class="title">y</span><span class="params">(X())</span></span>;</span><br><span class="line">  y.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s52"><a class="header-anchor" href="#输出-s52">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>编译错误</p></details><h3 id="分析-s52"><a class="header-anchor" href="#分析-s52">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>这涉及到most vexing parse。</p><p>C++在无法区分对象创建和函数定义时，会解释成函数定义。</p><p><code>Y y(X())</code>也可以认为是一个参数为X类型，返回值为Y，名称为y的函数的声明（C语言允许在函数参数周围添加多余的括号）。</p></details><h2 id="147"><a class="header-anchor" href="#147">¶</a>147</h2><h3 id="代码-s53"><a class="header-anchor" href="#代码-s53">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>; <span class="comment">//What is wrong here??/</span></span><br><span class="line">  x=<span class="number">1</span>;</span><br><span class="line">  std::cout&lt;&lt;x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s53"><a class="header-anchor" href="#输出-s53">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>1</code></p></details><h3 id="分析-s53"><a class="header-anchor" href="#分析-s53">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>这里的<code>??/</code>属于C语言中的trigraph，可以作为某些字符的替代，类似#193。</p><p>见<a href="https://en.wikibooks.org/wiki/C_Programming/C_trigraph">https://en.wikibooks.org/wiki/C_Programming/C_trigraph</a>。</p></details><h2 id="41"><a class="header-anchor" href="#41">¶</a>41</h2><h3 id="代码-s54"><a class="header-anchor" href="#代码-s54">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span>[<span class="string">&quot;ABC&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s54"><a class="header-anchor" href="#输出-s54">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>B</code></p></details><h3 id="分析-s54"><a class="header-anchor" href="#分析-s54">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>表达式<code>E1[E2]</code>等价于<code>((E1)+(E2))</code>。</p></details><h2 id="160"><a class="header-anchor" href="#160">¶</a>160</h2><h3 id="代码-s55"><a class="header-anchor" href="#代码-s55">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span> <span class="params">(<span class="type">int</span> a = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span> <span class="params">(<span class="type">int</span> a = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A *b = <span class="keyword">new</span> B;</span><br><span class="line">    b-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s55"><a class="header-anchor" href="#输出-s55">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>B1</code></p></details><h3 id="分析-s55"><a class="header-anchor" href="#分析-s55">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>变量b有静态类型A，动态类型B。</p><p>虚函数调用会使用指针或引用的静态类型中定义的默认参数。派生类的重写函数可以有不同的默认参数，也可以没有默认参数。</p></details><h2 id="233"><a class="header-anchor" href="#233">¶</a>233</h2><h3 id="代码-s56"><a class="header-anchor" href="#代码-s56">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = &amp;X::f;</span><br><span class="line">    cout &lt;&lt; is_same_v&lt;<span class="keyword">decltype</span>(ptr), <span class="built_in">int</span>()&gt;</span><br><span class="line">         &lt;&lt; is_same_v&lt;<span class="keyword">decltype</span>(ptr), <span class="built_in">int</span>(X::*)()&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s56"><a class="header-anchor" href="#输出-s56">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>00</code></p></details><h3 id="分析-s56"><a class="header-anchor" href="#分析-s56">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>返回类型、参数类型列表、引用限定、cv限定、异常（不包括默认参数）都是函数类型的一部分。</p><p>这里ptr是<code>int(X::*)() const&amp;&amp;</code>类型。</p><p>注意函数类型、函数签名、函数原型的区别。</p></details><h2 id="293"><a class="header-anchor" href="#293">¶</a>293</h2><h3 id="代码-s57"><a class="header-anchor" href="#代码-s57">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; (argv[argc] == <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s57"><a class="header-anchor" href="#输出-s57">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>1</code></p></details><h3 id="分析-s57"><a class="header-anchor" href="#分析-s57">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>argv[argc]</code>保证为0。</p></details><h2 id="179"><a class="header-anchor" href="#179">¶</a>179</h2><h3 id="代码-s58"><a class="header-anchor" href="#代码-s58">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i);</span><br><span class="line">    r = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s58"><a class="header-anchor" href="#输出-s58">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>未定义行为</p></details><h3 id="分析-s58"><a class="header-anchor" href="#分析-s58">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>修改const对象总是未定义行为。<code>const_cast</code>的用途不是这个。</p></details><h2 id="224"><a class="header-anchor" href="#224">¶</a>224</h2><h3 id="代码-s59"><a class="header-anchor" href="#代码-s59">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Base::f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Derived::f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived object;</span><br><span class="line">    std::cout &lt;&lt; object.<span class="built_in">f</span>();</span><br><span class="line">    std::cout &lt;&lt; ((Base&amp;)object).<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s59"><a class="header-anchor" href="#输出-s59">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>22</code></p></details><h3 id="分析-s59"><a class="header-anchor" href="#分析-s59">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>事实上纯虚函数也可以在类外为其提供一个定义。</p><p>带有纯虚函数的抽象类是无法创建对象的，但是我们可以在派生类中通过<code>Base::f()</code>进行调用。</p></details><h2 id="15"><a class="header-anchor" href="#15">¶</a>15</h2><h3 id="代码-s60"><a class="header-anchor" href="#代码-s60">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (x++ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;A&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;b&#x27;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;B&#x27;</span>; &#125;</span><br><span class="line">  A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="type">static</span> B b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (std::exception &amp;) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s60"><a class="header-anchor" href="#输出-s60">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>acabBA</code></p></details><h3 id="分析-s60"><a class="header-anchor" href="#分析-s60">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>因为<code>b</code>在第一次初始化时抛出异常，被视为没初始化。因此在第二次进入时会重新尝试。</p></details><h2 id="186"><a class="header-anchor" href="#186">¶</a>186</h2><h3 id="代码-s61"><a class="header-anchor" href="#代码-s61">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">takes_pointer</span><span class="params">(<span class="type">int</span>* pointer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">typeid</span>(pointer) == <span class="built_in">typeid</span>(<span class="type">int</span>[])) std::cout &lt;&lt; <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">typeid</span>(pointer) == <span class="built_in">typeid</span>(<span class="type">int</span>*)) std::cout &lt;&lt; <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">takes_array</span><span class="params">(<span class="type">int</span> array[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">typeid</span>(array) == <span class="built_in">typeid</span>(<span class="type">int</span>[])) std::cout &lt;&lt; <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">typeid</span>(array) == <span class="built_in">typeid</span>(<span class="type">int</span>*)) std::cout &lt;&lt; <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>* pointer = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">int</span> array[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">takes_pointer</span>(array);</span><br><span class="line">  <span class="built_in">takes_array</span>(pointer);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; (<span class="built_in">typeid</span>(<span class="type">int</span>*) == <span class="built_in">typeid</span>(<span class="type">int</span>[]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s61"><a class="header-anchor" href="#输出-s61">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>pp0</code></p></details><h3 id="分析-s61"><a class="header-anchor" href="#分析-s61">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>int*</code>是指针，<code>int[]</code>是一个未知个数的数组（是不完整类型），<code>int[1]</code>是一个元素的数组。</p><p>在函数传参中，数组会退化为指针。可以通过传数组的引用的方式避免。<code>int (&amp;a)[1]</code>。</p></details><h2 id="323"><a class="header-anchor" href="#323">¶</a>323</h2><h3 id="代码-s62"><a class="header-anchor" href="#代码-s62">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">char</span> c) : <span class="built_in">c_</span>(c) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; c_; &#125;</span><br><span class="line">    <span class="type">char</span> c_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123; ~<span class="built_in">Y</span>() <span class="built_in">noexcept</span>(<span class="literal">false</span>) &#123; <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;&quot;</span>); &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">        Y y;</span><br><span class="line">        <span class="function">A <span class="title">b</span><span class="params">(<span class="string">&#x27;b&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s62"><a class="header-anchor" href="#输出-s62">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>bcad</code></p></details><h3 id="分析-s62"><a class="header-anchor" href="#分析-s62">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>注意异常是在<code>y</code>的析构中抛出的。</p><p>首先<code>return &#123;'c'&#125;</code>构造了一个A的对象，然后析构b，析构y并抛出异常，导致堆栈展开，再按照反顺序，析构<code>return</code>构造的对象，再析构a。</p><p>然而目前<code>GCC</code>、<code>CLang</code>和<code>MSVC</code>都未遵守C++标准，会分别输出<code>bacd</code>、<code>bad</code>和<code>bad</code>。</p><p>注：如果没有抛出异常，应该是<code>bac</code>。</p><p><code>noexcept</code>是可以加一个常量表达式的，表示在该条件下不会发生异常。应该认为所有函数都会抛出异常，即<code>noexcept(false)</code>，因此通常只对明确不抛出异常的函数使用<code>noexcept</code>标记。</p><p>只有析构函数默认是<code>noexcept(true)</code>。</p></details><h2 id="350"><a class="header-anchor" href="#350">¶</a>350</h2><h3 id="代码-s63"><a class="header-anchor" href="#代码-s63">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Q</span>&#123;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Q</span>(Q&amp;&amp;)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;M&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Q</span>(<span class="type">const</span> Q&amp;)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;C&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Q</span>()&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;D&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ++v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">            std::cout &lt;&lt; v;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">takeQfunc</span><span class="params">(std::function&lt;<span class="type">void</span>(Q)&gt; qfunc)</span></span>&#123;</span><br><span class="line">    Q q;</span><br><span class="line">    q.<span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">qfunc</span>(q);</span><br><span class="line">    q.<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">takeQfunc</span>([](Q&amp;&amp; q)&#123;</span><br><span class="line">        q.<span class="built_in">change</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s63"><a class="header-anchor" href="#输出-s63">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>D0C0</code></p></details><h3 id="分析-s63"><a class="header-anchor" href="#分析-s63">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>虽然传进去的lambda的参数是一个纯右值，但是std::function的参数是一个不带引用的左值，在<code>qfunc(q)</code>中会发生拷贝构造产生一个临时值，然后该临时值进入lambda，调用了<code>q.change()</code>。</p><p>和这个类似的是以下情况（也是某个quiz）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;&amp;)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">float</span>&amp;&amp;)</span> </span>&#123;&#125;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">1.f</span>;</span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// call f(float&amp;&amp;)</span></span><br><span class="line"><span class="built_in">f</span>(y); <span class="comment">// call f(int&amp;&amp;)</span></span><br></pre></td></tr></table></figure></details><h2 id="360"><a class="header-anchor" href="#360">¶</a>360</h2><h3 id="代码-s64"><a class="header-anchor" href="#代码-s64">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; is_const_v&lt;<span class="type">const</span> <span class="type">int</span> *&gt;</span><br><span class="line">         &lt;&lt; is_const_v&lt;<span class="type">const</span> <span class="type">int</span> [<span class="number">1</span>]&gt;</span><br><span class="line">         &lt;&lt; is_const_v&lt;<span class="type">const</span> <span class="type">int</span> **&gt;</span><br><span class="line">         &lt;&lt; is_const_v&lt;<span class="function"><span class="type">const</span> <span class="title">int</span> <span class="params">(*)</span>[1]&gt;</span></span><br><span class="line"><span class="function">         &lt;&lt; is_const_v&lt;<span class="type">const</span> <span class="type">int</span> *[1]&gt;</span></span><br><span class="line"><span class="function">         &lt;&lt; is_const_v&lt;<span class="type">const</span> <span class="type">int</span> [1][1]&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s64"><a class="header-anchor" href="#输出-s64">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>010001</code></p></details><h3 id="分析-s64"><a class="header-anchor" href="#分析-s64">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>指针有顶层const和底层const。这里放在最前面都是底层const，也就是指向的元素是const的，但是你自身可以更改指向。</p><p>但是数组只有顶层const。</p></details><h2 id="226"><a class="header-anchor" href="#226">¶</a>226</h2><h3 id="代码-s65"><a class="header-anchor" href="#代码-s65">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">X</span>(X &amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">const</span> X &amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;3&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">X</span>(X &amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;4&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;5&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">    <span class="keyword">mutable</span> X x;</span><br><span class="line">    <span class="built_in">Y</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Y</span>(<span class="type">const</span> Y &amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Y y1;</span><br><span class="line">    Y y2 = std::<span class="built_in">move</span>(y1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s65"><a class="header-anchor" href="#输出-s65">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>1255</code></p></details><h3 id="分析-s65"><a class="header-anchor" href="#分析-s65">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>Y没有移动构造，所以调用拷贝构造。</p><p>由于类成员x被标记为mutable，<code>X(X &amp;)</code>是更好的匹配。</p><p>注意最后y1和y2中的x都会被析构。</p><p>注：<code>mutable</code>关键字用于修饰类成员，使其可以在const的成员函数中被修改。此外，在lambda函数中无法修改按值捕获的变量，可以添加mutable进行修改，但是与引用捕获还是不同的，因为这里修改的是一份拷贝。</p></details><h2 id="114"><a class="header-anchor" href="#114">¶</a>114</h2><h3 id="代码-s66"><a class="header-anchor" href="#代码-s66">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span>       </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  std::vector&lt;C&gt; v;</span><br><span class="line">  std::unique_ptr&lt;C&gt; u;</span><br><span class="line">  C *<span class="type">const</span> p;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">S</span>() </span><br><span class="line">    : <span class="built_in">v</span>(<span class="number">1</span>) </span><br><span class="line">    , <span class="built_in">u</span>(<span class="keyword">new</span> <span class="built_in">C</span>())</span><br><span class="line">    , <span class="built_in">p</span>(u.<span class="built_in">get</span>())</span><br><span class="line">  &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s;</span><br><span class="line">  <span class="type">const</span> S &amp;r = s;</span><br><span class="line"> </span><br><span class="line">  s.v[<span class="number">0</span>].<span class="built_in">foo</span>();</span><br><span class="line">  s.u-&gt;<span class="built_in">foo</span>();</span><br><span class="line">  s.p-&gt;<span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">  r.v[<span class="number">0</span>].<span class="built_in">foo</span>();</span><br><span class="line">  r.u-&gt;<span class="built_in">foo</span>();</span><br><span class="line">  r.p-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s66"><a class="header-anchor" href="#输出-s66">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>AAABAA</code></p></details><h3 id="分析-s66"><a class="header-anchor" href="#分析-s66">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>一个const的对象，其成员也是const的，但都是顶层的const，意味着<code>v</code>、<code>u</code>和<code>p</code>不能被赋值，但是<code>std::vector</code>比较特殊，当它为const时，<code>[]</code>会调用返回const元素的那个<code>operator[]</code>重载。</p></details><h2 id="124"><a class="header-anchor" href="#124">¶</a>124</h2><h3 id="代码-s67"><a class="header-anchor" href="#代码-s67">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = A&gt;</span><br><span class="line"><span class="keyword">struct</span> X;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&lt;A&gt; &#123;</span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&lt;B&gt; &#123;</span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = B&gt; <span class="keyword">class</span> C&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">g</span>() &#123;</span><br><span class="line">   C&lt;&gt;::<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">g</span>&lt;X&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s67"><a class="header-anchor" href="#输出-s67">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>2</code></p></details><h3 id="分析-s67"><a class="header-anchor" href="#分析-s67">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>这里的template又是个模板类<code>template&lt;typenmae T = B&gt; class C&gt;</code>，传进去的是<code>X&lt;B&gt;</code>。</p></details><h2 id="339"><a class="header-anchor" href="#339">¶</a>339</h2><h3 id="代码-s68"><a class="header-anchor" href="#代码-s68">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = p.<span class="built_in">get_future</span>();</span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; f.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; f.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s68"><a class="header-anchor" href="#输出-s68">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>未定义行为。</p></details><h3 id="分析-s68"><a class="header-anchor" href="#分析-s68">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>从一个future中只能get一次，后续的get是未定义的（此时<code>valid()</code>返回false），但鼓励抛出异常（主流编译器都这么做）。</p></details><h2 id="340"><a class="header-anchor" href="#340">¶</a>340</h2><h3 id="代码-s69"><a class="header-anchor" href="#代码-s69">¶</a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::promise&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">        std::future&lt;<span class="type">int</span>&gt; f1 = p.<span class="built_in">get_future</span>();</span><br><span class="line">        std::future&lt;<span class="type">int</span>&gt; f2 = p.<span class="built_in">get_future</span>();</span><br><span class="line">        p.<span class="built_in">set_value</span>(<span class="number">1</span>);</span><br><span class="line">        std::cout &lt;&lt; f1.<span class="built_in">get</span>() &lt;&lt; f2.<span class="built_in">get</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-s69"><a class="header-anchor" href="#输出-s69">¶</a>输出</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p><code>2</code></p></details><h3 id="分析-s69"><a class="header-anchor" href="#分析-s69">¶</a>分析</h3><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>从一个promise中只能得到一个future，后续会抛出<code>future_error</code>的异常。</p></details>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 41. 缺失的第一个正数</title>
      <link href="/2023/09/08/Leetcode-41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
      <url>/2023/09/08/Leetcode-41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h2><p>给定一个长度为$n$的数组$a$，对其中的所有正数求mex。要求时间复杂度$O(n)$，额外空间复杂度$O(1)$。</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>排序，时间复杂度不行。</p><p>桶排序，空间复杂度不行。</p><p>显然只能对$a$数组本身进行原地的操作 (in place)，最后希望能根据$a[i]$的取值判断出$i$是否存在于原数组中。</p><p>那就按下标顺序从小到大依次标记。设当前下标为$i$，如果$a[i]\gt i$，就先标记$a[a[i]]$，然后再覆盖$a[a[i]]$处的值来标记$a[i]$的存在；而如果$a[i]\le i$，直接对$a[a[i]]$进行标记即可。</p><p>下一个难点是用什么值来标记。显然可以取不在原数组中的任意值，但是$O(n)$算不出来，而原数组的取值范围又是整个int区间，不能用max+1，min-1这个trick。我的做法就是用n+1来标记，但需要把原数组中的n+1都先改成n+2（一开始没意识到要改，wa了一次），因为可以知道答案一定是小于等于n+1的，所以大于等于n+1的数的取值是无所谓的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;x : nums) <span class="keyword">if</span> (x == n + <span class="number">1</span>) x = n + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = i, x = nums[j];</span><br><span class="line">            <span class="keyword">while</span> (x &gt; i &amp;&amp; x &lt;= n) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = nums[x];</span><br><span class="line">                nums[x] = n + <span class="number">1</span>;</span><br><span class="line">                x = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= i) nums[x] = n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (d &lt;= n &amp;&amp; nums[d] == n + <span class="number">1</span>) ++d;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了题解才意识到这是置换的做法。</p><p>此外还有一种正负的做法（或者称为哈希）：显然负数是没用的，所以可以用负号作为标记的手段，与此同时绝对值保留为原取值，这样都不用担心覆盖的问题，不需要进行置换，更好写了。本质有点类似压位，反正就是在一个int的32bit里表达更多的信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linenoise库</title>
      <link href="/2023/09/04/Linenoise%E5%BA%93/"/>
      <url>/2023/09/04/Linenoise%E5%BA%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Perl 语言</title>
      <link href="/2023/09/04/Perl-%E8%AF%AD%E8%A8%80/"/>
      <url>/2023/09/04/Perl-%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>Perl 是一种脚本语言，它内置了正则表达式，在文本和字符串处理方面有一定的优势。</p><p><a href="https://catonmat.net/ftp/perl1line.txt">Perl one liners</a></p><p><a href="https://perldoc.perl.org/perlintro">Perl doc intro</a></p><h2 id="运行"><a class="header-anchor" href="#运行">¶</a>运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">perl prog.pl</span><br><span class="line"><span class="comment"># 或者使用shebang</span></span><br><span class="line"><span class="comment">#!/usr/bin/env perl</span></span><br><span class="line"><span class="comment">## 使用#!/usr/bin/perl则固定了perl的路径，而以上写法会在env中查找perl的安装路径，不一定在/usr/bin下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获潜在的问题，在5.35版本及以上会自动启用（`use v5.35`）</span></span><br><span class="line">use strict;</span><br><span class="line">use warning;</span><br></pre></td></tr></table></figure><h2 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标量以$起始</span></span><br><span class="line"><span class="keyword">my</span> $var = <span class="number">123</span>; <span class="comment"># 第一次使用变量使用my关键字进行声明，这是`use strict;`的要求，并且my会创建具有语法范围的变量，否则创建全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组以@起始，表示一列值，类型可以不同</span></span><br><span class="line"><span class="keyword">my</span> @arr = (<span class="string">&quot;camel&quot;</span>, <span class="number">42</span>, <span class="number">1.23</span>);</span><br><span class="line">$arr[<span class="number">0</span>]; <span class="comment"># 第一个元素</span></span><br><span class="line">$arr[<span class="comment">#arr]; # 最后一个元素</span></span><br><span class="line">@arr <span class="comment"># 数组长度</span></span><br><span class="line"><span class="comment">## 获取多个值（切片）</span></span><br><span class="line">@arr[<span class="number">0</span>,<span class="number">1</span>]; <span class="comment"># (&quot;camel&quot;, 42)</span></span><br><span class="line">@arr[<span class="number">0</span>..<span class="number">2</span>]; <span class="comment"># (&quot;camel&quot;, 42, 1.23)</span></span><br><span class="line"><span class="keyword">my</span> @sorted_arr = <span class="keyword">sort</span> @arr;</span><br><span class="line"><span class="keyword">my</span> @reversed_arr = <span class="keyword">reverse</span> @arr;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希以%起始，表示一个键值对集合，内部顺序不定</span></span><br><span class="line"><span class="keyword">my</span> %fruit_color = (</span><br><span class="line">    <span class="string">apple =&gt;</span> <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    <span class="string">banana =&gt;</span> <span class="string">&quot;yellow&quot;</span>,</span><br><span class="line">);</span><br><span class="line">$fruit_color&#123;<span class="string">&quot;apple&quot;</span>&#125;; <span class="comment"># &quot;red&quot;</span></span><br><span class="line"><span class="keyword">my</span> fruits = <span class="keyword">keys</span> %fruit_color;</span><br><span class="line"><span class="keyword">my</span> colors = <span class="keyword">values</span> @fruit_color;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件语句</span></span><br><span class="line"><span class="keyword">if</span> ($var) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">elsif</span> ($var eq <span class="string">&#x27;bar&#x27;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unless</span> (condition) &#123; <span class="comment"># 等价于 if (!condition)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 单行条件块可以使用条件后置</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;123&quot;</span> <span class="keyword">if</span> $var</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;345&quot;</span> <span class="keyword">unless</span> $var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环语句</span></span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">until</span> (condition) &#123; <span class="comment"># 等价于 while (!condition)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt;= <span class="number">5</span>; $i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (@array) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊标量</span></span><br><span class="line">$_ <span class="comment"># 默认变量，在foreach中会绑定到当前元素，也可以对其进行赋值，它是一些函数和操作的隐式默认参数（print，m//）</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="number">1</span>..<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;$_\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">subroutine</span> </span>&#123;</span><br><span class="line"><span class="comment"># @_是参数数组，$_[i]访问第i个参数</span></span><br><span class="line"><span class="comment"># 用return返回值，没有return则默认最后一行语句作为返回值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串</span></span><br><span class="line"><span class="comment">## 双引号会正常解析转义字符（包括换行符）和变量等，而单引号保持原样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运算符</span></span><br><span class="line">=</span><br><span class="line">. <span class="comment"># 字符串拼接</span></span><br><span class="line"><span class="keyword">x</span> <span class="comment"># 字符串重复</span></span><br><span class="line">.. <span class="comment"># 范围运算符</span></span><br><span class="line">&lt;=&gt; <span class="comment"># 左边小返回-1，相等返回0，左边大返回1 `cmp`</span></span><br><span class="line"><span class="string">q&#123;&#125;</span> <span class="comment"># 添加单引号</span></span><br><span class="line"><span class="string">qq&#123;&#125;</span> <span class="comment"># 添加双引号</span></span><br><span class="line"><span class="string">qx&#123;&#125;</span> <span class="comment"># 添加反引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式</span></span><br><span class="line"><span class="comment">## 匹配 m/regex/，可省去m</span></span><br><span class="line"><span class="comment">## 替换 s/pattern/replacement/</span></span><br><span class="line"><span class="comment">## =~ 相匹配</span></span><br><span class="line"><span class="comment">## !~ 不匹配</span></span><br><span class="line"><span class="keyword">if</span> ($a =~ <span class="regexp">/regex/</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">if</span> ($email =~ <span class="regexp">/([^@]+)@(.+)/</span>) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;Username is $1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;Hostname is $2\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell重定向</title>
      <link href="/2023/09/03/Shell%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2023/09/03/Shell%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="输入-输出重定向"><a class="header-anchor" href="#输入-输出重定向">¶</a>输入/输出重定向</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; file <span class="comment"># 输出重定向到file</span></span><br><span class="line"><span class="built_in">command</span> &lt; file <span class="comment"># 输入重定向到file</span></span><br><span class="line"><span class="built_in">command</span> &gt;&gt; file <span class="comment"># 输出以追加的方式重定向到file</span></span><br><span class="line">n &gt; file <span class="comment"># 文件描述符为n的文件重定向到file</span></span><br><span class="line">n &gt;&gt; file</span><br><span class="line">n &gt;&amp; m <span class="comment"># 输出文件合并</span></span><br><span class="line">n &lt;&amp; m</span><br><span class="line">&lt;&lt; <span class="string">tag # 将开始标记tag</span>和结束标记tag间的内容作为输入</span><br></pre></td></tr></table></figure><ul><li>标准输入：stdin，文件描述符为0</li><li>标准输出：stdout，文件描述符为1</li><li>标准错误：stderr，文件描述符为2</li><li>/dev/null</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; file 2&gt;&amp;1 <span class="comment"># stdout和stderr都输出到file</span></span><br></pre></td></tr></table></figure><h2 id="Here-document"><a class="header-anchor" href="#Here-document">¶</a>Here document</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n &lt;&lt; <span class="string">delimiter</span></span><br><span class="line"><span class="string">document</span></span><br><span class="line"><span class="string">delimiter</span></span><br></pre></td></tr></table></figure><p>将两个delimiter间的内容重定向输出后作为标准输入传递给文件描述符n。其中结尾的delimiter需要顶格写，周围不能有空格，但开始的delimiter周围的空格会被忽略。</p><p>delimiter应选择不会在document中出现，且不会引起混淆的字符串（字母开头，可包含字母和数字）。</p><p>使用<code>&lt;&lt;-</code>，可以让document保持缩进。</p><p>delimiter如果加单/双引号，则document中的内容不会进行shell替换，如变量、命令等。</p><p>输出重定向在开始的delimiter后指定。</p><h2 id="Here-string"><a class="header-anchor" href="#Here-string">¶</a>Here string</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &lt;&lt;&lt; <span class="string">word # 等价于echo word</span> | n</span><br></pre></td></tr></table></figure><p>word加单引号不会进行shell替换,双引号时会。</p><h2 id="Command-substitution"><a class="header-anchor" href="#Command-substitution">¶</a>Command substitution</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">command</span>)</span><br><span class="line">`<span class="built_in">command</span>`</span><br><span class="line">text=<span class="string">&quot;<span class="subst">$(command)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>命令替换允许执行命令并用命令的输出替换命令文本。</p><h2 id="Process-substitution"><a class="header-anchor" href="#Process-substitution">¶</a>Process substitution</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;(<span class="built_in">command</span>)</span><br><span class="line">&gt;(<span class="built_in">command</span>)</span><br><span class="line">diff &lt;(<span class="built_in">ls</span> dir1) &lt;(<span class="built_in">ls</span> dir2) <span class="comment"># 比较两个命令的输出</span></span><br></pre></td></tr></table></figure><p>进程替换允许将命令的输出保存到一个临时文件（命名管道）中，然后作为另一个命令的输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &lt;(<span class="built_in">ls</span>)</span><br><span class="line">/proc/self/fd/13</span><br><span class="line">$ <span class="built_in">cat</span> &lt;&lt;&lt;<span class="string">&quot;<span class="subst">$(ls)</span>&quot;</span></span><br><span class="line">$ <span class="built_in">cat</span> &lt; &lt;(<span class="built_in">ls</span>)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(ls)</span>&quot;</span> | <span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p>注：诸如管道、输入重定向、here document、here string都是将内容推送到标准输入流中，而进程替换则是保存到一个临时文件中，并用临时文件名来替换命令。这显然更强大。可以通过<code>&lt; &lt;(command)</code>来推送到标准输入流。</p><p>另外注意是否添加引号可能会有区别。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csmith——生成用于测试的随机C程序</title>
      <link href="/2023/09/03/Csmith%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E7%94%A8%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%9A%84%E9%9A%8F%E6%9C%BAC%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/09/03/Csmith%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E7%94%A8%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%9A%84%E9%9A%8F%E6%9C%BAC%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>Csmith 能够随机生成<strong>没有未定义行为</strong>的C程序（借助静态规则和运行时检查），用于编译器、静态分析器等处理源代码的工具的测试。</p><p>注意：生成的程序可能包含死循环，并且毕竟是随机生成的，与人写的代码还是有很大区别的。而且Csmith 只能生成<strong>C程序</strong>，不能生成<strong>C++程序</strong>。<a href="https://github.com/intel/yarpgen">yarpgen</a>可以随机生成C++程序。</p><h2 id="随机测试-差分测试"><a class="header-anchor" href="#随机测试-差分测试">¶</a>随机测试+差分测试</h2><p>包含如下三步：</p><ul><li>使用Csmith生成大量有效的C程序</li><li>用不同版本的编译器运行同一个C程序</li><li>比较编译器的输出，以多数的结果作为正确输出</li></ul><p><a data-fancybox="gallery" data-src="/post-images/Csmith.png" data-caption="Csmith 随机测试+差分测试"><img src="/post-images/Csmith.png" alt="Csmith 随机测试+差分测试"></a></p><h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/csmith-project/csmith.git</span><br><span class="line"><span class="built_in">cd</span> csmith</span><br><span class="line">sudo apt install g++ cmake m4</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/csmith .</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>这里的<code>m4</code>是一个文本处理工具，通常用于宏处理和文本替换。它可以用来编写、维护和生成各种类型的文本文件，包括配置文件、脚本、程序源代码等。</p><h2 id="运行"><a class="header-anchor" href="#运行">¶</a>运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HME</span>/csmith/bin</span><br><span class="line">csmith &gt; random1.c</span><br></pre></td></tr></table></figure><p>注：生成的程序的输出固定为<code>checksum = xxx</code>的形式，通过比较运行后输出的checksum的值来判断编译器是否正确编译。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU Binutils</title>
      <link href="/2023/09/03/GNU-Binutils/"/>
      <url>/2023/09/03/GNU-Binutils/</url>
      
        <content type="html"><![CDATA[<p>Binutils 是由很多处理汇编文件、目标文件以及库的二进制开发工具组成的集合。</p><h2 id="as"><a class="header-anchor" href="#as">¶</a>as</h2><p>汇编器，将汇编代码转化为目标文件。在不提供<code>-o</code>选项时，默认输出到a.out文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as file.s -o file.o</span><br><span class="line">as --32/--64 file.s # 32/64 bit</span><br></pre></td></tr></table></figure><h3 id="目标文件"><a class="header-anchor" href="#目标文件">¶</a>目标文件</h3><p>也叫可重定位文件，是经过编译但还未进行链接的中间文件。</p><h2 id="ld"><a class="header-anchor" href="#ld">¶</a>ld</h2><p>链接器，将若干目标文件链接为可执行文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ld file1.o file2.o -o exe</span><br><span class="line">ld file.o --dynamic-linker /lib64/ld-linux-x86-64.so.2 -e main -lc -o exe</span><br></pre></td></tr></table></figure><p>虽然说<code>gcc</code>在将源代码编译成汇编后就是依靠<code>as</code>和<code>ld</code>来生成最终的可执行文件（<code>gcc -v</code>显示的是<code>collect2</code>，不过这其实只是<code>ld</code>的封装），但是手动使用<code>gcc -S</code>，<code>as</code>和<code>ld</code>来生成可执行文件会产生很多问题（我到现在都还没成功），比如入口函数、程序终止等等。</p><h2 id="nm"><a class="header-anchor" href="#nm">¶</a>nm</h2><p>列出目标文件或可执行文件中的符号表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nm file</span><br><span class="line">-g # 列出全局符号</span><br><span class="line">-u # 列出未定义符号</span><br><span class="line">-a # 列出所有符号</span><br><span class="line">--demangle # 还原C++中修饰了的符号</span><br></pre></td></tr></table></figure><p>符号类型：大写为全局，小写为局部。</p><ul><li>U: 未定义符号</li><li>T: 文本符号</li><li>D: 数据符号</li><li>B: bss符号</li><li>A: 绝对符号</li></ul><h2 id="size"><a class="header-anchor" href="#size">¶</a>size</h2><p>列出目标文件或可执行文件中各个节的大小信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size file</span><br></pre></td></tr></table></figure><p>输出包括text，data，bss，dec，hex和filename列，其中dec和hex是总大小的十进制和十六进制表示。</p><h2 id="strings"><a class="header-anchor" href="#strings">¶</a>strings</h2><p>列出目标文件或可执行文件中可打印的字符串，默认只搜索数据段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings file</span><br><span class="line">strings -a file</span><br><span class="line">string -n number file # 限制长度至少为number</span><br></pre></td></tr></table></figure><h2 id="strip"><a class="header-anchor" href="#strip">¶</a>strip</h2><p>去除符号表，减小文件大小并加速执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strip file</span><br><span class="line">strip --strip-all file</span><br><span class="line">strip --strip-debug file</span><br><span class="line">strip --strip-unneeded file</span><br><span class="line">strip file -o stripped_file # 默认是替换源文件，-o则生成一个新文件</span><br></pre></td></tr></table></figure><h2 id="c-filt"><a class="header-anchor" href="#c-filt">¶</a>c++filt</h2><p>还原修饰的C++符号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++filt _Z1fv</span><br></pre></td></tr></table></figure><h2 id="addr2line"><a class="header-anchor" href="#addr2line">¶</a>addr2line</h2><p>将可执行文件中的地址翻译为对应的行号和文件名，需要编译信息（<code>-g</code>）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr2line -e exe --functions --demangle address </span><br></pre></td></tr></table></figure><p>可以将汇编代码和源文件代码一一对应起来，帮助理解。</p><h2 id="gprof"><a class="header-anchor" href="#gprof">¶</a>gprof</h2><p>用于程序性能分析，需要<code>-pg</code>选项以在每个函数入口处插入<code>mcount</code>函数用于插桩。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./exe # 运行后会生成一个gmon.out文件</span><br><span class="line">gprof exe gmon.out &gt; analysis.txt</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>计时基于采样，不准确</li><li>只分析用户态代码</li><li>不分析共享库代码</li><li>只观测主线程，且不一定线程安全</li></ul><h2 id="ar"><a class="header-anchor" href="#ar">¶</a>ar</h2><p>用于建立、修改静态库或从静态库中提取文件。其中静态库中包含了按照特定结构组织起来的一组目标文件（称为成员，有.a、.so、.o等类型），并保留各个文件的原始信息。</p><p>注：<code>ar</code>命令创建的文件用于存储编译后的目标文件以供链接，而<code>tar</code>命令创建的文件用于组织和归档文件和目录。这两种命令的主要用途和文件格式完全不同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar crv liba.a file1.o file2.o</span><br></pre></td></tr></table></figure><h2 id="ranlib"><a class="header-anchor" href="#ranlib">¶</a>ranlib</h2><p>在更新静态库后，更新符号表信息（一般不需要使用，该功能等价于<code>ar -s</code>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ranlib liba.a</span><br></pre></td></tr></table></figure><h2 id="readelf"><a class="header-anchor" href="#readelf">¶</a>readelf</h2><p>显示ELF格式文件的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readelf -h file</span><br><span class="line">readelf -a file</span><br><span class="line">readelf -s file # 符号表</span><br><span class="line">readelf -r file # 可重定位表</span><br><span class="line">readelf -S file # 节头表</span><br><span class="line">readelf -l file # 程序头表</span><br><span class="line">-W # 输出不换行</span><br></pre></td></tr></table></figure><h2 id="objdump"><a class="header-anchor" href="#objdump">¶</a>objdump</h2><p>显示目标文件的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objdump -d file # 反汇编</span><br><span class="line">objdump -d -S file # 与源代码对应</span><br><span class="line">objdump -d -l file # 与源代码中的行号对应</span><br><span class="line">objdump -M intel -d file # 使用intel格式</span><br><span class="line">objdump -f file # 查看文件头信息</span><br></pre></td></tr></table></figure><h2 id="objcopy"><a class="header-anchor" href="#objcopy">¶</a>objcopy</h2><p>将一种类型的目标文件转化为另一种类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objcopy --only-keep-debug file file.debuginfo # 抽取出调试信息</span><br></pre></td></tr></table></figure><h2 id="libiberty"><a class="header-anchor" href="#libiberty">¶</a>libiberty</h2><h2 id="libbfd"><a class="header-anchor" href="#libbfd">¶</a>libbfd</h2><p>二进制描述符库。</p><h2 id="libopcodes"><a class="header-anchor" href="#libopcodes">¶</a>libopcodes</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tabby 终端模拟器</title>
      <link href="/2023/08/26/tabby%E7%BB%88%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
      <url>/2023/08/26/tabby%E7%BB%88%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>用于平替Xshell和Xftp。</p><h2 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h2><p>外观/字体：支持Nerd Font</p><p>终端/右键点击：粘贴</p><p>终端/按下按键来点击链接：<code>Ctrl</code>（防止误点链接）</p><p>终端/选中时复制：关闭</p><p>配色方案：Nord</p><p>快捷键：</p><ul><li><code>Ctrl-Shift-O</code>: 关闭当前聚焦的窗格 (Cl<ins>o</ins>se)</li></ul><p>插件：</p><ul><li><code>community-color-schemes</code></li><li><code>docker</code></li><li><code>search-in-browser</code>：选中文字，<strong>长按</strong>右键后选择在浏览器中搜索</li><li><code>trzsz</code>：串行通信环境下的文件传输工具，有进度条并支持目录传输（lrzsz加强版）</li></ul><p>窗口/不透明度：自行调整</p><h2 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h2><ul><li>复制：<code>Ctrl+Shift+C</code></li><li>粘贴：<code>Ctrl+Shift+V</code>/右键</li><li>菜单：长按右键</li><li><code>Ctrl+Shift+S</code>：向右拆分窗口 (<ins>S</ins>plit)</li><li><code>Ctrl+Shift+D</code>：向下拆分窗口 (<ins>D</ins>own)</li><li><code>trzsz</code>(<code>trz/tsz</code>)：主要用于解决文件夹以及批量文件下载的<ul><li><code>trz dir/</code>：上传文件到指定文件夹下（<ins>R</ins>eceive，即接收到当前服务器）</li><li><code>tsz file1 file2</code>：下载（多个）文件（<ins>S</ins>end，即从当前服务器发送）</li><li><code>trz -d</code>和<code>tsz -r</code>：允许文件夹传输</li><li><code>-b</code>：二进制传输，对压缩包、图片等更快</li><li><code>-e</code>：转移控制字符</li><li><code>-y</code>：覆盖同名文件/文件夹，并支持断点续传</li><li>设置<code>Enable drag files and directories</code>后允许直接拖动文件/文件夹进行上传</li></ul></li></ul><h2 id="效果"><a class="header-anchor" href="#效果">¶</a>效果</h2><p>trzsz：<a data-fancybox="gallery" data-src="/post-images/trzsz.png" data-caption="trz上传文件"><img src="/post-images/trzsz.png" alt="trz上传文件"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 总结</title>
      <link href="/2023/08/25/vim%E6%80%BB%E7%BB%93/"/>
      <url>/2023/08/25/vim%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="vim常用键"><a class="header-anchor" href="#vim常用键">¶</a>vim常用键</h2><p><code>verb + noun</code> (cperator [number] motion/object)</p><h3 id="命令"><a class="header-anchor" href="#命令">¶</a>命令</h3><ul><li><code>:e</code>：打开文件</li><li><code>:wq</code>, <code>:x</code>, <code>:xa</code>：<code>x</code>等于<code>wq</code></li><li><code>vim +line_number path/to/file</code>：打开文件的指定行</li><li><code>!ls</code>：执行外部命令</li></ul><h3 id="编辑"><a class="header-anchor" href="#编辑">¶</a>编辑</h3><ul><li><code>i</code>：光标前插入</li><li><code>a</code>：光标后插入</li><li><code>o</code>：下一行插入</li><li><code>O</code>：上一行插入</li><li><code>I</code>：当前行开头插入</li><li><code>A</code>：当前行结尾插入</li><li><code>u</code>：撤销上一次改动</li><li><code>Ctrl-r</code>：重做</li><li><code>U</code>：撤销当前行的所有改动</li></ul><h3 id="动作"><a class="header-anchor" href="#动作">¶</a>动作</h3><ul><li><p><code>y</code>：复制</p></li><li><p><code>p</code>：粘贴</p></li><li><p><code>d</code>：删除</p></li><li><p><code>c</code>：替换</p></li><li><p><code>x</code>：删除单个字符</p></li><li><p><code>r</code>：替换单个字符</p></li><li><p><code>R</code>：连续替换多个字符</p></li><li><p><code>~</code>：修改大小写</p></li><li><p><code>.</code>：重复上一次<strong>更改</strong></p></li></ul><h3 id="移动"><a class="header-anchor" href="#移动">¶</a>移动</h3><ul><li><p><code>hjkl</code>：上下左右</p></li><li><p><code>gg</code>：首行</p></li><li><p><code>G</code>：最后一行</p></li><li><p><code>%</code>：移动到匹配的括号处</p></li><li><p><code>^</code>：当前行开头（第一个非空白字符）</p></li><li><p><code>0</code>：当前行开头（第一个字符）</p></li><li><p><code>$</code>：当前行结尾（最后一个字符）</p></li><li><p><code>n|</code>：当前行的第<code>n</code>列</p></li><li><p><code>b</code>：前一个word的结尾</p></li><li><p><code>w</code>：后一个word的开头</p></li><li><p><code>e</code>：后一个word的结尾</p></li><li><p><code>BWE</code>：WORD是除空白符外的字符序列，相比于word可以包含标点符号</p></li><li><p><code>fx</code>：移动到下一个字符<code>x</code> (find)</p></li><li><p><code>Fx</code>：移动到上一个字符<code>x</code></p></li><li><p><code>;</code>：重复<code>fF</code>移动</p></li><li><p><code>,</code>：反向移动</p></li><li><p><code>(</code>：前一个句子</p></li><li><p><code>)</code>：后一个句子</p></li><li><p><code>&#123;</code>：前一个段落</p></li><li><p><code>&#125;</code>：后一个段落</p></li><li><p><code>Ctrl-d</code>：向下滚动半个屏幕</p></li><li><p><code>Ctrl-f</code>：向下滚动一个屏幕</p></li><li><p><code>Ctrl-u</code>：向上滚动半个屏幕</p></li><li><p><code>Ctrl-b</code>：向上滚动一个屏幕</p></li><li><p><code>zt</code>：将当前行置于屏幕顶部</p></li><li><p><code>zz</code>：将当前行置于屏幕中央</p></li><li><p><code>zb</code>：将当前行置于屏幕底部</p></li><li><p><code>/</code>：正向搜索</p></li><li><p><code>?</code>：逆向搜索</p></li><li><p><code>n</code>：下一个匹配</p></li><li><p><code>N</code>：上一个匹配</p></li><li><p><code>*</code>：快速正向搜索当前单词</p></li><li><p><code>#</code>：快速逆向搜索当前单词</p></li><li><p><code>%s/regexp/replacement/g</code>：全局替换（不加g则只修改一次）</p></li><li><p><code>%s/regexp/replacement/gc</code>：对每个替换都提问是否进行</p></li></ul><h3 id="对象"><a class="header-anchor" href="#对象">¶</a>对象</h3><ul><li><p><code>i object</code>: inner object</p></li><li><p><code>a object</code>: around object</p></li><li><p><code>w</code>: word</p></li><li><p><code>p</code>: paragraph</p></li><li><p><code>s</code>: sentence</p></li><li><p><code>(</code>/<code>)</code>: a pair of ( )</p></li><li><p><code>[</code>/<code>]</code>: a pair of [ ]</p></li><li><p><code>&#123;</code>/<code>&#125;</code>: a pair of { }</p></li><li><p><code>&lt;</code>/<code>&gt;</code>: a pair of &lt; &gt;</p></li><li><p>&quot;: a pair of &quot; &quot;</p></li><li><p>': a pair of ’ ’</p></li><li><p><code>: a pair of </code> `</p></li></ul><h3 id="多窗口浏览"><a class="header-anchor" href="#多窗口浏览">¶</a>多窗口浏览</h3><ul><li>向下切分：<code>:sp [file]</code></li><li>向右切分：<code>:vsp [file]</code></li><li>上下左右移动：<code>&lt;Ctrl-h/j/k/l&gt;</code></li><li>关闭当前窗口：<code>:q</code></li></ul><h3 id="折叠"><a class="header-anchor" href="#折叠">¶</a>折叠</h3><ul><li><code>za</code>：翻转折叠</li><li><code>zR</code>：取消所有折叠</li><li><code>zM</code>：执行所有折叠</li></ul><h3 id="选择模式"><a class="header-anchor" href="#选择模式">¶</a>选择模式</h3><ul><li><code>&gt;</code>：右移</li><li><code>&lt;</code>：左移</li><li><code>y</code>：复制</li><li><code>d</code>：删除</li><li><code>u</code>：小写化</li><li><code>U</code>：大写化</li></ul><h3 id="选项"><a class="header-anchor" href="#选项">¶</a>选项</h3><ul><li>设置缩进大小：<code>:set shiftwidth=4</code></li><li>设置wrap：<code>set wrap</code></li><li>查看文件类型：<code>set filetype?</code></li></ul><h2 id="Neovim配置"><a class="header-anchor" href="#Neovim配置">¶</a>Neovim配置</h2><h3 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h3><p>Ubuntu apt安装的版本较旧，所以选择自行安装0.9.1版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/neovim/neovim/releases/download/v0.9.1/nvim.appimage</span><br><span class="line"><span class="built_in">chmod</span> u+x nvim.appimage</span><br><span class="line">./nvim.appimage --appimage-extract</span><br><span class="line">./squashfs-root/AppRun --version</span><br><span class="line">sudo <span class="built_in">mv</span> squashfs-root /</span><br><span class="line">sudo <span class="built_in">ln</span> -s /squashfs-root/AppRun /usr/bin/nvim</span><br></pre></td></tr></table></figure><h3 id="卸载"><a class="header-anchor" href="#卸载">¶</a>卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /usr/local/bin/nvim</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /usr/local/share/nvim/</span><br><span class="line"><span class="comment"># 移除配置</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="variable">$HOME</span>/.config/nvim</span><br><span class="line"><span class="built_in">rm</span> -rf <span class="variable">$HOME</span>/.local/share/nvim</span><br></pre></td></tr></table></figure><h3 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h3><h4 id="起点"><a class="header-anchor" href="#起点">¶</a>起点</h4><p>选择<code>NvChad</code>作为配置的起点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NvChad/NvChad ~/.config/nvim --depth 1 &amp;&amp; nvim</span><br><span class="line"><span class="comment"># 输入N，不采用示例配置</span></span><br></pre></td></tr></table></figure><p>在<code>custom/init.lua</code>中设置<code>vim.g.mapleader = &quot;,&quot;</code>，将<code>&lt;leader&gt;</code>设置为逗号。</p><p>插件配置参考<a href="https://github.com/ayamir/nvimdots">ayamir/nvimdots</a>、<a href="https://www.lazyvim.org/">lazyvim</a>和<a href="https://github.com/BrunoKrugel/dotfiles">BrunoKrugel/dotfiles</a>。</p><p>下面只介绍涉及到快捷键或者命令的插件，作为备忘。</p><ul><li><code>NvChadUpdate</code>：一键更新</li><li><code>&lt;Ctrl-s&gt;</code>：保存文件</li><li><code>&lt;Ctrl-c&gt;</code>：复制整个文件</li><li><code>&lt;leader&gt;rn</code>：切换相对行号</li></ul><h4 id="插件管理"><a class="header-anchor" href="#插件管理">¶</a>插件管理</h4><p><code>folke/lazy.nvim</code></p><ul><li><code>:Lazy</code>：打开Lazy面板</li></ul><h4 id="用户界面"><a class="header-anchor" href="#用户界面">¶</a>用户界面</h4><h5 id="主题"><a class="header-anchor" href="#主题">¶</a>主题</h5><ul><li><code>&lt;leader&gt;th</code>：选择主题</li></ul><p>选用<code>aquarium</code>，并设置<code>transparency=false</code>。</p><h5 id="面板"><a class="header-anchor" href="#面板">¶</a>面板</h5><p>设置<code>load_on_startup=true</code>（可选）。</p><h5 id="Buffer-line"><a class="header-anchor" href="#Buffer-line">¶</a>Buffer line</h5><ul><li><code>&lt;Tab&gt;</code>：下一个Buffer</li><li><code>&lt;S-Tab&gt;</code>：上一个Buffer</li><li><code>&lt;leader&gt;x</code>：关闭当前Buffer</li></ul><h4 id="工具"><a class="header-anchor" href="#工具">¶</a>工具</h4><h5 id="备忘单"><a class="header-anchor" href="#备忘单">¶</a>备忘单</h5><ul><li><code>&lt;leader&gt;ch</code>：打开备忘单</li></ul><h5 id="文件树"><a class="header-anchor" href="#文件树">¶</a>文件树</h5><p><code>nvim-tree/nvim-tree.lua</code></p><p><code>:h nvim-tree-mappings-default</code></p><ul><li><p><code>&lt;Ctrl-n&gt;</code>：打开/关闭文件树</p></li><li><p><code>NvimTreeFocus</code>, <code>&lt;leader&gt;e</code>：聚焦</p></li><li><p><code>&lt;CR&gt;</code>：打开光标所在文件/进入文件夹</p></li><li><p><code>j</code>/<code>k</code>：上下移动</p></li><li><p><code>a</code>：新建文件</p></li><li><p><code>d</code>：删除文件</p></li><li><p><code>r</code>：重命名文件</p></li><li><p><code>S</code>：搜索文件</p></li><li><p><code>&lt;BS&gt;</code>：关闭文件夹</p></li><li><p><code>q</code>：退出</p></li><li><p><code>&lt;Tab&gt;</code>：预览</p></li><li><p><code>c</code>：复制文件</p></li><li><p><code>p</code>：粘贴文件</p></li><li><p><code>x</code>：剪切文件</p></li></ul><h5 id="文件查找"><a class="header-anchor" href="#文件查找">¶</a>文件查找</h5><p><code>nvim-telescope/telescope.nvim</code></p><ul><li><p><code>&lt;leader&gt;ff</code>：查找文件</p></li><li><p><code>&lt;leader&gt;fw</code>：查找文件中的内容</p></li><li><p><code>&lt;leader&gt;fg</code>：查找时可以添加rg参数，此时搜索的文本需要用双引号包裹 (<code>&quot;foo&quot; -i</code>大小写不敏感查找)</p></li><li><p><code>&lt;leader&gt;gs</code>：<code>AdvancedGitSearch</code></p></li><li><p><code>&lt;leader&gt;fz</code>：在当前文件中fzf</p></li><li><p><code>&lt;leader&gt;th</code>：查找主题</p></li><li><p><code>&lt;leader&gt;cm</code>：查找git commit</p></li><li><p><code>&lt;leader&gt;gt</code>：查找git status</p></li><li><p><code>&lt;leader&gt;fa</code>：查找所有文件（包括隐藏文件）</p></li><li><p><code>&lt;leader&gt;fb</code>：查找打开的Buffer中的文件</p></li><li><p><code>&lt;leader&gt;fh</code>：查找帮助文件</p></li><li><p><code>&lt;Up&gt;</code>/<code>&lt;Down&gt;</code>或在Normal模式下<code>j</code>/<code>k</code>：上下移动</p></li><li><p><code>&lt;C-u&gt;</code>/<code>&lt;C-d&gt;</code>：在预览窗口上下移动</p></li><li><p><code>&lt;CR&gt;</code>：选择</p></li><li><p><code>?</code>：打开快捷键面板</p></li></ul><h5 id="终端"><a class="header-anchor" href="#终端">¶</a>终端</h5><ul><li><code>&lt;A-h&gt;</code>：在下方打开/关闭一个终端</li><li><code>&lt;A-v&gt;</code>：在右方打开/关闭一个终端</li><li><code>&lt;A-i&gt;</code>：打开/关闭一个浮动终端</li></ul><h5 id="行跳转"><a class="header-anchor" href="#行跳转">¶</a>行跳转</h5><p><code>nacro90/numb.nvim</code></p><ul><li><code>:&lt;number&gt;</code>：跳转到某行，该插件可以提供实时预览功能</li></ul><h4 id="编辑-s2"><a class="header-anchor" href="#编辑-s2">¶</a>编辑</h4><h5 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h5><p><code>numToStr/Comment.nvim</code></p><ul><li><code>gcc</code>：切换当前行注释</li><li><code>gc</code>：切换行注释</li><li><code>gb</code>：切换块注释</li></ul><h5 id="高亮"><a class="header-anchor" href="#高亮">¶</a>高亮</h5><p><code>nvim-treesitter/nvim-treesitter</code></p><ul><li><p>增量选择功能：</p><ul><li><code>&lt;CR&gt;</code>：扩大选择</li><li><code>&lt;BS&gt;</code>：缩小选择</li></ul></li><li><p><code>TSInstallInfo</code>：查看所有语言安装情况</p></li><li><p><code>TSEnable highlight</code>：开启语法高亮</p></li><li><p><code>TSUpdateSync</code>：更新</p></li><li><p><code>TSInstall lang</code>：安装</p></li><li><p><code>TSUninstall lang</code>：卸载</p></li></ul><h5 id="问题列表"><a class="header-anchor" href="#问题列表">¶</a>问题列表</h5><p><code>folke/trouble.nvim</code></p><ul><li><code>TroubleToggle</code>, <code>&lt;leader&gt;tt</code>：打开/关闭问题列表</li></ul><h5 id="TODO-高亮"><a class="header-anchor" href="#TODO-高亮">¶</a>TODO 高亮</h5><p><code>folke/todo-comments.nvim</code></p><ul><li><p>TODO:</p></li><li><p>PERF:</p></li><li><p>NOTE:</p></li><li><p>FIX:</p></li><li><p>WARN:</p></li><li><p>TEST:</p></li><li><p><code>:TodoTrouble</code>, <code>&lt;leader&gt;td</code>：列出所有todo</p></li><li><p><code>:TodoTelescope</code> <code>&lt;leader&gt;ts</code>：用telescope查找todo</p></li></ul><p>这里有一个bug是只能查看当前所在文件夹下的todos，而不是打开的文件所在的文件夹下的todos（如果设置<code>autochdir</code>，那么telescope插件又会出问题）。</p><h5 id="快速跳转"><a class="header-anchor" href="#快速跳转">¶</a>快速跳转</h5><p><code>folke/flash.nvim</code></p><p>根据位置提示快速跳转。</p><ul><li>集成到了搜索 (<code>/</code>/<code>?</code>) 中</li><li>集成到了<code>f</code>/<code>t</code>/<code>F</code>/<code>T</code>中，再输入任意一个字符，按<code>f</code>/<code>t</code>/<code>F</code>/<code>T</code>或者<code>;</code>/<code>,</code>移动到下一个/上一个匹配</li><li>按<code>s</code>/<code>S</code>（<code>s</code>是全局，<code>S</code>是treesitter中的所有父节点（还可以通过<code>;</code>/<code>,</code>扩大或缩小范围）），然后输入任意前缀</li></ul><h5 id="括号移动"><a class="header-anchor" href="#括号移动">¶</a>括号移动</h5><p><code>andymass/vim-matchup</code></p><ul><li><code>%</code>：除了原本的括号匹配（<code>()[]&#123;&#125;</code>）跳转外，还在特定于语言的匹配单词间跳转（比如if和else）</li></ul><h4 id="语言"><a class="header-anchor" href="#语言">¶</a>语言</h4><h5 id="符号树"><a class="header-anchor" href="#符号树">¶</a>符号树</h5><p><code>stevearc/aerial.nvim</code></p><ul><li><code>&lt;leader&gt;a</code>：打开关闭aerial</li><li><code>&lt;leader&gt;ta</code>：用telescope查找符号</li></ul><h5 id="格式化"><a class="header-anchor" href="#格式化">¶</a>格式化</h5><p><code>stevearc/conform.nvim</code></p><ul><li><code>&lt;leader&gt;fm</code>：格式化当前文件</li><li><code>FormatEnable</code>：开启保存时自动格式化</li><li><code>FormatDisable</code>：关闭保存时自动格式化</li><li><code>ConformInfo</code></li></ul><h5 id="LSP"><a class="header-anchor" href="#LSP">¶</a>LSP</h5><p>插件：<code>neovim/nvim-lspconfig</code>（配置）、<code>williamboman/mason.nvim</code>（安装管理）、<code>williamboman/mason-lspconfig.nvim</code></p><ul><li><code>LspInfo</code>：查看LSP状态</li><li><code>LspRestart</code>：重启LSP</li><li><code>LspStart</code>：启动LSP</li><li><code>LspStop</code>：关闭LSP</li><li><code>Mason</code>：Mason面板</li><li><code>MasonInstall &lt;package&gt;</code>, <code>MasonUninstall</code>：Mason安装</li><li><code>MasonUninstall &lt;package&gt;</code>, <code>:MasonUninstall</code>：Mason卸载</li><li><code>MasonUpdate</code>：Mason更新</li><li><code>MasonLog</code>：Mason日志</li></ul><p>Lsp快捷键：</p><ul><li><code>K</code>：查看文档</li><li><code>gr</code>：查看引用</li><li><code>gd</code>：查看定义</li><li><code>gi</code>：查看实现</li><li><code>&lt;leader&gt;ca</code>：code action</li><li><code>&lt;leader&gt;ra</code>：变量改名</li><li><code>&lt;leader&gt;D</code>：类型</li><li><code>&lt;leader&gt;</code>：签名</li></ul><h5 id="Glance"><a class="header-anchor" href="#Glance">¶</a>Glance</h5><ul><li><code>gD</code>：查看所有定义</li><li><code>gM</code>：查看所有实现</li><li><code>gY</code>：查看类型定义</li><li><code>gR</code>：查看所有引用</li></ul><h5 id="Clangd-Extension"><a class="header-anchor" href="#Clangd-Extension">¶</a>Clangd Extension</h5><ul><li><code>ClangdSwitchSourceHeader</code>：在头文件和代码文件间切换</li><li><code>ClangdInlayHints</code></li><li><code>ClangdAST</code>：显示选中代码段的AST</li><li><code>ClangdSymbolInfo</code>：显示光标所在处的类型</li><li><code>ClangdTypeHierarchy</code>：显示光标所在处的类层级关系</li></ul><h5 id="markdown"><a class="header-anchor" href="#markdown">¶</a>markdown</h5><p><code>iamcco/markdown-preview.nvim</code></p><ul><li><code>MarkdownPreviewToggle</code>, <code>&lt;F12&gt;</code></li></ul><h3 id="截图"><a class="header-anchor" href="#截图">¶</a>截图</h3><p><a data-fancybox="gallery" data-src="/post-images/nvim-dash.png" data-caption="nvim dashboard"><img src="/post-images/nvim-dash.png" alt="nvim dashboard"></a></p><p><a data-fancybox="gallery" data-src="/post-images/nvim-startup.png" data-caption="nvim startup time"><img src="/post-images/nvim-startup.png" alt="nvim startup time"></a></p><p><a data-fancybox="gallery" data-src="/post-images/nvim-cpp.png" data-caption="nvim cpp file"><img src="/post-images/nvim-cpp.png" alt="nvim cpp file"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 模板总结</title>
      <link href="/2023/08/25/leetcode%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/"/>
      <url>/2023/08/25/leetcode%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树遍历"><a class="header-anchor" href="#二叉树遍历">¶</a>二叉树遍历</h2><p>前序、中序、后序遍历（这里的前中后描述的是根节点的位置，左子树则永远在右子树之前）。</p><p>层次遍历（BFS）。</p><p>非递归实现使用栈。</p><h3 id="序列化和反序列化"><a class="header-anchor" href="#序列化和反序列化">¶</a>序列化和反序列化</h3><p>使用前序/后序遍历再加上中序遍历可以还原二叉树。</p><p>当包含（所有叶子节点的）空指针信息时，前序/后序遍历即可还原二叉树。</p><p>二叉搜索树的中序遍历是有序的，因此只需要前序/后序遍历即可还原（将前序/后续遍历排序就是中序遍历了）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 总结</title>
      <link href="/2023/08/25/markdown%E6%80%BB%E7%BB%93/"/>
      <url>/2023/08/25/markdown%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法"><a class="header-anchor" href="#基本语法">¶</a>基本语法</h2><h3 id="n-级标题"><a class="header-anchor" href="#n-级标题">¶</a>n 级标题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br></pre></td></tr></table></figure><h3 id="粗体"><a class="header-anchor" href="#粗体">¶</a>粗体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**粗体文本**</span></span><br></pre></td></tr></table></figure><p><strong>粗体文本</strong></p><h3 id="斜体"><a class="header-anchor" href="#斜体">¶</a>斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br></pre></td></tr></table></figure><p><em>斜体文本</em></p><h3 id="引用"><a class="header-anchor" href="#引用">¶</a>引用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用</span></span><br><span class="line"><span class="quote">&gt; 文本</span></span><br></pre></td></tr></table></figure><blockquote><p>引用文本</p></blockquote><ul><li>建议每一行引用都使用符号<code>&gt;</code>。</li></ul><h3 id="无序列表"><a class="header-anchor" href="#无序列表">¶</a>无序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 无序文本</span><br><span class="line"><span class="bullet">-</span> 无序文本</span><br></pre></td></tr></table></figure><ul><li>无序文本</li><li>无序文本</li></ul><h3 id="有序列表"><a class="header-anchor" href="#有序列表">¶</a>有序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 有序文本</span><br><span class="line"><span class="bullet">2.</span> 有序文本</span><br></pre></td></tr></table></figure><ol><li>有序文本</li><li>有序文本</li></ol><ul><li>如果列表项有换行，则建议给无序列表使用 3 个空格，给有序列表使用 2 个空格。</li><li>如果一个列表中的每个列表项都只有 1 行，建议列表项之间不要有空行。</li><li>如果列表项中有换行，建议在列表项之间空 1 行，这样会比较容易区分多行列表项的开始和结束。</li></ul><h3 id="行内代码"><a class="header-anchor" href="#行内代码">¶</a>行内代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`code`</span></span><br></pre></td></tr></table></figure><p><code>code</code></p><h3 id="分割线"><a class="header-anchor" href="#分割线">¶</a>分割线</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><hr><h3 id="文字链接"><a class="header-anchor" href="#文字链接">¶</a>文字链接</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">示例网站</span>](<span class="link">www.example.com</span>)</span><br></pre></td></tr></table></figure><p><a href="www.example.com">示例网站</a></p><h3 id="图片"><a class="header-anchor" href="#图片">¶</a>图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片</span>](<span class="link">/post-images/markdown-cheat.png</span>)</span><br></pre></td></tr></table></figure><p><a data-fancybox="gallery" data-src="/post-images/markdown-cheat.png" data-caption="图片"><img src="/post-images/markdown-cheat.png" alt="图片"></a></p><h3 id="网址链接"><a class="header-anchor" href="#网址链接">¶</a>网址链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;www.example.com&gt;</span><br></pre></td></tr></table></figure><p>&lt;<a href="http://www.example.com">www.example.com</a>&gt;</p><h2 id="扩展语法"><a class="header-anchor" href="#扩展语法">¶</a>扩展语法</h2><p>只介绍 Github 偏好的 Markdown（GFM），尽量保持兼容性。</p><h3 id="自动链接"><a class="header-anchor" href="#自动链接">¶</a>自动链接</h3><p><a href="http://www.example.com">www.example.com</a></p><p>禁用自动链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`www.example.com`</span><br></pre></td></tr></table></figure><p><code>www.example.com</code></p><h3 id="表格"><a class="header-anchor" href="#表格">¶</a>表格</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| Header | Header | Header |</span><br><span class="line">| :---   | :---:  | ---:   |</span><br><span class="line">| Left   | Middle | Right  |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">Header</th><th style="text-align:center">Header</th><th style="text-align:right">Header</th></tr></thead><tbody><tr><td style="text-align:left">Left</td><td style="text-align:center">Middle</td><td style="text-align:right">Right</td></tr></tbody></table><ul><li>表头与其他行使用<code>-</code>来分隔。</li></ul><h3 id="代码块"><a class="header-anchor" href="#代码块">¶</a>代码块</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```cpp</span></span><br><span class="line"><span class="code">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="code">int main() &#123;</span></span><br><span class="line"><span class="code">  std::cout &lt;&lt; &quot;Hello Markdown\n&quot;;</span></span><br><span class="line"><span class="code">  return 0;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">\```</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello Markdown\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>很多 Shell 命令都要粘贴到终端中去执行，因此最好避免在 Shell 命令中使用任何换行操作；可以在行尾使用一个<code>\</code>，这样既能避免命令换行，又能提高源码的可读性。</p></li><li><p>建议不要在没有输出内容的 Shell 命令前加<code>$</code>。在命令没有输出内容的情况下，<code>$</code>是没有必要的，因为内容全是命令，我们不会把命令和输出的内容混淆。</p></li><li><p>建议在有输出内容的 Shell 命令前加上<code>$</code>，这样会比较容易区分命令和输出的内容。（<code>$</code>代表普通用户，<code>#</code>代表超级用户）</p></li></ul><h3 id="删除线"><a class="header-anchor" href="#删除线">¶</a>删除线</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除文本~~</span><br></pre></td></tr></table></figure><p><s>删除文本</s></p><h3 id="任务列表"><a class="header-anchor" href="#任务列表">¶</a>任务列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [x] 已完成</span><br><span class="line">- [ ] TODO</span><br></pre></td></tr></table></figure><ul><li><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">已完成</label></li><li><input type="checkbox" id="checkbox2"><label for="checkbox2">TODO</label></li></ul><hr><p>表情符号：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:cry: :joy: :smile: :warning: :memo: :bulb:</span><br></pre></td></tr></table></figure><p>😢😂😄⚠️📝💡</p><p>参阅 <a href="https://gist.github.com/rxaviers/7360908">表情短代码列表</a></p><h2 id="Tricks"><a class="header-anchor" href="#Tricks">¶</a>Tricks</h2><p>主要是利用 HTML 实现一些额外的功能。</p><h3 id="下划线"><a class="header-anchor" href="#下划线">¶</a>下划线</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span>下划线文本<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br></pre></td></tr></table></figure><p><ins>下划线文本</ins></p><h3 id="缩进"><a class="header-anchor" href="#缩进">¶</a>缩进</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$nbsp <span class="comment">&lt;!-- No-Break Space 不换行空格 --&gt;</span></span><br><span class="line">$emsp <span class="comment">&lt;!-- Em Space 全角空格 --&gt;</span></span><br><span class="line">$ensp <span class="comment">&lt;!-- En Space 半角空格 --&gt;</span></span><br><span class="line"><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>缩进文本</span><br></pre></td></tr></table></figure><p>    缩进文本</p><h3 id="居中"><a class="header-anchor" href="#居中">¶</a>居中</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;center\&gt;居中文本\&lt;/center\&gt; # 标准已弃用</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center&quot;</span>&gt;</span>居中文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&lt;center&gt;居中文本&lt;/center&gt;</p><h3 id="颜色"><a class="header-anchor" href="#颜色">¶</a>颜色</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色文本<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure><p><font color="red">红色文本</font></p><hr><h3 id="图片大小"><a class="header-anchor" href="#图片大小">¶</a>图片大小</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.png&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:33%;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="目录"><a class="header-anchor" href="#目录">¶</a>目录</h3><p>[TOC]</p><h3 id="内容折叠"><a class="header-anchor" href="#内容折叠">¶</a>内容折叠</h3><p>需要安装<code>markdown-it-collapsible</code>插件</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+++ <span class="strong">**点击查看**</span></span><br><span class="line">隐藏内容。</span><br><span class="line"></span><br><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">def expand():</span></span><br><span class="line"><span class="code">  return &quot;exapndable&quot;</span></span><br><span class="line"><span class="code">\```</span></span><br><span class="line"></span><br><span class="line">+++</span><br></pre></td></tr></table></figure><details><summary><span class="details-marker">&nbsp;</span><strong>点击查看</strong></summary><p>隐藏内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">expand</span>():</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;expandable&quot;</span></span><br></pre></td></tr></table></figure></details><h3 id="数学公式"><a class="header-anchor" href="#数学公式">¶</a>数学公式</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>a = b + c * d - e<span class="built_in">_</span>0 * f<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> u&#125;&#123;<span class="keyword">\partial</span> t&#125;</span><br><span class="line">= h<span class="built_in">^</span>2 <span class="keyword">\left</span>( <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> x<span class="built_in">^</span>2&#125; +</span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> y<span class="built_in">^</span>2&#125; +</span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> z<span class="built_in">^</span>2&#125;<span class="keyword">\right</span>)<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\left</span>[</span><br><span class="line">    <span class="keyword">\begin</span>&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">      1<span class="built_in">&amp;</span>2<span class="built_in">&amp;</span>3<span class="keyword">\newline</span></span><br><span class="line">      4<span class="built_in">&amp;</span>5<span class="built_in">&amp;</span>6</span><br><span class="line">    <span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="keyword">\right</span>]</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;eqnarray&#125;</span><br><span class="line"><span class="keyword">\nabla</span><span class="keyword">\cdot</span><span class="keyword">\vec</span>&#123;E&#125; <span class="built_in">&amp;</span>=<span class="built_in">&amp;</span> <span class="keyword">\frac</span>&#123;<span class="keyword">\rho</span>&#125;&#123;<span class="keyword">\epsilon</span><span class="built_in">_</span>0&#125; <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\nabla</span><span class="keyword">\cdot</span><span class="keyword">\vec</span>&#123;B&#125; <span class="built_in">&amp;</span>=<span class="built_in">&amp;</span> 0 <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\nabla</span><span class="keyword">\times</span><span class="keyword">\vec</span>&#123;E&#125; <span class="built_in">&amp;</span>=<span class="built_in">&amp;</span> -<span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> B&#125;&#123;<span class="keyword">\partial</span> t&#125; <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\nabla</span><span class="keyword">\times</span><span class="keyword">\vec</span>&#123;B&#125; <span class="built_in">&amp;</span>=<span class="built_in">&amp;</span> <span class="keyword">\mu</span><span class="built_in">_</span>0<span class="keyword">\left</span>(<span class="keyword">\vec</span>&#123;J&#125;+<span class="keyword">\epsilon</span><span class="built_in">_</span>0<span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> E&#125;&#123;<span class="keyword">\partial</span> t&#125; <span class="keyword">\right</span>)</span><br><span class="line"><span class="keyword">\end</span>&#123;eqnarray&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$a = b + c * d - e_0 * f$</p><p>$$\frac{\partial u}{\partial t}= h^2 \left( \frac{\partial^2 u}{\partial x^2} +\frac{\partial^2 u}{\partial y^2} +\frac{\partial^2 u}{\partial z^2}\right)$$</p><p>$$\left[\begin{array}{cc|c}1&amp;2&amp;3\newline4&amp;5&amp;6\end{array}\right]$$</p><p>$$\begin{eqnarray}\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\nabla\cdot\vec{B} &amp;=&amp; 0 \\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)\end{eqnarray}$$</p><h2 id="排版-Tips"><a class="header-anchor" href="#排版-Tips">¶</a>排版 Tips</h2><ol><li>安装<code>markdownlint</code>插件。</li><li>使用<code>Trailing Spaces</code>插件。</li><li>URL前后加空格，这样可以避免和文字粘连。</li><li>建议中文和英文之间加空格，中文/英文和数字之间也要加空格。（试了几个<code>hexo</code>插件都存在一些问题，这条看情况遵守吧；这样做的一个好处是可以让编辑器帮你进行拼写检查）</li><li>英文标点符号（如，.；：？）与后面的字符之间需要加空格，与前面的字符之间不需要加空格。</li><li>中文标点符号和数字、中文、英文之间不需要添加空格。</li><li>中文排版使用全角标点符号，英文排版使用半角标点符号。</li><li>专有名词注意大小写问题。</li><li>括号的用法：在括号内只有英文时用英文括号，并在括号前后加一个半角空格；在括号内有中文时用中文括号。</li><li>英文没有顿号，因此在英文和阿拉伯数字并列时用逗号，否则用顿号。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>竞赛图</title>
      <link href="/2022/06/20/jing-sai-tu/"/>
      <url>/2022/06/20/jing-sai-tu/</url>
      
        <content type="html"><![CDATA[<p>若竞赛图存在环，则一定存在三元环。</p><p>大小为$n$($n&gt;1$)的强连通块，大小为$[3,n]$的简单环均存在。</p><p>任意竞赛图都有哈密顿路径（经过每个点一次的路径，不要求回到出发点）。</p><p><strong>增量构造</strong>：对于第$i$个点，要么放在第一个，要么从后往前找到第一个满足$j\rightarrow i$的，然后插在$j$的后面。</p><p>竞赛图存在哈密顿回路的充要条件是强联通。</p><p>先构造哈密顿路径，然后构造哈密顿回路。</p><p>维护链$v_1,\dots,v_k,\dots,v_i$​，其中$v_k\rightarrowv_1$​，然后考虑扩展到节点$i+1$来扩大环：</p><ol><li>$v_{i+1}\rightarrow v_1$​，直接扩大</li><li>找到最小的$j$，满足$v_{i+1}\rightarrow v_{j} (j\le k)$，然后修改路径为$v_{i+1},v_j,\dots,v_k,v_1,\dots,v_{j-1},v_{k+1},\dots,v_i$</li><li>直接考虑下一个节点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">gao</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; npath;</span><br><span class="line">  <span class="comment">// 哈密顿路</span></span><br><span class="line">  npath.<span class="built_in">push_back</span>(path.<span class="built_in">front</span>());</span><br><span class="line">  <span class="type">int</span> sz = path.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;sz; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (G[path[i]][npath.<span class="built_in">front</span>()]) npath.<span class="built_in">insert</span>(npath.<span class="built_in">begin</span>(), path[i]);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j=(<span class="type">int</span>)npath.<span class="built_in">size</span>()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[npath[j]][path[i]]) &#123;</span><br><span class="line">          npath.<span class="built_in">insert</span>(npath.<span class="built_in">begin</span>()+j+<span class="number">1</span>, path[i]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 哈密顿回路</span></span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;sz; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (G[npath[i]][npath[<span class="number">0</span>]]) k = i;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=k; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[npath[i]][npath[j]]) &#123;</span><br><span class="line">          vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">          tmp.<span class="built_in">push_back</span>(npath[i]);</span><br><span class="line">          tmp.<span class="built_in">insert</span>(tmp.<span class="built_in">end</span>(), npath.<span class="built_in">begin</span>()+j, npath.<span class="built_in">begin</span>()+k+<span class="number">1</span>);</span><br><span class="line">          tmp.<span class="built_in">insert</span>(tmp.<span class="built_in">end</span>(), npath.<span class="built_in">begin</span>(), npath.<span class="built_in">begin</span>()+j);</span><br><span class="line">          tmp.<span class="built_in">insert</span>(tmp.<span class="built_in">end</span>(), npath.<span class="built_in">begin</span>()+k+<span class="number">1</span>, npath.<span class="built_in">begin</span>()+i);</span><br><span class="line">          tmp.<span class="built_in">insert</span>(tmp.<span class="built_in">end</span>(), npath.<span class="built_in">begin</span>()+i+<span class="number">1</span>, npath.<span class="built_in">end</span>());</span><br><span class="line">          <span class="built_in">swap</span>(tmp, npath);</span><br><span class="line">          k = i;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">swap</span>(path, npath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强连通缩点后呈链状，拓扑序小的点向所有拓扑序大的点连边（因此可以直接根据强连通分量判断任意两点间的可达性）。</p><p><strong>Dirac定理</strong>：$n$阶($n\ge3$)<strong>无向</strong>简单图，任意不相邻的两个顶点$v_i,v_j$​，均有$d(v_i)+d(v_j)\gen$，则存在哈密顿回路。</p><p>先不断从首尾扩展，得到极大的路径$s,v_1,\dots,v_k,t$，若$s$和$t$有边则得到回路，否则一定存在$s\rightarrowv_{i+1},t\rightarrowv_i$​（鸽巢原理），构造得到回路$s,v_{i+1},\dots,t,v_i,\dots,s$。如果该回路长度小于$n$，剩余点一定与回路中的某个点有边相连，从该处将环断开，然后重复扩展即可。</p><p>$n$阶($n\ge2$)<strong>无向</strong>简单图，任意不相邻的两个顶点$v_i,v_j$​，均有$d(v_i)+d(v_j)\gen-1$，则存在哈密顿通路。</p><p>$n$阶($n\ge3$)<strong>无向</strong>简单图，任意顶点$v_i$​，均有$d(v_i)\ge\frac{n}{2}$​，则存在哈密顿回路。</p><p><strong>兰道定理</strong>：将竞赛图的出度从小到大排序得到比分序列$s$，满足以下条件则合法：</p><p>$\forall 1\leq k \leq n,\sum \limits_{i=1}^k s_i \geq\binom{k}{2}$，且$k=n$时必须取等号。</p><p>先构造序列$a=(0,1,\dots,n-1)$，此时$a$的前缀小于$s$，后缀大于$s$（因为$a$和$s$的总和相同），然后找到第一个$a_l&lt;s_l$​，以及最后一个$a_u=a_l$​（为了保证修改后$a$仍然有序），再找到第一个$a_v&gt;s_v$​，则$a_u&lt;s_u\le s_v&lt;a_v$​，即$a_v\gea_u+2$，若$v\rightarrow u$，或$v\rightarrow p,p\rightarrowu$，就将相应边进行翻转，这样不断调整，最终$a=s$。</p><p>强连图竞赛图计数：$g_i=f_i-\sum_{j=1}^{i-1}\binom{i}{j}g_jf_{i-j}$​，即枚举拓扑序最小的强连通分量的大小。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oneTBB 并行编程框架</title>
      <link href="/2022/05/21/onetbb-bing-xing-bian-cheng-kuang-jia/"/>
      <url>/2022/05/21/onetbb-bing-xing-bian-cheng-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/oneapi-src/oneTBB.git</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>make过程中可能出现如下问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c++: fatal error: Killed signal terminated program cc1plus</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><p>原因就是内存太小了，减小并行度或者临时换页 （<a href="https://blog.csdn.net/weixin_44796670/article/details/121234446">参考</a>）</p><h3 id="计时"><a class="header-anchor" href="#计时">¶</a>计时</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">tick_count t0 = tick_count::<span class="built_in">now</span>();</span><br><span class="line">tick_count t1 = tick_count::<span class="built_in">now</span>();</span><br><span class="line"><span class="built_in">printf</span>(“work took %g seconds\n”,(t1-t0).<span class="built_in">seconds</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">std::cerr &lt;&lt; std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(end - start).<span class="built_in">count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>只记时一次，容易出现波动</p><p>使用<code>google benchmark</code>，可以跑多次求平均值</p><h3 id="控制运行的线程数"><a class="header-anchor" href="#控制运行的线程数">¶</a>控制运行的线程数</h3><p>Thread local storage：<code>thread_local</code>表明该变量的作用域是线程，每个线程都有一份拷贝。</p><p>对于TBB而言，你不知道任务和线程之间的对应关系。</p><p><code>enumerable_thread_specific</code>：provides thread local storage that acts like anSTL container with one element per thread. The container permits iteratingover the elements using the usual STL iteration idioms. Any thread can iterateover all the local copies, seeing the other threads localdata.（每个线程有一份拷贝，并且所有拷贝被组织成一个容器，可以顺序遍历容器来结合最终结果）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">ets_vector_t</span> = enumerable_thread_specific&lt;vector&lt;<span class="type">int</span>&gt;&gt;;</span><br><span class="line"><span class="function"><span class="type">ets_vector_t</span> <span class="title">partial</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="number">10</span>, [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="type">ets_vector_t</span>::reference local = partial.<span class="built_in">local</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span>&amp; x : local) x = <span class="number">20</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : partial)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j) sum[j] += it[j];</span><br></pre></td></tr></table></figure><p>用法就是包装一个tbb::enumerable_thread_specific，然后在内部使用local得到自己的那份拷贝，此外可以遍历整个容器，得到每一份拷贝。（如果该线程第一次调用local，就会创建一份，否则会使用自己已经创建的那份）</p><p>可以使用<code>size()</code>得到有几个拷贝，但是该容器只支持顺序遍历，不能随机访问(不支持<code>[]</code>)。所以如果指定线程想查看对方的私有拷贝，这是不行的，你既不知道它的下标，也没办法直接访问</p><p><code>combinable</code>：provides thread local storage for holding per-threadsubcomputations that will later be reduced to a single result. Each thread canonly see its local data or, after calling combine, the combined data.（用于存储中间结果，只能看到自己的数据）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">combinable&lt;vector&lt;<span class="type">int</span>&gt;&gt; partial&#123;[]()&#123;<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N); &#125;&#125;;</span><br><span class="line"><span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="number">10</span>, [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; local = partial.<span class="built_in">local</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(N)</span></span>;</span><br><span class="line">partial.<span class="built_in">combine_each</span>([&amp;](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) sum[i] += a[i];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>combinable需要传入一个lambda，在local中会调用，用于初始化。</p><p>通过combine_each将每份拷贝的结果合并起来。</p><p>note：个人感觉这两者差不多，combine_each其实就等价于顺序遍历拷贝构成的容器</p><hr><p>Task</p><p><code>parallel_invoke(f1,f2...)</code>（隐式的task spawning和barrier）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task_group g;</span><br><span class="line">g.<span class="built_in">run</span>(f1);</span><br><span class="line">g.<span class="built_in">run</span>(f2);</span><br><span class="line">...</span><br><span class="line">g.<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure><p><code>run_and_wait(f)</code>：we avoid the overhead of enqueueing-schedulingdequeuingsteps, and second, we avoid the potential stealing that can happen while thetask is in the queue.</p><p><code>cancel()</code></p><p>如果有大量任务，线性spawn不如递归spawn（满二叉的形式）</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parallel_for</span>(<span class="number">0</span>, n, [](<span class="type">int</span> i) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, n), [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; range r) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">parallel_reduce</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, n), init,  <span class="comment">// 规约</span></span><br><span class="line">  [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; range r, <span class="keyword">auto</span> pre) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  [&amp;](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="comment">// combine</span></span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">parallel_scan</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, n), init,  <span class="comment">// 前缀规约</span></span><br><span class="line">  [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; range r, <span class="keyword">auto</span> pre, <span class="type">bool</span> is_final_scan) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_final_scan) &#123;</span><br><span class="line">        <span class="comment">// write</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [&amp;](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="comment">// combine</span></span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>并行过滤：考虑对一个vector执行一个过滤条件。我目前认为最好的写法是先resize足够大的空间，然后通过一个atomic记录结果vector的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> local_base = res_size.<span class="built_in">fetch_add</span>(local_size);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; local_size; i++) res[local_base + i] = local_res[i];</span><br></pre></td></tr></table></figure><p>POD_vector(?)：上述情况中必须先resize，不能reserve，而resize的一个问题是会对所有元素做一遍memset，有时候这是很多余的，所以可以通过一些trick避免这个初始化的过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于调试的c++日志库-spdlog</title>
      <link href="/2022/05/20/yong-yu-diao-shi-de-cri-zhi-ku-spdlog/"/>
      <url>/2022/05/20/yong-yu-diao-shi-de-cri-zhi-ku-spdlog/</url>
      
        <content type="html"><![CDATA[<h3 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/gabime/spdlog.git</span><br></pre></td></tr></table></figure><p>header-only 所以直接include头文件即可，当然也可以install成静态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(xxx</span><br><span class="line">PRIVATE</span><br><span class="line">  spdlog/<span class="keyword">include</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>日志级别：info、warn、error、critical</p><p>mt后缀表示多线程（multi threaded），st后缀表示单线程</p><blockquote><p>spdlog takes the “include what you need” approach - your code should includethe features that actually needed.</p></blockquote><p>输出使用fmt库，类似python</p><p>编译器log过滤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_DEBUG</span></span><br><span class="line"></span><br><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::debug); <span class="comment">// or spdlog::set_level(spdlog::level::trace);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SPDLOG_LOGGER_TRACE</span>(file_logger , <span class="string">&quot;Some trace message that will not be evaluated.&#123;&#125; ,&#123;&#125;&quot;</span>, <span class="number">1</span>, <span class="number">3.23</span>);</span><br><span class="line"><span class="built_in">SPDLOG_LOGGER_DEBUG</span>(file_logger , <span class="string">&quot;Some Debug message that will be evaluated.. &#123;&#125; ,&#123;&#125;&quot;</span>, <span class="number">1</span>, <span class="number">3.23</span>);</span><br><span class="line"><span class="built_in">SPDLOG_DEBUG</span>(<span class="string">&quot;Some debug message to default logger that will be evaluated&quot;</span>);</span><br></pre></td></tr></table></figure><p>set level</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::info); <span class="comment">// Set global log level to info</span></span><br><span class="line">spdlog::<span class="built_in">debug</span>(<span class="string">&quot;This message should not be displayed!&quot;</span>);</span><br><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::trace); <span class="comment">// Set specific logger&#x27;s log level</span></span><br><span class="line">spdlog::<span class="built_in">debug</span>(<span class="string">&quot;This message should be displayed..&quot;</span>);</span><br><span class="line">```cpp</span><br><span class="line"></span><br><span class="line">backtrace</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// Backtrace support</span></span><br><span class="line"><span class="comment">// Loggers can store in a ring buffer all messages (including debug/trace) for later inspection.</span></span><br><span class="line"><span class="comment">// When needed, call dump_backtrace() to see what happened:</span></span><br><span class="line">spdlog::<span class="built_in">enable_backtrace</span>(<span class="number">10</span>); <span class="comment">// create ring buffer with capacity of 10 messages</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  spdlog::<span class="built_in">debug</span>(<span class="string">&quot;Backtrace message &#123;&#125;&quot;</span>, i); <span class="comment">// not logged..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// e.g. if some error happened:</span></span><br><span class="line">spdlog::<span class="built_in">dump_backtrace</span>(); <span class="comment">// log them now!</span></span><br></pre></td></tr></table></figure><p>shutdown</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release all spdlog resources, and drop all loggers in the registry.</span></span><br><span class="line"><span class="comment">// This is optional (only mandatory if using windows + async log).</span></span><br><span class="line">spdlog::<span class="built_in">shutdown</span>();</span><br></pre></td></tr></table></figure><h3 id="logger"><a class="header-anchor" href="#logger">¶</a>logger</h3><blockquote><p>Each logger contains a vector of one or more<code>std::shared_ptr&lt;spdlog::sink&gt;</code>.</p><p>On each log call (if the log level is right) the logger will call the<code>sink(log_msg)</code> function on each of them.</p></blockquote><p>spdlog会默认创建一个全局的logger（stdout、color、mt），直接使用<code>spdlog::info(..)</code>调用的就是该logger</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_default_logger</span>(some_other_logger);</span><br><span class="line">spdlog::<span class="built_in">info</span>(<span class="string">&quot;Use the new default logger&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> console = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;some_unique_name&quot;</span>); <span class="comment">// create logger</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> file_logger = spdlog::<span class="built_in">rotating_logger_mt</span>(<span class="string">&quot;file_logger&quot;</span>, <span class="string">&quot;logs/mylogfile&quot;</span>, <span class="number">1048576</span> * <span class="number">5</span>, <span class="number">3</span>); <span class="comment">// rotate 3个文件循环log</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_sink_mt&gt;();</span><br><span class="line"><span class="keyword">auto</span> my_logger= std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;mylogger&quot;</span>, sink); <span class="comment">// manually,不会register</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;spdlog::sink_ptr&gt; sinks;</span><br><span class="line">sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_sink_st&gt;());</span><br><span class="line">sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::daily_file_sink_st&gt;(<span class="string">&quot;logfile&quot;</span>, <span class="number">23</span>, <span class="number">59</span>));</span><br><span class="line"><span class="keyword">auto</span> combined_logger = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;name&quot;</span>, <span class="built_in">begin</span>(sinks), <span class="built_in">end</span>(sinks)); <span class="comment">// one log and multiple sink</span></span><br><span class="line"><span class="comment">//register it if you need to access it globally</span></span><br><span class="line">spdlog::<span class="built_in">register_logger</span>(combined_logger);</span><br></pre></td></tr></table></figure><h3 id="sink"><a class="header-anchor" href="#sink">¶</a>sink</h3><p>log和sink都分别由st和mt</p><p>logger的功能由sink决定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logger：</span><br><span class="line">spdlog::rotating_logger_mt</span><br><span class="line">spdlog::daily_logger_mt</span><br><span class="line">spdlog::basic_logger_mt</span><br><span class="line">spdlog::stdout_logger_mt</span><br><span class="line">spdlog::stderr_logger_st</span><br><span class="line">spdlog::stdout_color_mt</span><br><span class="line">spdlog::stderr_color_st</span><br><span class="line">-----------------------</span><br><span class="line">sink：</span><br><span class="line">example：spdlog::sinks::rotating_file_sink_mt</span><br></pre></td></tr></table></figure><h3 id="register"><a class="header-anchor" href="#register">¶</a>register</h3><blockquote><p>spdlog maintains a global (per process) registry of the created loggers.</p><p>The purpose is for loggers to be accessed easily from anywhere in theproject without passing them around.（避免参数传递）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">get</span>(<span class="string">&quot;logger_name&quot;</span>); <span class="comment">// 内部有lock，最好使用一个变量保存</span></span><br><span class="line">spdlog::<span class="built_in">register_logger</span>(some_logger);</span><br><span class="line">spdlog::<span class="built_in">drop</span>(<span class="string">&quot;logger_name&quot;</span>);</span><br><span class="line"><span class="comment">//or remove them all</span></span><br><span class="line">spdlog::<span class="built_in">drop_all</span>()</span><br></pre></td></tr></table></figure><h3 id="format"><a class="header-anchor" href="#format">¶</a>format</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_pattern</span>(<span class="string">&quot;*** [%H:%M:%S %z] [thread %t] %v ***&quot;</span>); <span class="comment">// global to all</span></span><br><span class="line">some_logger-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">some_logger-&gt;<span class="built_in">sinks</span>()[<span class="number">0</span>]-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google benchmark</title>
      <link href="/2022/05/07/google-benchmark/"/>
      <url>/2022/05/07/google-benchmark/</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/google/benchmark.git</span><br><span class="line"><span class="built_in">cd</span> benchmark</span><br><span class="line">cmake -E make_directory <span class="string">&quot;build&quot;</span></span><br><span class="line">cmake -E <span class="built_in">chdir</span> <span class="string">&quot;build&quot;</span> cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES=on -DCMAKE_BUILD_TYPE=Release ../</span><br><span class="line">cmake --build <span class="string">&quot;build&quot;</span> --config Release</span><br><span class="line"></span><br><span class="line">cmake -E <span class="built_in">chdir</span> <span class="string">&quot;build&quot;</span> ctest --build-config Release</span><br><span class="line"></span><br><span class="line">sudo cmake --build <span class="string">&quot;build&quot;</span> --config Release --target install</span><br></pre></td></tr></table></figure><h3 id="cmake"><a class="header-anchor" href="#cmake">¶</a>cmake</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(benchmark REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(xxx</span><br><span class="line">PRIVATE</span><br><span class="line">  benchmark::benchmark</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeFunction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">max</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BM_SomeFunction</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123; <span class="comment">// a wrapper</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">    <span class="built_in">SumeFunction</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_SomeFunction);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK_MAIN</span>();</span><br></pre></td></tr></table></figure><p>也可以自己定义main函数，只需要在最后加上以下两行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::benchmark::<span class="built_in">Initialize</span>(&amp;argc, argv);</span><br><span class="line">::benchmark::<span class="built_in">RunSpecifiedBenchmarks</span>();</span><br></pre></td></tr></table></figure><p>官方对整型变量的支持比较好，有各种range的传参方式。如果需要传入其他变量，需要使用CAPTURE，传参方式类似emplace_back之类的Iterations可以指定迭代次数Unit指定时间单位（默认是ns）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BENCHMARK_CAPTURE</span>(BM_xxx, xxx_test, arg)</span><br><span class="line">  -&gt;<span class="built_in">Iterations</span>(<span class="number">5</span>)</span><br><span class="line">  -&gt;<span class="built_in">Unit</span>(benchmark::kMillisecond);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>固定区间最值查询</title>
      <link href="/2021/09/28/gu-ding-qu-jian-zui-zhi-cha-xun/"/>
      <url>/2021/09/28/gu-ding-qu-jian-zui-zhi-cha-xun/</url>
      
        <content type="html"><![CDATA[<p>对于一维，用单调队列就可以解决。二维的话，先对每一列做一遍，然后压缩成一维更高维同理。。。</p><p>这里主要记录一下前k优最值的记录例如现在要求固定区间的最小值和次小值。我们只需要维护两个单增队列。每当移动r指针，先维护第一个队列的单调性，弹出的元素塞到第二个队列中。那么次大值就是第一个栈中的次大值或者第二个栈中的最大值。</p><p>另外可以采用双栈模拟队列的方式，栈中存的是pair(当前元素大小，栈底到当前元素的最小值)。同理对于k小值只要修改second为k维的tuple即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>析合树（permutation tree）</title>
      <link href="/2021/09/13/xi-he-shu-permutation-tree/"/>
      <url>/2021/09/13/xi-he-shu-permutation-tree/</url>
      
        <content type="html"><![CDATA[<p>仅限于解决<strong>排列</strong>中与连续段相关的问题，局限性比较大，虽然平凡序列也能做，但是会复杂很多一些定义：段：该区间排序后值域连续本原段：与其它连续段只有包含和相离的关系，没有相交关系儿子排列：各个儿子离散化后的编号形成的排列合点：儿子排列为顺序或逆序（叶子也认为是合点）析点：不是合点的节点</p><ul><li>合点的儿子序列的任意子区间都是一个连续段</li><li>析点的儿子序列的任意长度大于1的子区间都不是连续段（否则该区间就是一个本原段）</li></ul><p>析合树就是由若干本原段构成，且每个本原段是合点和析点中的一种。增量构造$O(n\log n)$，维护前$i$个结点的栈，然后考虑当前结点$P_i$​</p><ol><li>栈顶为合点且可以成为它的儿子</li><li>栈的某个后缀可以生成一个合点作为父亲</li><li>栈的某个后缀可以生成一个析点作为父亲</li></ol><p>最主要的一个辅助工具是快速查询$[j,i]$这个区间是否是连续段，由于是排列，所以只需要检查$Q_j=\max\limits_{i\lek\le j}P_k-\min\limits_{i\le k\le j}P_k-(i-j)=0$，又注意到$Q_j\ge 0$，因此用单调栈和线段树维护$Q$，值为0的点就可以作为连续段的左端点。</p><p>代码解释：节点数要开两倍$id_i$​：表示排列中第$i$个数在析合树中的编号$L_i,R_i$​：编号为$i$的点在排列中对应的下标范围$SR_i$​：编号为$i$的点当前最靠右（最后加入）的儿子的$L$$type_i$​：编号为$i$的点的类型，1表示合点，0表示析点$rt$：析合树的根节点$cnt$：析合树的节点数$askmn$：单点查询一个点的$Q$，用于检查是否为连续段$askpos$：找到最靠左的可以与当前右端点构成连续段下标对于当前点$i$，先维护好$Q$序列</p><ol><li>如果能与栈顶最右的儿子形成连续段就作为它的儿子（此时栈顶必然是合点，因为析点不可能有子区间是连续段）</li><li>如果能与栈顶构成连续段，则生成一个合点</li><li>否则如果某个后缀是连续段，就生成一个析点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ptree &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = N&lt;&lt;<span class="number">1</span>, LOG = <span class="number">17</span>;</span><br><span class="line"><span class="type">int</span> id[M], L[M], R[M], SR[M], type[M], rt, cnt;</span><br><span class="line"><span class="type">int</span> stk[M], stk1[M], stk2[M], tp, tp1, tp2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; G[x].<span class="built_in">push_back</span>(y); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(tp1 &amp;&amp; a[i]&lt;=a[stk1[tp1]]) &#123;</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>, stk1[tp1<span class="number">-1</span>]+<span class="number">1</span>, stk1[tp1], a[stk1[tp1]]);</span><br><span class="line">      --tp1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>, stk1[tp1]+<span class="number">1</span>, i, -a[i]);</span><br><span class="line">    stk1[++tp1] = i;</span><br><span class="line">    <span class="keyword">while</span>(tp2 &amp;&amp; a[i]&gt;=a[stk2[tp2]]) &#123;</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>, stk2[tp2<span class="number">-1</span>]+<span class="number">1</span>, stk2[tp2], -a[stk2[tp2]]);</span><br><span class="line">      --tp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>, stk2[tp2]+<span class="number">1</span>, i, a[i]);</span><br><span class="line">    stk2[++tp2] = i;</span><br><span class="line">    id[i] = ++cnt;</span><br><span class="line">    L[cnt] = R[cnt] = i;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">askpos</span>(<span class="number">1</span>), now = cnt;</span><br><span class="line">    <span class="keyword">while</span>(tp &amp;&amp; L[stk[tp]]&gt;=pos) &#123;</span><br><span class="line">      <span class="keyword">if</span>(type[stk[tp]] &amp;&amp; <span class="built_in">askmn</span>(<span class="number">1</span>, SR[stk[tp]])==<span class="number">0</span>) &#123;</span><br><span class="line">        R[stk[tp]] = i, SR[stk[tp]] = L[now], <span class="built_in">add</span>(stk[tp], now), now = stk[tp--];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">askmn</span>(<span class="number">1</span>, L[stk[tp]])==<span class="number">0</span>) &#123;</span><br><span class="line">        type[++cnt] = <span class="number">1</span>;</span><br><span class="line">        L[cnt] = L[stk[tp]], R[cnt] = i, SR[cnt] = L[now];</span><br><span class="line">        <span class="built_in">add</span>(cnt, stk[tp--]), <span class="built_in">add</span>(cnt, now);</span><br><span class="line">        now = cnt;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">add</span>(++cnt, now);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="built_in">add</span>(cnt, stk[tp--]);</span><br><span class="line">        &#125; <span class="keyword">while</span>(tp &amp;&amp; <span class="built_in">askmn</span>(<span class="number">1</span>, L[stk[tp]])!=<span class="number">0</span>);</span><br><span class="line">        L[cnt] = L[stk[tp]], R[cnt] = i, <span class="built_in">add</span>(cnt, stk[tp--]);</span><br><span class="line">        now = cnt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++tp] = now;</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  rt = stk[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//namespace Ptree</span></span><br></pre></td></tr></table></figure><ul><li><p>Codeforces 526F – Pudding Monsters查询一个排列的连续段个数，显然只需要完成Q序列的维护即可</p></li><li><p>CERC 17 Problem I – Instrinsic Interval给出一个排列，每次查询给出$l,r$，问你最短的包含该区间的连续段的左右端点我们先求出LCA，如果是析点，说明答案只能是LCA的左右端点；否则可以在儿子序列中找到一个最小的包含$l,r$的子区间，实质上利用倍增跳到LCA的儿子即可</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu 6356 反向ST表/线段树剪枝</title>
      <link href="/2021/09/07/hdu-6536-fan-xiang-st-biao-xian-duan-shu-jian-zhi/"/>
      <url>/2021/09/07/hdu-6536-fan-xiang-st-biao-xian-duan-shu-jian-zhi/</url>
      
        <content type="html"><![CDATA[<p>给出m次区间取max的操作<code>(l,r,v)</code>，问你最后数组的状态(初始均为0)，操作通过随机的方式给出。</p><p>区间取max，可以用sgbt来做，不过注意到本题操作随机(既然是随机给出的，必然有它的用意)，所以可以用剪枝的方式：维护区间最大值和最小值，当前最大值比v还小就是区间覆盖，最小值比v还大就直接reutrn。</p><p>此外还有一种反向ST表的操作，我们可以先得到高层ST表的状态，然后再从高到低递推出底层的状态即可。当然这种方式有很大的限制，感觉只适用于区间取最值，只有最后一次询问的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">uint x, y, z, w;</span><br><span class="line"><span class="function">uint <span class="title">rng61</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = x^(x&lt;&lt;<span class="number">11</span>);</span><br><span class="line">  x = x^(x&gt;&gt;<span class="number">4</span>);</span><br><span class="line">  x = x^(x&lt;&lt;<span class="number">5</span>);</span><br><span class="line">  x = x^(x&gt;&gt;<span class="number">14</span>);</span><br><span class="line">  w = x^(y^z);</span><br><span class="line">  x = y;</span><br><span class="line">  y = z;</span><br><span class="line">  z = w;</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">if</span>(x&lt;y) x = y; &#125;</span><br><span class="line"><span class="type">int</span> st[N][<span class="number">18</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%u%u%u&quot;</span>, &amp;n, &amp;m, &amp;x, &amp;y, &amp;z);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n; j++) st[i][j] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">    uint f0 = <span class="built_in">rng61</span>(), f1 = <span class="built_in">rng61</span>(), f2 = <span class="built_in">rng61</span>();</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">min</span>(f0%n+<span class="number">1</span>, f1%n+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">max</span>(f0%n+<span class="number">1</span>, f1%n+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> v = f2%(<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">31</span> - __builtin_clz(r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Max</span>(st[l][k], v);</span><br><span class="line">    <span class="built_in">Max</span>(st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k], v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">16</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;(j+<span class="number">1</span>))<span class="number">-1</span>&lt;=n; i++) &#123;</span><br><span class="line">      <span class="built_in">Max</span>(st[i][j], st[i][j+<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">Max</span>(st[i+(<span class="number">1</span>&lt;&lt;j)][j], st[i][j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) ans ^= <span class="number">1ll</span>*i*st[i][<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj2724 蒲公英 区间众数+强制在线</title>
      <link href="/2021/09/03/bzoj2724-pu-gong-ying-qu-jian-zhong-shu-qiang-zhi-zai-xian/"/>
      <url>/2021/09/03/bzoj2724-pu-gong-ying-qu-jian-zhong-shu-qiang-zhi-zai-xian/</url>
      
        <content type="html"><![CDATA[<p>可以离线的话怎么做？首先想到的肯定是莫队，不过删除操作有点棘手。目前只有两个想法：1.无脑上回滚莫队。2.再加一个分块来维护出现次数，移动O(1)，查询$O(\sqrtn)$。不过感觉都没有在线简单</p><p>分块之后，如果维护的信息可以递推，我们可以很方便的维护出任意两个块之间的信息。本题就是任意两个块之间的众数，这是很容易的，而且是$O(\frac{N^2}{B})$的。可以发现答案肯定要么是上面这个，要么是两个边缘块中出现的数字。所以我们只需要枚举边缘块的数字来进行更新即可。一种显然的想法就是对每个数字进行二分来求解出现次数，这样是$O(MB\logN)$的，需要对B进行权衡。另外一种很妙的思路，考虑到两个边缘块对答案的贡献最多是$2B$，那我直接O(1)去check贡献能不能再+1，这样就是$O(MB)$的了(注：M是询问次数，N是数字个数，B是块大小，根据均值不等式使两个复杂度相等，选择最优的B即可，当然具体实现时只要大致估计一个常数即可)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e4</span> + <span class="number">5</span>, B = <span class="number">250</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], v[N], tot;</span><br><span class="line"><span class="type">int</span> f[B][B], g[B][B], cnt[N];</span><br><span class="line"><span class="type">int</span> blo, num, bl[N], l[B], r[B], pos[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lsh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> tmp[N];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) tmp[i] = a[i];</span><br><span class="line">  <span class="built_in">sort</span>(tmp+<span class="number">1</span>, tmp+n+<span class="number">1</span>);</span><br><span class="line">  tot = <span class="built_in">unique</span>(tmp+<span class="number">1</span>, tmp+n+<span class="number">1</span>) - tmp - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> pre = a[i];</span><br><span class="line">    a[i] = <span class="built_in">lower_bound</span>(tmp+<span class="number">1</span>, tmp+tot+<span class="number">1</span>, a[i]) - tmp;</span><br><span class="line">    v[a[i]] = pre;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; i++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y=x; y&lt;=num; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l[y]; i&lt;=r[y]; i++) &#123;</span><br><span class="line">      <span class="type">int</span> cur = a[i];</span><br><span class="line">      cnt[cur]++;</span><br><span class="line">      <span class="keyword">if</span>(!res || cnt[cur]&gt;cnt[res] || (cnt[cur]==cnt[res] &amp;&amp; cur&lt;res)) &#123;</span><br><span class="line">        res = cur;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][y] = res;</span><br><span class="line">    g[x][y] = cnt[res];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  blo = <span class="built_in">sqrt</span>(n);</span><br><span class="line">  num = (n+blo<span class="number">-1</span>)/blo;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) bl[i] = (i<span class="number">-1</span>)/blo + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=num; i++) l[i] = (i<span class="number">-1</span>)*blo + <span class="number">1</span>, r[i] = i*blo;</span><br><span class="line">  r[num] = n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=num; i++) <span class="built_in">build</span>(i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    p[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    pos[i] = (<span class="type">int</span>)p[a[i]].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(bl[x]+<span class="number">1</span>&lt;=bl[y]<span class="number">-1</span>) res = f[bl[x]+<span class="number">1</span>][bl[y]<span class="number">-1</span>], cnt = g[bl[x]+<span class="number">1</span>][bl[y]<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=<span class="built_in">min</span>(r[bl[x]], y); i++) &#123;</span><br><span class="line">    <span class="type">int</span> nxt = (a[i]&lt;res ? cnt : cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(pos[i]+nxt<span class="number">-1</span>&lt;(<span class="type">int</span>)p[a[i]].<span class="built_in">size</span>() &amp;&amp; p[a[i]][pos[i]+nxt<span class="number">-1</span>]&lt;=y) &#123;</span><br><span class="line">      res = a[i];</span><br><span class="line">      cnt = nxt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(bl[x]!=bl[y]) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l[bl[y]]; i&lt;=y; i++) &#123;</span><br><span class="line">      <span class="type">int</span> nxt = (a[i]&lt;res ? cnt : cnt+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span>(pos[i]-nxt+<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; p[a[i]][pos[i]-nxt+<span class="number">1</span>]&gt;=x) &#123;</span><br><span class="line">        res = a[i];</span><br><span class="line">        cnt = nxt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="built_in">lsh</span>();</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> lstans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    l = (l + lstans - <span class="number">1</span>)%n + <span class="number">1</span>, r = (r + lstans - <span class="number">1</span>)%n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="built_in">swap</span>(l, r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lstans = v[<span class="built_in">qry</span>(l, r)]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一下各种软件的配置</title>
      <link href="/2021/08/29/ji-lu-yi-xia-ge-chong-ruan-jian-de-pei-zhi/"/>
      <url>/2021/08/29/ji-lu-yi-xia-ge-chong-ruan-jian-de-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>为了方便管理，统一放到D:\environment目录下</p><h2 id="MinGW"><a class="header-anchor" href="#MinGW">¶</a>MinGW</h2><p><a href="https://www.jianshu.com/p/ee1ccb0a3062">https://www.jianshu.com/p/ee1ccb0a3062</a> 照这个做即可gcc/g++ 8.1.0</p><h2 id="Clang以及Clangd"><a class="header-anchor" href="#Clang以及Clangd">¶</a>Clang以及Clangd</h2><p><a href="https://www.cnblogs.com/FrankOu/p/14215850.html">https://www.cnblogs.com/FrankOu/p/14215850.html</a></p><h2 id="sublime-text"><a class="header-anchor" href="#sublime-text">¶</a>sublime text</h2><p>sublime的配色我比较喜欢，而且很轻量，用于写一些算法竞赛题和一些简单的python、shell脚本官网有最新的4版本fontsize改成10.5左右比较舒服ctrl+x 删除当前行<a href="https://blog.csdn.net/qq_39599067/article/details/81270330">https://blog.csdn.net/qq_39599067/article/details/81270330</a> 代码片段配置<a href="https://jingyan.baidu.com/article/cb5d6105ae0c44005c2fe0f1.html">https://jingyan.baidu.com/article/cb5d6105ae0c44005c2fe0f1.html</a> 括号高亮<a href="https://blog.csdn.net/qq_43816826/article/details/108406114">https://blog.csdn.net/qq_43816826/article/details/108406114</a> repl python快捷键配置<a href="https://segmentfault.com/a/1190000004463984">https://segmentfault.com/a/1190000004463984</a> AdvancedNewFilec++17 build system似乎在c++17中bits/stdc++.h有点问题？（当然linux下没问题），所以还是用c++14吧，懒得折腾了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;g++&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-Wall&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-std=c++17&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file_regex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;working_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;file_path&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;selector&quot;</span><span class="punctuation">:</span> <span class="string">&quot;source.c, source.c++&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span><span class="string">&quot;cp936&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;variants&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RunInCommand&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;cmd&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/c&quot;</span><span class="punctuation">,</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-Wall&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-std=c++17&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;&amp;&amp;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;start&quot;</span><span class="punctuation">,</span> <span class="string">&quot;cmd&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/c&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125; &amp; echo.&amp;pause&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>file icon插件：美化作用trailingspace：检测行末多余空格sublimelinter：静态检查sublimelinter-clangclang-format：格式化lsp：language server port</p><h2 id="typora"><a class="header-anchor" href="#typora">¶</a>typora</h2><p>写markdown直接下载即可</p><h2 id="Adobe-Acrobat"><a class="header-anchor" href="#Adobe-Acrobat">¶</a>Adobe Acrobat</h2><p>pdf reader</p><h2 id="Velocity"><a class="header-anchor" href="#Velocity">¶</a>Velocity</h2><p>离线文档</p><h2 id="DeepL"><a class="header-anchor" href="#DeepL">¶</a>DeepL</h2><p>翻译ctrl+q</p><h2 id="CopyQ"><a class="header-anchor" href="#CopyQ">¶</a>CopyQ</h2><p>剪贴板ctrl+shift+q：去除换行符</p><h2 id="vscode"><a class="header-anchor" href="#vscode">¶</a>vscode</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021中国大学生程序设计竞赛（CCPC）- 网络选拔赛</title>
      <link href="/2021/08/28/2021-zhong-guo-da-xue-sheng-cheng-xu-she-ji-jing-sai-ccpc-wang-luo-xuan-ba-sai/"/>
      <url>/2021/08/28/2021-zhong-guo-da-xue-sheng-cheng-xu-she-ji-jing-sai-ccpc-wang-luo-xuan-ba-sai/</url>
      
        <content type="html"><![CDATA[<p>hdu的服务器有点问题，体验比较差感觉打的中规中矩，不过能排到前50还是比较惊讶，估计受题目风格以及服务器问题的影响。（看来大部分队伍受网络的影响挺大的，而且听说有多道疑似原题，要重赛了，不过也无所谓）</p><h2 id="1001"><a class="header-anchor" href="#1001">¶</a>1001</h2><p>简单的分类讨论，解不等式即可</p><h2 id="1002"><a class="header-anchor" href="#1002">¶</a>1002</h2><p>队友过的，暴力</p><h2 id="1006"><a class="header-anchor" href="#1006">¶</a>1006</h2><p>构造题，发现$x^2+(x+3)^2-(x+1)^2-(x+2)^2=4$后，根据模4的值分别构造即可</p><h2 id="1007"><a class="header-anchor" href="#1007">¶</a>1007</h2><p>枚举$g(x)$，转成二次函数，剩下的就是二分加取整的琐碎问题</p><h2 id="1008"><a class="header-anchor" href="#1008">¶</a>1008</h2><p>我先想了一个看上去很可行的解法，不过最后统计答案复杂度会炸最后队友给出正解，考虑求解$v(l,r)\leqx$的区间个数，从大到小枚举gcd，然后抠出所有gcd的倍数，考虑相邻两个数形成的区间$[L,R]$，则以$[1,L]$中的点为左端点时，右端点必须满足小于R，才有可能使得$v(l,r)\lex$，然后就是一个前缀取min，整体求sum的segment beats了。（事实上由于维护的序列是单调的，也可以二分+区间覆盖来做，<s>然而我写T了</s> ，可能是我写挂了，也可能是卡了3log，而sgbt更趋近于单个log，看了题解，直接在线段树上二分就行了，我在外面套个二分是该t）</p><h2 id="1009"><a class="header-anchor" href="#1009">¶</a>1009</h2><p>前缀和+map 类似于求多少个子区间的和为0，只不过扩展成二维的了</p><h2 id="1011"><a class="header-anchor" href="#1011">¶</a>1011</h2><p>队友过的，没参与</p><h2 id="1012"><a class="header-anchor" href="#1012">¶</a>1012</h2><p>考虑dp来求解，当求解完$dp_x$​，枚举所有$p \midx$，让$[dp_{x+1},dp_{x+p-1}]$与$dp_x+1$取min即可。容易发现只要对每个x，考虑在质数集中<strong>最大</strong>的x的因子即可，又容易发现这个$dp$是单增的，所以不断维护当前覆盖到的最大右端点即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在debian8上使用支持c++17的g++版本</title>
      <link href="/2021/06/22/zai-debian8-shang-shi-yong-zhi-chi-c17-de-gban-ben/"/>
      <url>/2021/06/22/zai-debian8-shang-shi-yong-zhi-chi-c17-de-gban-ben/</url>
      
        <content type="html"><![CDATA[<p>最近调试编译器遇到一个比较矛盾的事情。cpp文件通过我的compiler转成arm汇编，然后通过qemu-arm的debian虚拟机上的g++将arm文件汇编、链接后转成可执行文件就可以跑结果了。然而我的compiler用了一些c++17的特性（optional、stringview），debian8最新只有g++4.9.2，没法支持c++17。我只能在本地转成arm汇编再传上去测试，效率太低。我想把两个过程都放到debian上，然后写个脚本一键测试。于是有两种选择</p><ul><li>把代码的c++17相关删了🤡</li><li>让虚拟机支持-std=c++17</li></ul><p>显然还是要努力试一下后者。看了一下debian9有g++6，debian10有g++8。我一开始以为要把整个系统都升级，结果大半夜跑了2个小时还没完，等不了就ctrl+c了，然后发现虚拟机坏了，gg。第二天重下了虚拟机，重新来过。尝试了一下直接装debian10的g++到debian8上。具体做法就是在镜像源里加了buster，（8的别名是jessie，9的别名是stretch，10的别名是buster）。然后apt-get update，apt-get install g++，它会自动帮你把各种依赖都安装升级。<a data-fancybox="gallery" data-src="/post-images/1624337438397.png" data-caption=""><img src="/post-images/1624337438397.png" alt=""></a>然后就能愉快的跑了<a data-fancybox="gallery" data-src="/post-images/1624337477434.png" data-caption=""><img src="/post-images/1624337477434.png" alt=""></a><a data-fancybox="gallery" data-src="/post-images/1624337482828.png" data-caption=""><img src="/post-images/1624337482828.png" alt=""></a>最后记得apt-get autoremove清理下旧版本</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsl</title>
      <link href="/2021/04/09/wsl/"/>
      <url>/2021/04/09/wsl/</url>
      
        <content type="html"><![CDATA[<p>WSL和VMware之间切换需要在PowerShell中输入以下命令并重启（需要管理员权限）</p><p>但其实Wsl和VMware是可以共存的，只是VMware会慢一些（我实际使用没有明显感觉）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off/auto</span><br></pre></td></tr></table></figure><p>WSL位于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\这里是你自己的user的名字\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\rootfs</span><br></pre></td></tr></table></figure><p>通过以下方式可以将WSL从C盘移动到D盘<br><a href="https://blog.csdn.net/w851685279/article/details/108904106?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/w851685279/article/details/108904106?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242</a></p><p>WSL会使用Windows中以vhdx为后缀的虚拟磁盘文件，它会自动扩容，但是不会缩容。<br>所以在WSL中删除文件，Windows上的磁盘大小不会变，此时只能进行手动压缩。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br><span class="line">diskpart</span><br><span class="line"><span class="keyword">select</span> vdisk file=<span class="string">&quot;D:\wsl-ubuntu22.04\ext4.vhdx&quot;</span></span><br><span class="line">compact vdisk</span><br><span class="line">detach vdisk</span><br></pre></td></tr></table></figure><p>WSL的时间经常会不准，可以用<code>sudo ntpdate pool.ntp.org</code>校准。</p><p>Windows更新到23H2后启动WSL会出现”wsl: 检测到 localhost 代理配置，但未镜像到 WSL 。NAT 模式下的 WSL 不支持 localhost 代理。”的报错，<br>解决方案如下：</p><p>在C:\Users\xxx.wslconfig中添加：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual  # gradual  | dropcache | disabled</span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=true</span><br><span class="line">firewall=true</span><br><span class="line">autoProxy=true</span><br></pre></td></tr></table></figure><p>然后<code>wsl --shutdown</code>重启即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环</title>
      <link href="/2021/03/28/yue-se-fu-huan/"/>
      <url>/2021/03/28/yue-se-fu-huan/</url>
      
        <content type="html"><![CDATA[<p>n个人（编号从0开始），从1开始依次报数，报到k的那个人退出，并继续循环报数，问最后剩下的人的编号这个问题还是要从递归的角度去考虑设$f_{n-1}$​表示n个人时最后剩下的那个人那么对于n个人的情况，第一个出局的人是k-1，之后就相当于是从k开始的n-1个人的约瑟夫环问题所以很容易得到递推式$f_n = (f_{n-1} + k)%n$同样的如果要求第m个出局的人，也可以用上述公式$f_{n,m}=(f_{n-1,m-1}+k)%n$对于$k \ll n$的情况，考虑$f_{i+x-1}=(f_{i-1}+x*k)%(i+x-1)$，当$f_{i-1}+x*k\leq i+x-1$时不会取模，所以快速递推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">J</span><span class="params">(ll n, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  ll ans = <span class="number">0</span>, i = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">  &#123;</span><br><span class="line">    ll cnt = (i-ans<span class="number">-2</span>)/(k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!cnt)</span><br><span class="line">    &#123;</span><br><span class="line">      ans = (ans + k)%i;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(i+cnt&gt;n)</span><br><span class="line">      &#123;</span><br><span class="line">        ans = (ans + k*(n-i+<span class="number">1</span>))%n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        i += cnt;</span><br><span class="line">        ans = (ans + k*cnt)%i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外对于k=2的特殊情况，可以考虑当n为2的幂次的时候答案就是1，所以当n为$2^x+y$的形式时，答案为$2*y+1$</p><p>求第x个人是第几个死的（0下标）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n, ll k, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n)</span><br><span class="line">  &#123;</span><br><span class="line">    x = (x+n)%n;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n) x += (k-x<span class="number">-1</span>+n<span class="number">-1</span>)/n*n;</span><br><span class="line">    <span class="keyword">if</span>((x+<span class="number">1</span>)%k==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ans += (x+<span class="number">1</span>)/k;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(k&gt;n)</span><br><span class="line">      &#123;</span><br><span class="line">        ans += x/k;</span><br><span class="line">        ll tmp = x;</span><br><span class="line">        x = x-(x/n+<span class="number">1</span>)*(x/k)+(x+n)/n*n-k;</span><br><span class="line">        n -= tmp/k;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ans += n/k;</span><br><span class="line">        x = x-x/k;</span><br><span class="line">        x += n-n/k*k;</span><br><span class="line">        n -= n/k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-k bfs</title>
      <link href="/2021/03/24/1-k-bfs/"/>
      <url>/2021/03/24/1-k-bfs/</url>
      
        <content type="html"><![CDATA[<p>考虑一个单源最短路径问题，但是图的边权范围是1-k，k不大，那就可以用以下方法本质上在一个队列中同时最多只有k+1种不同的dis的取值，因此只需要用k+1个队列来维护即可，当前队列为空时，就循环移位找到下一个非空的队列即可复杂度为$O(nk+m)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q[K+<span class="number">1</span>];</span><br><span class="line">q[<span class="number">0</span>].<span class="built_in">push</span>(s);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>, inq = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(inq&gt;<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span>(q[idx].<span class="built_in">empty</span>()) idx = (idx+<span class="number">1</span>)%(k+<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> u = q[idx].<span class="built_in">front</span>(); q[dx].<span class="built_in">pop</span>();</span><br><span class="line">  inq--;</span><br><span class="line">  <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u]) &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(d[v]&gt;d[u]+w) &#123;</span><br><span class="line">      d[v] = d[u] + w;</span><br><span class="line">      q[d[v]%(k+<span class="number">1</span>)].<span class="built_in">push</span>(v);</span><br><span class="line">      ++inq;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拟阵</title>
      <link href="/2021/03/22/ni-zhen/"/>
      <url>/2021/03/22/ni-zhen/</url>
      
        <content type="html"><![CDATA[<p>$M(S,I)$表示一个拟阵，其中I是S的某些子集的集合，满足这些子集在某种定义下是独立的一个拟阵M需要满足如下三个性质：</p><ul><li>空集属于I</li><li>若集合A属于I，则A的任意一个子集也属于I（遗传性）</li><li>若集合A属于I，任意一个size大于A的属于I的集合B中总能找到元素加入A，使其仍在I中（交换性）</li></ul><p>满足以上定义的最好的解释例子就是线性无关向量组。基：最大独立集，即I中size最大的那个子集环：最小的非独立集，去掉任意元素后就是一个独立集</p><p>典型的拟阵：</p><ul><li>uniform matroid：size$\leq k$的子集</li><li>linear matroid：线性无关的子集</li><li>colorful matroid：每个元素有一种颜色，如果一个集合中所有元素颜色各不相同就独立</li><li>graphic matroid：每个元素是一条边，一个集合中的边没有环就独立</li><li>上一个拟阵的对偶拟阵：对于一个集合，保留在S中且不在该集合中的所有边后，整个图连通则独立。注：必须是删边，如果是考虑集合中的边连通的话，显然不满足遗传性。</li></ul><p>拟阵交考虑现在有两个拟阵（其中的一个独立集本质上就代表着满足了某种约束的集合），那么我们要求同时满足这两个拟阵的约束条件下的最大独立集，这时候就要用到拟阵交了。该算法的流程是不断维护当前的共同独立集I，然后尝试加入一个新的元素s：定义一种交换图，对于任意两个元素x，y，若满足$x\in I, y \notinI,I-\{x\}+\{y\}\in{I_1}$​，就从x向y连一条有向边；若满足$x\in I, y\notin I,I-\{x\}+\{y\}\in{I_2}$​，就从y向x连一条有向边。简单说来就是如果把I中的某个元素x替换成没有选的某个元素y后，如果该独立集符合$I_1$​的定义，就加一条$x\rightarrowy$的边，如果符合$I_2$​的定义，就加一条$x \leftarrow y$的边。对于所有不在I中的元素x，若$I+\{x\}\in I_1$​，则源点S向其连边对于所有不在I中的元素x，若$I+\{x\}\in I_2$​，则其向汇点T连边然后从S向T跑一遍<strong>最短路</strong>，如果有这样的路径就把路径上的所有元素的状态取反（对称差）上述过程称为一次增广不断进行增广操作就可以得到最大独立集了复杂度为$O(r^2n(C_1+C_2))$，其中r为秩，$C_1$​和$C_2$​分别表示M1和M2检查当前集合是否为独立集的调用次数再考虑如果每个元素是带权的话，其实也很简单，如果一个元素当前在I，就把它的权值定为$-w$，否则定为$w$，然后跑最长路就可以得到最大权独立集了。上述算法的一个瓶颈其实是在检查是否为独立集上，这点一定要仔细实现。要支持加入一个元素判断是否还是独立集，删除一个元素并加入一个元素判断是否是独立集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">aug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> S = n, T = n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(in[i])</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) <span class="keyword">if</span>(!in[j])</span><br><span class="line">    &#123;</span><br><span class="line">      in[i] = <span class="number">0</span>, in[j] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(m1.<span class="built_in">check</span>(in)) G[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">      <span class="keyword">if</span>(m2.<span class="built_in">check</span>(in)) G[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">      in[i] = <span class="number">1</span>, in[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(!in[i])</span><br><span class="line">  &#123;</span><br><span class="line">    in[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m1.<span class="built_in">check</span>(in)) G[S].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(m2.<span class="built_in">check</span>(in)) G[i].<span class="built_in">push_back</span>(T);</span><br><span class="line">    in[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n+<span class="number">2</span>, -inf)</span>, <span class="title">pre</span><span class="params">(n+<span class="number">2</span>)</span>, <span class="title">inq</span><span class="params">(n+<span class="number">2</span>)</span></span>;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(S), dis[S] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    inq[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;n) cost = in[u] ? -w[u] : w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(dis[v]&lt;dis[u]+cost)</span><br><span class="line">      &#123;</span><br><span class="line">        dis[v] = dis[u] + cost;</span><br><span class="line">        pre[v] = u;</span><br><span class="line">        <span class="keyword">if</span>(!inq[v]) q.<span class="built_in">push</span>(v), inq[v] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pre[T]==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x=pre[T]; x!=S; x=pre[x]) in[x] ^= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n个数，每个数可以任意+1,-1</title>
      <link href="/2021/03/18/n-ge-shu-mei-ge-shu-ke-yi-ren-yi-1-1/"/>
      <url>/2021/03/18/n-ge-shu-mei-ge-shu-ke-yi-ren-yi-1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="变成非降序列的最小代价"><a class="header-anchor" href="#变成非降序列的最小代价">¶</a>变成非降序列的最小代价</h2><p>显然对于第i个数如果要变就变成之前已经出现过的数，所以离散化后dp即可，$O(n^2)$考虑当前数y，以及之前的最大值x，如果$y\lt x$，此时需要将x变小，y变大，容易发现不管怎么调整代价都是$y-x$，这边的策略是直接把y变成x。考虑y之前的最大值z，如果$z\leq x$，显然没有问题，否则我们也不用关心改成了什么，因为现在最大值变成了z，那就尽可能减小所以用一个大根堆，如果当前数小于堆顶，就把堆顶变成当前数</p><h2 id="变成严格降序列"><a class="header-anchor" href="#变成严格降序列">¶</a>变成严格降序列</h2><p>对每个数减去下标后，套用上面的做法，一个小trick</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双栈模拟队列</title>
      <link href="/2021/03/12/shuang-zhan-mo-ni-dui-lie/"/>
      <url>/2021/03/12/shuang-zhan-mo-ni-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="普通队列"><a class="header-anchor" href="#普通队列">¶</a>普通队列</h2><p>支持push和pop操作</p><p>使用两个对顶栈stk1和stk2，push操作就直接加到stk2的尾部，pop操作就从stk1中弹出，如果stk1为空，就把stk2中的所有元素依次pop后push入stk1</p><h2 id="双端队列"><a class="header-anchor" href="#双端队列">¶</a>双端队列</h2><p>支持push_front、push_back、pop_front、pop_back操作</p><p>同样用两个对顶栈来实现，但是如果pop_front和pop_back操作交替进行，使用上面的方法就会TLE。考虑均摊的思想，如果在pop时该栈空了，就把另一个栈栈底的$\fracn2$​个元素push过去</p><h2 id="摊还"><a class="header-anchor" href="#摊还">¶</a>摊还</h2><p>考虑现在总共有n个物品，然后在m个位置可能会消耗物品，我们可以把这n个物品均分到这m个位置，如果某个位置的物品被消耗完说明物品数至少减少了$\frac1m$​，之后我们统计当前物品的数量后再进行均分。$T(n)=T(\frac{n(m-1)}{m})+O(n)$$T(n)=O(n)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纳什均衡</title>
      <link href="/2021/03/08/na-shi-jun-heng/"/>
      <url>/2021/03/08/na-shi-jun-heng/</url>
      
        <content type="html"><![CDATA[<p>甲乙两人进行一个博弈，有A、B两种选择，而他们的组合选择会对应某种收益（双方均知道这些组合选择的后果），而每个人不知道对方如何选择，所以每个人会选择自己期望意义下有最大收益的那个（即对方选A或选B两种情况综合之下）。现在站在甲的角度去考虑，有以下几种情况：</p><ul><li>乙选A的时候我选A比B更优，乙选B的时候我选A还是比B更优，那么毫无疑问我会选择A</li><li>同理可能选择B完全优于选择A</li></ul><p>同样的，站在乙的角度也会出现这两种情况。此时另外一者能够想到对方的选择，而自己只能在这个前提下选择更优的一种当然也可能出现，某种情况下A优，某种情况下B优，这时候就涉及到一种混合策略，假设我有p的概率选择A，(1-p)的概率选择B，为了利益最大化，那么我要使得对方在选A或选B的时候自己期望得到的收益相同，即$pV(A,A) + (1-p)V(B, A) = pV(A, B) + (1-p)V(B,B)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用dp解决各个本质不同方案的平方和</title>
      <link href="/2021/03/05/li-yong-dp-jie-jue-ge-ge-ben-zhi-bu-tong-fang-an-de-ping-fang-he/"/>
      <url>/2021/03/05/li-yong-dp-jie-jue-ge-ge-ben-zhi-bu-tong-fang-an-de-ping-fang-he/</url>
      
        <content type="html"><![CDATA[<p>前提：如果只是简单的求和，可以利用dp[s]来解决那么再加一维，dp[s1][s2]，然后在转移的时候当且仅当下一个状态两者相同才转移，这样得到的结果就是平方和，可以发现这实际上是在对s1和s2这两种状态作匹配，如果某种状态有x个，那么这两者之间就会匹配$x^2$次同理，继续加维，可以得到更高次方和的结果</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间k次覆盖 费用流模型</title>
      <link href="/2021/02/28/qu-jian-k-ci-fu-gai-fei-yong-liu-mo-xing/"/>
      <url>/2021/02/28/qu-jian-k-ci-fu-gai-fei-yong-liu-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>各出n个带权区间，让你保留最多的区间，使得数轴上的每个点最多被覆盖了k次</p><p>建立超源0，超汇maxv+1i和i+1连一条费用为0，流量为k的边对于每个区间，s向t+1连一条费用为-w，流量为1的边跑一遍最小费用流即可容易发现这个图是个dag，可以直接dp求出势能h后跑dijkstra</p><p>gym102759F区间2次覆盖板子，卡了spfa</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">namespace</span> MCMF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>, M = <span class="number">1e6</span> + <span class="number">5</span>, inf = <span class="number">1e9</span>;</span><br><span class="line">  <span class="type">const</span> ll linf = <span class="number">1e18</span>;</span><br><span class="line">  <span class="type">int</span> cnt, head[N];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> next, to, w;</span><br><span class="line">    ll f;</span><br><span class="line">  &#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w, ll f)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    e[++cnt] = &#123;head[u], v, w, f&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> n, s, t;</span><br><span class="line">  <span class="type">int</span> flow;</span><br><span class="line">  <span class="type">int</span> p[N], a[N];</span><br><span class="line">  ll d[N], h[N], cost;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _n, <span class="type">int</span> _s, <span class="type">int</span> <span class="type">_t</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    n = _n, s = _s, t = <span class="type">_t</span>;</span><br><span class="line">    cnt = <span class="number">1</span>, flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, (n+<span class="number">1</span>)&lt;&lt;<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> cap, ll cost)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(u, v, cap, cost), <span class="built_in">addedge</span>(v, u, <span class="number">0</span>, -cost);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getH</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) h[i] = linf;</span><br><span class="line">    h[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s; i&lt;t; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=head[i]; j; j=e[j].next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = e[j].to;</span><br><span class="line">        <span class="keyword">if</span>(e[j].w &amp;&amp; h[v]&gt;h[i]+e[j].f) h[v] = h[i] + e[j].f;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) d[i] = linf;</span><br><span class="line">    d[s] = <span class="number">0</span>, a[s] = inf;</span><br><span class="line">    priority_queue&lt;pli, vector&lt;pli&gt;, greater&lt;pli&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> cur = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="type">int</span> u = cur.se;</span><br><span class="line">      <span class="keyword">if</span>(cur.fi&gt;d[u]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        ll w = e[i].f + h[u] - h[v];</span><br><span class="line">        <span class="keyword">if</span>(e[i].w&amp;&amp;d[v]&gt;d[u]+w)</span><br><span class="line">        &#123;</span><br><span class="line">          p[v] = i;</span><br><span class="line">          a[v] = <span class="built_in">min</span>(a[u], e[i].w);</span><br><span class="line">          pq.<span class="built_in">push</span>(&#123;d[v]=d[u]+w, v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(d[i]&lt;linf) h[i] += d[i];</span><br><span class="line">      <span class="keyword">else</span> h[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> d[t]!=linf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">getH</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">Dijkstra</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      flow += a[t], cost += a[t]*h[t];</span><br><span class="line">      <span class="type">int</span> u = t;</span><br><span class="line">      <span class="keyword">while</span>(u!=s)</span><br><span class="line">      &#123;</span><br><span class="line">        e[p[u]].w -= a[t], e[p[u]^<span class="number">1</span>].w += a[t];</span><br><span class="line">        u = e[p[u]^<span class="number">1</span>].to;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  MCMF::<span class="built_in">init</span>(<span class="number">500002</span>, <span class="number">0</span>, <span class="number">500001</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> s, e; ll w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;s, &amp;e, &amp;w);</span><br><span class="line">    MCMF::<span class="built_in">add</span>(s, e+<span class="number">1</span>, <span class="number">1</span>, -w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MCMF::t; i++) MCMF::<span class="built_in">add</span>(i, i+<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  MCMF::<span class="built_in">go</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, -MCMF::cost);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Regular Contest 111</title>
      <link href="/2021/01/10/atcoder-regular-contest-111/"/>
      <url>/2021/01/10/atcoder-regular-contest-111/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><p>求$\lfloor \frac{10^n}{m} \rfloor$$1\leq n \leq 10^{18},1\leq m \leq 10000$</p><p>把$x % y$改写成$\lfloor \frac{x}{y} \rfloor$求出$p=10^n % m$，再求出$q=(10^n-p) % m^2$那么答案就是$\frac{10^n-p}{m} - \frac{10^n-p-q}{m}$​，即$\frac{q}{m}$快速幂即可</p><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>有n张牌，每张有两面，各有数字$a_i$​和$b_i$​，每张牌选择一面朝上，问你最多能有几种数字。</p><p>相当于给$a_i$​和$b_i$​连边，然后对于每个连通块如果是树，那就要少一种，否则全可以有然后比赛时候我却只想到一个二分图的建法，甚至还在犹豫要不要用HK冲（太菜惹。。）最后也是乱搞过去的，如果某个数字只有一张牌有，那就让翻，这样按照拓扑把这些贪心掉之后，剩下的每个数字都至少有两个牌有，那么这些数字都可以有（其实和题解的结论一样）</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>每个人有权值$a_i$​，有物品$p_i$​，且重$b_i$​，每次可以选择两个人交换他们的物品，问你最少多少次使得所有i满足$p_i=i$，一个额外条件是如果$a_i\le b_i$​后这个人就不能再交换了。</p><p>可以任意交换，要最少次数，显然是考虑每个置换环贪心的想肯定是先让$a_i$​小的人先归位，尽可能让$a_i$​大的人作中介所以按照$a$排序后一个个换即可题解说的是如果换不了就一定无解。我写的时候是如果一次换不了，就尝试让$a$最大的那个作中介，似乎不会出现这种情况？</p><h2 id="D"><a class="header-anchor" href="#D">¶</a>D</h2><p>一个无向图，让你给所有边定向，使得每个点可以达到的点数满足给定的数组$c$，保证存在解</p><p>因为一定有解，那么对于一条边，如果两个点的c不同，一定是让大的连向小的，所以只用考虑相等的。我当时想的是肯定是环，但是这样很难构造。其实本质就是让你把这个无向图定向成一个强连通的图。先跑出一个dfs树，然后对于树边从dfs序小的到大的，对于非树边从dfs序大的到小的即可。我边的数组也只开了100，导致一直wa（不知道为什么不是re），自闭了</p><h2 id="E"><a class="header-anchor" href="#E">¶</a>E</h2><p>给定A,B,C,D，让你求有多少个正整数i满足$[A+Bi,A+Ci]$区间内没有D的倍数显然区间长度$\geq D$的时候一定有D的倍数所有i一定满足$\leq \lfloor \frac{D-2}{C-B} \rfloor$其次就是$\lfloor \frac{A+Bi-1}{D} \rfloor= \lfloor \frac{A+Ci}{D}\rfloor$又由于这两者最多相差1，所以只要求出$\sum \limits_{i=1}^{up} \lfloor\frac{A+Ci}{D} \rfloor - \lfloor \frac{A+Bi-1}{D}\rfloor$，就是包含D的倍数的不合法区间了，用up减掉即可。这东西就是一个基本的类欧几里得了$\sum\limits_{i=0}^{n} \lfloor \frac{ai+b}{c} \rfloor$，套个板子即可</p><p>比赛就写ABC，D没写出来，E没看，感觉这次DE挺套路的，然后ABC我写的有点慢，BC也都是猜的结论不太敢写，想了好久</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018-2019 ACM-ICPC, Asia Jiaozuo Regional Contest gym102028</title>
      <link href="/2021/01/09/2018-2019-acm-icpc-asia-jiaozuo-regional-contest-gym102028/"/>
      <url>/2021/01/09/2018-2019-acm-icpc-asia-jiaozuo-regional-contest-gym102028/</url>
      
        <content type="html"><![CDATA[<p>前五题不难（银），第六题（B or H）都不会</p><h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><p>真签到</p><h2 id="D"><a class="header-anchor" href="#D">¶</a>D</h2><p>初中题，有点烦有两种情况，懒得写了</p><h2 id="E"><a class="header-anchor" href="#E">¶</a>E</h2><p>很容易打表找到规律</p><h2 id="F"><a class="header-anchor" href="#F">¶</a>F</h2><p>很直白的bfs，需要对给出的图进行一些转化（我的转化方法不太好，导致有点难写）</p><h2 id="I"><a class="header-anchor" href="#I">¶</a>I</h2><p>横轴上有n个点，让你选择k个点，最大化他们两两之间距离的和k从1~n都回答一遍两个点一定是取最左和最右，三个点随便再取一个，四个点一定是取最左两个和最右两个，那么结论就很显然了</p><h2 id="H"><a class="header-anchor" href="#H">¶</a>H</h2><p>给定n个数，定义一个子区间的值为该区间的最大值，让你求所有本质不同的子区间的值的和没有本质不同那就很模板了，单调栈或者笛卡尔树即可但是本质不同就很棘手，想了想后缀自动机感觉做不了，又想了想单调栈和笛卡尔树感觉也不行，哈希也没法搞。看到题解的后缀数组后就知道了。忘了本质不同还可以后缀数组了。先想一下后缀数组是怎么求本质不同的串的，就是求出$height_i$​，那么对于从位置i开始的后缀，他会多统计$height_{rk_i}$​​个前缀，即从i开始，以$i$ ~ $i+height_{rk_i}-1$结束的这些区间的值重复算了，减掉即可令$r_i = i+height_{rk_i}-1$先建出笛卡尔树，对于当前点u，当前范围为[L,R],则左子树内所有$r_i$​大于等于u的，都要减掉$a_u$​的贡献即要求出左子树(包括u)内$\sum_{i=L}^u max(r_i-u+1,0) -\sum_{i=L}^u max(r_i-R,0)$可以用线段树合并来维护</p><p>这题发现了我sa板子的一个问题，在求height数组的时候要注意i+k和j+k的范围，否则在多组数据+数组是int的时候会挂掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;a[i+k]==a[j+k]) k++;</span><br></pre></td></tr></table></figure><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>有两种怪物，血量攻击力分别为$HP_A,ATK_A,HP_B,ATK_B$第i回合你会先受到活着的怪物的攻击，然后你可以选择一只怪物造成i的伤害，让你最小化自己所受的伤害的同时最小化攻击序列的字典序（尽可能优先打A）先考虑怎么最小化自己受到的伤害定义f(t)表示最小的x，使得$\sum_{i=1}^x \geq t$一定是在$f(HP_A+HP_B)$回合以内，先优先打死A，或者先优先打死B考虑先打死A，如果前$f(HP_A)$回合都用来打A，剩余回合打B也能把B打死那这就是最优的，否则假设缺了x点伤害，打A富余了y点伤害，必然有关系$y\geqx$，为了让B尽可能靠后，只要在第y回合改成打B即可考虑先打死B，先在前$f(HP_B)$回合都打B，后面打A，如果打B富余了x点伤害，我们让前$f(x+1)-1$个回合改成打A即可，如果A还缺了x的伤害，那就让前面最后一下打A延迟x回合</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>一个$n \times n$的棋盘，每一列上都一个棋子（且都不同行），现在有四种操作和两种询问</p><ul><li>L K：所有棋子同时向左移动k步，如果碰到边界就不动</li><li>R K：所有棋子同时向右移动k步，如果碰到边界就不动</li><li>U K：所有棋子同时向上移动k步，如果碰到边界就不动</li><li>D K：所有棋子同时向下移动k步，如果碰到边界就不动</li><li>询问初始第i个棋子现在的位置</li><li>询问有多少对棋子现在在同一个位置上</li></ul><p>$n \leq 3\times 10^5$这种二维问题，一个想法就是行列分离做，这边显然也可以行列分离转成一维去思考就考虑所有棋子在一条横轴上，可以同时左右移动k步对于碰到过左边界的棋子，以后就永远在一起了，右边界也是这样第一步左移k，那么1~k的棋子之后就相同了另一个套路是n个棋子一起动不好维护，那么我们去维护边界，左移k，我们让左边界右移k就行了，这样$\leq$左边界的棋子都相当于是在左边界上，这样一来相当于是左右边界不断在向中间靠拢，因为不断移动下去合并的棋子就越来越多了。但是我们维护的并不是真实的左边界坐标，所以还需要维护一个变量d。左移就让d+k，右移就让d-k，则l-k和r-k就是真实的边界了，当然还需要保证真实边界在1~n范围内，因为碰到边界就不动了这样横轴纵轴分别维护就可以解决第一个询问了，对于第二个询问，我们相当于是LRDU四个边界在不断的往中间压缩，由于初始行列均不同，要位于同一个格子，必须同在LR轴中的一个，UD轴的一个，用四个变量LD，LU，RD，RU分别维护一下，注意特判L=R，D=U的情况。具体维护的话，因为lrud这四个轴都是单调变化的，那么每次移动的时候判断一下当前碰到边界的点即可，注意不要重复统计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, ul, ur, dl, dr;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">ll C[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bound</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, d;</span><br><span class="line">  <span class="type">int</span> p[N], id[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; l = <span class="number">1</span>, r = n, d = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; p[x] = y, id[y] = x; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">movel</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r &amp;&amp; l+d-k&lt;<span class="number">1</span>) <span class="built_in">check</span>(id[++l]);</span><br><span class="line">    <span class="keyword">if</span>(l+d-k&gt;=<span class="number">1</span>) d -= k;</span><br><span class="line">    <span class="keyword">else</span> d = <span class="number">1</span> - l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mover</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r &amp;&amp; r+d+k&gt;n) <span class="built_in">check</span>(id[--r]);</span><br><span class="line">    <span class="keyword">if</span>(r+d+k&lt;=n) d += k;</span><br><span class="line">    <span class="keyword">else</span> d = n - r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[k]&lt;=l) <span class="keyword">return</span> l + d;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p[k]&gt;=r) <span class="keyword">return</span> r + d;</span><br><span class="line">    <span class="keyword">return</span> p[k] + d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;lr, ud;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(vis[id]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(lr.p[id]&lt;=lr.l &amp;&amp; ud.p[id]&lt;=ud.l) ul++, vis[id] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(lr.p[id]&lt;=lr.l &amp;&amp; ud.p[id]&gt;=ud.r) dl++, vis[id] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(lr.p[id]&gt;=lr.r &amp;&amp; ud.p[id]&lt;=ud.l) ur++, vis[id] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(lr.p[id]&gt;=lr.r &amp;&amp; ud.p[id]&gt;=ud.r) dr++, vis[id] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lr.l==lr.r &amp;&amp; ud.l==ud.r) <span class="keyword">return</span> C[ul+dl+ur+dr];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(lr.l==lr.r) <span class="keyword">return</span> C[ul+ur] + C[dl+dr];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ud.l==ud.r) <span class="keyword">return</span> C[ul+dl] + C[ur+dr];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> C[ul] + C[ur] + C[dl] + C[dr];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ul = ur = dl = dr = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">  lr.<span class="built_in">init</span>(n), ud.<span class="built_in">init</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    lr.<span class="built_in">set</span>(i, y); ud.<span class="built_in">set</span>(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">check</span>(lr.id[<span class="number">1</span>]), <span class="built_in">check</span>(lr.id[n]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ud.<span class="built_in">get</span>(k), lr.<span class="built_in">get</span>(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;!&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span>());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;L&#x27;</span>) lr.<span class="built_in">movel</span>(k);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>) lr.<span class="built_in">mover</span>(k);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;U&#x27;</span>) ud.<span class="built_in">movel</span>(k);</span><br><span class="line">      <span class="keyword">else</span> ud.<span class="built_in">mover</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N; i++) C[i] = <span class="number">1ll</span>*i*(i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 695 (Div. 2)</title>
      <link href="/2021/01/09/codeforces-round-695-div-2/"/>
      <url>/2021/01/09/codeforces-round-695-div-2/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><p>有n个数字，同时从0开始，按照0~9的顺序循环，每一秒变化一次。现在可以暂停某个数字的变化，然后距离它x的数字会在x秒后暂停变化，问所有数字都暂停后的最大数字是多少。显然高位越大越好，发现操作第2个数字后可以使前三位为989，这样必然是最大的</p><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>给定一个数组a，如果$a_i\lt a_{i-1},a_i\lt a_{i+1}$​，或者$a_i\gt a_{i-1},a_i\gt a_{i+1}$​，则是坏的三元组，要求你至多修改一个数使坏的三元组个数最少考虑修改一个数，只会影响到以$a_{i-1},a_i,a_{i+1}$​这三个数为中心的三元组，在最优的情况下，$a_i$​的取值必然是$a_{i-2},a_{i-1},a_i,a_{i+1},a_{i+2},\inf,-\inf$这七种之一，暴力枚举一下（这边没细想，不知道只取$a_{i-1}$​或$a_{i+1}$​行不行）</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>有三个多重集，定义一种操作是，选择某个多重集中的数x，另一个多重集中的数y，然后删除这两个数，把x-y放到x所在的多重集中，让你最大化最后剩下的那个数的值我们可以让x去减掉所有的y，再让z去减掉x，那就相当于只损失了一个x先枚举剩下的那个数在哪个多重集中，必然是让最小的那个数当作x的角色，再考虑怎么去掉同一集合中的其他数t，可以选择另外两个多重集中的最小值mn，然后让t和mn中的较小者充当x的角色，这样损失就是$\min(t,mn)$。所以最小损失就是该多重集的最小值，以及该多重集的次小值和其余两个多重集的最小值中的最小值的和（有点绕。。）</p><h2 id="D"><a class="header-anchor" href="#D">¶</a>D</h2><p>一个人初始在1~n的任意一点，然后每次可以向左或者向右走一步，走k步后就形成一条路径$c_0,c_1,…,c_k$​，定义该路径的价值为$\sum_{i=0}^ka_{c_i}$​​，求所有不同的路径的价值和，要求支持单点修改$a_i$​先求出$dp_{i,j}$​表示第i步在j的方案数，我们可以发现这个dp的转移正向和反向是相同的，那么到$dp_k$​的时候$dp_{i,j}$​的贡献就相当于$dp_{k-i,j}$​，所以随便维护一下前缀和就可以$O(1)$带修了</p><h2 id="E"><a class="header-anchor" href="#E">¶</a>E</h2><p>给一棵带点权的无根树，一个点u作为根是合法的，仅当对于其它任意点v，u到v的路径上的点权均不同可以用换根dp来做固定1为根，先dfs一遍跑出$dp_u$​，表示只考虑u的子树时，以u为根是否合法。这个很简单，只要u的所有儿子v合法，且u的点权在子树中没有出现过即可。再考虑求出$dp2_u$​，表示考虑除去u的子树后的部分，以u为根是否合法。首先u的点权只能在u的子树当中出现，u的父亲fa的点权也只能在u的子树中出现，$dp2_{fa}$​要合法。此外对于fa，除去u点后其余儿子的dp要都是1。满足以上所有条件，$dp2_u$​就是1。最后当$dp_u=1$且$dp2_u=1$时，表明u是合法的具体实现需要用map启发式合并</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC Central Russia Regional Contest (CRRC 19) gym102780</title>
      <link href="/2021/01/09/icpc-central-russia-regional-contest-crrc-19-gym102780/"/>
      <url>/2021/01/09/icpc-central-russia-regional-contest-crrc-19-gym102780/</url>
      
        <content type="html"><![CDATA[<p>除了两道题没什么人过外比较简单</p><h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><p>小学数学</p><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>初中物理</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>模拟题，带一点点推理</p><h2 id="D"><a class="header-anchor" href="#D">¶</a>D</h2><p>给定a,b，让你求一个x，满足$a^x=x^b$其中$2\leq a,b \leq 10000$容易想到x可以表示$a^t$的形式考虑$t\geq 1$的情况$a^t = tb$可以直接暴力枚举t，幂次的增速是迅速的考虑$t\le 1$的情况小数没法枚举了，但是可以找到a的因子d，使得d的幂次=a，转而用d的幂次去表示x即可</p><h2 id="F"><a class="header-anchor" href="#F">¶</a>F</h2><p>给定一个字符串，两个人轮流操作，每次操作可以选择一种字母，然后删除一个或者二个或者全部，问谁赢。可以把每种字母想成一堆石子，那就是一个只能取1个或2个或全部的NIM游戏，跑一下sg即可，其实直接手推也行</p><h2 id="H"><a class="header-anchor" href="#H">¶</a>H</h2><p>一个数n，两个轮流让其减1，减5，或者减13，问谁赢跟F差不多，跑一下dp即可</p><h2 id="I"><a class="header-anchor" href="#I">¶</a>I</h2><p>有一个$n \times n$的网格，现在有一个特殊点，然后每次你可以进行三种询问</p><ul><li>询问某个点是不是特殊点</li><li>询问某条线段是否包含特殊点</li><li>询问某个三角形是否包含特殊点</li></ul><p>$n \leq 10^8$，询问次数不超过60看到这个数据范围和询问次数就想到二分，x和y可以分开做，那么我们相当于要通过一次询问判断这个特殊点的坐标是小于x还是大于x。这边有个条件就是询问的点的坐标可以超过n，在$10^9$以内就行，那就很简单了，每次问一个右边的特别大的三角形，保证可以盖住大于x的这块矩形就可以了</p><h2 id="J"><a class="header-anchor" href="#J">¶</a>J</h2><p>让你用不超过5个数，使得它们的立方和等于x$x\leq 10^{100000}$考虑$(x-1)^3 + (x+1)^3 = 2x^3 + 6x$那如果x是6的倍数，让y=x/6，然后用y-1，y+1，-y, -y这四个数就可以表示出x了其余按照%6讨论一下即可比如x%6=2，就先表示出x-8，再加个$2^3$即可</p><h2 id="K"><a class="header-anchor" href="#K">¶</a>K</h2><p>给定n个不同的数，每次可以交换相邻的两个数，问你最少交换几次，使得这n个数先减后增从大到小考虑每个数，最大的数只能放在最左边或者最右边，然后似乎就有种$n^2$的dp了，但是仔细思考可以发现最大的数放在左边还是右边是不影响次大的数的，所以每个数贪心的放就行了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笛卡尔树</title>
      <link href="/2020/12/23/di-qia-er-shu/"/>
      <url>/2020/12/23/di-qia-er-shu/</url>
      
        <content type="html"><![CDATA[<p>类似treap，权值满足二叉搜索树，键值满足堆一般用在序列上，以下标为权值，值为键值，利用单调栈可以$O(n)$建树因为下标是单调递增的，所以只需要在单调栈中维护出最右链，在插入一个新点的时候，不断排掉大于自己值的点，然后自己成为栈顶的右儿子，排掉的最后一个点作其左儿子有什么用呢笛卡尔树上两个点的LCA就代表这个区间的RMQ对一个点，它是其代表的区间的最值，左子树是左区间，右子树是右区间，这就形成了良好的递归性质，可以方便思考和解题</p><h2 id="P4755"><a class="header-anchor" href="#P4755">¶</a>P4755</h2><p>定义点对$(i,j)$是好的，当且仅当$a_i\times a_j \leq \max(a_i,…,a_j)$显然可以启发式分治做，利用st表找到最值的位置，然后启发式遍历左右区间中小的那一边然后求最值即可。其实这种思想放在笛卡尔树上也是一样的，dfs遍历，然后通过遍历小的那颗子树来统计答案。统计答案可以直接用动态开点线段树，然后线段树合并即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], sz[N];</span><br><span class="line"><span class="type">int64_t</span> ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, cnt;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> rt[N&lt;&lt;<span class="number">5</span>], tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].cnt = t[t[p].l].cnt + t[t[p].r].cnt; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) p = ++tot;</span><br><span class="line">  t[p].cnt++;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(t[p].l, l, mid, x);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">upd</span>(t[p].r, mid+<span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(r&lt;=v) <span class="keyword">return</span> t[p].cnt;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="built_in">ask</span>(t[p].l, l, mid, v);</span><br><span class="line">  <span class="keyword">if</span>(v&gt;mid) ans += <span class="built_in">ask</span>(t[p].r, mid+<span class="number">1</span>, r, v);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    t[x].cnt += t[y].cnt;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  t[x].l = <span class="built_in">merge</span>(t[x].l, t[y].l, l, mid);</span><br><span class="line">  t[x].r = <span class="built_in">merge</span>(t[x].r, t[y].r, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> st[N], ch[N][<span class="number">2</span>], top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    j = top;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;a[st[j]]&lt;a[i]) j--;</span><br><span class="line">    <span class="keyword">if</span>(j) ch[st[j]][<span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;top) ch[i][<span class="number">0</span>] = st[j+<span class="number">1</span>];</span><br><span class="line">    top = j;</span><br><span class="line">    st[++top] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p || l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(ch[p][<span class="number">0</span>], l, p<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">dfs</span>(ch[p][<span class="number">1</span>], p+<span class="number">1</span>, r);</span><br><span class="line">  sz[p] = sz[ch[p][<span class="number">0</span>]] + sz[ch[p][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]&lt;sz[ch[p][<span class="number">1</span>]]) <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=p<span class="number">-1</span>; i++) ans += <span class="built_in">ask</span>(rt[ch[p][<span class="number">1</span>]], <span class="number">1</span>, inf, a[p]/a[i]);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>; i&lt;=r; i++) ans += <span class="built_in">ask</span>(rt[ch[p][<span class="number">0</span>]], <span class="number">1</span>, inf, a[p]/a[i]);</span><br><span class="line">  rt[p] = <span class="built_in">merge</span>(rt[ch[p][<span class="number">0</span>]], rt[ch[p][<span class="number">1</span>]], <span class="number">1</span>, inf);</span><br><span class="line">  <span class="built_in">upd</span>(rt[p], <span class="number">1</span>, inf, a[p]);</span><br><span class="line">  ans += <span class="built_in">ask</span>(rt[p], <span class="number">1</span>, inf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="built_in">build</span>();</span><br><span class="line">  <span class="built_in">dfs</span>(st[<span class="number">1</span>], <span class="number">1</span>, n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客多校3-Sort-the-Strings-Revision"><a class="header-anchor" href="#牛客多校3-Sort-the-Strings-Revision">¶</a>牛客多校3 Sort the Strings Revision</h2><p>有一个序列，第i个元素的值为$i % 10$，n次操作，每次将$p_i$​位置的值换成$d_i$​，其中$p_i$​为一个排列，问你操作前后共$n+1$个序列的字典序排名显然越小的$p_i$​越占据主导地位，根据序列p建出笛卡尔树，然后如果$p_i&gt;d_i$​，说明修改后字典序更小，优先遍历右子树，反之优先遍历左子树。有一个问题是如果$p_i=d_i$​，此时就不知道左右子树哪个小了，可以人为的先让这样的$p_i$​取一个极大值，这样这些$p_i$​只可能在叶子节点了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, base = <span class="number">10000019</span>;</span><br><span class="line"><span class="type">int</span> n, p[N], d[N];</span><br><span class="line"><span class="type">int</span> st[N], ch[N][<span class="number">2</span>], rk[N], top, rnk;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) ch[i][<span class="number">0</span>] = ch[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    j = top;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; a[st[j]]&gt;a[i]) j--;</span><br><span class="line">    <span class="keyword">if</span>(j) ch[st[j]][<span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;top) ch[i][<span class="number">0</span>] = st[j+<span class="number">1</span>];</span><br><span class="line">    top = j;</span><br><span class="line">    st[++top] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r || p[rt]==mod)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) rk[i] = rnk++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p[rt]%<span class="number">10</span>&gt;d[rt]) <span class="built_in">dfs</span>(ch[rt][<span class="number">1</span>], rt+<span class="number">1</span>, r), <span class="built_in">dfs</span>(ch[rt][<span class="number">0</span>], l, rt);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">dfs</span>(ch[rt][<span class="number">0</span>], l, rt), <span class="built_in">dfs</span>(ch[rt][<span class="number">1</span>], rt+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> pseed, pa, pb, pmod;</span><br><span class="line">  <span class="type">int</span> dseed, da, db, dmod;</span><br><span class="line">  rnk = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;pseed, &amp;pa, &amp;pb, &amp;pmod);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;dseed, &amp;da, &amp;db, &amp;dmod);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) p[i] = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">swap</span>(p[pseed%(i+<span class="number">1</span>)], p[i]);</span><br><span class="line">    pseed = (<span class="number">1ll</span>*pseed*pa + pb)%pmod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    d[i] = dseed%<span class="number">10</span>;</span><br><span class="line">    dseed = (<span class="number">1ll</span>*dseed*da + db)%dmod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(d[i]==p[i]%<span class="number">10</span>) p[i] = mod;</span><br><span class="line">  <span class="built_in">build</span>(p);</span><br><span class="line">  <span class="type">int</span> rt = st[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">dfs</span>(rt, <span class="number">0</span>, n);</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, pw = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ans = (ans + <span class="number">1ll</span>*rk[i]*pw%mod)%mod;</span><br><span class="line">    pw = <span class="number">1ll</span>*pw*base%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛74</title>
      <link href="/2020/12/22/niu-ke-lian-xi-sai-74/"/>
      <url>/2020/12/22/niu-ke-lian-xi-sai-74/</url>
      
        <content type="html"><![CDATA[<p>ABCD都很一眼</p><h2 id="E"><a class="header-anchor" href="#E">¶</a>E</h2><p>看到题也想到思路了，然而写法复杂了，加上写错一个地方，再加上出题人数据范围不给下限，正整数包含0可还行，写了一个多小时给定一个联通简单无向图，定义一种操作是，随机选择两个不同的点，将他们之间最短路径上的所有点都变成黑色，问你操作k次后黑色点的个数的期望$n \leq 500$思路很简单，考虑每个点变黑的概率是多少，一次操作变黑，就是枚举有多少对点，它们之间存在一条最短路经过该点。然后这题就没了先跑一遍floyd，然后枚举i,j,k，如果$d_{ik}+d_{kj}=d_{ij}$​，说明i和j的最短路中有k我写复杂了，考虑以每个点为根的最短路径图，固定选根，那么要让第i个点变黑，就必须选择第i个点的后继可达点（最短路径图是个DAG，拓扑排序+bitset，复杂度其实有点炸，不过题目数据w存在0，这时候就不是DAG了，这做法就挂了）另外我竟然在初始化时写出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G[i][j] = (i^j)*inf</span><br></pre></td></tr></table></figure><p>没多想把i!=j改成了i^j，蠢了</p><h2 id="F"><a class="header-anchor" href="#F">¶</a>F</h2><p>一个n个节点的树，对其染至多m种颜色，定义一颗树是好的，当且仅当存在一条链使得端点是同色，且除端点外存在一个点与端点不同色。问染色方案数的期望（树的形态任意）$n \leq 10^7, m \leq 10^7$存在问题转成反问题，每条链都不合法，要么整条链同色，要么都不同色， <s>然后就不会了</s>按照dfs序来dp$dp_{ij}$​表示考虑到dfs序为i的点时，已经染了j种颜色，且整棵树不合法则$dp_{ij} = dp_{i-1j} + dp_{i-1j-1}(m-j+1)$要么和父亲同色，要么选择一种没出现过的颜色容易发现所有形态树的染色方案树是相同的，所以答案等价于求一棵树的染色方案数考虑这个式子的组合意义，就是i个有标号球，m个有标号盒子，然后放入其中的j个的方案数可以直接求出来是$\binom{m}{j}\binom{i-1}{j-1}$，即先从m个盒子里选j个，然后这j个任意排列，之后就是个隔板法了最后的答案是$m^n - \sum_{i=1}^m dp_{ni}$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构模板整合</title>
      <link href="/2020/12/16/shu-ju-jie-gou-mo-ban-zheng-he/"/>
      <url>/2020/12/16/shu-ju-jie-gou-mo-ban-zheng-he/</url>
      
        <content type="html"><![CDATA[<h2 id="替罪羊树"><a class="header-anchor" href="#替罪羊树">¶</a>替罪羊树</h2><p>维护权值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> alpha = <span class="number">0.7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> val, sz, cnt;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + t[p].cnt; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bad</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> t[p].cnt &amp;&amp; t[p].sz*alpha&lt;<span class="built_in">max</span>(t[t[p].ls].sz, t[t[p].rs].sz); &#125;</span><br><span class="line"><span class="type">int</span> ord[N], top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(t[p].ls);</span><br><span class="line">  <span class="keyword">if</span>(t[p].cnt) ord[++top] = p;</span><br><span class="line">  <span class="built_in">dfs</span>(t[p].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, p = ord[mid];</span><br><span class="line">  t[p].ls = <span class="built_in">build</span>(l, mid<span class="number">-1</span>);</span><br><span class="line">  t[p].rs = <span class="built_in">build</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(p);</span><br><span class="line">  p = <span class="built_in">build</span>(<span class="number">1</span>, top);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = ++tot;</span><br><span class="line">  t[p].val = v, t[p].ls = t[p].rs = <span class="number">0</span>;</span><br><span class="line">  t[p].cnt = t[p].sz = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="built_in">newnode</span>(p, v);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v==t[p].val) t[p].cnt++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="built_in">ins</span>(t[p].ls, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">ins</span>(t[p].rs, v);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bad</span>(p)) <span class="built_in">rebuild</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v==t[p].val) t[p].cnt--;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="built_in">del</span>(t[p].ls, v);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">del</span>(t[p].rs, v);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">bad</span>(p)) <span class="built_in">rebuild</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Less</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v, <span class="type">bool</span> eq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].cnt&amp;&amp;v==t[p].val) <span class="keyword">return</span> t[t[p].ls].sz + t[p].cnt*eq;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="keyword">return</span> <span class="built_in">Less</span>(t[p].ls, v, eq);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> t[t[p].ls].sz + t[p].cnt + <span class="built_in">Less</span>(t[p].rs, v, eq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].ls, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(t[t[p].ls].sz+t[p].cnt&gt;=k) <span class="keyword">return</span> t[p].val;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].rs, k-t[p].cnt-t[t[p].ls].sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fhq-treap"><a class="header-anchor" href="#fhq-treap">¶</a>fhq treap</h2><p>维护区间的（按size分裂），带有up、down以及fa的维护</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>|<span class="built_in">rand</span>(); &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> fa, key, sz;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = ++tot;</span><br><span class="line">  t[p].ls = t[p].rs = t[p].fa = <span class="number">0</span>;</span><br><span class="line">  t[p].key = <span class="built_in">rnd</span>();</span><br><span class="line">  t[p].sz = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> k, <span class="type">int</span> fx=<span class="number">0</span>, <span class="type">int</span> fy=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123; x = y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz)</span><br><span class="line">  &#123;</span><br><span class="line">    y = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].ls, x, t[p].ls, k, fx, p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    x = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].rs, t[p].rs, y, k-t[t[p].ls].sz<span class="number">-1</span>, p, fy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x) t[x].fa = fx;</span><br><span class="line">  <span class="keyword">if</span>(y) t[y].fa = fy;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) &#123; p = x|y; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">down</span>(x);</span><br><span class="line">    p = x;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].rs, t[p].rs, y);</span><br><span class="line">    t[t[p].rs].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">down</span>(y);</span><br><span class="line">    p = y;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].ls, x, t[p].ls);</span><br><span class="line">    t[t[p].ls].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downall</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">downall</span>(t[p].fa);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">downall</span>(p);</span><br><span class="line">  <span class="type">int</span> rk = t[t[p].ls].sz + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(t[p].fa)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t[t[p].fa].rs==p) rk += t[t[p].fa].sz - t[p].sz;</span><br><span class="line">    p = t[p].fa;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].ls, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k==t[t[p].ls].sz+<span class="number">1</span>) <span class="keyword">return</span> t[p].c;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].rs, k-t[t[p].ls].sz<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="splay"><a class="header-anchor" href="#splay">¶</a>splay</h2><p>维护区间，注意及时up，只需要在kth中down即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rt;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], sz[N], fa[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> l = ch[p][<span class="number">0</span>], r = ch[p][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> p = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  sz[p] = <span class="number">1</span>, fa[p] = f, ch[f][p&gt;f] = p;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">build</span>(l, p<span class="number">-1</span>, p); <span class="built_in">build</span>(p+<span class="number">1</span>, r, p);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x];</span><br><span class="line">    <span class="keyword">if</span>(fa[y]!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l<span class="number">-1</span>), y = <span class="built_in">kth</span>(rt, r+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="keyword">return</span> ch[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCT"><a class="header-anchor" href="#LCT">¶</a>LCT</h2><p>维护边权：拆点维护边双：每次加边，如果两端点已经连通，则用并查集缩起来，然后在access的时候，x=fa[x]=find(fa[x])</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], fa[N], rev[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">notrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>]==x || ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">swap</span>(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">  rev[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(rev[x])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">0</span>]) <span class="built_in">reverse</span>(ch[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">1</span>]) <span class="built_in">reverse</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushall</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">notrt</span>(x)) <span class="built_in">pushall</span>(fa[x]);</span><br><span class="line">  <span class="built_in">down</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">notrt</span>(y)) ch[z][ch[z][<span class="number">1</span>]==y] = x;</span><br><span class="line">    ch[y][k] = ch[x][!k]; fa[ch[x][!k]] = y;</span><br><span class="line">    ch[x][!k] = y, fa[y] = x, fa[x] = z;</span><br><span class="line">    <span class="built_in">up</span>(y), <span class="built_in">up</span>(x), <span class="built_in">up</span>(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pushall</span>(x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> f=fa[x]; f=fa[x], <span class="built_in">notrt</span>(x); <span class="built_in">rotate</span>(x))</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">notrt</span>(f)) <span class="built_in">rotate</span>(<span class="built_in">rs</span>(x) == <span class="built_in">rs</span>(f) ? f : x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; x; y=x, x=fa[x])</span><br><span class="line">    <span class="built_in">splay</span>(x), ch[x][<span class="number">1</span>] = y, <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">  <span class="built_in">reverse</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findrt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">  <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) <span class="built_in">down</span>(x), x = ch[x][<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">splay</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">makert</span>(x);</span><br><span class="line">  <span class="built_in">access</span>(y); <span class="built_in">splay</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">makert</span>(x);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">findrt</span>(y)!=x) fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">makert</span>(x);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">findrt</span>(y)==x&amp;&amp;fa[y]==x&amp;&amp;!ch[y][<span class="number">0</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    fa[y] = ch[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">up</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a class="header-anchor" href="#哈希表">¶</a>哈希表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2174729</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span> &#123; <span class="type">int</span> next, v; ull k; &#125;e[M+<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> head[M], st[N], tp, sz;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(ull k)</span> </span>&#123; <span class="keyword">return</span> k % M; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; sz = <span class="number">0</span>; <span class="keyword">while</span>(tp) head[st[tp--]] = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(ull k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">f</span>(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = head[t]; p; p = e[p].next)</span><br><span class="line">      <span class="keyword">if</span>(e[p].k==k) <span class="keyword">return</span> e[p].v;</span><br><span class="line">    ++sz;</span><br><span class="line">    e[sz] = &#123;head[t], sz, k&#125;;</span><br><span class="line">    head[t] = sz; st[++tp] = t;</span><br><span class="line">    <span class="keyword">return</span> sz;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希set"><a class="header-anchor" href="#哈希set">¶</a>哈希set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HashSet</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span> &#123; <span class="type">int</span> next; ull k; &#125;e[M+<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> head[M], st[N], tp, sz;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(ull k)</span> </span>&#123; <span class="keyword">return</span> k % M; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; sz = <span class="number">0</span>; <span class="keyword">while</span>(tp) head[st[tp--]] = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(ull k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = head[<span class="built_in">f</span>(k)]; p; p = e[p].next)</span><br><span class="line">      <span class="keyword">if</span>(e[p].k==k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(ull k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">get</span>(k)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">f</span>(k);</span><br><span class="line">    e[++sz] = &#123;head[t], k&#125;;</span><br><span class="line">    head[t] = sz; st[++tp] = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="gp-hash"><a class="header-anchor" href="#gp-hash">¶</a>gp_hash</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">custom_hash</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">uint64_t</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> FIXED_RANDOM = chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">return</span> x + FIXED_RANDOM;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">custom_hash</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">splitmix64</span><span class="params">(<span class="type">uint64_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// http://xorshift.di.unimi.it/splitmix64.c</span></span><br><span class="line">    x += <span class="number">0x9e3779b97f4a7c15</span>;</span><br><span class="line">    x = (x ^ (x &gt;&gt; <span class="number">30</span>)) * <span class="number">0xbf58476d1ce4e5b9</span>;</span><br><span class="line">    x = (x ^ (x &gt;&gt; <span class="number">27</span>)) * <span class="number">0x94d049bb133111eb</span>;</span><br><span class="line">    <span class="keyword">return</span> x ^ (x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">uint64_t</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> FIXED_RANDOM = chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">splitmix64</span>(x + FIXED_RANDOM);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">gp_hash_table&lt;ull, <span class="type">int</span>, custom_hash&gt;</span><br><span class="line">gp_hash_table&lt;ull, <span class="type">bool</span>&gt;</span><br><span class="line">gp_hash_table&lt;ull, null_type&gt;</span><br></pre></td></tr></table></figure><h2 id="bitset压位-64位和32位速度差不多"><a class="header-anchor" href="#bitset压位-64位和32位速度差不多">¶</a>bitset压位(64位和32位速度差不多)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bitset</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> uint = <span class="type">uint32_t</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">32</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> uint up = numeric_limits&lt;uint&gt;::<span class="built_in">max</span>();</span><br><span class="line">  vector&lt;uint&gt; b; <span class="type">int</span> sz;</span><br><span class="line">  <span class="built_in">Bitset</span>(<span class="type">int</span> _sz=<span class="number">0</span>) &#123; sz = _sz; b.<span class="built_in">resize</span>((sz+B<span class="number">-1</span>)/B, <span class="number">0</span>); &#125;</span><br><span class="line">  Bitset <span class="keyword">operator</span> | (<span class="type">const</span> Bitset &amp;oth) <span class="type">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Bitset <span class="title">res</span><span class="params">(sz)</span></span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i+<span class="number">3</span>&lt;(<span class="type">int</span>)b.<span class="built_in">size</span>(); i+=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      res.b[i] = b[i] | oth.b[i];</span><br><span class="line">      res.b[i+<span class="number">1</span>] = b[i+<span class="number">1</span>] | oth.b[i+<span class="number">1</span>];</span><br><span class="line">      res.b[i+<span class="number">2</span>] = b[i+<span class="number">2</span>] | oth.b[i+<span class="number">2</span>];</span><br><span class="line">      res.b[i+<span class="number">3</span>] = b[i+<span class="number">3</span>] | oth.b[i+<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;(<span class="type">int</span>)b.<span class="built_in">size</span>())</span><br><span class="line">      res.b[i] = b[i] | oth.b[i], i++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; b[p/B] |= (<span class="number">1ull</span>&lt;&lt;(p%B)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; b[p/B] &amp;= (up^(<span class="number">1ull</span>&lt;&lt;(p%B))); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setv</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>&#123; (v ? <span class="built_in">set</span>(p) : <span class="built_in">reset</span>(p)); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(uint x, <span class="type">int</span> bit)</span> </span>&#123; <span class="keyword">return</span> (x&gt;&gt;bit)&amp;<span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getf0</span><span class="params">(uint x)</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;B; i++) <span class="keyword">if</span>(!<span class="built_in">get</span>(x, i)) <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getf1</span><span class="params">(uint x)</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;B; i++) <span class="keyword">if</span>(<span class="built_in">get</span>(x, i)) <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getl0</span><span class="params">(uint x)</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=B<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) <span class="keyword">if</span>(!<span class="built_in">get</span>(x, i)) <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getl1</span><span class="params">(uint x)</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=B<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) <span class="keyword">if</span>(<span class="built_in">get</span>(x, i)) <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findr0</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = x/B, q = x%B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q; i&lt;B; i++) <span class="keyword">if</span>(!<span class="built_in">get</span>(b[p], i)) <span class="keyword">return</span> x+i-q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>; i&lt;(<span class="type">int</span>)b.<span class="built_in">size</span>(); i++)</span><br><span class="line">      <span class="keyword">if</span>(b[i]!=up) <span class="keyword">return</span> x+B<span class="number">-1</span>-q+(i-p<span class="number">-1</span>)*B+<span class="built_in">getf0</span>(b[i])+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sz + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findr1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = x/B, q = x%B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q; i&lt;B; i++) <span class="keyword">if</span>(<span class="built_in">get</span>(b[p], i)) <span class="keyword">return</span> x+i-q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>; i&lt;(<span class="type">int</span>)b.<span class="built_in">size</span>(); i++)</span><br><span class="line">      <span class="keyword">if</span>(b[i]) <span class="keyword">return</span> x+B<span class="number">-1</span>-q+(i-p<span class="number">-1</span>)*B+<span class="built_in">getf1</span>(b[i])+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sz + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findl0</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = x/B, q = x%B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q; i&gt;=<span class="number">0</span>; i--) <span class="keyword">if</span>(!<span class="built_in">get</span>(b[p], i)) <span class="keyword">return</span> x+i-q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span>(b[i]!=up) <span class="keyword">return</span> x-q-(p<span class="number">-1</span>-i)*B-(B-<span class="built_in">getl0</span>(b[i]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findl1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = x/B, q = x%B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q; i&gt;=<span class="number">0</span>; i--) <span class="keyword">if</span>(<span class="built_in">get</span>(b[p], i)) <span class="keyword">return</span> x+i-q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span>(b[i]) <span class="keyword">return</span> x-q-(p<span class="number">-1</span>-i)*B-(B-<span class="built_in">getl1</span>(b[i]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Honorable Mention 平衡树+树状数组</title>
      <link href="/2020/12/13/honorable-mention-ping-heng-shu-shu-zhuang-shu-zu/"/>
      <url>/2020/12/13/honorable-mention-ping-heng-shu-shu-zhuang-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>给定一个排列$p_i$​，表示第i个人的排名，要求支持两种操作：</p><ul><li>第x个人的排名上升到y，显然原来y$\sim$rank(x)-1的人的排名就要下降1</li><li>问第x到第y个人中有多少人的排名在后40%</li></ul><p>我们发现第一个操作需要以排名为下标进行维护，而第二个操作又需要以编号为下标进行维护。似乎不太可做。但是仔细想想，对于后40%，我们并不关心谁在前谁在后，我们只需要知道哪些人是在后40%那么用一个树状数组，以编号为下标维护哪些人是后40%然后用一个平衡树，以排名为下标来维护第一个操作。当x的排名原先在后40%，然后提升后不再后40%，就需要对树状数组的x-1，然后对原来排名40%的那个在树状数组中+1。然后只需要将x这个节点删掉，再插到排名为y节点的前面就可以了。还有一个问题，x的排名怎么求，我们以排名为下标怎么求排名呢。容易发现对于每个编号在平衡树中的节点是一一对应的，所以我们用数组保存x是平衡树中的哪个节点，然后把它splay到根，则左儿子的size+1就是排名了。最后不要忘记在splay中前后各插入一个哨兵！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, q, p[N], rp[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) c[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) ans += c[i];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rt;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], sz[N], val[N], fa[N], id[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">if</span>(p) sz[p] = sz[ch[p][<span class="number">0</span>]] + sz[ch[p][<span class="number">1</span>]] + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bld</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> p = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  sz[p] = <span class="number">1</span>;</span><br><span class="line">  ch[p][<span class="number">0</span>] = ch[p][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p&gt;=<span class="number">2</span>&amp;&amp;p&lt;=n+<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    val[p] = rp[p<span class="number">-1</span>];</span><br><span class="line">    id[rp[p<span class="number">-1</span>]] = p;</span><br><span class="line">  &#125;</span><br><span class="line">  fa[p] = f, ch[f][p&gt;f] = p;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">bld</span>(l, p<span class="number">-1</span>, p); <span class="built_in">bld</span>(p+<span class="number">1</span>, r, p);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x];</span><br><span class="line">    <span class="keyword">if</span>(fa[y]!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnk</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">splay</span>(p);</span><br><span class="line">  <span class="keyword">return</span> sz[ch[p][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l<span class="number">-1</span>), y = <span class="built_in">kth</span>(rt, l+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="type">int</span> z = ch[y][<span class="number">0</span>];</span><br><span class="line">  ch[y][<span class="number">0</span>] = <span class="number">0</span>; fa[z] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">  <span class="type">int</span> x2 = <span class="built_in">kth</span>(rt, r<span class="number">-1</span>), y2 = <span class="built_in">kth</span>(rt, r);</span><br><span class="line">  <span class="built_in">splay</span>(x2); <span class="built_in">splay</span>(y2, x2);</span><br><span class="line">  ch[y2][<span class="number">0</span>] = z; fa[z] = y2;</span><br><span class="line">  <span class="built_in">up</span>(y2); <span class="built_in">up</span>(fa[y2]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p+i);</span><br><span class="line">    rp[p[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">  <span class="type">int</span> lim = n*<span class="number">0.6</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=lim+<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">upd</span>(rp[i], <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">bld</span>(<span class="number">1</span>, n+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  rt = (n+<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(y&lt;=lim)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> rkx = <span class="built_in">rnk</span>(id[x]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(rkx&gt;lim)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">upd</span>(x, <span class="number">-1</span>);</span><br><span class="line">          <span class="built_in">upd</span>(val[<span class="built_in">kth</span>(rt, lim+<span class="number">1</span>)], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ins</span>(rkx+<span class="number">1</span>, y+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(y)-<span class="built_in">ask</span>(x<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rope 块状链表实现的STL容器</title>
      <link href="/2020/12/13/rope-kuai-zhuang-lian-biao-shi-xian-de-stl-rong-qi/"/>
      <url>/2020/12/13/rope-kuai-zhuang-lian-biao-shi-xian-de-stl-rong-qi/</url>
      
        <content type="html"><![CDATA[<p>crope = rope（可以直接cin cout）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br></pre></td></tr></table></figure><p>可以较快速的解决区间移动、区间插入删除、区间翻转问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rp.<span class="built_in">push_back</span>(x); <span class="comment">// 在末尾插入 x</span></span><br><span class="line">rp.<span class="built_in">insert</span>(pos, x); <span class="comment">// 从pos 处插入一个数组x</span></span><br><span class="line">rp.<span class="built_in">erase</span>(pos, x); <span class="comment">// 从pos 处删除 x 个元素</span></span><br><span class="line">rp.<span class="built_in">length</span>(); <span class="comment">// 返回 rp 的大小</span></span><br><span class="line">rp.<span class="built_in">size</span>(); <span class="comment">// 同上</span></span><br><span class="line">rp.<span class="built_in">replace</span>(pos, x); <span class="comment">// 将 pos 处的元素替换成 x</span></span><br><span class="line">rp.<span class="built_in">substr</span>(pos, x); <span class="comment">// 从 pos 处开始提取 x 个元素</span></span><br><span class="line">rp.<span class="built_in">copy</span>(pos, x, s); <span class="comment">// 从 pos 处开始复制 x 个元素到 s(string or char*(末尾要手动加0)) 中</span></span><br><span class="line">rp[x]; <span class="comment">// 访问第 x 个元素</span></span><br><span class="line">rp.<span class="built_in">at</span>(x); <span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">operator</span>.+() <span class="comment">//拼接操作，很快速</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line">rope&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,m,k,l;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)s.<span class="built_in">push_back</span>(i);</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;k);</span><br><span class="line">    s=s.<span class="built_in">substr</span>(l<span class="number">-1</span>,k)+s.<span class="built_in">substr</span>(<span class="number">0</span>,l<span class="number">-1</span>)+s.<span class="built_in">substr</span>(l+k<span class="number">-1</span>,n+<span class="number">1</span>-k-l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line">rope&lt;<span class="type">int</span>&gt;a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,m,x,y;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    a.<span class="built_in">insert</span>(<span class="number">0</span>,a.<span class="built_in">substr</span>(x<span class="number">-1</span>,y));</span><br><span class="line">    a.<span class="built_in">erase</span>(x+y<span class="number">-1</span>,y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">      cout&lt;&lt;a[i];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C、Shuffle Cards 区间移位 splay</title>
      <link href="/2020/12/12/cshuffle-cards-qu-jian-yi-wei-splay/"/>
      <url>/2020/12/12/cshuffle-cards-qu-jian-yi-wei-splay/</url>
      
        <content type="html"><![CDATA[<p>一个序列初始为1-n的排列，现在有m次操作，将一个区间移到最前面。问所有操作结束后的序列是什么</p><p>突然发现没有写过区间平移的问题，然后去找了一道，然后就调了2小时，很难受。</p><p>罗列一下几个易错点：pushup的时候最好特判一下p==0，这时候就直接return，否则总感觉容易出问题splay一个不好的地方就是要加哨兵，反正左后各加一个就完事了偷懒把取区间写了个split，然后就导致了一个问题（bug根源）当要提取的区间是一个空区间就会出现奇奇怪怪的问题（插入和删除的时候需要），因为这时候它会返回0，我就没办法维护我本来需要的返回节点的父亲了。所以最好还是不要写split函数了😭</p><p>说一下区间平移怎么做其实就是区间插入问题，先把一个区间提取出来，把这个区间删除掉，然后假设这个节点要插入到p（要注意前面这个区间删除带来的影响）节点的后面，那就把p转到根，p+1转到p的儿子，则把刚才提取的区间插到p+1的左儿子就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> rt;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], sz[N], fa[N], val[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(!x) <span class="keyword">return</span>; sz[x] = sz[ch[x][<span class="number">0</span>]] + sz[ch[x][<span class="number">1</span>]] + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> p = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  sz[p] = <span class="number">1</span>, fa[p] = f, val[p] = p;</span><br><span class="line">  ch[f][p&gt;f] = p;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">build</span>(l, p<span class="number">-1</span>, p), <span class="built_in">build</span>(p+<span class="number">1</span>, r, p);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x];</span><br><span class="line">    <span class="keyword">if</span>(fa[y]!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">go</span>(ch[p][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span>(val[p]&gt;=<span class="number">2</span> &amp;&amp; val[p]&lt;=n+<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, val[p]<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">go</span>(ch[p][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, n+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  rt = (n+<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    ++a;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">kth</span>(rt, <span class="number">1</span>), y = <span class="built_in">kth</span>(rt, a);</span><br><span class="line">    <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">    <span class="type">int</span> z = ch[y][<span class="number">0</span>];</span><br><span class="line">    fa[z] = <span class="number">0</span>;</span><br><span class="line">    ch[y][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">    <span class="type">int</span> tx = <span class="built_in">kth</span>(rt, b+<span class="number">1</span>), ty = <span class="built_in">kth</span>(rt, b+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">splay</span>(tx); <span class="built_in">splay</span>(ty, tx);</span><br><span class="line">    ch[ty][<span class="number">0</span>] = z;</span><br><span class="line">    fa[z] = ty;</span><br><span class="line">    <span class="built_in">up</span>(ty); <span class="built_in">up</span>(fa[ty]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">go</span>(rt);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2042 [NOI2005]维护数列</title>
      <link href="/2020/12/11/p2042-noi2005wei-hu-shu-lie/"/>
      <url>/2020/12/11/p2042-noi2005wei-hu-shu-lie/</url>
      
        <content type="html"><![CDATA[<p>大毒瘤题区间插入，区间删除，区间覆盖，区间翻转，区间和，区间最大子段和</p><p>只说一下splay的话，区间插入和删除怎么做插入：先把插入的所有节点按照中序遍历建成一棵平衡树，然后把l转到根，l+1转到l的儿子，那么直接把这颗平衡树的根作为l+1的左儿子即可删除：同样的，把l-1转到根，r+1转到l-1的儿子，然后直接把r的左儿子变成0即可。这道题操作比较多，需要考虑空间回收。很简单，只要把这课丢掉的树遍历一下每个节点的编号塞到一个数组中，然后每次新开节点的时候，如果数组中有编号就直接取一个，否则再新开节点，不过复用节点要注意信息的清空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e6</span> + <span class="number">5</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], id[N];</span><br><span class="line"><span class="type">int</span> buc[N], tp;</span><br><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (tp ? buc[tp--] : ++tot); &#125;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], sz[N], val[N], sum[N], mx[N], lx[N], rx[N], fa[N];</span><br><span class="line"><span class="type">bool</span> same[N], rev[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> l = ch[p][<span class="number">0</span>], r = ch[p][<span class="number">1</span>];</span><br><span class="line">  sum[p] = sum[l] + sum[r] + val[p];</span><br><span class="line">  sz[p] = sz[l] + sz[r] + <span class="number">1</span>;</span><br><span class="line">  mx[p] = <span class="built_in">max</span>(&#123;mx[l], mx[r], rx[l]+lx[r]+val[p]&#125;);</span><br><span class="line">  lx[p] = <span class="built_in">max</span>(lx[l], sum[l]+val[p]+lx[r]);</span><br><span class="line">  rx[p] = <span class="built_in">max</span>(rx[r], sum[r]+val[p]+rx[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setv</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  val[p] = v, sum[p] = v*sz[p];</span><br><span class="line">  lx[p] = rx[p] = (sum[p]&gt;<span class="number">0</span> ? sum[p] : <span class="number">0</span>);</span><br><span class="line">  mx[p] = (sum[p]&gt;<span class="number">0</span> ? sum[p] : val[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setrev</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">swap</span>(ch[p][<span class="number">0</span>], ch[p][<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">swap</span>(lx[p], rx[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = ch[p][<span class="number">0</span>], r = ch[p][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(same[p])</span><br><span class="line">  &#123;</span><br><span class="line">    same[l] = <span class="number">1</span>, <span class="built_in">setv</span>(l, val[p]);</span><br><span class="line">    same[r] = <span class="number">1</span>, <span class="built_in">setv</span>(r, val[p]);</span><br><span class="line">    same[p] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(rev[p])</span><br><span class="line">  &#123;</span><br><span class="line">    rev[l] ^= <span class="number">1</span>, <span class="built_in">setrev</span>(l);</span><br><span class="line">    rev[r] ^= <span class="number">1</span>, <span class="built_in">setrev</span>(r);</span><br><span class="line">    rev[p] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x], z = fa[y];</span><br><span class="line">    <span class="keyword">if</span>(z!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l<span class="number">-1</span>), y = <span class="built_in">kth</span>(rt, r+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="keyword">return</span> ch[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makesame</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setv</span>(x, v), same[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setrev</span>(x), rev[x] ^= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rec</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> l = ch[x][<span class="number">0</span>], r = ch[x][<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">rec</span>(l); <span class="built_in">rec</span>(r);</span><br><span class="line">  buc[++tp] = x;</span><br><span class="line">  fa[x] = ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = <span class="number">0</span>, rev[x] = same[x] = <span class="number">0</span>;</span><br><span class="line">  sz[x] = val[x] = sum[x] = mx[x] = lx[x] = rx[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">rec</span>(ch[y][<span class="number">0</span>]); ch[y][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bld</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, p = id[mid];</span><br><span class="line">  val[p] = a[mid];</span><br><span class="line">  <span class="keyword">if</span>(f) fa[p] = id[f], ch[id[f]][mid&gt;f] = p;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    mx[p] = sum[p] = a[l];</span><br><span class="line">    same[p] = rev[p] = <span class="number">0</span>;</span><br><span class="line">    lx[p] = rx[p] = <span class="built_in">max</span>(a[l], <span class="number">0</span>);</span><br><span class="line">    sz[p] = <span class="number">1</span>;</span><br><span class="line">    ch[p][<span class="number">0</span>] = ch[p][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bld</span>(l, mid<span class="number">-1</span>, mid);</span><br><span class="line">  <span class="built_in">bld</span>(mid+<span class="number">1</span>, r, mid);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=r-l+<span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    id[i] = <span class="built_in">newnode</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bld</span>(<span class="number">1</span>, r-l+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l), y = <span class="built_in">kth</span>(rt, l+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="type">int</span> z = id[(r-l+<span class="number">2</span>)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">  fa[z] = y, ch[y][<span class="number">0</span>] = z;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  mx[<span class="number">0</span>] = -inf, a[<span class="number">1</span>] = -inf, a[n+<span class="number">2</span>] = inf;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i+<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n+<span class="number">2</span>; i++) id[i] = <span class="built_in">newnode</span>();</span><br><span class="line">  <span class="built_in">bld</span>(<span class="number">1</span>, n+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  rt = (n+<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> com[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, com);</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]!=<span class="string">&#x27;M&#x27;</span>||com[<span class="number">2</span>]!=<span class="string">&#x27;X&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    ++l, r = l + r - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>) <span class="built_in">ins</span>(l, r);</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>) <span class="built_in">del</span>(l, r);</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(com[<span class="number">2</span>]==<span class="string">&#x27;X&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mx[<span class="built_in">split</span>(<span class="number">2</span>, sz[rt]<span class="number">-1</span>)]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">        <span class="built_in">makesame</span>(l, r, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>) <span class="built_in">reverse</span>(l, r);</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;G&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum[<span class="built_in">split</span>(l, r)]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3215 [HNOI2011]括号修复 / [JSOI2011]括号序列</title>
      <link href="/2020/12/11/p3215-hnoi2011gua-hao-xiu-fu-jsoi2011gua-hao-xu-lie/"/>
      <url>/2020/12/11/p3215-hnoi2011gua-hao-xiu-fu-jsoi2011gua-hao-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>给定一个括号序列，要求支持下面的操作</p><ul><li>替换某个区间的所有括号为左括号或者右括号</li><li>将一个区间的括号进行翻转</li><li>将一个区间的括号进行反转，左括号&lt;-&gt;右括号</li><li>询问一个区间内至少改变几个括号才能成为一个合法的括号序列</li></ul><p>毒瘤题不过我连询问的答案是什么都想错了（好菜啊）先消掉合法的括号，最后肯定是))))((((的形式，维护区间前缀最小和后缀最大即可，由于有反转操作还要维护区间前缀最大和后缀最小。感觉自己对平衡树维护的题还是不熟，每次都一堆错误。最主要的问题就是忘记了本节点信息，主要是线段树的信息完全由子节点合并而来，但是在平衡树中本节点的信息是不包含在子节点中的。此外在建树的时候每个节点的信息都要记录下来，而不是像线段树一样只在叶子节点的时候记录，然后其余节点直接通过pushup得到即可，切记！！然后就是下传标记的问题，主要是反转和覆盖操作的先后顺序会有影响，然后我竟然就不会了（不是和加法乘法一样吗， <s>好久没写了</s> ）在覆盖的时候，可以把反转和翻转的标记清零。在反转的时候，需要把覆盖的标记取反。然后下传的时候先传反转，然后再传覆盖，因为这个时候肯定是先有反转再有覆盖的，否则覆盖会把反转的标记清掉。顺便回忆一下加法和乘法标记，在乘法的时候要把加法标记也乘一下，在下传的时候先传乘法再传加法。这种多标记的问题，最好对每个标记写一个函数，否则会很乱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">char</span> c[N];</span><br><span class="line"><span class="type">int</span> rt;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], sz[N], val[N], fa[N], lmn[N], rmn[N], lmx[N], rmx[N], sum[N];</span><br><span class="line"><span class="type">int</span> rev[N], cov[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> l = ch[p][<span class="number">0</span>], r = ch[p][<span class="number">1</span>];</span><br><span class="line">  sz[p] = sz[l] + sz[r] + <span class="number">1</span>;</span><br><span class="line">  lmn[p] = <span class="built_in">min</span>(lmn[l], sum[l]+val[p]+lmn[r]);</span><br><span class="line">  lmx[p] = <span class="built_in">max</span>(lmx[l], sum[l]+val[p]+lmx[r]);</span><br><span class="line">  rmn[p] = <span class="built_in">min</span>(rmn[r], sum[r]+val[p]+rmn[l]);</span><br><span class="line">  rmx[p] = <span class="built_in">max</span>(rmx[r], sum[r]+val[p]+rmx[l]);</span><br><span class="line">  sum[p] = sum[l] + sum[r] + val[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setv</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  val[p] = v, sum[p] = v*sz[p];</span><br><span class="line">  lmn[p] = rmn[p] = <span class="built_in">min</span>(<span class="number">0</span>, sum[p]);</span><br><span class="line">  lmx[p] = rmx[p] = <span class="built_in">max</span>(<span class="number">0</span>, sum[p]);</span><br><span class="line">  cov[p] = v;</span><br><span class="line">  inv[p] = <span class="number">0</span>;</span><br><span class="line">  rev[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setrev</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">swap</span>(ch[p][<span class="number">0</span>], ch[p][<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">swap</span>(lmn[p], rmn[p]);</span><br><span class="line">  <span class="built_in">swap</span>(lmx[p], rmx[p]);</span><br><span class="line">  rev[p] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setinv</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">swap</span>(lmn[p], lmx[p]);</span><br><span class="line">  <span class="built_in">swap</span>(rmn[p], rmx[p]);</span><br><span class="line">  lmn[p] *= <span class="number">-1</span>;</span><br><span class="line">  lmx[p] *= <span class="number">-1</span>;</span><br><span class="line">  rmn[p] *= <span class="number">-1</span>;</span><br><span class="line">  rmx[p] *= <span class="number">-1</span>;</span><br><span class="line">  sum[p] *= <span class="number">-1</span>;</span><br><span class="line">  val[p] *= <span class="number">-1</span>;</span><br><span class="line">  inv[p] ^= <span class="number">1</span>;</span><br><span class="line">  cov[p] *= <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(inv[p])</span><br><span class="line">  &#123;</span><br><span class="line">    inv[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setinv</span>(ch[p][<span class="number">0</span>]); <span class="built_in">setinv</span>(ch[p][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cov[p])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setv</span>(ch[p][<span class="number">0</span>], cov[p]); <span class="built_in">setv</span>(ch[p][<span class="number">1</span>], cov[p]);</span><br><span class="line">    cov[p] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(rev[p])</span><br><span class="line">  &#123;</span><br><span class="line">    rev[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setrev</span>(ch[p][<span class="number">0</span>]); <span class="built_in">setrev</span>(ch[p][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> p = (l+r)&gt;&gt;<span class="number">1</span>, v = (c[p<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">  sz[p] = <span class="number">1</span>, sum[p] = val[p] = v;</span><br><span class="line">  fa[p] = f, ch[f][p&gt;f] = p;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    lmx[p] = rmx[p] = <span class="built_in">max</span>(<span class="number">0</span>, v);</span><br><span class="line">    lmn[p] = rmn[p] = <span class="built_in">min</span>(<span class="number">0</span>, v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>(l, p<span class="number">-1</span>, p); <span class="built_in">build</span>(p+<span class="number">1</span>, r, p);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x];</span><br><span class="line">    <span class="keyword">if</span>(fa[y]!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l<span class="number">-1</span>), y = <span class="built_in">kth</span>(rt, r+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="keyword">return</span> ch[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setv</span>(x, v);</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setrev</span>(x);</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setinv</span>(x);</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, n+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  rt = (n+<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> com[<span class="number">10</span>], cc[<span class="number">2</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, com, &amp;l, &amp;r);</span><br><span class="line">    ++l, ++r;</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, cc);</span><br><span class="line">      <span class="built_in">replace</span>(l, r, (cc[<span class="number">0</span>]==<span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x = <span class="built_in">split</span>(l, r);</span><br><span class="line">      <span class="type">int</span> pmn = lmn[x], smx = rmx[x];</span><br><span class="line">      <span class="type">int</span> y = fa[x];</span><br><span class="line">      <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">      <span class="built_in">assert</span>(pmn&lt;=<span class="number">0</span>); <span class="built_in">assert</span>(smx&gt;=<span class="number">0</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((-pmn+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)+((smx+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>) <span class="built_in">reverse</span>(l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>) <span class="built_in">invert</span>(l, r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡树之splay</title>
      <link href="/2020/12/11/ping-heng-shu-zhi-splay/"/>
      <url>/2020/12/11/ping-heng-shu-zhi-splay/</url>
      
        <content type="html"><![CDATA[<p>伸展树的核心操作就是splay了，将每次访问的点splay到根节点（类似输入法，频繁打的词会比较靠前）。而正确的splay操作可以保证在将x旋转到根节点的过程中，沿途的所有父节点的深度都会至少减少一半，这种自我调整的特性保证了splay树在各种操作下均摊$O(\log n)$rotate需要分3种情况，splay需要分6种情况比较麻烦，不再赘述（ <s>其实是不会</s> ），只给出代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x];</span><br><span class="line">    <span class="keyword">if</span>(fa[y]!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>splay(x,g)表示将x旋转到g的儿子处，当g=0时即将x旋转到根。用splay来维护权值大小我觉得很麻烦，码量和常数都比较大，一般情况下用pbds或者fhqtreap替代即可。但是用splay来维护区间还是需要只要的。做法也很简单，如果要维护[l,r]，先把l-1旋转到根，再把r+1旋转到l-1的儿子，那么此时r+1的左子树就是要操作的[l,r]部分，直接对这个根节点打上相应的标记即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l<span class="number">-1</span>), y = <span class="built_in">kth</span>(rt, r+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="keyword">return</span> ch[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pushdown操作只需要在kth函数中进行即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而pushup操作在每次进行split区间操作后都要执行，假设split返回的节点是x，那么就要pushup(y)以及pushup(fa[y])：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setv</span>(x, v);</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实splay的所有操作都可以用fhqtreap来替代，不过在区间操作中要找到区间下标x的点这一功能还是splay方便，只需要把这个点splay到根就可以了，而treap则需要额外维护父亲，而自下而上找。当然splay无可替代的地方就是LCT了，如果用treap就会多一个log。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5217 贫穷 fhq treap</title>
      <link href="/2020/12/07/p5217-pin-qiong-fhq-treap/"/>
      <url>/2020/12/07/p5217-pin-qiong-fhq-treap/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串序列要求支持以下操作</p><ul><li>在x位置后插入一个字母</li><li>删除x位置的字母</li><li>翻转区间[x,y]</li><li>输出初始字符串序列第x个字母当前位置</li><li>输出当前字符串序列第x个字母</li><li>输出区间[x,y]字母种类数</li></ul><p>前三个很简单。第四个要查节点号为x的字母的位置，由于是维护区间，按size分裂，所以自上而下找不了，只能额外维护父亲，然后自下而上找。由于第三个区间翻转操作，导致左右儿子可能会改变，所以要先到根节点把所有懒标记pushdown下来，再自下而上找才能正确第五个就是查第k大（区间意义下），直接split和merge比较好，如果是从根递归着走，不要忘记pushdown第六个状压维护一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>|<span class="built_in">rand</span>(); &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> mask, sz, fa, key, c;</span><br><span class="line">  <span class="type">bool</span> rev;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = ++tot;</span><br><span class="line">  t[p].ls = t[p].rs = t[p].fa = <span class="number">0</span>;</span><br><span class="line">  t[p].mask = <span class="number">1</span>&lt;&lt;c, t[p].c = c, t[p].key = <span class="built_in">rnd</span>();</span><br><span class="line">  t[p].sz = <span class="number">1</span>;</span><br><span class="line">  t[p].rev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + <span class="number">1</span>;</span><br><span class="line">  t[p].mask = t[t[p].ls].mask | t[t[p].rs].mask | (<span class="number">1</span>&lt;&lt;t[p].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t[p].rev)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">swap</span>(t[p].ls, t[p].rs);</span><br><span class="line">    t[t[p].ls].rev ^= <span class="number">1</span>;</span><br><span class="line">    t[t[p].rs].rev ^= <span class="number">1</span>;</span><br><span class="line">    t[p].rev = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> k, <span class="type">int</span> fx=<span class="number">0</span>, <span class="type">int</span> fy=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123; x = y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz)</span><br><span class="line">  &#123;</span><br><span class="line">    y = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].ls, x, t[p].ls, k, fx, p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    x = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].rs, t[p].rs, y, k-t[t[p].ls].sz<span class="number">-1</span>, p, fy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x) t[x].fa = fx;</span><br><span class="line">  <span class="keyword">if</span>(y) t[y].fa = fy;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) &#123; p = x|y; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">down</span>(x);</span><br><span class="line">    p = x;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].rs, t[p].rs, y);</span><br><span class="line">    t[t[p].rs].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">down</span>(y);</span><br><span class="line">    p = y;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].ls, x, t[p].ls);</span><br><span class="line">    t[t[p].ls].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downall</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">downall</span>(t[p].fa);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">downall</span>(p);</span><br><span class="line">  <span class="type">int</span> rk = t[t[p].ls].sz + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(t[p].fa)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t[t[p].fa].rs==p) rk += t[t[p].fa].sz - t[p].sz;</span><br><span class="line">    p = t[p].fa;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rk*(p==rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].ls, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k==t[t[p].ls].sz+<span class="number">1</span>) <span class="keyword">return</span> t[p].c;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].rs, k-t[t[p].ls].sz<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">newnode</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">merge</span>(rt, rt, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> opt[<span class="number">2</span>], c[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">    <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;k, c);</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">split</span>(rt, x, y, k);</span><br><span class="line">      z = <span class="built_in">newnode</span>(c[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">      <span class="built_in">merge</span>(x, x, z);</span><br><span class="line">      <span class="built_in">merge</span>(rt, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">split</span>(rt, x, y, k);</span><br><span class="line">      <span class="built_in">split</span>(x, x, z, k<span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">merge</span>(rt, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">split</span>(rt, x, y, r);</span><br><span class="line">      <span class="built_in">split</span>(x, z, x, l<span class="number">-1</span>);</span><br><span class="line">      t[x].rev ^= <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">merge</span>(x, z, x);</span><br><span class="line">      <span class="built_in">merge</span>(rt, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get</span>(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, <span class="built_in">char</span>(<span class="built_in">kth</span>(rt, k)+<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">split</span>(rt, x, y, r);</span><br><span class="line">      <span class="built_in">split</span>(x, z, x, l<span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, __builtin_popcount(t[x].mask));</span><br><span class="line">      <span class="built_in">merge</span>(x, z, x);</span><br><span class="line">      <span class="built_in">merge</span>(rt, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡树之FHQ Treap</title>
      <link href="/2020/12/06/ping-heng-shu-zhi-fhq-treap/"/>
      <url>/2020/12/06/ping-heng-shu-zhi-fhq-treap/</url>
      
        <content type="html"><![CDATA[<p>treap，顾名思义tree+heap既有平衡树的性质：左儿子权值&lt;本节点权值&lt;右儿子权值，中序遍历有序，且树高尽可能小又有heap的性质：键值满足小根堆，左儿子的键值和右儿子的键值都大于本节点的键值而FHQ Treap仅仅通过两个函数就能够进行维护，思想好懂，代码也很简洁。更重要的是相比于之前的替罪羊树或者pbds这种只能维护大小关系的平衡树而言，它可以胜任splay拥有的维护区间的特质。首先是普通的维护大小关系：split函数，将一棵树按照给定的权值v划分成两棵树，并且保证第一棵树的权值均小于等于v，第二棵树的权值均大于v。显然只要递归分裂的树，考虑当前节点的权值和给定的v的关系即可。注意分裂的两个节点传引用。merge函数，将两棵树合成一棵树，要求第一棵树的权值均小于等于第二棵树同样是递归考虑，那么当前两棵树谁的根作为合并的树的根呢？按照权值来看都是可以的，但是为了保持平衡性，就要维护键值的小根堆性质，所以让键值小的那个节点作为根即可。注意合并的那个节点要传引用。由于split和merge都会改变父子关系，所以最后要pushup维护好子树的信息。而对于普通平衡树所支持的插入、删除、第k大、排名、前驱、后继等等，只要基于split和merge两个函数就可以轻松实现，比较简单， <s>懒得写了</s>p6136：fhq treap 8.2s，替罪羊5.81s，不过fhq treap代码短点。当然两者都很好理解。一般情况下fhqtreap足以应对所有情况（除了LCT以及重度卡常题（紫荆花之恋？听说），所以splay还是得懂）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> val, key, sz;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> tot, rt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>)|<span class="built_in">rand</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = ++tot;</span><br><span class="line">  t[p].val = v, t[p].sz = <span class="number">1</span>;</span><br><span class="line">  t[p].ls = t[p].rs = <span class="number">0</span>;</span><br><span class="line">  t[p].key = <span class="built_in">rnd</span>();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123; a = b = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[p].val&lt;=v) &#123; a = p; <span class="built_in">split</span>(t[p].rs, t[a].rs, b, v); &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; b = p; <span class="built_in">split</span>(t[p].ls, a, t[b].ls, v); &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!a||!b) &#123; p = a|b; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[a].key&lt;t[b].key) &#123; p = a; <span class="built_in">merge</span>(t[p].rs, t[a].rs, b); &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; p = b; <span class="built_in">merge</span>(t[p].ls, a, t[b].ls); &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="built_in">newnode</span>(v);</span><br><span class="line">  <span class="built_in">split</span>(p, x, y, v);</span><br><span class="line">  <span class="built_in">merge</span>(x, x, z); <span class="built_in">merge</span>(p, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">split</span>(p, x, y, v); <span class="built_in">split</span>(x, x, z, v<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">merge</span>(z, t[z].ls, t[z].rs);</span><br><span class="line">  <span class="built_in">merge</span>(x, x, z); <span class="built_in">merge</span>(p, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].ls, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k==t[t[p].ls].sz+<span class="number">1</span>) <span class="keyword">return</span> t[p].val;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].rs, k-t[t[p].ls].sz<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Less</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v, <span class="type">bool</span> eq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">split</span>(p, x, y, v<span class="number">-1</span>+eq);</span><br><span class="line">  <span class="type">int</span> ans = t[x].sz;</span><br><span class="line">  <span class="built_in">merge</span>(p, x, y);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">int</span>(<span class="built_in">time</span>(<span class="number">0</span>)));</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, x; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">ins</span>(rt, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">    x ^= last;</span><br><span class="line">    <span class="keyword">switch</span>(op)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">ins</span>(rt, x); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">del</span>(rt, x); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: last = <span class="built_in">Less</span>(rt, x, <span class="number">0</span>) + <span class="number">1</span>; ans ^= last; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: last = <span class="built_in">kth</span>(rt, x); ans ^= last; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>: last = <span class="built_in">kth</span>(rt, <span class="built_in">Less</span>(rt, x, <span class="number">0</span>)); ans ^= last; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: last = <span class="built_in">kth</span>(rt, <span class="built_in">Less</span>(rt, x, <span class="number">1</span>)+<span class="number">1</span>); ans ^= last;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是维护区间，也很简单，改一下split和merge的定义即可。split，给定一个树，把一棵树的前k个节点划分给一棵树，剩余节点划分给另一棵树merge，将两棵树合并成一棵树，需要保证一棵树完全处在另一棵树的前面写法和上面类似，不再赘述考虑对区间[l,r]的操作怎么做：先把rt的前r个节点split给x，其他的丢给y再把x的前l-1个节点split给z此时x就是[l,r]区间内所有节点构成的treap的根了，直接在根上打标记即可。最后按照顺序z，x，y进行merge。考虑pushup和pushdown在什么时候进行。pushup是要维护当前子树的信息，因此需要在左右儿子改变后调用，而pushdown是为了下放赖在当前节点上的懒标记，所以要在左右儿子改变前调用，想清楚这两点就知道了，应该在split和merge进入子树前pushdown，在回溯上来之后再pushup。p3391 文艺平衡树，区间翻转，显然只要把要操作的区间split出来然后在根上打一个翻转标记即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>|<span class="built_in">rand</span>(); &#125;</span><br><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> val, key, sz;</span><br><span class="line">  <span class="type">bool</span> tag;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">swap</span>(t[p].ls, t[p].rs);</span><br><span class="line">  <span class="keyword">if</span>(t[p].ls) t[t[p].ls].tag ^= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].rs) t[t[p].rs].tag ^= <span class="number">1</span>;</span><br><span class="line">  t[p].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = ++tot;</span><br><span class="line">  t[p].val = v;</span><br><span class="line">  t[p].sz = <span class="number">1</span>; t[p].tag = <span class="number">0</span>;</span><br><span class="line">  t[p].ls = t[p].rs = <span class="number">0</span>;</span><br><span class="line">  t[p].key = <span class="built_in">rnd</span>();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123; x = y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) &#123; y = p; <span class="built_in">split</span>(t[p].ls, x, t[p].ls, k); &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; x = p, <span class="built_in">split</span>(t[p].rs, t[p].rs, y, k-t[t[p].ls].sz<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) &#123; p = x|y; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t[x].tag) <span class="built_in">down</span>(x);</span><br><span class="line">    p = x;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].rs, t[x].rs, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t[y].tag) <span class="built_in">down</span>(y);</span><br><span class="line">    p = y;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].ls, x, t[y].ls);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">newnode</span>(v);</span><br><span class="line">  <span class="built_in">merge</span>(p, p, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="built_in">split</span>(rt, x, y, r);</span><br><span class="line">  <span class="built_in">split</span>(x, z, x, l<span class="number">-1</span>);</span><br><span class="line">  t[x].tag ^= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">merge</span>(x, z, x);</span><br><span class="line">  <span class="built_in">merge</span>(rt, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="built_in">print</span>(t[p].ls);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t[p].val);</span><br><span class="line">  <span class="built_in">print</span>(t[p].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">int</span>(<span class="built_in">time</span>(<span class="number">0</span>)));</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">ins</span>(rt, i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="built_in">rev</span>(l, r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(rt);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护区间信息的时候，一定要注意平衡树和线段树是不一样的，线段树只要左右儿子取优即可（因为本节点维护的区间是左右儿子维护的区间的并），而平衡树左右儿子维护的信息是不包含本节点的，所以还需要维护本节点的值，和该值再取优。在维护区间的时候，就丧失了权值大小的比较了，那么如何知道编号为i的节点在区间中的哪个位置呢？显然从根开始是不知道该走左还是右的。但是如果我们从i节点不断跳父亲直至根，然后不断维护小于你的节点个数就可以了，而treap的树高是$\log n$级别的，复杂度没问题。要维护节点的父亲，一种简单的做法是在pushup的时候维护一下p的左右儿子的父亲为p，但这样子是有问题的，根节点的fa值是错误的，没法及时清零，当然如果只有一棵treap，且知道根节点的编号，就可以通过==rt来判断，否则就应该在split和merge中维护fa：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> fx, <span class="type">int</span> fy, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123; x = y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz)</span><br><span class="line">  &#123;</span><br><span class="line">    y = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].ls, x, t[p].ls, fx, p, k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    x = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].rs, t[p].rs, y, p, fy, k-t[t[p].ls].sz<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x) t[x].fa = fx;</span><br><span class="line">  <span class="keyword">if</span>(y) t[y].fa = fy;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) &#123; p = x|y; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">  &#123;</span><br><span class="line">    p = x;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].rs, t[p].rs, y);</span><br><span class="line">    t[t[p].rs].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    p = y;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].ls, x, t[p].ls);</span><br><span class="line">    t[t[p].ls].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回编号为p的节点所在treap的根节点，以及在原数组中的下标：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">get</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> rk = t[t[p].ls].sz + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(t[p].fa)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p==t[t[p].fa].rs) rk += t[t[p].fa].sz - t[p].sz;</span><br><span class="line">    p = t[p].fa;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make_pair</span>(p, rk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡树之替罪羊树</title>
      <link href="/2020/12/06/ping-heng-shu-zhi-ti-zui-yang-shu/"/>
      <url>/2020/12/06/ping-heng-shu-zhi-ti-zui-yang-shu/</url>
      
        <content type="html"><![CDATA[<p>很简单的思路，在每次插入和删除的时候，检查一下左右子树是不是失衡，如果失衡就将整棵子树进行拍扁(中序遍历存到数组)，重构(每次以中心点为当前的根，然后递归左右区间)。失衡的判定：当左子树或者右子树的大小超过了整个子树大小的某个比例alpha（一般定义在0.7~0.8）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bad</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> t[p].cnt &amp;&amp; t[p].sz*alpha&lt;<span class="built_in">max</span>(t[t[p].ls].sz, t[t[p].rs].sz); &#125;</span><br></pre></td></tr></table></figure><p>几个细节：</p><ul><li>删除的实现采用最简单的惰性删除，找到对应的节点后让cnt–即可，即使等于0也没有关系，因为在拍扁重构的时候可以把等于0的节点直接丢弃掉</li><li>由于插入删除的时候可能需要重构，因此一定要记得传引用</li><li>这种平衡树最大的特点就是好写加常数小(均摊mlogn)</li></ul><p>记住拍扁重构的思想应该就很容易手写了吧</p><p>前驱、后继、第k大、排名其实没必要每个都实现一个函数。只需要实现求第k大，然后求小于x的数的个数以及小于等于x的数的个数即可，只与后两者只有细微的差异，完全可以合并到一个函数中洛谷模板p3369开O2 170ms：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> alpha = <span class="number">0.7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> val, sz, cnt;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + t[p].cnt; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bad</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> t[p].cnt &amp;&amp; t[p].sz*alpha&lt;<span class="built_in">max</span>(t[t[p].ls].sz, t[t[p].rs].sz); &#125;</span><br><span class="line"><span class="type">int</span> ord[N], top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(t[p].ls);</span><br><span class="line">  <span class="keyword">if</span>(t[p].cnt) ord[++top] = p;</span><br><span class="line">  <span class="built_in">dfs</span>(t[p].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, p = ord[mid];</span><br><span class="line">  t[p].ls = <span class="built_in">build</span>(l, mid<span class="number">-1</span>);</span><br><span class="line">  t[p].rs = <span class="built_in">build</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(p);</span><br><span class="line">  p = <span class="built_in">build</span>(<span class="number">1</span>, top);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = ++tot;</span><br><span class="line">  t[p].val = v, t[p].ls = t[p].rs = <span class="number">0</span>;</span><br><span class="line">  t[p].cnt = t[p].sz = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="built_in">newnode</span>(p, v);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v==t[p].val) t[p].cnt++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="built_in">ins</span>(t[p].ls, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">ins</span>(t[p].rs, v);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bad</span>(p)) <span class="built_in">rebuild</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v==t[p].val) t[p].cnt--;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="built_in">del</span>(t[p].ls, v);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">del</span>(t[p].rs, v);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">bad</span>(p)) <span class="built_in">rebuild</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Less</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v, <span class="type">bool</span> eq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].cnt&amp;&amp;v==t[p].val) <span class="keyword">return</span> t[t[p].ls].sz + t[p].cnt*eq;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="keyword">return</span> <span class="built_in">Less</span>(t[p].ls, v, eq);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> t[t[p].ls].sz + t[p].cnt + <span class="built_in">Less</span>(t[p].rs, v, eq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].ls, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(t[t[p].ls].sz+t[p].cnt&gt;=k) <span class="keyword">return</span> t[p].val;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].rs, k-t[p].cnt-t[t[p].ls].sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span>(n--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> t, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="built_in">ins</span>(rt, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>) <span class="built_in">del</span>(rt, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Less</span>(rt, x, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">kth</span>(rt, x));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">kth</span>(rt, <span class="built_in">Less</span>(rt, x, <span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">kth</span>(rt, <span class="built_in">Less</span>(rt, x, <span class="number">1</span>)+<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECPC 2019 Kickoff</title>
      <link href="/2020/12/04/ecpc-2019-kickoff/"/>
      <url>/2020/12/04/ecpc-2019-kickoff/</url>
      
        <content type="html"><![CDATA[<p>除了I没人过（没看），都不难特别简单的略过</p><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>给三根木棍长度a,b,c，再给一个k，你可以选择<strong>一根</strong>木棍让它的长度最多延长k，问你这三根木棍构成的三角形的最大面积</p><p>考虑枚举延长的边，我们可以算出这条边的范围，然后利用余弦定理求出这条边对角的范围，最大化这个角的sin值即可</p><h2 id="K"><a class="header-anchor" href="#K">¶</a>K</h2><p>n盆植物，第i盆初始高度为$h_i$​，生成速度为$g_i$​，问你最短第几天所有植物会形成非降序列</p><p>显然考虑相邻两盆，抽象成直线即可，要么是$[0,l]$,要么是$[r,\inf]$，维护l和r即可</p><h2 id="J"><a class="header-anchor" href="#J">¶</a>J</h2><p>一个序列，只有’a’,‘b’,‘c’，且’b’最多一个，现在可以交换任意两个位置，问你满足相邻两个位置的字母要么相等，要么有一个是’b’</p><p>没有b的时候，显然只有全是a或者全是c才能满足有1个b，只能是aaabcccc或者ccccbaaa的形式，取个min即可</p><h2 id="L"><a class="header-anchor" href="#L">¶</a>L</h2><p>给一个数n，初始有x=0，每次操作从$[0, 2^n-1]$中随机选择一个数r，让$x=x^r$，设期望p步后该数变为0，问期望步数的平方</p><p>答案就是$\sum_{i=1}^{\infty}i^2(1-\frac{1}{2^n})^{i-1}\frac{1}{2^n}$</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p><a data-fancybox="gallery" data-src="/post-images/1607088246259.png" data-caption=""><img src="/post-images/1607088246259.png" alt=""></a>给出一个序列，然后执行一次上述函数后，问你得到的序列这个函数就是每次优先找到跟你与运算不等于0的数，如果没有这样的数，再找到第一个与运算等于0的。考虑优化找这个数的过程与不等于0，那肯定有一位你是1，它也是1。用30个队列，每个队列存第i位为1的数的下标那么如果当前进行到u，枚举30位，找到队列中第一个没访问过的数，取它们的最小数就是下一个数了。显然访问过的数可以pop掉。如果没有这样的数了，剩下没访问过的显然跟你与运算都是0，用个链表维护即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], b[N], top;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q[<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> to[N], from[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">  vis[u] = <span class="number">1</span>; b[++top] = a[u]; to[from[u]] = to[u]; from[to[u]] = from[u];</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> nxt = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">30</span>; i++)</span><br><span class="line">      <span class="keyword">if</span>((a[u]&gt;&gt;i)&amp;<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q[i].<span class="built_in">empty</span>() &amp;&amp; vis[q[i].<span class="built_in">front</span>()]) q[i].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!q[i].<span class="built_in">empty</span>()) nxt = <span class="built_in">min</span>(nxt, q[i].<span class="built_in">front</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span>(nxt==n+<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(nxt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> nxt = to[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">while</span>(nxt&lt;=n &amp;&amp; vis[nxt]) nxt = to[nxt];</span><br><span class="line">  <span class="keyword">if</span>(nxt&lt;=n) <span class="built_in">dfs</span>(nxt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;sorting.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    to[i] = i + <span class="number">1</span>; from[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=<span class="number">30</span>; j++)</span><br><span class="line">      <span class="keyword">if</span>((a[i]&gt;&gt;j)&amp;<span class="number">1</span>) q[j].<span class="built_in">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, b[i], <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a class="header-anchor" href="#D">¶</a>D</h3><p>有一个无向图，然后给你q个二元组(d,c)，表示在第d天之前访问过c，问你第0天的起点可能有几个按照d升序给出，其中第i天你可以选择不动，也可以选择移到相邻的一个节点$n \leq 2000,m\leq 10^4$</p><p>显然在每个点跑一遍bfs求出两两的最短路，相邻二元组的城市我们都走最短路，如果后面天数不够，只能往前面借，假设后面最多欠了x天，那么起点和$c_1$​的距离要满足$\leq d_1-x$。一个错误是我把bfs的距离初始化成-1，然后某些点和$c_1$​可能不连通，我也把它算作可行点了</p><h3 id="F"><a class="header-anchor" href="#F">¶</a>F</h3><p>还以为是道高深计算几何，然而是个数位dp有两条斜率为$s_1,s_2$​,且都是2的幂次的过原点的直线，给定$x_l,x_r$​让你求$\sum_{i=x_l}^{x_r} (s_1i) \otimes (s_2i)$首先可以转成前缀和，把下界限变成0，然后设$2^{k_1}=s_1,2^{k_2}=s_2$把式子变成$\sum_{i=0}^{n}(i&lt;&lt;k_1) \otimes(i&lt;&lt;k_2)$设$k_1&lt;k_2$​，去掉$k_1$​，$k_2$​变成$k=k_2-k_1$​，最后答案乘上$2^{k_1}$​则$\sum_{i=0}^{n}i \otimes (i&lt;&lt;k)$显然按位考虑对于$[0,k-1]$位，我们只要统计$[0,n]$中那位等于1的数量对于$[41-k,40]$位，我们也只要统计$[0,n]$中那位等于1的数量对于$[k,40]$位，我们要统计$[0,n]$中x位不等于x-k位的数量写两个数位dp就行了。。写完一个，cv一下改改就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll s1, s2, xl, xr;</span><br><span class="line">ll dp[<span class="number">45</span>][<span class="number">2</span>], dp2[<span class="number">45</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">45</span>], top;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> lim, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  ll &amp;x = dp[p][lim];</span><br><span class="line">  <span class="keyword">if</span>(~x) <span class="keyword">return</span> x;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> up = lim ? a[p] : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(p==t)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(up==<span class="number">1</span>) x = <span class="built_in">dfs</span>(p<span class="number">-1</span>, lim, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)</span><br><span class="line">      x = (x + <span class="built_in">dfs</span>(p<span class="number">-1</span>, lim&amp;&amp;i==up, t))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> lim, <span class="type">int</span> tv, <span class="type">int</span> t, <span class="type">int</span> t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  ll &amp;x = dp2[p][lim][tv];</span><br><span class="line">  <span class="keyword">if</span>(~x) <span class="keyword">return</span> x;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> up = lim ? a[p] : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p==t) x = (x + <span class="built_in">dfs2</span>(p<span class="number">-1</span>, lim&amp;&amp;i==up, i, t, t2))%mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p==t2 &amp;&amp; tv!=i) x = (x + <span class="built_in">dfs2</span>(p<span class="number">-1</span>, lim&amp;&amp;i==up, tv, t, t2))%mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p!=t2) x = (x + <span class="built_in">dfs2</span>(p<span class="number">-1</span>, lim&amp;&amp;i==up, tv, t, t2))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(<span class="type">int</span> k, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    ll n = x;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">      a[top++] = n&amp;<span class="number">1</span>;</span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top&lt;=<span class="number">40</span>) a[top++] = <span class="number">0</span>;</span><br><span class="line">    ans = (ans + (<span class="number">1ll</span>&lt;&lt;i)%mod*<span class="built_in">dfs</span>(top<span class="number">-1</span>, <span class="number">1</span>, i))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">41</span>-k; i&lt;=<span class="number">40</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    ll n = x;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">      a[top++] = n&amp;<span class="number">1</span>;</span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top&lt;=<span class="number">40</span>) a[top++] = <span class="number">0</span>;</span><br><span class="line">    ans = (ans + (<span class="number">1ll</span>&lt;&lt;(i+k))%mod*<span class="built_in">dfs</span>(top<span class="number">-1</span>, <span class="number">1</span>, i))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=k; i&lt;=<span class="number">40</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp2));</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    ll n = x;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">      a[top++] = n&amp;<span class="number">1</span>;</span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top&lt;=<span class="number">40</span>) a[top++] = <span class="number">0</span>;</span><br><span class="line">    ans = (ans + (<span class="number">1ll</span>&lt;&lt;i)%mod*<span class="built_in">dfs2</span>(top<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, i, i-k))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> k1 = <span class="number">0</span>, k2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;s1, &amp;s2, &amp;xl, &amp;xr);</span><br><span class="line">  <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k1)&lt;s1) ++k1;</span><br><span class="line">  <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k2)&lt;s2) ++k2;</span><br><span class="line">  <span class="keyword">if</span>(k1&gt;k2) <span class="built_in">swap</span>(k1, k2);</span><br><span class="line">  <span class="type">int</span> k = k2 - k1;</span><br><span class="line">  <span class="keyword">if</span>(!k) &#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">  ll ans = (<span class="built_in">work</span>(k, xr) - <span class="built_in">work</span>(k, xl<span class="number">-1</span>) + mod)%mod;</span><br><span class="line">  ans = (<span class="number">1ll</span>&lt;&lt;k1)%mod*ans%mod;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;geometry.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H"><a class="header-anchor" href="#H">¶</a>H</h3><p>有一个无向图，然后给你一个某个点s到其他点最短路的数组d，且要求最短路至少要经过一条边这个限制是为了防止$d_s=0$，让你找到最小的满足条件的s</p><p>没有想到很好的做法，给出一种奇怪的做法考虑以s为源点的距离数组构成的最短路图如果这个距离数组是合法的，那么这个最短路图要满足是一个连通的DAG，且只有s的入度等于0我们对每个点i，让$d_i=0$，然后建出最短路图判断一下是否满足以上条件就知道i能不能是源点了下面考虑加速以上做法我们先把原数组的最短路图建出来，对于每个i，把和它有关的边去掉，然后让$d_i=0$，再枚举和它相连的边建出新边即可。那么对于原数组建出的最短路图中的某条边$(i,j)$(i&lt;j)来说，它存在于[1,i−1],[i+1,j−1]，[j+1,n][1,i-1],[i+1,j-1]，[j+1,n][1,i−1],[i+1,j−1]，[j+1,n]这三个区间所以线段树分治即可，在叶子的时候再建出新边。注意维护连通块数量以及入度为0的点数还需要注意要满足i的所有边的权值的最小值要是$d_i$​的一半</p><p>线段树分治在叶子不要忘记rollback<code>if(l==r)</code>不要return</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll s[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; G[N];</span><br><span class="line"><span class="type">int</span> fa[N], sz[N], undo[N*<span class="number">3</span>], top, scc, ans, deg[N], zcnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x!=fa[x]) x = fa[x];</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">  <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(sz[x]&gt;sz[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  undo[++top] = x;</span><br><span class="line">  --scc;</span><br><span class="line">  fa[x] = y;</span><br><span class="line">  sz[y] += sz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rollback</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top&gt;t)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x = undo[top];</span><br><span class="line">    sz[fa[x]] -= sz[x];</span><br><span class="line">    fa[x] = x;</span><br><span class="line">    ++scc;</span><br><span class="line">    --top;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; op[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> px, <span class="type">int</span> py)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">  &#123;</span><br><span class="line">    op[p].<span class="built_in">emplace_back</span>(px, py);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">ins</span>(p&lt;&lt;<span class="number">1</span>, l, mid, x, y, px, py);</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">ins</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, x, y, px, py);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(~ans) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> dfn = top;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : op[p])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">merge</span>(it.fi, it.se);</span><br><span class="line">    <span class="keyword">if</span>(!deg[it.se]) --zcnt;</span><br><span class="line">    ++deg[it.se];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> tmp = top, mn = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[l])</span><br><span class="line">    &#123;</span><br><span class="line">      mn = <span class="built_in">min</span>(mn, it.se);</span><br><span class="line">      <span class="keyword">if</span>(it.se==s[it.fi])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">merge</span>(l, it.fi);</span><br><span class="line">        <span class="keyword">if</span>(!deg[it.fi]) --zcnt;</span><br><span class="line">        ++deg[it.fi];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(scc==<span class="number">1</span> &amp;&amp; zcnt==<span class="number">1</span> &amp;&amp; mn*<span class="number">2</span>==s[l]) ans = l;</span><br><span class="line">    <span class="built_in">rollback</span>(tmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[l])</span><br><span class="line">      <span class="keyword">if</span>(it.se==s[it.fi])</span><br><span class="line">        <span class="keyword">if</span>(!(--deg[it.fi])) ++zcnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">go</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">go</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">rollback</span>(dfn);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : op[p])</span><br><span class="line">    <span class="keyword">if</span>(!(--deg[it.se])) ++zcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;hide.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, s+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    G[u].<span class="built_in">emplace_back</span>(v, w); G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line">  scc = n, ans = <span class="number">-1</span>, zcnt = n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[i])</span><br><span class="line">      <span class="keyword">if</span>(s[i]+it.se==s[it.fi])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> x = i, y = it.fi;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>) <span class="built_in">ins</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x<span class="number">-1</span>, i, it.fi);</span><br><span class="line">        <span class="keyword">if</span>(y&lt;n) <span class="built_in">ins</span>(<span class="number">1</span>, <span class="number">1</span>, n, y+<span class="number">1</span>, n, i, it.fi);</span><br><span class="line">        <span class="keyword">if</span>(x+<span class="number">1</span>&lt;y) <span class="built_in">ins</span>(<span class="number">1</span>, <span class="number">1</span>, n, x+<span class="number">1</span>, y<span class="number">-1</span>, i, it.fi);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="built_in">go</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次剩余</title>
      <link href="/2020/12/03/er-ci-sheng-yu/"/>
      <url>/2020/12/03/er-ci-sheng-yu/</url>
      
        <content type="html"><![CDATA[<p>给定n和奇素数p，求x满足$x^2 \equiv n ($mod$\ p)$</p><p>首先考虑有没有解，有解的n称为二次剩余，无解的n称为非二次剩余根据费马小定理，当p为质数时，满足$n^p \equiv n ($mod$\ p)$由于p是奇质数，则$n^{2\frac{p-1}{2}} \equiv 1 ($mod$\ p)$即$n^{\frac{p-1}{2}}$​为1在模p意义下开根的结果，只有1和-1两种可能有欧拉准则，当$n^{\frac{p-1}{2}} \equiv 1$时，n是二次剩余，否则是非二次剩余。当n是二次剩余时，易得$x^{2\frac{p-1}{2}} \equiv x^{p-1} \equiv 1$成立，必要性得到。充分性以及非二次剩余的证明鸽了。</p><p>再考虑有解时有几个解，设两个不同的解$x_1,x_2$​，则满足$x_1^2 \equivx_2^2$​，即$x_1^2-x_2^2 \equiv (x_1+x_2)(x_1-x_2)\equiv 0$，由于$x_1 \neq x_2$​，只有可能$x_1$和$x_2$互为相反数，由于$p$是奇数，$x_1$和$x_2$的奇偶性一定不同，因此值一定不同。所以除0外每个二次剩余都对应两个解，且这两个解互为相反数。同样的，两个相反数对应了一个二次剩余，因此在$[1,p-1]$中总共有$\frac{p-1}{2}$​个二次剩余</p><p>最后考虑有解时怎么求。先找到一个a，满足$a^2-n$是非二次剩余，随机找即可，一次有$\frac{1}{2}$​的概率找到令$i^2 \equiv a^2-n$有$(a+i)^{p+1} \equiv n$</p><ul><li>$i^p \equiv i(a^2-n)^{\frac{p-1}{2}} \equiv -i$</li><li>$(a+b)^p \equiv a^p+b^p$ 考虑二项式定理$(a+i)^{p+1} \equiv (a^p+i^p)(a+i) \equiv (a-i)(a+i) \equiv n$那么$(a+i)^{\frac{p+1}{2}}$​就是一个解由于$a^2-n$是非二次剩余，因此$i$实际不存在，但是我们可以类似复数一样定义，然后定义乘法即可计算快速幂了，定义形如$a+bi$，则$a+i$就是$a+1i$$(a+bi)(c+di) \equiv (ac+bdi^2+adi+bci)$，把$i^2$用$a^2-n$代替即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ll w, n, p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">  ll x, y;</span><br><span class="line">  <span class="built_in">Complex</span>(<span class="type">int</span> _x,<span class="type">int</span> _y) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">  Complex <span class="keyword">operator</span> * (<span class="type">const</span> Complex &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(((x*b.x%p+y*b.y%p*w%p)%p+p)%p,((x*b.y%p+y*b.x%p)%p+p)%p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ll <span class="title">powcp</span><span class="params">(Complex a,ll b,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Complex <span class="title">ans</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans*a;</span><br><span class="line">    a = a*a;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n %= p;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">powmod</span>(n,(p<span class="number">-1</span>)/<span class="number">2</span>,p)==p<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//无解</span></span><br><span class="line">  ll a;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    a = <span class="built_in">rand</span>()%p;</span><br><span class="line">    w = ((a*a%p-n)%p+p)%p;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">powmod</span>(w,(p<span class="number">-1</span>)/<span class="number">2</span>,p)==p<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Complex <span class="title">x</span><span class="params">(a,<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">powcp</span>(x,(p+<span class="number">1</span>)/<span class="number">2</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">int</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)));</span><br><span class="line">ll ans1 = <span class="built_in">solve</span>(n,p), ans2;</span><br><span class="line"><span class="keyword">if</span>(ans1==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;Hola!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  ans2 = p - ans1;</span><br><span class="line">  <span class="keyword">if</span>(ans1&gt;ans2) <span class="built_in">swap</span>(ans1,ans2);</span><br><span class="line">  <span class="keyword">if</span>(ans1==ans2) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans1);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,ans1,ans2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述做法由于要手写一个复数类，比较麻烦，而且常数也大，还有一种<code>ToneLLi_Shanks</code>算法原理鸽了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">TS</span><span class="params">(ll n, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="number">2</span>) <span class="keyword">return</span> (n&amp;<span class="number">1</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Pow</span>(n, p&gt;&gt;<span class="number">1</span>, p)!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(p&amp;<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">Pow</span>(n, (p+<span class="number">1</span>)&gt;&gt;<span class="number">2</span>, p);</span><br><span class="line">  <span class="type">int</span> s = __builtin_ctzll(p^<span class="number">1</span>);</span><br><span class="line">  ll q = p&gt;&gt;s, z = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span>(; <span class="built_in">Pow</span>(z, p&gt;&gt;<span class="number">1</span>, p)==<span class="number">1</span>; z++);</span><br><span class="line">  ll c = <span class="built_in">Pow</span>(z, q, p);</span><br><span class="line">  ll r = <span class="built_in">Pow</span>(n, (q+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>, p);</span><br><span class="line">  ll t = <span class="built_in">Pow</span>(n, q, p), tmp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> m=s, i; t!=<span class="number">1</span>; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, tmp=t; tmp!=<span class="number">1</span>; i++) tmp = tmp*tmp%p;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;--m; ) c = c*c%p;</span><br><span class="line">    r = r*c%p;</span><br><span class="line">    c = c*c%p;</span><br><span class="line">    t = t*c%p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;p);</span><br><span class="line">  ll ans = <span class="built_in">TS</span>(n, p);</span><br><span class="line">  <span class="keyword">if</span>(ans==<span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Hola!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!ans) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ll ans2 = p - ans;</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;ans2) <span class="built_in">swap</span>(ans, ans2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, ans, ans2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：对于三次剩余若$p % 3 = 2$，则每个数都是三次剩余，并且有唯一解$n^{\frac{2p-1}{3}}$​若$p % 3 = 1$，则有$\frac{p-1}{3}$​个数是三次剩余，且每个数有三个解</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020秦皇岛 J Jewel Splitting</title>
      <link href="/2020/12/03/2020-qin-huang-dao-j-jewel-splitting/"/>
      <url>/2020/12/03/2020-qin-huang-dao-j-jewel-splitting/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>一个长度为n的字符串，让你排成长为d，宽为$\lfloor \frac{n}{d}\rfloor$的矩形，即将连续的长度d的子串作为一行，多余的n%d个丢弃，问有多少种不同的矩形，mod 998244353$n \leq 3 \times 10^5$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>显然不同的d互不影响，可以分开做当$d \mid n$，就是一个可重集排列，用map来维护每种hash值出现的个数当$d \nmid n$，那么我们可能会丢弃$[1,n%d],[d+1,d+n%d]…$，容易发现相邻两种只有两个字符串是不同的，因此动态维护即可。有个问题是，丢弃不同的区间，剩余的串的类型是一模一样的，即这个状态的map是一样的，这时候不能重复算，因此还要对每个时刻的map状态进行hash。思路不难，但是卡常。不双hash会wa，双hash又tle🤡</p><p>字符串的rollinghash的本质其实就是将这个字符串用base进制的数来表示，然后可以O(1)的求每个子区间的hash值（我好像到现在才明白字符串hash就是用base进制数来表示。。。）考虑map的状态怎么求，就相对于有很多pairs，（hash，cnt）。我的做法是把hash值丢到map里然后映射成小的编号，然后cnt就可以用数组来存了，然后map的状态就相当于第id[hash]位的值为cnt，用cnt*pw[id[hash]]来表示即可。如果只要整个串的hash值，各个位的值用异或也是可以，这样可以快点。然后就是双hash的值，用pair的话肯定会慢，这里用int存，然后高低位合并成一个ull即可。</p><p>通过这题测了一下各种map和setunordered_set很没用，set和map比较稳定，unordered_map有时快有时慢，加了手写hash也慢，很不稳定。所以一般情况下还是用set和map就行了，稳定log，unordered容易卡成n如果要实现无序的set，不推荐unordered_set。如果可以离线，那就vector此外pbds的gp_hash_table很快，被卡map可以用这个代替unordered_map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line">gp_hash_table&lt;ull, <span class="type">int</span>&gt; id;</span><br><span class="line">gp_hash_table&lt;ull, <span class="type">bool</span>&gt; vis;</span><br><span class="line">gp_hash_table&lt;ull, null_type&gt; vis;</span><br></pre></td></tr></table></figure><p>无序set也可以用下面两个，测出来bool快一点，null_type内存小点gp_hash_table封装的函数不多，只有下标、insert要实现count，要靠find==end所以最好开局部，不要开全局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map：2700ms</span><br><span class="line">gp_hash_table：1700ms</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">uint64_t</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, mod2 = <span class="number">1e9</span> + <span class="number">9</span>, base = <span class="number">19260817</span>;</span><br><span class="line"><span class="type">int</span> kase;</span><br><span class="line"><span class="type">int</span> n, fac[N&lt;&lt;<span class="number">1</span>], ifac[N&lt;&lt;<span class="number">1</span>], cnt[N&lt;&lt;<span class="number">1</span>], ans, tot;</span><br><span class="line"><span class="type">int</span> HSH, HSH2;</span><br><span class="line"><span class="comment">//map&lt;ull, int&gt; id;</span></span><br><span class="line">gp_hash_table&lt;ull, <span class="type">int</span>&gt; id;</span><br><span class="line">gp_hash_table&lt;ull, <span class="type">bool</span>&gt; vis;</span><br><span class="line"><span class="comment">//map&lt;int, bool&gt; vis;</span></span><br><span class="line"><span class="comment">//set&lt;int&gt; st;</span></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> pw[N&lt;&lt;<span class="number">1</span>], pw2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> hsh[N], hsh2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; x += y; <span class="keyword">if</span>(x&gt;=mod) x -= mod; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pw[<span class="number">0</span>] = pw2[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>*n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    pw[i] = <span class="number">1ll</span>*pw[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">    pw2[i] = <span class="number">1ll</span>*pw2[i<span class="number">-1</span>]*base%mod2;</span><br><span class="line">    fac[i] = <span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  ifac[n] = <span class="built_in">Pow</span>(fac[n], mod<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) ifac[i] = <span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    hsh[i] = (<span class="number">1ll</span>*hsh[i<span class="number">-1</span>]*base%mod + s[i])%mod;</span><br><span class="line">    hsh2[i] = (<span class="number">1ll</span>*hsh2[i<span class="number">-1</span>]*base%mod2 + s[i])%mod2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; x -= y; <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x += mod; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sub2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; x -= y; <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x += mod2; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Sub</span>(hsh[r], <span class="number">1ll</span>*hsh[l<span class="number">-1</span>]*pw[r-l+<span class="number">1</span>]%mod); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Sub2</span>(hsh2[r], <span class="number">1ll</span>*hsh2[l<span class="number">-1</span>]*pw2[r-l+<span class="number">1</span>]%mod2); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ull hv = (ull)<span class="built_in">get</span>(l, r)&lt;&lt;<span class="number">32</span>|<span class="built_in">get2</span>(l, r), p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> it = id.<span class="built_in">find</span>(hv);</span><br><span class="line">  <span class="keyword">if</span>(it==id.<span class="built_in">end</span>()) p = id[hv] = ++tot;</span><br><span class="line">  <span class="keyword">else</span> p = it-&gt;second;</span><br><span class="line">  HSH ^= <span class="number">1ll</span>*pw[p]*cnt[p]%mod;</span><br><span class="line">  HSH2 ^= <span class="number">1ll</span>*pw2[p]*cnt[p]%mod2;</span><br><span class="line">  ans = <span class="number">1ll</span>*ans*fac[cnt[p]]%mod*ifac[cnt[p] + v]%mod;</span><br><span class="line">  cnt[p] += v;</span><br><span class="line">  HSH ^= <span class="number">1ll</span>*pw[p]*cnt[p]%mod;</span><br><span class="line">  HSH2 ^= <span class="number">1ll</span>*pw2[p]*cnt[p]%mod2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(gp_hash_table&lt;ull, <span class="type">int</span>&gt; &amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  gp_hash_table&lt;ull, <span class="type">int</span>&gt; tmp;</span><br><span class="line">  table.<span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(gp_hash_table&lt;ull, <span class="type">bool</span>&gt; &amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  gp_hash_table&lt;ull, <span class="type">bool</span>&gt; tmp;</span><br><span class="line">  table.<span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; i++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//st.clear();</span></span><br><span class="line">  <span class="built_in">clear</span>(id); <span class="built_in">clear</span>(vis);</span><br><span class="line">  tot = HSH = HSH2 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  ans = fac[n/d];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n%d+<span class="number">1</span>; i&lt;=n; i+=d) <span class="built_in">upd</span>(i, i+d<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//vector&lt;pair&lt;ull, int&gt;&gt; lsh;</span></span><br><span class="line">  <span class="comment">//lsh.push_back(&#123;(ull)HSH&lt;&lt;32|HSH2, ans&#125;);</span></span><br><span class="line">  <span class="built_in">Add</span>(sum, ans); vis.<span class="built_in">insert</span>(&#123;(ull)HSH&lt;&lt;<span class="number">32</span>|HSH2, <span class="number">1</span>&#125;);</span><br><span class="line">  <span class="keyword">if</span>(n%d)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> m = n/d*d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i+=d)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">upd</span>(i, i+d<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">upd</span>(i+n%d, i+n%d+d<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">      <span class="comment">//lsh.push_back(&#123;(ull)HSH&lt;&lt;32|HSH2, ans&#125;);</span></span><br><span class="line">      <span class="keyword">if</span>(vis.<span class="built_in">find</span>((ull)HSH&lt;&lt;<span class="number">32</span>|HSH2)==vis.<span class="built_in">end</span>()) <span class="built_in">Add</span>(sum, ans), vis.<span class="built_in">insert</span>(&#123;(ull)HSH&lt;&lt;<span class="number">32</span>|HSH2, <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  sort(begin(lsh), end(lsh));</span></span><br><span class="line"><span class="comment">  for(int i=0; i&lt;(int)lsh.size(); )</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    int j = i + 1;</span></span><br><span class="line"><span class="comment">    while(j&lt;(int)lsh.size() &amp;&amp; lsh[j]==lsh[i])</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      //assert(lsh[j].second==lsh[i].second);</span></span><br><span class="line"><span class="comment">      ++j;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Add(sum, lsh[i].second);</span></span><br><span class="line"><span class="comment">    i = j;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//for(int i=1; i&lt;=300000; i++) s[i] = char(&#x27;a&#x27;+i%26);</span></span><br><span class="line">  <span class="comment">//s[300001] = 0;</span></span><br><span class="line">  n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>; d&lt;=n; d++) <span class="built_in">Add</span>(res, <span class="built_in">work</span>(d));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, ++kase, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pre</span>(N<span class="number">-5</span>);</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codechef Counting Spaghetti 数学</title>
      <link href="/2020/11/25/codechef-counting-spaghetti-shu-xue/"/>
      <url>/2020/11/25/codechef-counting-spaghetti-shu-xue/</url>
      
        <content type="html"><![CDATA[<p>现在有$L, L+1,…R-1,R$这R-L+1个数字，问你能够组成多少种不同的数字和$L \leq 10^9, R \leq 10^9$</p><p>考虑用x个数字来组合1个数字：$[L, R]$内的所有数字</p><p>2个数字：$[L+L+1, R+R-1]$内的所有数字</p><p>3个数字：$[L+L+1+L+2, R+R-1-R-2]$内的所有数字</p><p>则对于x个数字有：$l_x = \frac{x(2L+x-1)}{2}$, $r_x = \frac{x(2R-x+1)}{2}$</p><p>因此只要求用1$\sim$R-L+1个数字构成的各个区间的并集的长度即可考虑$l_x&gt;r_{x-1}$则要满足$x^2 + (L-R-2)x + R + 1 &gt; 0$当$(R-L+2)^2 - 4R - 4&lt;0$时，所有区间都不相交，又发现此时R-L+1在$O(\sqrt R​$)级别，所以暴力求出各个区间的长度相加即可否则，求出两个根x1，x2，则在$[x1,x2]$这一段区间都是相交的，区间并的左端点为x1的左端点，右端点x2的右端点。考虑$\frac{R-L+2 \pm \sqrt{(R-L+2)^2-4R-4}}{2}$设R-L+2为a，4R-4为b，且满足$a \geq \sqrt b$$a-\sqrt{a^2-b} = a-\sqrt{(a+\sqrt b)(a - \sqrt b)} \leq a - \sqrt{(a-\sqrt b)^2} = \sqrt b$所以1$\sim$x1的长度在$O(\sqrt b)$级别，而x2$\sim$a的长度为$a-\frac{R-L+2 + \sqrt{(R-L+2)^2-4R-4}}{2} = \frac{R-L+2 - \sqrt{(R-L+2)^2-4R-4}}{2}$​，也在$O(\sqrt b)$级别，所以只需要对两端不相交的部分暴力即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC 江西省大学生程序设计竞赛</title>
      <link href="/2020/11/20/2020icpc-jiang-xi-sheng-da-xue-sheng-cheng-xu-she-ji-jing-sai/"/>
      <url>/2020/11/20/2020icpc-jiang-xi-sheng-da-xue-sheng-cheng-xu-she-ji-jing-sai/</url>
      
        <content type="html"><![CDATA[<p>题目都不难，D题题面出锅</p><h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><p>定义$F_j$​为j各位数字之和求$\sum_{i=1}^n\sum_{j=1}^i [gcd(i,j)==1]F(j)$莫比乌斯反演，知道$\mu * I = \epsilon$，则$\sum \limits_{d \mid gcd(i,j)} 1 = [gcd(i,j)==1]$$d\mid gcd(i,j)$等价于$d\mid i,d\mid j$转换成枚举d，然后就可以$O(n\log n)$枚举倍数算了</p><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>签到</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>有n个区间，要求选择某些区间，定义选择出的区间的价值为min(选择的区间个数，区间交集的长度)，要求最大化该价值$n \leq 3\times 10^5$显然可以二分，$O(n\log n)$的check也很简单，但是会被卡t考虑如何$O(n)$的check看价值能不能达到v，就等价于选择v个区间，且这些区间的交集的长度$\geq v$将所有区间按照左端点先排序枚举交集的区间的左端点l，则右端点为l+v-1，只要左端点小于等于l的区间中存在至少v个右端点$\geq l+v-1$即可，尺取法</p><h2 id="D"><a class="header-anchor" href="#D">¶</a>D</h2><p>有n个数字，总长度不超过$10^6$，让你求这些数字的所有本质不同子串的价值（数字大小）和我描述成本质不同子串之后，应该很容易想到exsam<s>几个月没写概念都忘完</s>只需要建出exsam的dag图，然后按照拓扑序dp即可，只需要知道以每个endpos集合（即图上的每个节点）结尾的所有子串的和，如u有个i的出边连向v，则就有$dp[u]\times 10+i\times |u|$的贡献，$|u|$就表示u这个endpos集合的大小，就是len[u] - len[fa[u]]交上去wa了，想到一个前导0的坑点，比如302中，02和2应该算同一个？这样应该也能做，只要把原点的0出边的状态能到达的点的endpos集合大小-1就行。其实并不是题面模998244353，数据是模1000000007，离谱</p><h2 id="E"><a class="header-anchor" href="#E">¶</a>E</h2><p>一个长度为n的序列c，求有多少个子序列满足每种数字出现偶数次$n\leq 10^6,c_i\leq 20$子序列考虑前缀和，对20种数字状压即可</p><h2 id="F"><a class="header-anchor" href="#F">¶</a>F</h2><p>让你构造一个最大的数，满足它的每个前缀都能被这个前缀的长度整除，构造的数字要求用火柴棒表示，且要求恰好使用n根$n \leq 10^{100}$稍微想想就能感觉到符合的数位数不会很大，事实上长度超过3就一定不行了，所以暴力dfs就完事了</p><h2 id="G"><a class="header-anchor" href="#G">¶</a>G</h2><p>一个集合包含1-n n个数，要求你依次选择m个数的集合，要求集合间没有交集，集合可以空，求操作的方案数转化一下，可以考虑第i个数归属哪个集合，显然有m+1种选择，没被选或者选到第j个集合。所以答案就是$(m+1)^n$python的pow自带快速幂</p><h2 id="H"><a class="header-anchor" href="#H">¶</a>H</h2><p>一个序列，要求支持修改一个数，询问以某个数为最小值的区间个数。保证序列中没有重复数字显然只要找到左右两边第一个小于你的数即可记录区间最小值，线段树上贪心着走即可</p><h2 id="I"><a class="header-anchor" href="#I">¶</a>I</h2><p>规律题</p><h2 id="J"><a class="header-anchor" href="#J">¶</a>J</h2><p>二维SG</p><h2 id="K"><a class="header-anchor" href="#K">¶</a>K</h2><p>可以从起点出发带x个物品，走第y步路的消费是$x^y$，多次询问从s到t，你拥有m元钱，则在起点最多带多少个物品。点数是100先跑个floyd，则s到t的花费就是一个等比数列，二分一下公比即可，注意公比为1的情况</p><h2 id="L"><a class="header-anchor" href="#L">¶</a>L</h2><p>n皇后，但是可以在一条斜线状压dp</p><h2 id="M"><a class="header-anchor" href="#M">¶</a>M</h2><p>输出string s+string t</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ccpc 绵阳</title>
      <link href="/2020/11/02/2020ccpc-mian-yang/"/>
      <url>/2020/11/02/2020ccpc-mian-yang/</url>
      
        <content type="html"><![CDATA[<h2 id="D：-Defuse-the-Bombs"><a class="header-anchor" href="#D：-Defuse-the-Bombs">¶</a>D： Defuse the Bombs</h2><p>有n个计数器，初值为$a_i$​，每秒钟可以将一个计数器的值+1，然后所有的计数器的值-1。问最多几秒后所有计数器的最小值$\lt 0$$n\leq 10^5, 0 \leq a_i \leq 10^9$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>转化一下问题：每秒钟可以让一个计数器值+1，第i秒钟要求所有计数器的值$\geq i$，问第几秒后不满足。假如第x秒钟满足条件，则要满足$sum_p+x \geq x*p$，其中$a_p$​为小于x的最大的p。先枚举$a_i$​，找到第一个不满足的，那么答案就是$\frac{sum_i}{i-1}+1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  ll p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1ll</span>*i*a[i]-sum[i]&gt;a[i]) <span class="keyword">break</span>;</span><br><span class="line">    p = i;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; sum[p]/(p<span class="number">-1</span>)+<span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> kase=<span class="number">1</span>; kase&lt;=_; kase++) <span class="built_in">solve</span>(kase);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Knowledge-is-Power"><a class="header-anchor" href="#K-Knowledge-is-Power">¶</a>K Knowledge is Power</h2><p>给定数x，要求将其分解成若干大于1的数，要求满足两两互质且和为x。最小化这些数的最大值和最小值的差值。$5 \leq x \leq 10^9$</p><h3 id="做法-s2"><a class="header-anchor" href="#做法-s2">¶</a>做法</h3><p>x为奇数，显然$2\frac{x-1}{2}, \frac{x+1}{2}$​最优，为1考虑x为偶数：x=6无解x=8，分成3和5即可（我一开始误判成无解）通过打表得到答案只可能是2，3，4x是3的倍数，显然可以分成y, y+1, y+2的形式，又由于y一定是奇数，所以合法，答案为2$x%3==1$，如果能分成互质的y, y+1, y+3则为3，否则为4$x%3==2$，如果能分成互质的y, y+2, y+3则为3，否则为4</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">6</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x&amp;<span class="number">1</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">0</span>) cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(__gcd(x/<span class="number">2</span><span class="number">-1</span>, x/<span class="number">2</span>+<span class="number">1</span>)==<span class="number">1</span>) cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> a = (x<span class="number">-5</span>)/<span class="number">3</span>, b = a+<span class="number">2</span>, c = a+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(a, b)==<span class="number">1</span> &amp;&amp; __gcd(a, c)==<span class="number">1</span> &amp;&amp; __gcd(b, c)==<span class="number">1</span>) ok = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> a = (x<span class="number">-4</span>)/<span class="number">3</span>, b = a+<span class="number">1</span>, c = a+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>( __gcd(a, b)==<span class="number">1</span> &amp;&amp; __gcd(a, c)==<span class="number">1</span> &amp;&amp; __gcd(b, c)==<span class="number">1</span>) ok = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(ok) cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=_; k++) <span class="built_in">solve</span>(k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-Joy-of-Handcraft"><a class="header-anchor" href="#J-Joy-of-Handcraft">¶</a>J Joy of Handcraft</h2><p>有n个灯泡，分别有周期$t_i$​，每两个周期中，前一个周期亮，后一个周期暗，有亮度$x_i$​。问1-m每个时间内的最大亮度$n \leq 10^5, m \leq 10^5, t_i \leq 10^5, x_i \leq 10^5$</p><h3 id="做法-s3"><a class="header-anchor" href="#做法-s3">¶</a>做法</h3><p>周期相同的只要取亮度最大的那个，然后暴力枚举每种周期的灯泡亮的时间，复杂度是$O(n\log n)$，注意到将亮度排序后，就是个区间覆盖问题了，线段树即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cov[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cov[p&lt;&lt;<span class="number">1</span>] = cov[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = cov[p];</span><br><span class="line">  cov[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">  &#123;</span><br><span class="line">    cov[p] = v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cov[p]) <span class="built_in">push</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">cover</span>(p&lt;&lt;<span class="number">1</span>, l, mid, x, y, v);</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">cover</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, x, y, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123; cout &lt;&lt; cov[p] &lt;&lt; <span class="string">&quot; \n&quot;</span>[l==m]; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(cov[p]) <span class="built_in">push</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">print</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">print</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">4</span>*m; i++) cov[i] = <span class="number">0</span>;</span><br><span class="line">  vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">lamb</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : lamb) cin &gt;&gt; it.first &gt;&gt; it.second;</span><br><span class="line">  <span class="built_in">sort</span>(<span class="built_in">begin</span>(lamb), <span class="built_in">end</span>(lamb));</span><br><span class="line">  vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; tmp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="type">int</span>)lamb.<span class="built_in">size</span>(); )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;(<span class="type">int</span>)lamb.<span class="built_in">size</span>() &amp;&amp; lamb[j].first==lamb[i].first) ++j;</span><br><span class="line">    tmp.<span class="built_in">push_back</span>(&#123;lamb[j<span class="number">-1</span>].second, lamb[j<span class="number">-1</span>].first&#125;);</span><br><span class="line">    i = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(<span class="built_in">begin</span>(tmp), <span class="built_in">end</span>(tmp));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : tmp)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=m; k+=<span class="number">2</span>*it.second) <span class="built_in">cover</span>(<span class="number">1</span>, <span class="number">1</span>, m, k, <span class="built_in">min</span>(m, k+it.second<span class="number">-1</span>), it.first);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=_; k++) <span class="built_in">solve</span>(k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L-Lottery"><a class="header-anchor" href="#L-Lottery">¶</a>L Lottery</h2><p>有n种石头，第i种石头体积为$2^{a_i}$​，数量为$x_i$​，问能拼成的体积数量。$n \leq 10^5, a_i, x_i \leq 10^9$</p><h3 id="做法-s4"><a class="header-anchor" href="#做法-s4">¶</a>做法</h3><p>按照体积从小到大考虑设当前枚举到第i块石头，前$i-1$块石头(前mx的体积中)不能拼成的体积为ans，前$2^{a_{i-1}}$​的体积中有delta个不能被拼成，之前所有石头能拼成的最大体积为$mx$。$mx\geq 2^{a_i}$​：那么对于$2^{a_{i-1}}$​到$2^{a_i}$​之间，每$2^{a_{i-1}}$​个就有delta个体积不能被拼成。因此$\leq 2^{a_i}$​的体积中不能拼成的体积的数量就是$2^{a_i-a_{i-1}}\times delta$，前i块石头不能拼成的体积就要增加$delta\times x_i$​个$mx\lt 2^{a_i}$​：那么$mx+1$到$2^{a_i}-1$之间的体积就无法拼成前$2^{a_{i}}$​的体积中有$ans+2^{a_i}-mx-1$不能被拼成前i块石头不能拼成的体积增加$delta\times x_i$​个</p><p>由于有取模操作，不能直接判断$mx$和$2^{a_i}$​的大小关系，用一个map来存储mx的二进制表示即可，只要mx的二进制中最高位high$\geq a_i$​，就说明$mx \geq 2^{a_i}$​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; p[i].fi &gt;&gt; p[i].se;</span><br><span class="line">  map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; bit;</span><br><span class="line">  <span class="built_in">sort</span>(p+<span class="number">1</span>, p+n+<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> mx = <span class="number">0</span>, delta = <span class="number">0</span>, ans = <span class="number">0</span>, high = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="built_in">Pow</span>(<span class="number">2</span>, p[i].fi);</span><br><span class="line">    <span class="keyword">if</span>(high&gt;=p[i].fi)</span><br><span class="line">    &#123;</span><br><span class="line">      delta = <span class="number">1ll</span>*delta*<span class="built_in">Pow</span>(<span class="number">2</span>, p[i].fi-p[i<span class="number">-1</span>].fi)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      delta = ((cur-mx<span class="number">-1</span>+ans)%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (ans + <span class="number">1ll</span>*delta*p[i].se)%mod;</span><br><span class="line">    mx = (mx + <span class="number">1ll</span>*cur*p[i].se)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">30</span>; j++)</span><br><span class="line">      <span class="keyword">if</span>((p[i].se&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> x = p[i].fi + j;</span><br><span class="line">        bit[x]++;</span><br><span class="line">        <span class="keyword">while</span>(bit[x]==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          bit[x] = <span class="number">0</span>;</span><br><span class="line">          ++x;</span><br><span class="line">          bit[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        high = <span class="built_in">max</span>(high, x);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  cout &lt;&lt; ((mx - ans + <span class="number">1</span>)%mod+mod)%mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=_; k++) <span class="built_in">solve</span>(k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Game-of-Cards"><a class="header-anchor" href="#G-Game-of-Cards">¶</a>G Game of Cards</h2><p>有$c_0$​个0号牌，$c_1$​个1号牌，$c_2$​个2号牌，$c_3$​个3号牌，每次操作可以选取两张和不超过3的牌，然后将这两张牌换成一张它们的和的号的牌，不能操作者输。$0\leq c_0,c_1,c_2, c_3\leq 10^9$</p><h3 id="做法-s5"><a class="header-anchor" href="#做法-s5">¶</a>做法</h3><p>简单分析一下：3号牌只能和0号牌组合，且只会增加不会减少，影响到局面的就是3号牌有还是没有。如果操作0号牌，每次必然会减少1，所以0号牌影响局面的是它的奇偶性。然后只需要对1和2的数目以及3号牌是0还是1，0号牌是奇数还是偶数打个sg表即可。发现只有0号牌时，需要特判。此外3号牌没有影响。0号牌有偶数个时，2号牌为0和非0时，1号牌模3各有一个规律0号牌有奇数个时，2号牌为0和1和&gt;1时，1号牌模3各有一规律if else一下即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">win</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Rabbit\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lose</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Horse\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a, b, c, d;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  <span class="type">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!c)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b%<span class="number">3</span>==<span class="number">2</span>) ok = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> ok = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b%<span class="number">3</span>==<span class="number">0</span>) ok = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!c)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b%<span class="number">3</span>==<span class="number">2</span>) ok = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b%<span class="number">3</span>==<span class="number">0</span>) ok = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> ok = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b%<span class="number">3</span>==<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!b&amp;&amp;!c&amp;&amp;!d)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a&amp;<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> ok = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ok ? <span class="built_in">win</span>() : <span class="built_in">lose</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=_; k++) <span class="built_in">solve</span>(k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019ccpc 秦皇岛A. Angle Beats</title>
      <link href="/2020/10/09/2019ccpc-qin-huang-dao-a-angle-beats/"/>
      <url>/2020/10/09/2019ccpc-qin-huang-dao-a-angle-beats/</url>
      
        <content type="html"><![CDATA[<p>给定n个点，有q次询问，每次询问给出一定点，问从原来的n个点中选出两个和当前点构成直角三角形的方案数$n\leq2000,q\leq2000$思路很显然，第一种是询问点作为直角顶点，第二种是询问点不是直角顶点，分别统计即可对于第一种，只要记录所有点和询问点的斜率，第二种只要预处理出初始的每个点和其它点的斜率如果用atan2，精度会炸，这里用分数的形式来表示，如果斜率为$\dfrac{y}{x}$​,那就要查找$\dfrac{-x}{y}$的个数，提前将斜率预处理好并排序，然后查询只要upper_bound - lower_bound即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> db eps = <span class="number">1e-15</span>, pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Frac</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a%b); &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="built_in">Frac</span>() : <span class="built_in">a</span>(<span class="number">0</span>), <span class="built_in">b</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Frac</span>(<span class="type">int</span> x) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Frac</span>(<span class="type">int</span> x, <span class="type">int</span> y) &#123; a = x, b = y; <span class="built_in">norm</span>(); &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Frac f) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="number">1ll</span>*a*f.b &lt; <span class="number">1ll</span>*b*f.a; &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> == (Frac f) &#123; <span class="keyword">return</span> <span class="number">1ll</span>*a*f.b == <span class="number">1ll</span>*b*f.a; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">norm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(a), <span class="built_in">abs</span>(b));</span><br><span class="line">    a = a/g*<span class="built_in">sgn</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(!a) b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!b) a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> b = <span class="built_in">abs</span>(b/g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> (x&lt;-eps ? <span class="number">-1</span> : x&gt;eps); &#125;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">&#125;p[N];</span><br><span class="line">Frac seq[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(i&lt;x) seq[x][i] = <span class="built_in">Frac</span>(p[i].y-p[x].y, p[i].x-p[x].x);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;x) seq[x][i<span class="number">-1</span>] = <span class="built_in">Frac</span>(p[i].y-p[x].y, p[i].x-p[x].x);</span><br><span class="line">    <span class="built_in">sort</span>(seq[x]+<span class="number">1</span>, seq[x]+n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">  <span class="built_in">pre</span>();</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; p[<span class="number">0</span>].x &gt;&gt; p[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) seq[<span class="number">0</span>][i] = <span class="built_in">Frac</span>(p[i].y-p[<span class="number">0</span>].y, p[i].x-p[<span class="number">0</span>].x);</span><br><span class="line">    <span class="built_in">sort</span>(seq[<span class="number">0</span>]+<span class="number">1</span>, seq[<span class="number">0</span>]+n+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">Frac <span class="title">k</span><span class="params">(-p[<span class="number">0</span>].x+p[i].x, p[<span class="number">0</span>].y-p[i].y)</span></span>;</span><br><span class="line">      ans += <span class="built_in">upper_bound</span>(seq[i]+<span class="number">1</span>, seq[i]+n, k) - <span class="built_in">lower_bound</span>(seq[i]+<span class="number">1</span>, seq[i]+n, k);</span><br><span class="line">      ans2 += <span class="built_in">upper_bound</span>(seq[<span class="number">0</span>]+<span class="number">1</span>, seq[<span class="number">0</span>]+n+<span class="number">1</span>, k) - <span class="built_in">lower_bound</span>(seq[<span class="number">0</span>]+<span class="number">1</span>, seq[<span class="number">0</span>]+n+<span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans + ans2/<span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; q) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cf487E tourists 树剖+线段树维护圆方树</title>
      <link href="/2020/10/09/cf487e-tourists-shu-pou-xian-duan-shu-wei-hu-yuan-fang-shu/"/>
      <url>/2020/10/09/cf487e-tourists-shu-pou-xian-duan-shu-wei-hu-yuan-fang-shu/</url>
      
        <content type="html"><![CDATA[<p>给定无向图，每个点有点权，多次询问两点间所有简单路径上的点权的最小值，并要求支持修改点权</p><p>考虑建出圆方树，将方点的点权置为所有相邻圆点的点权的最小值，那答案就是两个点在圆方树上的路径上的点权最小值。但是如果一个圆点和多个方点相邻，在修改的时候复杂度就炸了。此时的trick是让1为根，方点维护所有儿子的圆点的权值最小值，这样在修改时圆点只需要单点修改其父亲即可，而在查询时，如果lca是一个方点，再统计一下方点的父亲这个圆点的答案即可。树剖，线段树支持单点修改，区间查询最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> low[N], dfn[N], stk[N], clk, top, cnt;</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N], T[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  low[u] = dfn[u] = ++clk;</span><br><span class="line">  stk[++top] = u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">      <span class="keyword">if</span>(low[v]&gt;=dfn[u])</span><br><span class="line">      &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x!=v; top--)</span><br><span class="line">        &#123;</span><br><span class="line">          x = stk[top];</span><br><span class="line">          T[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">          T[x].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        T[cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">        T[u].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mst[M];</span><br><span class="line"><span class="keyword">namespace</span> HLD</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sz[M], top[M], son[M], dep[M], fa[M], dfn[M], idfn[M], tot;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>; fa[u] = f;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;=n) mst[u].<span class="built_in">insert</span>(val[u]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : T[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(v!=f)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;n) mst[u].<span class="built_in">insert</span>(val[v]);</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[v]&gt;sz[son[u]]) son[u] = v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    top[u] = t;</span><br><span class="line">    dfn[u] = ++tot;</span><br><span class="line">    idfn[tot] = u;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : T[u])</span><br><span class="line">      <span class="keyword">if</span>(v!=son[u]&amp;&amp;v!=fa[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> HLD::fa;</span><br><span class="line"><span class="keyword">using</span> HLD::idfn;</span><br><span class="line"><span class="keyword">using</span> HLD::dep;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, mn;</span><br><span class="line">&#125;t[M&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].mn = <span class="built_in">min</span>(t[p&lt;&lt;<span class="number">1</span>].mn, t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mn); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].l = l, t[p].r = r;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mn = *mst[idfn[l]].<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mn = y;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>, x, y);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y);</span><br><span class="line">  <span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y) <span class="keyword">return</span> t[p].mn;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, ans = inf;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">askt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = inf;</span><br><span class="line">  <span class="keyword">while</span>(HLD::top[x]!=HLD::top[y])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[HLD::top[x]]&lt;dep[HLD::top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(<span class="number">1</span>, HLD::dfn[HLD::top[x]], HLD::dfn[x]));</span><br><span class="line">    x = fa[HLD::top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(<span class="number">1</span>, HLD::dfn[x], HLD::dfn[y]));</span><br><span class="line">  <span class="keyword">if</span>(x&gt;n) ans = <span class="built_in">min</span>(ans, val[fa[x]]);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; val[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(v); G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  cnt = n; <span class="built_in">tarjan</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  HLD::<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), HLD::<span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>*n);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> op; <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(fa[x])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> pre = *mst[fa[x]].<span class="built_in">begin</span>();</span><br><span class="line">        mst[fa[x]].<span class="built_in">erase</span>(mst[fa[x]].<span class="built_in">find</span>(val[x]));</span><br><span class="line">        mst[fa[x]].<span class="built_in">insert</span>(y);</span><br><span class="line">        <span class="type">int</span> cur = *mst[fa[x]].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(pre!=cur) <span class="built_in">upd</span>(<span class="number">1</span>, HLD::dfn[fa[x]], cur);</span><br><span class="line">      &#125;</span><br><span class="line">      val[x] = y;</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>, HLD::dfn[x], y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">askt</span>(x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Capture Stars 圆的反演</title>
      <link href="/2020/10/08/capture-stars-yuan-de-fan-yan/"/>
      <url>/2020/10/08/capture-stars-yuan-de-fan-yan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/7830/D">https://ac.nowcoder.com/acm/contest/7830/D</a>有一个大圆和一个小圆，两者内切于原点，然后再大圆内小圆外有若干个点，现在让你找一个圆使其和小圆外切，大圆内切，并且最大化该圆覆盖的点数这种多个圆有相切关系的题，考虑圆的反演反演：一个反演点O，一个反演半径R，在O的同侧有两个点P和P’，若满足|OP||OP’|=R*R，则P和P’互为反演点不经过反演点的圆的反演仍然是一个圆经过反演点的圆的反演是一条直线点反演还是点</p><p>再考虑本题，以小圆和大圆的内切点即原点为反演点，反演半径任意，这样就变成了两条直线，而要找的圆在反演后就是相切于这两条直线的圆，点反演后仍为点对于每个点，仅当圆心的纵坐标处于一个区间内才能覆盖，全部求出后差分前缀和即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pdi = pair&lt;db, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> db eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> (x&lt;-eps ? <span class="number">-1</span> : x&gt;eps); &#125;</span><br><span class="line"><span class="function">db <span class="title">sqr</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">db R, r, invr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span></span><br><span class="line">&#123;</span><br><span class="line">  db x, y;</span><br><span class="line">  <span class="built_in">P</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">P</span>(db _x, db _y) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">  P <span class="keyword">operator</span> * (<span class="type">const</span> db k) &#123; <span class="keyword">return</span> <span class="built_in">P</span>(k*x, k*y); &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; R &gt;&gt; r;</span><br><span class="line">  invr = <span class="number">2</span>*R;</span><br><span class="line">  db xl = <span class="number">0.5</span>*<span class="built_in">sqr</span>(invr)/R, xr = <span class="number">0.5</span>*<span class="built_in">sqr</span>(invr)/r;</span><br><span class="line">  db O = (xl+xr)/<span class="number">2</span>, Or = (xr-xl)/<span class="number">2</span>;</span><br><span class="line">  vector&lt;pdi&gt; seg;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    db d = <span class="built_in">sqrt</span>(<span class="built_in">sqr</span>(p[i].x) + <span class="built_in">sqr</span>(p[i].y));</span><br><span class="line">    db dd = <span class="built_in">sqr</span>(invr)/d;</span><br><span class="line">    p[i] = p[i]*(dd/d);</span><br><span class="line">    db t = <span class="built_in">fabs</span>(O-p[i].x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(Or-t)&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    db delta = <span class="built_in">sqrt</span>(<span class="built_in">sqr</span>(Or)-<span class="built_in">sqr</span>(t));</span><br><span class="line">    seg.<span class="built_in">push_back</span>(&#123;p[i].y-delta, <span class="number">1</span>&#125;);</span><br><span class="line">    seg.<span class="built_in">push_back</span>(&#123;p[i].y+delta+eps, <span class="number">-1</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(<span class="built_in">begin</span>(seg), <span class="built_in">end</span>(seg));</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : seg)</span><br><span class="line">  &#123;</span><br><span class="line">    cur += it.second;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;ans) ans = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Naomi with Graph 最小割</title>
      <link href="/2020/10/08/naomi-with-graph-zui-xiao-ge/"/>
      <url>/2020/10/08/naomi-with-graph-zui-xiao-ge/</url>
      
        <content type="html"><![CDATA[<p>给定一张n个点m条边的无向图，每个点有权值$a_i$​，现在可以任意加边，要求最小化$\sum_{i=1}^n(a_i-dist_i)^2$，其中$dist_i$​表示1到i点的最短路$n \leq 40,m \leq 1600$</p><p>任意加边并不代表每个点的的$dist_i$​都可以任意，仍然要满足一下条件$dist_1 = 0$$dist_i \not = 0, i \not= 1$$|dist_i-dist_j| \leq 1,(i,j) \in E$</p><p>考虑对每个点拆成n-1个点，S和第一个点相连，第i个点和第i+1个点相连，第n-1个点和T相连，边权即为$(a_i-j)^2$，由于$dist_1=0$，所以直接让1拆出的第一个点和S不连边，最后再加上$a_i^2$​的贡献。再考虑第三个限制，如果i和j有边，就让i拆出的第x个点向j拆出的第x-1个点连边，j同理。这样如果割掉i点拆出的x和x+1之间的边，就表示$dist_i=x$，并且此时对于和i有边的j，必须割掉x-1和x或者x和x+1或者x+1和x+2这三条边之一。所以这样建图再跑最小割即可。<a data-fancybox="gallery" data-src="/post-images/1602154040898.jpg" data-caption=""><img src="/post-images/1602154040898.jpg" alt=""></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小圆覆盖至少x个点</title>
      <link href="/2020/10/06/zui-xiao-yuan-fu-gai-zhi-shao-x-ge-dian/"/>
      <url>/2020/10/06/zui-xiao-yuan-fu-gai-zhi-shao-x-ge-dian/</url>
      
        <content type="html"><![CDATA[<p>先考虑一个问题，平面上有n个点，问用一个单位圆最多能覆盖几个点可以转化成将所有点变成以该点为圆心的单位圆，被圆覆盖最多次的点就是答案考虑枚举一个圆，其余圆和该圆如果有交，就是该圆上的一段圆弧，求出极角后就可以转化为一个区间覆盖最多次的问题，差分+前缀和即可。该题可以二分最小圆的半径，然后用以上方法来check即可<a href="https://www.zhihu.com/question/266750532/answer/312982493">https://www.zhihu.com/question/266750532/answer/312982493</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pdi = pair&lt;db, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> db eps = <span class="number">1e-8</span>, pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> (x&lt;-eps ? <span class="number">-1</span> : x&gt;eps); &#125;</span><br><span class="line"><span class="function">db <span class="title">sqr</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="type">int</span> n, s;</span><br><span class="line">db R;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span></span><br><span class="line">&#123;</span><br><span class="line">  db x, y;</span><br><span class="line">  <span class="built_in">P</span>() &#123;&#125;</span><br><span class="line">  <span class="function">db <span class="title">dis</span><span class="params">(P p)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">sqr</span>(x-p.x) + <span class="built_in">sqr</span>(y-p.y)); &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">norm</span><span class="params">(db&amp; theta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">sgn</span>(theta)&lt;<span class="number">0</span>) theta += <span class="number">2</span>*pi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(db r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    vector&lt;pdi&gt; pre;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      db d = p[i].<span class="built_in">dis</span>(p[j]);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">sgn</span>(d)==<span class="number">0</span>) &#123; ++cnt; <span class="keyword">continue</span>; &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">sgn</span>(d<span class="number">-2</span>*r)&gt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      db p1 = <span class="built_in">atan2</span>(p[j].y-p[i].y, p[j].x-p[i].x);</span><br><span class="line">      db p2 = <span class="built_in">acos</span>(<span class="number">0.5</span>*d/r);</span><br><span class="line">      db l = p1 - p2, r = p1 + p2;</span><br><span class="line">      <span class="built_in">norm</span>(l), <span class="built_in">norm</span>(r);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">sgn</span>(r-l)&gt;=<span class="number">0</span>) pre.<span class="built_in">push_back</span>(&#123;l, <span class="number">1</span>&#125;), pre.<span class="built_in">push_back</span>(&#123;r+eps, <span class="number">-1</span>&#125;);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        pre.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;), pre.<span class="built_in">push_back</span>(&#123;r+eps, <span class="number">-1</span>&#125;);</span><br><span class="line">        pre.<span class="built_in">push_back</span>(&#123;l, <span class="number">1</span>&#125;), pre.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>*pi+eps, <span class="number">-1</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx = cnt, cur = cnt;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">begin</span>(pre), <span class="built_in">end</span>(pre));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="type">int</span>)pre.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      cur += pre[i].se;</span><br><span class="line">      <span class="keyword">if</span>(cur&gt;mx) mx = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mx&gt;=s) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  db l = <span class="number">0.0</span>, r = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      r = <span class="built_in">max</span>(r, p[i].<span class="built_in">dis</span>(p[j]));</span><br><span class="line">  db ans = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">  &#123;</span><br><span class="line">    db mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid, ans = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans + R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">  cin &gt;&gt; R;</span><br><span class="line">  <span class="keyword">if</span>(s&gt;n) cout &lt;&lt; <span class="string">&quot;The cake is a lie.\n&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">work</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020牛客国庆集训派对day1</title>
      <link href="/2020/10/01/2020-niu-ke-guo-qing-ji-xun-pai-dui-day1/"/>
      <url>/2020/10/01/2020-niu-ke-guo-qing-ji-xun-pai-dui-day1/</url>
      
        <content type="html"><![CDATA[<p>题目都不难，貌似是去年欧洲区域赛题</p><h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><p>给定一个长度为n的字符串，问你最少在 <strong>后面</strong> 添加多少个字符，使其变成回文串$n \leq 4 \times10^5$注意是只能加在后面，所以马拉车一下就行，找一个最长的回文后缀，然后补齐前缀即可（如果是任意添加，那答案就是正串和反串的LCS，只能$n^2$</p><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>给定一个长度为n的数组a，定义$g(i, j) =gcd(a_i,\dots,a_j),m(i,j) =max(a_i,\dots,a_j)$，求$\sum_{i=1}^n\sum_{j=i}^ng(i,j)m(i,j)$$n \leq 2\times10^5$很套路的题，gcd可以分成不同的log段枚举右端点，利用单调栈和线段树动态维护后缀最值，然后二分gcd不同的段的左端点即可一种更好的写法是利用路径压缩，可以去掉一个log令$g_i$​表示i到当前右端点的gcd的值，$nxt_i$​表示i左边第一个g与$g_i$​不同的点，不断跳$nxt_i$​，当i和$nxt_i$​的gcd相同时，就合并$nxt_i= nxt_{nxt_i}$</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>给定一棵树，每次可以修改一个点的父亲，问最少几次操作变成一条链答案就是所有大于2的点的度数-2的和因为度数$\leq 2$可以不管，$&gt;2$，就必须把其它的点挪走</p><h2 id="D"><a class="header-anchor" href="#D">¶</a>D</h2><p>给定n个点，1条直线，参数r让你在这条直线上选择一个点作为圆心，作一个半径为r的圆，覆盖最多的点，求点数$n \leq 3 \times 10^5$考虑每个点能被覆盖的都是直线上的一个区间，求出区间后，就相当于用一个长度为$2r$的区间覆盖最多的区间，因为区间的长度都是小于$2r$的，所以离散化之后差分前缀和取max即可另一种做法是先按区间的左端点升序排序，枚举第i个区间作为最后一个被覆盖的区间，贪心的考虑肯定将圆心放在该区间的左端点上（即尽可能的靠左），此时覆盖的点的个数就是前面所有右端点$\geq$该左端点的区间个数，pbds即可</p><h2 id="E"><a class="header-anchor" href="#E">¶</a>E</h2><p>求$\sum\limits_{i=n}^m \sum\limits_{d\mid i} 1$$n\leq m \leq 10^{12}$转成枚举因数d的贡献就是一个整除分块了</p><h2 id="F"><a class="header-anchor" href="#F">¶</a>F</h2><p>有n个数，让你找k个使得它们相与的结果最大从高位往低位贪心即可，该位有超过k个1就取</p><h2 id="G"><a class="header-anchor" href="#G">¶</a>G</h2><p>给出q个字符串$s_i$​，询问长度n的字符串中有多少串不包含这q个字符串$\sum\limits_{i=1}^q |s_i| \leq 100$，$n\leq10^9$到最后才想到ac自动机，一开始一直在想容斥对这q个串建出trie图，然后标记出不合法的位（每个串的末端，以及每个串可识别的后缀）接下来就转成图上n步路径问题，对邻接矩阵作快速幂即可</p><h2 id="H"><a class="header-anchor" href="#H">¶</a>H</h2><p>给出两个字符串s和t，只包含字符AGCT，保证t可由s交换字符得到，问最少的交换次数考虑置换，对于一个长度为x的循环，需要x-1次交换，所以只要贪心的最大化循环个数即可，即最小化每个循环的长度。由于只有这四种字符，所以只有可能是1234元环，从小到大搞就行</p><h2 id="I"><a class="header-anchor" href="#I">¶</a>I</h2><p>给出一张无向图，多次询问只考虑给定的一个大小为s的点集时连通块的个数询问的点集大小和不超过$10^5$也很套路，考虑度数小的点，直接暴力枚举所有出边，如果在当前点集中就用并查集合并再考虑度数大的点，对于度数大的点和度数小的点的边，我们在度数小的点中已经枚举了，所以只考虑度数大的点和度数大的点之间的边，设置阈值$n\sqrt n$​，显然这样的点个数不超过$2\sqrt n$​，直接预处理出这些点之间有没有边（用一个二维矩阵存储），再对于点集内所有度数大的点单独做一次二维for循环合并即可</p><h2 id="J"><a class="header-anchor" href="#J">¶</a>J</h2><p>给出一个数组，然后询问是否存在相应的大小关系的三元组$(x_1, x_2, x_3)$总共有13种，分别做即可</p><ul><li>三个相等111，看有没有一个数出现3次以上，map记录</li><li>$x_1=x_2$​，枚举$x_2$​，如果前面有相等的$x_1$​，就看后面有没有大于和小于$x_2$​的，112，221</li><li>$x_2 = x_3$​，上一种倒着做，122，211</li><li>$x_1=x_3$​，对每种数，取最左出现和最右出现的，然后只要看两者间的最大值和最小值和这个数的关系，121，212</li><li>$x_1&lt;x_2&lt;x_3$​，枚举中间数，123</li><li>$x_1&gt;x_2&gt;x_3$​，同理，321</li><li>$x_1&lt;x_2&gt;x_3$​，枚举中间数，然后看左右两侧小于$x_2$​的最大的和最小的数的大小关系，132，231</li><li>$x_1&gt;x_2&lt;x_3$​，同理，213，312</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACL Beginner Contest F - Heights and Pairs</title>
      <link href="/2020/09/29/acl-beginner-contest-f-heights-and-pairs/"/>
      <url>/2020/09/29/acl-beginner-contest-f-heights-and-pairs/</url>
      
        <content type="html"><![CDATA[<p>有2n个人，身高分别为$h_i$​，求将他们两两配对，且每对人身高均不同的方案数(mod 998244353)$n\leq 5\times 10^4,h_i \leq 10^5$</p><p>设恰好有i对人身高不同的方案数为$g_i$​，至少有i对人身高不同的方案数为$f_i$恰好不好求，先求至少$f_i = \sum \limits_{j=i}^n \binom{j}{i}g_j$利用二项式反演$g_i = \sum \limits_{j=i}^n(-1)^{j-i}\binom{j}{i}f_j$答案即为$g_0$​单独考虑每种身高，若身高为h的有x个人，则将他们配成身高相同的i组人的方案数是$\dfrac{\sum\limits_{j=1}^i \binom{x-2*j+2}{2}}{i!}$这样对每种身高就可以写出一个OGF，全部乘起来后$x^i$的系数就是i组人配对的方案数，再考虑剩余的$2n-2i$个人，任意配对的方案数为$\dfrac{(2n-2i)!}{(n-i)!2^{(n-i)}}$​，两项相乘就是$f_i$​，再用上述式子即可得到$g_0$​其中n个OGF相乘利用分治NTT即可</p><p>在reverse一个空数组时会re，要注意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, h[N], cnt[N], d[N], sd[N];</span><br><span class="line"><span class="type">int</span> *f[N], buf[N&lt;&lt;<span class="number">5</span>], *<span class="built_in">np</span>(buf);</span><br><span class="line"><span class="type">int</span> fac[N], ifac[N], g[N];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> up, w[N], rev[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpw</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myassert</span><span class="params">(<span class="type">bool</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x) <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> poly</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) inv[i] = <span class="number">1ll</span>*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    up = <span class="number">1</span>; <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(up&lt;=n) up &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">    <span class="type">int</span> wn = <span class="built_in">fpw</span>(G, mod&gt;&gt;l); w[up&gt;&gt;<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>; i&lt;up; i++) w[i] = <span class="number">1ll</span>*w[i<span class="number">-1</span>]*wn%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) w[i] = w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> </span>&#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, n&lt;&lt;<span class="number">2</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(n)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> *b)</span> </span>&#123; <span class="keyword">while</span>(n--) *b++ = <span class="number">1ll</span>**a++*x%mod; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dot</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> n, <span class="type">int</span> *c)</span> </span>&#123; <span class="keyword">while</span>(n--) *c++ = <span class="number">1ll</span>**a++**b++%mod; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp[N];</span><br><span class="line">    <span class="type">int</span> u = __builtin_ctz(up/l), t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) tmp[i] = a[rev[i]&gt;&gt;u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i^l; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>, d=i&lt;&lt;<span class="number">1</span>; j^l; j+=d)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">          t = tmp[i|j|k]*w[i|k]%mod, tmp[i|j|k] = tmp[j|k]+mod-t, tmp[j|k] += t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) a[i] = tmp[i]%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">IDFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+l); <span class="built_in">DFT</span>(a, l);</span><br><span class="line">    <span class="built_in">mul</span>(a, l, mod-mod/l, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">conv</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> l)</span> </span>&#123; <span class="built_in">DFT</span>(a, l); <span class="built_in">DFT</span>(b, l); <span class="built_in">dot</span>(a, b, l, a); <span class="built_in">IDFT</span>(a, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> *b, <span class="type">int</span> m, <span class="type">int</span> *c)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> l, ta[N], tb[N];</span><br><span class="line">    <span class="keyword">if</span>(n+m==<span class="number">0</span>) <span class="comment">//此时l=1，IDFT会re！！</span></span><br><span class="line">    &#123;</span><br><span class="line">      c[<span class="number">0</span>] = <span class="number">1ll</span>*a[<span class="number">0</span>]*b[<span class="number">0</span>]%mod;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l = <span class="built_in">getlen</span>(n+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) ta[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=m; i++) tb[i] = b[i];</span><br><span class="line">    <span class="built_in">conv</span>(ta, tb, l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n+m; i++) c[i] = ta[i];</span><br><span class="line">    <span class="built_in">clear</span>(ta, l), <span class="built_in">clear</span>(tb, l);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fac[i] = <span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">  ifac[n] = <span class="built_in">fpw</span>(fac[n], mod<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) ifac[i] = <span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a&lt;b||b&lt;<span class="number">0</span>||a&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span>*fac[a]*ifac[b]%mod*ifac[a-b]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  f[p] = np, np += sd[r] - sd[l<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=d[l]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      f[p][i] = cur;</span><br><span class="line">      cur = <span class="number">1ll</span>*cur*<span class="built_in">comb</span>(cnt[l]<span class="number">-2</span>*i, <span class="number">2</span>)%mod*inv[i+<span class="number">1</span>]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">solve</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">solve</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  poly::<span class="built_in">mul</span>(f[p&lt;&lt;<span class="number">1</span>], sd[mid]-sd[l<span class="number">-1</span>], f[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>], sd[r]-sd[mid], f[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">init</span>(<span class="number">2</span>*n);</span><br><span class="line">  poly::<span class="built_in">init</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>*n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; h[i];</span><br><span class="line">    cnt[h[i]]++;</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, h[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=mx; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    d[i] = cnt[i]/<span class="number">2</span>;</span><br><span class="line">    sd[i] = sd[i<span class="number">-1</span>] + d[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve</span>(<span class="number">1</span>, <span class="number">1</span>, mx);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=sd[mx]; i++) g[i] = <span class="number">1ll</span>*f[<span class="number">1</span>][i]*fac[<span class="number">2</span>*n<span class="number">-2</span>*i]%mod*ifac[n-i]%mod*<span class="built_in">fpw</span>(<span class="built_in">fpw</span>(<span class="number">2</span>, n-i), mod<span class="number">-2</span>)%mod;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=sd[mx]; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ans = (ans - g[i] + mod)%mod;</span><br><span class="line">    <span class="keyword">else</span> ans = (ans + g[i])%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj2821 循环卷积 bluestein算法</title>
      <link href="/2020/09/25/poj2821-xun-huan-juan-ji-bluestein-suan-fa/"/>
      <url>/2020/09/25/poj2821-xun-huan-juan-ji-bluestein-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>已知多项式A*B=C,其中*为循环卷积，给出B和C求A对B和C进行任意长度的DFT（bluestein，狭义的CZT），然后点值相除再变换回去即可$ij = \binom{i+j}{2} - \binom{i}{2} - \binom{j}{2}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">19</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cp</span></span><br><span class="line">&#123;</span><br><span class="line">  db x, y;</span><br><span class="line">  <span class="built_in">cp</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">cp</span>(db _x, db _y): <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">  cp <span class="keyword">operator</span> + (cp &amp;oth) &#123; <span class="keyword">return</span> <span class="built_in">cp</span>(x+oth.x, y+oth.y); &#125;</span><br><span class="line">  cp <span class="keyword">operator</span> - (cp &amp;oth) &#123; <span class="keyword">return</span> <span class="built_in">cp</span>(x-oth.x, y-oth.y); &#125;</span><br><span class="line">  cp <span class="keyword">operator</span> * (cp &amp;oth) &#123; <span class="keyword">return</span> <span class="built_in">cp</span>(x*oth.x-y*oth.y, x*oth.y+y*oth.x); &#125;</span><br><span class="line">  cp <span class="keyword">operator</span> / (cp &amp;oth) &#123; <span class="keyword">return</span> <span class="built_in">cp</span>((x*oth.x+y*oth.y)/(oth.x*oth.x+oth.y*oth.y), (y*oth.x-x*oth.y)/(oth.x*oth.x+oth.y*oth.y)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> up, rev[N];</span><br><span class="line">cp w[N], pw[N];</span><br><span class="line"><span class="type">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  up = <span class="number">1</span>; <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(up&lt;=n) up &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;up; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">      w[i+j] = <span class="built_in">cp</span>(<span class="built_in">cos</span>(pi*j/i), <span class="built_in">sin</span>(pi*j/i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(cp *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> cp t;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i^l; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>, d=i&lt;&lt;<span class="number">1</span>; j^l; j+=d)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">        t = a[i|j|k]*w[i|k], a[i|j|k] = a[j|k]-t, a[j|k] = a[j|k]+t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IDFT</span><span class="params">(cp *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+l); <span class="built_in">DFT</span>(a, l);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) a[i].x /= l, a[i].y /= l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cp a[N], b[N], c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span>*x*(x<span class="number">-1</span>)/<span class="number">2</span>%n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bluestein</span><span class="params">(cp *a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> cp x[N], y[N];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) x[i].x = x[i].y = y[i].x = y[i].y = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) x[i] = pw[n-<span class="built_in">comb</span>(i)]*a[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++) y[i] = pw[<span class="built_in">comb</span>(i)];</span><br><span class="line">  <span class="built_in">reverse</span>(x, x+n);</span><br><span class="line">  <span class="built_in">DFT</span>(x, up); <span class="built_in">DFT</span>(y, up);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) x[i] = x[i]*y[i];</span><br><span class="line">  <span class="built_in">IDFT</span>(x, up);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&lt;=<span class="number">2</span>*n<span class="number">-2</span>; i++) a[i-n+<span class="number">1</span>] = x[i]*pw[n-<span class="built_in">comb</span>(i-n+<span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ibluestein</span><span class="params">(cp *a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+n); <span class="built_in">bluestein</span>(a, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) a[i].x /= n, a[i].y /= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(cp *a, cp * b, cp * c, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">bluestein</span>(a, n);</span><br><span class="line">  <span class="built_in">bluestein</span>(b, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) c[i] = a[i]/b[i];</span><br><span class="line">  <span class="built_in">Ibluestein</span>(c, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;b[i].x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;c[i].x);</span><br><span class="line">  <span class="built_in">init</span>(<span class="number">3</span>*n<span class="number">-3</span>);</span><br><span class="line">  pw[<span class="number">0</span>] = <span class="built_in">cp</span>(<span class="number">1</span>, <span class="number">0</span>); pw[<span class="number">1</span>] = <span class="built_in">cp</span>(<span class="built_in">cos</span>(<span class="number">2</span>*pi/n), <span class="built_in">sin</span>(<span class="number">2</span>*pi/n));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) pw[i] = pw[i<span class="number">-1</span>]*pw[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">div</span>(c, b, a, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>, a[i].x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客 导一导 莱布尼茨求导公式</title>
      <link href="/2020/09/24/niu-ke-dao-yi-dao-lai-bu-ni-ci-qiu-dao-gong-shi/"/>
      <url>/2020/09/24/niu-ke-dao-yi-dao-lai-bu-ni-ci-qiu-dao-gong-shi/</url>
      
        <content type="html"><![CDATA[<p>求$\sum\limits_{i=1}^k a_i\frac{sinx}{x^i}^{(n)}$输出$\frac{sinx}{x^i}$ 和$\frac{cosx}{x^i}$​前的系数$n, k \leq 10^5$</p><p>$(uv)^{(n)} = \sum\limits_{k=0}^n \binom{n}{k}u^{(k)}v^{(n-k)}$$\sum\limits_{j=0}^k \binom{k}{j} sinx^{(k-j)}\sum\limits_{i=1}^k(a_ix^{-i})^{(j)}$发现是一个多项式乘法的形式，继续化简$\sum\limits_{j=0}^k \binom{k}{j}sinx^{(k-j)}\sum\limits_{i=1}^ka_i(-i)^{\underline{j}}x^{-i-j}$$\sum\limits_{j=0}^k\binom{k}{j} sinx^{(k-j)}x^{-j}(-1)^j\sum\limits_{i=1}^ka_i\frac{(i+j-1)!}{(i-1)!}x^{-i}$把$(i+j-1)!$提出来，其余的就是两个多项式，NTT相乘后，最后再乘上$(i+j-1)!$的贡献即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, k, fac[N], ifac[N], a[N], b[N], bb[N], c[N];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> up, w[N], rev[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpw</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> poly</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    up = <span class="number">1</span>; <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(up&lt;=n) up &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">    <span class="type">int</span> wn = <span class="built_in">fpw</span>(G, mod&gt;&gt;l); w[up&gt;&gt;<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>; i&lt;up; i++) w[i] = <span class="number">1ll</span>*w[i<span class="number">-1</span>]*wn%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) w[i] = w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> </span>&#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, n&lt;&lt;<span class="number">2</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(n)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> *b)</span> </span>&#123; <span class="keyword">while</span>(n--) *b++ = <span class="number">1ll</span>**a++*x%mod; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dot</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> n, <span class="type">int</span> *c)</span> </span>&#123; <span class="keyword">while</span>(n--) *c++ = <span class="number">1ll</span>**a++**b++%mod; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp[N];</span><br><span class="line">    <span class="type">int</span> u = __builtin_ctz(up/l), t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) tmp[i] = a[rev[i]&gt;&gt;u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i^l; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>, d=i&lt;&lt;<span class="number">1</span>; j^l; j+=d)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">          t = tmp[i|j|k]*w[i|k]%mod, tmp[i|j|k] = tmp[j|k]+mod-t, tmp[j|k] += t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) a[i] = tmp[i]%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">IDFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+l); <span class="built_in">DFT</span>(a, l);</span><br><span class="line">    <span class="built_in">mul</span>(a, l, mod-mod/l, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;m||n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  poly::<span class="built_in">init</span>(n+k);</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n+k; i++) fac[i] = <span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">  ifac[n+k] = <span class="built_in">fpw</span>(fac[n+k], mod<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n+k<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) ifac[i] = <span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    a[i] = <span class="number">1ll</span>*a[i]*ifac[i<span class="number">-1</span>]%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  poly::<span class="built_in">DFT</span>(a, up);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    b[i] = <span class="built_in">comb</span>(n, i);</span><br><span class="line">    <span class="keyword">if</span>((n-i)%<span class="number">4</span>&gt;<span class="number">1</span>) b[i] = mod - b[i];</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">1</span>) b[i] = mod - b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i+=<span class="number">2</span>) bb[i] = b[i];</span><br><span class="line">  poly::<span class="built_in">DFT</span>(bb, up);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) c[i] = <span class="number">1ll</span>*a[i]*bb[i]%mod;</span><br><span class="line">  poly::<span class="built_in">IDFT</span>(c, up);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n+k; i++) cout &lt;&lt; <span class="number">1ll</span>*c[i]*fac[i<span class="number">-1</span>]%mod &lt;&lt; <span class="string">&quot; \n&quot;</span>[i==n+k];</span><br><span class="line"></span><br><span class="line">  poly::<span class="built_in">clear</span>(bb, up);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i+=<span class="number">2</span>) bb[i] = b[i];</span><br><span class="line">  poly::<span class="built_in">DFT</span>(bb, up);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) c[i] = <span class="number">1ll</span>*a[i]*bb[i]%mod;</span><br><span class="line">  poly::<span class="built_in">IDFT</span>(c, up);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n+k; i++) cout &lt;&lt; <span class="number">1ll</span>*c[i]*fac[i<span class="number">-1</span>]%mod &lt;&lt; <span class="string">&quot; \n&quot;</span>[i==n+k];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5394 【模板】下降幂多项式乘法</title>
      <link href="/2020/09/24/p5394-mo-ban-xia-jiang-mi-duo-xiang-shi-cheng-fa/"/>
      <url>/2020/09/24/p5394-mo-ban-xia-jiang-mi-duo-xiang-shi-cheng-fa/</url>
      
        <content type="html"><![CDATA[<p>下降幂多项式：Falling Factorial Polynomial(FFP)形式$f(x) = \sum \limits_{i=0}^{n}a_ix^{\underline{i}}$普通多项式与下降幂多项式是一一对应的（从高幂次向低幂次配系数即可）现在给出两个下降幂多项式f，g，要求出这两个多项式乘法的结果（输出普通多项式的系数）$n \leq 10^5$在FFT下，普通多项式在单位根处的点值可以快速计算而下降幂多项式在$0 \dots n$处的点值可以快速计算考虑f(x)的EGF：$\sum\limits_{i=0}^{\infty} \frac{f(i)}{i!}x^i = \sum \limits_{i=0}^{\infty}\frac{\sum \limits_{j=0}^{n} a_ji^{\underline{j}}}{i!}x^i = \sum\limits_{j=0}^n a_j \sum\limits_{i=0}^\infty \frac{1}{(i-j)!}x^i =\sum\limits_{j=0}^n a_jx^j \sum\limits_{i=0}^\infty \frac{x^i}{i!} =e^x\sum\limits_{i=0}^na_ix^i$所以我们只要把下降幂多项式当成普通多项式，然后卷上一个$e^x$就可以快速计算出f(x)在$0\dots n$处的取值（实质是$\frac{f(x)}{x!}$​）那么将f和g分别卷上$e^x$然后对应点值相乘，再反变换回去（乘上$e^{-x} =\sum\limits_{i=0}^\infty \frac{(-x)^i}{i!}$​）即可复杂度$O(n\log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> up, w[N], rev[N], fac[N], ifac[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpw</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> poly</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    up = <span class="number">1</span>; <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(up&lt;=n) up &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">    <span class="type">int</span> wn = <span class="built_in">fpw</span>(G, mod&gt;&gt;l); w[up&gt;&gt;<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>; i&lt;up; i++) w[i] = <span class="number">1ll</span>*w[i<span class="number">-1</span>]*wn%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) w[i] = w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> </span>&#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, n&lt;&lt;<span class="number">2</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(n)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> *b)</span> </span>&#123; <span class="keyword">while</span>(n--) *b++ = <span class="number">1ll</span>**a++*x%mod; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dot</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> n, <span class="type">int</span> *c)</span> </span>&#123; <span class="keyword">while</span>(n--) *c++ = <span class="number">1ll</span>**a++**b++%mod; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp[N];</span><br><span class="line">    <span class="type">int</span> u = __builtin_ctz(up/l), t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) tmp[i] = a[rev[i]&gt;&gt;u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i^l; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>, d=i&lt;&lt;<span class="number">1</span>; j^l; j+=d)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">          t = tmp[i|j|k]*w[i|k]%mod, tmp[i|j|k] = tmp[j|k]+mod-t, tmp[j|k] += t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) a[i] = tmp[i]%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">IDFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+l); <span class="built_in">DFT</span>(a, l);</span><br><span class="line">    <span class="built_in">mul</span>(a, l, mod-mod/l, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">conv</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> l)</span> </span>&#123; <span class="built_in">DFT</span>(a, l); <span class="built_in">DFT</span>(b, l); <span class="built_in">dot</span>(a, b, l, a); <span class="built_in">IDFT</span>(a, l); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m, a[N], b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ffp</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> tmp[N];</span><br><span class="line">  poly::<span class="built_in">clear</span>(tmp, up);</span><br><span class="line">  <span class="keyword">if</span>(op) <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) tmp[i] = ifac[i];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) <span class="keyword">if</span>(i&amp;<span class="number">1</span>) tmp[i] = mod - ifac[i]; <span class="keyword">else</span> tmp[i] = ifac[i];</span><br><span class="line">  poly::<span class="built_in">conv</span>(a, tmp, up);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> deg = n + m;</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=deg; i++) fac[i] = <span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">  ifac[deg] = <span class="built_in">fpw</span>(fac[deg], mod<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=deg<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) ifac[i] = <span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">  poly::<span class="built_in">init</span>(deg&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=m; i++) cin &gt;&gt; b[i];</span><br><span class="line">  <span class="built_in">ffp</span>(a, deg, <span class="number">1</span>); <span class="built_in">ffp</span>(b, deg, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) a[i] = <span class="number">1ll</span>*a[i]*b[i]%mod*fac[i]%mod;</span><br><span class="line">  <span class="built_in">ffp</span>(a, deg, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=deg; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i==deg];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这玩意除了做这种<s>没啥用</s>的模板题还能干啥呢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客挑战赛41 D买糖果 折半 多点求值</title>
      <link href="/2020/09/23/niu-ke-tiao-zhan-sai-41-d-mai-tang-guo-zhe-ban-duo-dian-qiu-zhi/"/>
      <url>/2020/09/23/niu-ke-tiao-zhan-sai-41-d-mai-tang-guo-zhe-ban-duo-dian-qiu-zhi/</url>
      
        <content type="html"><![CDATA[<p>给定n个数，求所有非空子集的和的乘积mod 998244353$n \leq 32$</p><p>考虑折半L，R，很容易状压求出两部分内部各自的贡献，两部分共同的贡献可以用$\prod\limits_{i=1}^{(1&lt;&lt;L)-1} \prod \limits_{j=1}^{(1&lt;&lt;R)-1} (c_i + d_j)$令$f(x) = \prod \limits_{j=1}^{(1&lt;&lt;R)-1}(x+d_j)$，显然可以用分治NTT求得该多项式，然后只要对每个$c_i$​求值后乘积即可，多点求值板子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">17</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> up, w[N], rev[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpw</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> poly</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) inv[i] = <span class="number">1ll</span>*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    up = <span class="number">1</span>; <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(up&lt;=n) up &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">    <span class="type">int</span> wn = <span class="built_in">fpw</span>(G, mod&gt;&gt;l); w[up&gt;&gt;<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>; i&lt;up; i++) w[i] = <span class="number">1ll</span>*w[i<span class="number">-1</span>]*wn%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) w[i] = w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> </span>&#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, n&lt;&lt;<span class="number">2</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(n)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> *b)</span> </span>&#123; <span class="keyword">while</span>(n--) *b++ = <span class="number">1ll</span>**a++*x%mod; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dot</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> n, <span class="type">int</span> *c)</span> </span>&#123; <span class="keyword">while</span>(n--) *c++ = <span class="number">1ll</span>**a++**b++%mod; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp[N];</span><br><span class="line">    <span class="type">int</span> u = __builtin_ctz(up/l), t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) tmp[i] = a[rev[i]&gt;&gt;u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i^l; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>, d=i&lt;&lt;<span class="number">1</span>; j^l; j+=d)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">          t = tmp[i|j|k]*w[i|k]%mod, tmp[i|j|k] = tmp[j|k]+mod-t, tmp[j|k] += t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) a[i] = tmp[i]%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">IDFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+l); <span class="built_in">DFT</span>(a, l);</span><br><span class="line">    <span class="built_in">mul</span>(a, l, mod-mod/l, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">conv</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> l)</span> </span>&#123; <span class="built_in">DFT</span>(a, l); <span class="built_in">DFT</span>(b, l); <span class="built_in">dot</span>(a, b, l, a); <span class="built_in">IDFT</span>(a, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Inv</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c[N], l;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) &#123; b[<span class="number">0</span>] = <span class="built_in">fpw</span>(a[<span class="number">0</span>], mod<span class="number">-2</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">Inv</span>(a, b, n&gt;&gt;<span class="number">1</span>); l = <span class="built_in">getlen</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) c[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>; i&lt;l; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DFT</span>(c, l); <span class="built_in">DFT</span>(b, l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) b[i] = (<span class="number">2ll</span><span class="number">-1ll</span>*c[i]*b[i]%mod+mod)%mod*b[i]%mod;</span><br><span class="line">    <span class="built_in">IDFT</span>(b, l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>; i&lt;l; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> *f[N], *g[N], buf[N&lt;&lt;<span class="number">5</span>], *<span class="built_in">np</span>(buf);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> *b, <span class="type">int</span> m, <span class="type">int</span> *c, <span class="type">int</span> deg, <span class="type">int</span> st)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> A[N], B[N], l;</span><br><span class="line">    l = <span class="built_in">getlen</span>(deg), <span class="built_in">copy</span>(a, a+n+<span class="number">1</span>, A), <span class="built_in">copy</span>(b, b+m+<span class="number">1</span>, B);</span><br><span class="line">    <span class="built_in">conv</span>(A, B, l); <span class="built_in">copy</span>(A+st, A+deg+<span class="number">1</span>, c);</span><br><span class="line">    <span class="built_in">clear</span>(A, l), <span class="built_in">clear</span>(B, l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eval_init</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    g[p] = np, np += r-l+<span class="number">2</span>, f[p] = np, np += r-l+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123; g[p][<span class="number">0</span>] = (mod-a[l])%mod, g[p][<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="type">int</span> lc = p&lt;&lt;<span class="number">1</span>, rc = lc|<span class="number">1</span>, mid = (l+r)&gt;&gt;<span class="number">1</span>, up1 = mid-l+<span class="number">1</span>, up2 = r-mid;</span><br><span class="line">    <span class="built_in">eval_init</span>(lc, l, mid, a); <span class="built_in">eval_init</span>(rc, mid+<span class="number">1</span>, r, a);</span><br><span class="line">    <span class="built_in">mul</span>(g[lc], up1, g[rc], up2, g[p], up1+up2, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eval_work</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123; a[l] = f[p][<span class="number">0</span>]; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="type">int</span> lc = p&lt;&lt;<span class="number">1</span>, rc = lc|<span class="number">1</span>, mid = (l+r)&gt;&gt;<span class="number">1</span>, up1 = mid-l+<span class="number">1</span>, up2 = r-mid;</span><br><span class="line">    <span class="built_in">mul</span>(f[p], r-l, g[rc], up2, f[lc], r-l, up2);</span><br><span class="line">    <span class="built_in">eval_work</span>(lc, l, mid, a);</span><br><span class="line">    <span class="built_in">mul</span>(f[p], r-l, g[lc], up1, f[rc], r-l, up1);</span><br><span class="line">    <span class="built_in">eval_work</span>(rc, mid+<span class="number">1</span>, r, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> *b, <span class="type">int</span> m, <span class="type">int</span> *c)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> invg[N], q[N];</span><br><span class="line">    <span class="built_in">eval_init</span>(<span class="number">1</span>, <span class="number">1</span>, m, b);</span><br><span class="line">    <span class="built_in">reverse</span>(g[<span class="number">1</span>], g[<span class="number">1</span>]+m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Inv</span>(g[<span class="number">1</span>], invg, m);</span><br><span class="line">    <span class="built_in">reverse</span>(invg, invg+m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">mul</span>(a, n, invg, m, q, n+m, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">copy</span>(q+n+<span class="number">1</span>, q+n+m+<span class="number">1</span>, f[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">eval_work</span>(<span class="number">1</span>, <span class="number">1</span>, m, c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) c[i] = (<span class="number">1ll</span>*c[i]*b[i]%mod+a[<span class="number">0</span>])%mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, a[<span class="number">35</span>];</span><br><span class="line"><span class="type">int</span> c[N], d[N], v[N];</span><br><span class="line"><span class="type">int</span> *f[N], pool[N&lt;&lt;<span class="number">5</span>], *<span class="built_in">ptr</span>(pool);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  f[p] = ptr, ptr += r-l+<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123; f[p][<span class="number">0</span>] = d[l], f[p][<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="type">int</span> lc = p&lt;&lt;<span class="number">1</span>, rc = lc|<span class="number">1</span>, mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">solve</span>(lc, l, mid); <span class="built_in">solve</span>(rc, mid+<span class="number">1</span>, r);</span><br><span class="line">  poly::<span class="built_in">mul</span>(f[lc], mid-l+<span class="number">1</span>, f[rc], r-mid, f[p], r-l+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="type">int</span> L = n/<span class="number">2</span>, R = n - L, ans = <span class="number">1</span>;</span><br><span class="line">  poly::<span class="built_in">init</span>((<span class="number">1</span>&lt;&lt;(R+<span class="number">1</span>))<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;(<span class="number">1</span>&lt;&lt;L); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;L; j++)</span><br><span class="line">        <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>) cur += a[j];</span><br><span class="line">    ans = <span class="number">1ll</span>*ans*cur%mod;</span><br><span class="line">    c[i] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;(<span class="number">1</span>&lt;&lt;R); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;R; j++)</span><br><span class="line">        <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>) cur += a[L+j];</span><br><span class="line">    ans = <span class="number">1ll</span>*ans*cur%mod;</span><br><span class="line">    d[i] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve</span>(<span class="number">1</span>, <span class="number">1</span>, (<span class="number">1</span>&lt;&lt;R)<span class="number">-1</span>);</span><br><span class="line">  poly::<span class="built_in">eval</span>(f[<span class="number">1</span>], (<span class="number">1</span>&lt;&lt;R)<span class="number">-1</span>, c, (<span class="number">1</span>&lt;&lt;R)<span class="number">-1</span>, v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;(<span class="number">1</span>&lt;&lt;L); i++) ans = <span class="number">1ll</span>*ans*v[i]%mod;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>狄利克雷卷积相关</title>
      <link href="/2020/09/18/di-li-ke-lei-juan-ji-xiang-guan/"/>
      <url>/2020/09/18/di-li-ke-lei-juan-ji-xiang-guan/</url>
      
        <content type="html"><![CDATA[<p>狄利克雷卷积即乘法卷积$f_n = \sum \limits_{d\mid n} g_dh_{\frac{n}{d}}$两个积性函数的狄利克雷卷积仍然积性</p><h2 id="Dirichlet-k-th-root"><a class="header-anchor" href="#Dirichlet-k-th-root">¶</a>Dirichlet k-th root</h2><p>给定f，令$g^k = f$，求g此处乘法为狄利克雷卷积有结论$f^{mod} = \epsilon$，因而$f^{mod+1} = f$，尝试找一个x，使得$x * k = p * mod+1$，这样$f^x$即为答案。$x=inv(k)$即可由于狄利克雷卷积具有结合律，套一个快速幂</p><h2 id="P4714-「数学」约数个数和"><a class="header-anchor" href="#P4714-「数学」约数个数和">¶</a>P4714 「数学」约数个数和</h2><p>求$f_n = \sum \limits_{i_1\mid n}\sum \limits_{i_2\midi_1} \dots \sum \limits_{i_k\mid i_{k-1}} 1$</p><p>$n \leq 10^{18},k \leq 10^{18}$</p><p>上面这个求和形式可以转化成狄利克雷卷积的形式令$g_i = 1$，则$f = \epsilon^k * g$然而这里数字太大，做不了这是一个积性函数，所以对n质因数分解后考虑单个素因子的幂次的值（这里要pollard-rho）对于$f_{p^x}$​，我们相当于枚举了所有满足$x_1+x_2+\dots + x_k \leqx$，其中$x_i \geq 0$的x的组合，根据插板法其值为$\binom{x+k}{k}$，由于幂次不会很大，可以转化成$\binom{x+k}{x}$，暴力计算即可</p><h2 id="hdu5628-Clarke-and-math"><a class="header-anchor" href="#hdu5628-Clarke-and-math">¶</a>hdu5628 Clarke and math</h2><p>求$f_n = \sum \limits_{i_1\mid n}\sum \limits_{i_2\midi_1} \dots \sum \limits_{i_k\mid i_{k-1}}g_{i_k}$</p><p>$n \leq 10^5, k\leq 10^5$</p><p>这题就是把上题的1换成了$kg_{i_k}$​​显然的做法就是狄利克雷卷积加快速幂这边考虑仿照上一题的做法，令$h_i$​表示$g_j$​转移给$jf_{ij}$​的贡献，如果能算出$h_i$​，那么$O(n\log n)$枚举倍数即可解决这同样是个积性函数，考虑$h_{p^x}$​，相当于枚举了所有满足$x_1+x_2+\dots + x_k = x$，其中$x_i \geq 0$的x的组合，根据插板法值为$\binom{x+k-1}{x}$这里n很小，所以可以利用素数筛$O(n)$求得该积性函数h所以总复杂度是$O(n\log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, up = <span class="number">2e5</span>;</span><br><span class="line"><span class="type">int</span> fac[N], ifac[N], f[N], g[N], h[N];</span><br><span class="line"><span class="type">int</span> n, k, pr[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpw</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fac[i] = <span class="number">1ll</span>*i*fac[i<span class="number">-1</span>]%mod;</span><br><span class="line">  ifac[n] = <span class="built_in">fpw</span>(fac[n], mod<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) ifac[i] = <span class="number">1ll</span>*(i+<span class="number">1</span>)*ifac[i+<span class="number">1</span>]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a&lt;<span class="number">0</span>||b&lt;<span class="number">0</span>||a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span>*fac[a]*ifac[b]%mod*ifac[a-b]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  h[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) h[i] = k, pr[++pr[<span class="number">0</span>]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=pr[<span class="number">0</span>]&amp;&amp;<span class="number">1ll</span>*pr[j]*i&lt;=n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      vis[pr[j]*i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%pr[j]==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> tmp = i/pr[j], cnt = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp%pr[j]==<span class="number">0</span>) ++cnt, tmp /= pr[j];</span><br><span class="line">        h[pr[j]*i] = <span class="number">1ll</span>*h[tmp]*<span class="built_in">comb</span>(cnt+k<span class="number">-1</span>, cnt)%mod;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> h[pr[j]*i] = <span class="number">1ll</span>*h[i]*h[pr[j]]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, f+i), g[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">get</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; i*j&lt;=n; j++)</span><br><span class="line">      g[i*j] = (g[i*j] + <span class="number">1ll</span>*f[i]*h[j])%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, g[i], <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>(up);</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC178</title>
      <link href="/2020/09/17/abc178/"/>
      <url>/2020/09/17/abc178/</url>
      
        <content type="html"><![CDATA[<p>比较水的一场</p><h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><p>！运算符</p><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>四种边界取个max</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>简单容斥</p><h2 id="D"><a class="header-anchor" href="#D">¶</a>D</h2><p>问你有多少个序列满足所有元素都$\geq 3$并且和等于s$s\leq 2000$考虑枚举这个序列的长度为n那么就要满足$x_1+\dots +x_n = s - 2n$，其中$x_i$​为正整数，每个数$\geq 3$，那么我们给每个数减掉2就转化为正整数的要求，下面就是一个经典的组合数插板问题，答案是$\binom{s-2n-1}{n-1}$</p><h2 id="E"><a class="header-anchor" href="#E">¶</a>E</h2><p>给定n个点的坐标，求两点间的最大曼哈顿距离很套路的题，保存(+x,+y),(+x,-y),(-x,+y),(-x,-y)四种情况的最值，枚举取max即可，容易发现虽然枚举中有不合法的情况，但一定不是最优解（因为这时候我们把绝对值取负了）</p><h2 id="F"><a class="header-anchor" href="#F">¶</a>F</h2><p>给定两个长度为n递增序列a和b，要求重排b，使得对于所有i，满足$a_i \neq b_i$​$n \leq 2\times 10^5$可以转化为一个网络流问题，对于每个$b_i$​，你可以放的位置就是a中所有$a_j \neq b_i$​的j，连边跑最大流即可，然而显然会爆这种特殊的网络流，考虑贪心的解法维护一个优先队列，对于每个$a_i$​，我们选择不等于$a_i$​的且可放置位置最少的那个$b_j$​，即在a中和它相等的元素最多。这样贪心即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDU95</title>
      <link href="/2020/09/15/edu95/"/>
      <url>/2020/09/15/edu95/</url>
      
        <content type="html"><![CDATA[<h2 id="D-Trash-Problem"><a class="header-anchor" href="#D-Trash-Problem">¶</a>D. Trash Problem</h2><p>有n堆物品排成一条线，可以将同一位置的<strong>所有</strong>物品同时移动到相邻的位置，q次操作，每次可以添加一堆物品或者删除一堆物品，并询问将所有物品移动成小于等于2堆的最小代价$n \leq 10^5,q \leq 10^5$第一反应应该是中位数，但要发现每次必须同时移动同一位置的所有物品，那么如果移成一堆，答案就是最大坐标$x_n$​-最小坐标$x_1$​，考虑移成两堆，只要枚举一个分割点i，然后前面的代价是$x_i-x_1$​，后面的代价是$x_n-x_{i+1}$​，所以最小代价就是最大坐标-最小坐标-相邻坐标的最大差值。利用multiset动态维护即可tips:可以用rbegin来指向最后一个元素，比--end方便点</p><h2 id="E-Expected-Damage"><a class="header-anchor" href="#E-Expected-Damage">¶</a>E. Expected Damage</h2><p>有n个怪物，第i个怪物的伤害为$d_i$​，现在有一个盾牌，有属性a和b，当$a\gt 0$时，可以免疫$\lt b$的伤害，而$\geq b$的伤害会使$a-1$（不会受到伤害），而当$a=0$时，会受到所有的伤害。现在有m种盾牌，对于每种需要回答在n!种打怪方式下，受到的伤害的期望$n \leq 2\times 10^5,m \leq 2\times 10^5$考虑每种怪物的贡献，容易发现可以分成伤害$&lt;b$和$\geq b$两类计算最好的做法是从整体上考虑定义ge为伤害$\geq b$的怪物数量，le为$&lt;b$的怪物数量，将d排序后lowerbound即可对于伤害$\geq b$的ge个怪物，排在前a个是没有伤害的，因为会被盾牌挡掉，所以有贡献的概率就是$\frac{ge-a}{ge}$，再乘上这些怪物的伤害和即可对于伤害$\lt b$的le个怪物，必须保证前面有至少a个伤害$\geq b$的怪物，可以固定住ge个怪物的位置，那么现在有ge+1个空位，前a个是没有贡献的，所以有贡献的概率就是$\frac{ge+1-a}{ge+1}$​，再乘上一个前缀和即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, m, d[N], sum[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) inv[i] = <span class="number">1ll</span>*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; d[i];</span><br><span class="line">  <span class="built_in">sort</span>(d+<span class="number">1</span>, d+n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) sum[i] = (sum[i<span class="number">-1</span>] + d[i])%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> le = <span class="built_in">lower_bound</span>(d+<span class="number">1</span>, d+n+<span class="number">1</span>, b) - d - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ge = n - le;</span><br><span class="line">    <span class="type">int</span> x = (ge &lt; a ? <span class="number">0</span> : <span class="number">1ll</span>*(ge-a)*inv[ge]%mod*(sum[n]-sum[le])%mod);</span><br><span class="line">    <span class="type">int</span> y = (ge &lt; a ? <span class="number">0</span> : <span class="number">1ll</span>*(ge+<span class="number">1</span>-a)*inv[ge+<span class="number">1</span>]%mod*sum[le]%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((x+y)%mod+mod)%mod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Three-Occurrences"><a class="header-anchor" href="#G-Three-Occurrences">¶</a>G. Three Occurrences</h2><p>给出一个数组a，定义一个区间是好的，当且仅当每个数恰好出现0次或者3次，询问好区间的个数$n\leq 5\times 10^5, 1\leq a_i \leq n$考虑固定左端点为i，那么$a_i$​出现0次和3次就是两个连续的区间，我们对$1-n$的每个数维护它的合法区间，如果是合法的就让这段区间的每个数都等于1，我们可以用一颗线段树来维护。从后往前枚举左端点，对于$a_i$​，我们先删除它之前的合法区间(两段区间-1)，然后再加上它当前的合法区间(两端区间+1)，只需要查询左端点-n中大小等于n的值的个数即可(显然最大值$\leq n$，所以维护最大值以及最大值个数即可)$O(n\log n)$这题还有一种更加普适的哈希做法，而且复杂度是$O(n)$的，先咕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, mx, cnt, tag;</span><br><span class="line">  <span class="built_in">seg</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">seg</span>(<span class="type">int</span> _l, <span class="type">int</span> _r) : <span class="built_in">l</span>(_l), <span class="built_in">r</span>(_r), <span class="built_in">mx</span>(<span class="number">0</span>), <span class="built_in">cnt</span>(<span class="number">0</span>), <span class="built_in">tag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].mx = <span class="built_in">max</span>(t[p&lt;&lt;<span class="number">1</span>].mx, t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx);</span><br><span class="line">  t[p].cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].mx==t[p&lt;&lt;<span class="number">1</span>].mx) t[p].cnt += t[p&lt;&lt;<span class="number">1</span>].cnt;</span><br><span class="line">  <span class="keyword">if</span>(t[p].mx==t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx) t[p].cnt += t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setv</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].mx += v;</span><br><span class="line">  t[p].tag += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setv</span>(p&lt;&lt;<span class="number">1</span>, t[p].tag); <span class="built_in">setv</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, t[p].tag);</span><br><span class="line">  t[p].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p] = <span class="built_in">seg</span>(l, r);</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mx = n, t[p].cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setv</span>(p, v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">push</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>, x, y, v);</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y, v);</span><br><span class="line">  <span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chk</span><span class="params">(pii &amp;a, pii b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.fi==b.fi) a.se += b.se;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(a.fi&lt;b.fi) a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y) <span class="keyword">return</span> &#123;t[p].mx, t[p].cnt&#125;;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">push</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; pii ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">chk</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">chk</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="type">int64_t</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) p[i].<span class="built_in">push_back</span>(n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> sz = p[a[i]].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(sz&gt;=<span class="number">4</span>) <span class="built_in">upd</span>(<span class="number">1</span>, p[a[i]][sz<span class="number">-3</span>], p[a[i]][sz<span class="number">-4</span>]<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> suf = p[a[i]][sz<span class="number">-1</span>];</span><br><span class="line">    p[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    ++sz;</span><br><span class="line">    <span class="keyword">if</span>(sz&gt;=<span class="number">4</span>) <span class="built_in">upd</span>(<span class="number">1</span>, p[a[i]][sz<span class="number">-3</span>], p[a[i]][sz<span class="number">-4</span>]<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>, i, suf<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur = <span class="built_in">ask</span>(<span class="number">1</span>, i, n);</span><br><span class="line">    <span class="keyword">if</span>(cur.fi==n) ans += cur.se;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6800 【模板】Chirp-Z Transform</title>
      <link href="/2020/09/13/p6800-mo-ban-chirp-z-transform/"/>
      <url>/2020/09/13/p6800-mo-ban-chirp-z-transform/</url>
      
        <content type="html"><![CDATA[<p>给出一个n项多项式P，要求出在$c^0,c^1,…,c^{m-1}$处多项式的值$n\leq 10^6,m\leq 10^6$</p><h4 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h4><p>直接多点求值会t$\sum \limits_{i=0}^{n-1}a_ic^{mi}P(cm)$考虑把$mi$换一下$mi = \binom{m+i}{2} - \binom{m}{2} -\binom{i}{2}$$P(c^m) = c^{-\binom{m}{2}}\sum\limits_{i=0}^{n-1}(a_ic^{-\binom{i}{2}})(c^{\binom{m+i}{2}})$减法卷积，把前一个翻转后NTT即可注意指数上的取模要用扩展欧拉定理如果把c换成$\omega_n^1$​即$complex(cos(2\pi/n),sin(2\pi/n))$，就是bluestein算法了，可以解决任意长度的卷积，就是常数很大，因为一次DFT就相当于一次多项式乘法，即三次DFT小优化：由于我们只需要得到n到n+m项的值，所以n次多项式和n+m次多项式我们只需要求到n+m即可，而不用求到2*n+m</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n, c, m, a[N], b[N];</span><br><span class="line"><span class="type">int</span> up, w[N], rev[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpw</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  up = <span class="number">1</span>; <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(up&lt;=n) up &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">  <span class="type">int</span> wn = <span class="built_in">fpw</span>(G, mod&gt;&gt;l); w[up&gt;&gt;<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>; i&lt;up; i++) w[i] = <span class="number">1ll</span>*w[i<span class="number">-1</span>]*wn%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) w[i] = w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(n)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> *b)</span> </span>&#123; <span class="keyword">while</span>(n--) *b++ = <span class="number">1ll</span>**a++*x%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dot</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> n, <span class="type">int</span> *c)</span> </span>&#123; <span class="keyword">while</span>(n--) *c++ = <span class="number">1ll</span>**a++**b++%mod; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp[N];</span><br><span class="line">  <span class="type">int</span> u = __builtin_ctz(up/l), t;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) tmp[i] = a[rev[i]&gt;&gt;u];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i^l; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>, d=i&lt;&lt;<span class="number">1</span>; j^l; j+=d)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">        t = tmp[i|j|k]*w[i|k]%mod, tmp[i|j|k] = tmp[j|k]+mod-t, tmp[j|k] += t;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) a[i] = tmp[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IDFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+l); <span class="built_in">DFT</span>(a, l);</span><br><span class="line">  <span class="built_in">mul</span>(a, l, mod-mod/l, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;c, &amp;m);</span><br><span class="line">  --n, --m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    a[i] = <span class="number">1ll</span>*a[i]*<span class="built_in">fpw</span>(c, (mod<span class="number">-1</span>)<span class="number">-1ll</span>*i*(i<span class="number">-1</span>)/<span class="number">2</span>%(mod<span class="number">-1</span>))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n+m; i++) b[i] = <span class="built_in">fpw</span>(c, <span class="number">1ll</span>*i*(i<span class="number">-1</span>)/<span class="number">2</span>%(mod<span class="number">-1</span>));</span><br><span class="line">  <span class="built_in">init</span>(<span class="number">2</span>*n+m);</span><br><span class="line">  <span class="built_in">reverse</span>(a, a+n+<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> l = <span class="built_in">getlen</span>(<span class="number">2</span>*n+m);</span><br><span class="line">  <span class="built_in">DFT</span>(a, l); <span class="built_in">DFT</span>(b, l); <span class="built_in">dot</span>(a, b, l, a); <span class="built_in">IDFT</span>(a, l);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n; i&lt;=n+m; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, <span class="number">1ll</span>*a[i]*<span class="built_in">fpw</span>(c, (mod<span class="number">-1</span>)<span class="number">-1ll</span>*(i-n)*(i-n<span class="number">-1</span>)/<span class="number">2</span>%(mod<span class="number">-1</span>))%mod, <span class="string">&quot; \n&quot;</span>[i==n+m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G、Pikachu 问题转化+换根dp</title>
      <link href="/2020/09/03/gpikachu-wen-ti-zhuan-hua-huan-gen-dp/"/>
      <url>/2020/09/03/gpikachu-wen-ti-zhuan-hua-huan-gen-dp/</url>
      
        <content type="html"><![CDATA[<p>给定一棵n个点的树，定义一张完全图，$w(u, v) = dis(u, v)$，问你各对节点间的最大流的和$n \leq 10^5$最大流不好想，转化成最小割，那么s到t的最小割就是将完全图分成两个不连通的完全图，其中一个包含s，另一个包含t，然后要最大化这两个完全图内部的边权和。容易发现当其中一个点为孤立点，另一个为n-1个点的完全图是最优，相当于割去孤立点与其他n-1个点间的所有边。所以s与t间的最大流等于min(s与其他所有点在树上的距离和，t与其他所有点在树上的距离和)。我们可以通过换根dp求出每个节点与其他所有点在树上的距离和，然后从大到小排序后，每个的贡献就是(rank-1)次，粗略估算可以发现答案需要用__int128存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, sz[N];</span><br><span class="line">vector&lt;pii&gt; G[N];</span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sz[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    sz[u] += sz[v];</span><br><span class="line">    dp[u][<span class="number">0</span>] += dp[v][<span class="number">0</span>] + w*sz[v];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    dp[v][<span class="number">1</span>] = dp[u][<span class="number">0</span>] - dp[v][<span class="number">0</span>] - w*sz[v] + w*(sz[u] - sz[v]) + dp[u][<span class="number">1</span>] + w*(n - sz[u]);</span><br><span class="line">    <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> buf[<span class="number">70</span>], tp;</span><br><span class="line">  tp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(!x) buf[tp = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    buf[++tp] = x%<span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=tp; i&gt;=<span class="number">1</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) G[i].<span class="built_in">clear</span>(), dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    G[u].<span class="built_in">emplace_back</span>(v, w); G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="function">vector&lt;ll&gt; <span class="title">alldis</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) alldis[i<span class="number">-1</span>] = dp[i][<span class="number">0</span>] + dp[i][<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">sort</span>(<span class="built_in">begin</span>(alldis), <span class="built_in">end</span>(alldis)); <span class="built_in">reverse</span>(<span class="built_in">begin</span>(alldis), <span class="built_in">end</span>(alldis));</span><br><span class="line">  __int128 ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) ans += (__int128)i*alldis[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, kase); <span class="built_in">print</span>(ans); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> kase=<span class="number">1</span>; kase&lt;=_; ++kase) <span class="built_in">solve</span>(kase);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kinetic Tournament</title>
      <link href="/2020/09/03/kinetic-tournament/"/>
      <url>/2020/09/03/kinetic-tournament/</url>
      
        <content type="html"><![CDATA[<p>又是一个凸壳问题现在有n条直线，第i条的斜率为$k_i$​，截距为$b_i$​，当前x坐标的值为$x_i$​，要求支持以下操作1.修改第i条直线的斜率、截距2.让$[l, r]$范围内所有直线的x坐标的值增加delta3.询问$[l, r]$范围内所有直线的y坐标的最大值<a href="https://codeforces.com/blog/entry/82094">https://codeforces.com/blog/entry/82094</a>第二个操作必须是增加，不能减少其实就是用普通的线段树来做，如果不带修改，就是一棵胜者树(tournament)，自底向上进行pushup操作，p结点存储的是子树内所有直线中y坐标最大的那条，第一个操作和第三个操作就是普通的线段树了。对于第二个操作，我们在每个结点额外维护一个叫wait的变量，表示<strong>如果子树内胜者发生变化，最少要让整个子树的x坐标增加wait</strong>，这个东西可以pushup来维护，而区间增加delta，用一个lazytag即可。但是当且仅当当前区间的wait值大于这个增量delta时我们才直接整个子树修改，否则由于胜者会发生变化，所以我们继续递归下去（类似于segment beats，也是用摊还分析(<s>不会</s>)），复杂度大概是$\lt O(n\log^3n) \ or \approx O(n\log^2n)$那么问题来了，这玩意有啥用第一个操作可以当成插入和删除直线，第二个操作相当于修改询问的值，如果询问非增我们可以离线下来，第三个操作就是区间凸壳询问，而且斜率是否单调无关紧要。如果用一般的CHT，要实现区间查询，还要在外面套一个fenwicktree或者是segtree，复杂度上并没有优势，此外这个东西还能支持删除操作，似乎有点用。考虑一个树上的斜率优化，斜率单调我们可以用可回退的队列来维护凸壳，但是有了这个我们直接无脑树剖，管他斜率单不单调。以上纯属猜想，未经实践。。</p><h2 id="cf1178-G-The-Awesomest-Vertex"><a class="header-anchor" href="#cf1178-G-The-Awesomest-Vertex">¶</a>cf1178 G. The Awesomest Vertex</h2><p>这个问题相当于上面的支持2和3操作的版本，同时是子树问题（dfs序即可）这边要维护的是$|b_ix + a_ib_i|$的最大值，由于带绝对值，要同时维护最大值和最小值，我们考虑维护$-b_ix - a_ib_i$​的最大值即可。似乎要建两棵线段树，不过这边用一个技巧。我们开一个2*n的线段树，把这两棵树合起来，一颗放在$2i-1$的位置，一颗放在$2i$的位置，然后就可以当成一棵来操作了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll inf = LLONG_MAX;</span><br><span class="line"><span class="type">int</span> n, q, a[N], b[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> in[N], out[N], num[N], id;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  in[u] = ++id;</span><br><span class="line">  num[id] = u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    a[v] += a[u]; b[v] += b[u];</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  out[u] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">  ll k, b, x;</span><br><span class="line">  <span class="function">ll <span class="title">eval</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> k*x + b; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Line&amp; oth)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ll x1 = <span class="built_in">eval</span>(), x2 = oth.<span class="built_in">eval</span>();</span><br><span class="line">    <span class="keyword">if</span>(x1!=x2) <span class="keyword">return</span> x1 &gt; x2;</span><br><span class="line">    <span class="keyword">return</span> k &gt; oth.k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">isect</span><span class="params">(<span class="type">const</span> Line&amp; oth)</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">eval</span>()-oth.<span class="built_in">eval</span>())/(oth.k-k) + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  Line L;</span><br><span class="line">  ll wait, tag;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setv</span><span class="params">(<span class="type">int</span> p, ll add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].L.x += add;</span><br><span class="line">  t[p].tag += add;</span><br><span class="line">  t[p].wait -= add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> l1 = t[p&lt;&lt;<span class="number">1</span>].L, l2 = t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].L;</span><br><span class="line">  <span class="keyword">if</span>(!l1.<span class="built_in">cmp</span>(l2)) <span class="built_in">swap</span>(l1, l2);</span><br><span class="line">  t[p].L = l1;</span><br><span class="line">  t[p].wait = <span class="built_in">min</span>(t[p&lt;&lt;<span class="number">1</span>].wait, t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].wait);</span><br><span class="line">  <span class="keyword">if</span>(l1.k&lt;l2.k) t[p].wait = <span class="built_in">min</span>(t[p].wait, l1.<span class="built_in">isect</span>(l2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setv</span>(p&lt;&lt;<span class="number">1</span>, t[p].tag), <span class="built_in">setv</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, t[p].tag);</span><br><span class="line">  t[p].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].l = l, t[p].r = r, t[p].wait = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x = num[(l+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(l&amp;<span class="number">1</span>) t[p].L = &#123;b[x], <span class="number">1ll</span>*a[x]*b[x], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span> t[p].L = &#123;-b[x], <span class="number">-1ll</span>*a[x]*b[x], <span class="number">0</span>&#125;;</span><br><span class="line">    t[p].wait = inf;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y, ll add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y &amp;&amp; t[p].wait&gt;add)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setv</span>(p, add);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>, x, y, add);</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y, add);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y) <span class="keyword">return</span> t[p].L.<span class="built_in">eval</span>();</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">qry</span>(p&lt;&lt;<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">qry</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> fa; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;fa);</span><br><span class="line">    G[fa].<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b+i);</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>*n);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;v);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ll x; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>, in[v]*<span class="number">2</span><span class="number">-1</span>, out[v]*<span class="number">2</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">qry</span>(<span class="number">1</span>, in[v]*<span class="number">2</span><span class="number">-1</span>, out[v]*<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cache friendly</title>
      <link href="/2020/09/02/cache-friendly/"/>
      <url>/2020/09/02/cache-friendly/</url>
      
        <content type="html"><![CDATA[<p>尽量减少cache miss保证时空局部性，尽量连续地访存，使用局部变量使用指针访问可以加快速度（仅限于卡常）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *st = a + <span class="number">1</span>, *ed = a + n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(st!=ed) <span class="built_in">work</span>(*(st++));</span><br></pre></td></tr></table></figure><ul><li>对树进行树链剖分后，子树是一个连续的区间，树上的路径也可以被划分成log段连续区间。然后利用数据结构对这些连续区间进行操作即可。但是有些时候数据结构这块不好写，或者常数很大，比如说需要$O(n\sqrt n \logn)$来维护$10^5$个节点的操作，这时候我们可以直接对所有连续段for循环暴力$O(n^2)$维护，然后注意访问的连续性，这样cache的miss率是log级别的，通过pragma等预编译命令加速会有不错的效果</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast,no-stack-protector&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target(<span class="string">&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>该方法可以用于树上dp，如果是子树dp的话直接利用dfs序即可如果是到根的树链上dp，那就先树剖，然后对每个点把到根的路径化成log个连续段，然后暴力我们用一个局部变量存储需要更新的dp[u]，然后用来更新的dp[v]就是连续访存的，可以达到一定的加速效果，用指针可以略微加速</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updt</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll cur = LLONG_MAX, a = dep[u], b = p[u];</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    ll *p=tmpdep+dfn[top[x]]<span class="number">-1</span>, *q = dp+dfn[top[x]]<span class="number">-1</span>, *ped = tmpdep + dfn[x];</span><br><span class="line">    <span class="keyword">while</span>(p!=ped) <span class="built_in">chk</span>(cur, *(++q)+(a-*(++p)*b));</span><br><span class="line">    x = fa[<span class="number">0</span>][top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  ll *p=tmpdep+dfn[x]<span class="number">-1</span>, *ped = tmpdep+dfn[y], *q = dp+dfn[x] - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p!=ped) <span class="built_in">chk</span>(cur, *(++q)+(a-*(++p)*b));</span><br><span class="line">  dp[dfn[u]] = cur + q[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试$10^5$次的数据级别2.5s能出结果，这在一些时限比较宽松，正解复杂度要多个log或者根号的情况下可能可以骗过去，而$2\times 10^5$就是10s左右才能出结果了。</p><ul><li>点分治的时候我们要处理跨越重心的各部分的贡献，这需要双指针或者一些数据结构来维护，同样的我们把它们映射到连续的数组段上，在进行暴力也会有一定加速</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4072 [SDOI2016]征途 推式子 斜率优化dp</title>
      <link href="/2020/09/02/p4072-sdoi2016zheng-tu-tui-shi-zi-xie-lu-you-hua-dp/"/>
      <url>/2020/09/02/p4072-sdoi2016zheng-tu-tui-shi-zi-xie-lu-you-hua-dp/</url>
      
        <content type="html"><![CDATA[<p>给定n段路的长度，每天可以走连续的几段路，要求你走m天，并最小化每天走的路程长度的方差$\times m^2$的大小$n \leq 3000,m \leq 3000$</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>方差：$\frac{1}{m}\sum (x_i - \bar{x})^2m$ = $\frac{1}{m}(\sum x_i^2 + \sum \bar{x}^2 - 2\sum x_i\bar{x}) = \sum x_i$$\frac{1}{m}(\sum (x_i - \bar{x})^2) = m(\sum x_i^2 - \bar{x}\sum x_i)$ = $m\sum x_i^2 - (\sum x_i)^2$容易发现后一项是定值，所以只需要最小化$\sum x_i^2$​即可$dp_{i,j}$​表示前i段路走了j天的最小方差$dp_{i,j} = \min \limits_{k&lt;i} \{dp_{k,j-1} + (sum_i-sum_k)^2\}$每次询问$sum_i$​处y的最小值，然后插入一条斜率为$-2sum_i$​，截距为$sum_i^2 + dp_{i,j-1}$​的直线。斜率单调递减，询问单调递增，双端队列维护下凸壳即可通过斜率优化就可以$n^2$通过本题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, d[N];</span><br><span class="line">ll sum[N], dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">  ll k, b;</span><br><span class="line">  <span class="function">ll <span class="title">eval</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> k*x + b; &#125;</span><br><span class="line">  <span class="function">db <span class="title">insect</span><span class="params">(Line oth)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">db</span>(b-oth.b)/(oth.k-k); &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="type">int</span> ql, qr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, d+i), sum[i] = sum[i<span class="number">-1</span>] + d[i], dp[i][<span class="number">0</span>] = sum[i]*sum[i];</span><br><span class="line">  <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">  ll ans = dp[n][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">2</span>; c&lt;=m; c++, p^=<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    q[ql=qr=<span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span>(ql&lt;qr &amp;&amp; q[ql].<span class="built_in">insect</span>(q[ql+<span class="number">1</span>])&lt;=sum[i]) ++ql;</span><br><span class="line">      dp[i][p] = q[ql].<span class="built_in">eval</span>(sum[i]) + sum[i]*sum[i];</span><br><span class="line">      Line cur = &#123;<span class="number">-2</span>*sum[i], sum[i]*sum[i]+dp[i][p^<span class="number">1</span>]&#125;;</span><br><span class="line">      <span class="keyword">while</span>(ql&lt;qr &amp;&amp; cur.<span class="built_in">insect</span>(q[qr])&lt;=cur.<span class="built_in">insect</span>(q[qr<span class="number">-1</span>])) --qr;</span><br><span class="line">      q[++qr] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, dp[n][p]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, m*ans-sum[n]*sum[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4655 [CEOI2017]Building Bridges 斜率优化</title>
      <link href="/2020/09/02/p4655-ceoi2017building-bridges-xie-lu-you-hua/"/>
      <url>/2020/09/02/p4655-ceoi2017building-bridges-xie-lu-you-hua/</url>
      
        <content type="html"><![CDATA[<p>有n根柱子，第i根柱子的高度为$h_i$​，被拆除的代价为$w_i$​，在j和i两根柱子间架桥的费用为$(h_i-h_j)^2 + \sum \limits_{k=j+1}^{i-1} w_k$​，问连接1和n的最小代价</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>$dp_i = \min \limits_{j&lt;i} \{dp_j + (h_i-h_j)^2 + s_{i-1} - s_j\}$ 此处s为w的前缀和显然可以化为斜率优化的形式每次询问$h_i$​处y的最小值，然后插入一条斜率为$-2h_i$​，截距为$h_i^2-s_i+dp_i$​的直线。由于这里的$h_i$​不具备单调性，所以不能用队列来维护。可以用平衡树、李超树或者cdq分治解决</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, h[N];</span><br><span class="line">ll w[N], dp[N];</span><br><span class="line"><span class="type">bool</span> Cmp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">mutable</span> ll k, b, p;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Line&amp; oth) <span class="type">const</span> &#123; <span class="keyword">return</span> Cmp ? p &lt; oth.p : k &lt; oth.k; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConvecHull</span> : multiset&lt;Line&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ll inf = LLONG_MAX;</span><br><span class="line">  <span class="function">ll <span class="title">div</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a&gt;<span class="number">0</span> ? inf : -inf;</span><br><span class="line">    <span class="keyword">return</span> a / b - ((a ^ b) &lt; <span class="number">0</span> &amp;&amp; a % b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isect</span><span class="params">(iterator x, iterator y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="built_in">end</span>()) &#123; x-&gt;p = inf; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;k == y-&gt;k) x-&gt;p = x-&gt;b &gt; y-&gt;b ? inf : -inf;</span><br><span class="line">    <span class="keyword">else</span> x-&gt;p = <span class="built_in">div</span>((y-&gt;b - x-&gt;b), (x-&gt;k - y-&gt;k));</span><br><span class="line">    <span class="keyword">return</span> x-&gt;p &gt;= y-&gt;p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll k, ll b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">insert</span>(&#123;k, b, <span class="number">0</span>&#125;), y = z++, x = y;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isect</span>(y, z)) z = <span class="built_in">erase</span>(z);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="built_in">begin</span>() &amp;&amp; <span class="built_in">isect</span>(--x, y)) <span class="built_in">isect</span>(x, y = <span class="built_in">erase</span>(y));</span><br><span class="line">    <span class="keyword">while</span> ((y = x) != <span class="built_in">begin</span>() &amp;&amp; (--x)-&gt;p &gt;= y-&gt;p) <span class="built_in">isect</span>(x, <span class="built_in">erase</span>(y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">qry</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Cmp = <span class="number">1</span>; <span class="keyword">auto</span> l = *<span class="built_in">lower_bound</span>(&#123;<span class="number">0</span>, <span class="number">0</span>, x&#125;); Cmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l.k * x + l.b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;ch;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, h+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, w+i), w[i] += w[i<span class="number">-1</span>];</span><br><span class="line">  ch.<span class="built_in">add</span>(<span class="number">2</span>*h[<span class="number">1</span>], <span class="number">-1ll</span>*h[<span class="number">1</span>]*h[<span class="number">1</span>]+w[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    dp[i] = -ch.<span class="built_in">qry</span>(h[i]) + w[i<span class="number">-1</span>] + <span class="number">1ll</span>*h[i]*h[i];</span><br><span class="line">    ch.<span class="built_in">add</span>(<span class="number">2</span>*h[i], <span class="number">-1ll</span>*h[i]*h[i]+w[i]-dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dp[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforces1396C</title>
      <link href="/2020/08/31/codeforces1396c/"/>
      <url>/2020/08/31/codeforces1396c/</url>
      
        <content type="html"><![CDATA[<p>有n个关卡，每关有$a_i$​个小怪(1hp)和1个boss(2hp)，在第i关可以转移到i-1和i+1关，需要花费d，有三种武器</p><ul><li>花费r1，让一只怪物-1hp</li><li>花费r2，让所有怪物-1hp</li><li>花费r3，秒杀一只怪物</li></ul><p>其中第一和第三种武器必须在没有小怪的情况下才能攻击boss，并且如果没有秒掉boss（还剩1滴血），则会被强制转移到相邻的关卡（花费d），问你杀死所有怪物的最小花费$n \leq 10^6,1\leq r1 \leq r2 \leq r3 \leq 10^9$</p><h3 id="解法"><a class="header-anchor" href="#解法">¶</a>解法</h3><p>在某一关中我们要么用r3直接秒掉boss避免强制转移(先用r1清小怪)，要么就先让boss少一滴血(用r1清小怪再点一下boss或者一下r2)转移走，之后再回来用一下r1点死boss。所以每关其实只有两种选择，一是用r1杀掉小怪后用r3秒掉boss(cost1=a[i]*r1+r3)，二是用r2或者(a[i]*r1+r1)让boss剩1hp然后强制转移走回来后再花r1杀死boss(cost2=min(a[i]*r1+r1,r2))，然后就可以dp了$dp_{i,0}$​表示第i关已经解决的最小费用，$dp_{i,1}$​表示第i关的boss还剩1hp然后还没强制跳转的最小费用$dp_{0,0}=min(dp_{i-1,0}+d+min(cost1,2*d+cost2+r1),dp_{i-1,1}+3*d+r1+min(cost1,cost2+r1))$如果上一关已经消灭($dp_{i-1,0}$​)，这一关要么就cost1，要么就cost2然后来回跳两个d，再一个r1补死如果上一关还有1hp，那么这关消灭后再回去补死上一关再回来$dp_{i,1} = dp_{i-1,0}+d+cost2$还有一种特殊情况就是在倒数第二关强制转移到最后一关，然后消灭最后一关再转移到倒数第二关补死之后结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line">ll r1, r2, r3, d, dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;r1, &amp;r2, &amp;r3, &amp;d);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = -d;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ll c1 = <span class="built_in">min</span>(a[i]*r1+r1, r2), c2 = a[i]*r1 + r3;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]+d+<span class="built_in">min</span>(c2, <span class="number">2</span>*d+c1+r1), dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">3</span>*d+r1+<span class="built_in">min</span>(r1+c1, c2));</span><br><span class="line">    dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+d+c1;</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="built_in">min</span>(dp[n][<span class="number">0</span>], dp[n<span class="number">-2</span>][<span class="number">0</span>]+d+a[n]*r1+r3+r1+<span class="number">2</span>*d+<span class="built_in">min</span>(a[n<span class="number">-1</span>]*r1+r1, r2));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸包</title>
      <link href="/2020/08/30/convex-hull-trick/"/>
      <url>/2020/08/30/convex-hull-trick/</url>
      
        <content type="html"><![CDATA[<h2 id="计算几何中的凸包"><a class="header-anchor" href="#计算几何中的凸包">¶</a>计算几何中的凸包</h2><p>给定n个点求凸包利用andrew算法（比graham好写一点而且常数小）将所有点按照x为第一关键字，y为第二关键字排序然后从前往后用栈维护出下凸壳，再从后往前用栈维护出上凸壳即可考虑当前栈中的最后两个点p，q，现在加入一个点o，那么只要看q-p和o-p这两条直线的左右关系即可，用叉积判断多边形用vector存储，凸包分为严格凸包和非严格凸包（一般都是建成严格的），区别就是如果叉积等于0的时候不再pop，那么就是非严格的，可能会存在多点共线的情况另外要注意多边形点数少于3的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Polygon <span class="title">ConvexHull</span><span class="params">(Polygon&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = s.<span class="built_in">size</span>(), sz = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">  <span class="function">Polygon <span class="title">res</span><span class="params">(<span class="number">2</span>*n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(sz&gt;<span class="number">0</span> &amp;&amp; <span class="built_in">crossop</span>(res[sz<span class="number">-1</span>], res[sz], s[i])&lt;=<span class="number">0</span>) --sz;</span><br><span class="line">    res[++sz] = s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> pre = sz;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(sz&gt;pre &amp;&amp; <span class="built_in">crossop</span>(res[sz<span class="number">-1</span>], res[sz], s[i])&lt;=<span class="number">0</span>) --sz;</span><br><span class="line">    res[++sz] = s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="built_in">resize</span>(sz);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多边形面积(相邻点叉积求和，逆时针为正，顺时针为负)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">db <span class="title">getarea</span><span class="params">(Polygon&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  db ans = <span class="number">0</span>; <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) ans += (s[i]^s[(i+<span class="number">1</span>)%n]);</span><br><span class="line">  <span class="keyword">return</span> ans/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凸包周长(相邻点距离求和即可)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">db <span class="title">getcir</span><span class="params">(Polygon&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">db ans = <span class="number">0</span>; <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) ans += s[i].<span class="built_in">dis</span>(s[(i+<span class="number">1</span>)%n]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凸包直径(旋转卡壳，对于每条边(i,i+1)，找到距离这条边最远的点j，容易发现具有单调性，可以用双指针实现)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">db <span class="title">ConvexDiameter</span><span class="params">(Polygon&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">0</span>].<span class="built_in">dis</span>(s[<span class="number">1</span>]);</span><br><span class="line">  <span class="type">int</span> j = <span class="number">2</span>; db ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cross</span>(s[i], s[i+<span class="number">1</span>], s[j])&lt;<span class="built_in">cross</span>(s[i], s[i+<span class="number">1</span>], s[(j+<span class="number">1</span>)%n])) j = (j+<span class="number">1</span>)%n;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(s[i].<span class="built_in">dis</span>(s[j]), s[i+<span class="number">1</span>].<span class="built_in">dis</span>(s[j])));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凸包的闵可夫斯基和还是凸包(定义就是一个凸包中的点按照原点和另一个凸包中的点形成的向量移动后形成的图形)闵可夫斯基和后的凸包的边是由原来的两个凸包上的边构成的，所以归并排序一下即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Polygon <span class="title">Minkowski</span><span class="params">(Polygon&amp; a, Polygon&amp; b)</span> <span class="comment">//可能有三点共线，可以再求一次凸包</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Polygon c;</span><br><span class="line">  <span class="type">int</span> n = a.<span class="built_in">size</span>(), m = b.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;n||j&lt;m; )</span><br><span class="line">  &#123;</span><br><span class="line">    c.<span class="built_in">push_back</span>(a[i%n]+b[j%m]);</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=n) ++j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=m) ++i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sgn</span>((a[(i+<span class="number">1</span>)%n]-a[i])^(b[(j+<span class="number">1</span>)%m]-b[j]))&gt;=<span class="number">0</span>) ++i;</span><br><span class="line">    <span class="keyword">else</span> ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划中的凸包"><a class="header-anchor" href="#动态规划中的凸包">¶</a>动态规划中的凸包</h2><p>一般用于斜率优化，考虑一个dp转移式$f_i = \max \limits_{k&lt;i} \{ f_k + a_ib_k\}$可以把后面的东西看成$b_ka_i + f_k$​，即$kx+b$的直线形式，然后我们就是要对每个$a_i$​找到之前所有直线中在该点处的最大值(别人的斜率优化可能是按照斜率的，不过我觉得这样子更直观一点，也不需要移项，如果了解李超树，很容易发现这完全可以用李超树来做)当然用李超树来做似乎有点大材小用，容易发现答案一定是在所有直线形成的上凸壳上，而且每条直线会有一个贡献范围</p><ul><li><p>如果插入的直线斜率单调($b_k$​)，且询问点也单调($a_i$​)这时候我们只需要用双端队列来维护上凸壳即可，在队尾不断插入直线并且维护凸壳，在队首及时排掉已经结束贡献了的点，对于当前询问的最优点就是队首</p></li><li><p>如果插入的直线斜率单调($b_k$​)，但询问点不单调($a_i$​)斜率单调，所以我们仍然可以线性地维护上凸壳，但是我们不能pop_front来维护最优点，因为最优点没有单调性了，所以我们需要在凸壳上二分，找到最优决策点</p></li><li><p>如果插入的直线斜率不单调($b_k$​)，且询问点也不单调($a_i$​)一种方法就是李超树了，另一种方法是用平衡树来维护，以下给出一份set实现的代码（很好用，如果插入的是直线就用这个，如果是线段的话就只能李超树了）k和b分别是斜率和截距，p类似于最优决策点（不用管）div函数是一个下取整函数，负数的时候的取整和正数会有区别isect是求两条直线的交点，然后进行判断（类似于李超树中的判断）使用的时候只需要add(k,b)来添加一条直线，qry(x)来询问在x点处的最大值当然如果要求最小值，只需要add(-k,-b)，然后-qry(x)就是答案了</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Cmp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">mutable</span> ll k, b, p;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Line&amp; oth) <span class="type">const</span> &#123; <span class="keyword">return</span> Cmp ? p &lt; oth.p : k &lt; oth.k; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConvecHull</span> : multiset&lt;Line&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ll inf = LLONG_MAX;</span><br><span class="line">  <span class="function">ll <span class="title">div</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a&gt;<span class="number">0</span> ? inf : -inf;</span><br><span class="line">    <span class="keyword">return</span> a / b - ((a ^ b) &lt; <span class="number">0</span> &amp;&amp; a % b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isect</span><span class="params">(iterator x, iterator y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="built_in">end</span>()) &#123; x-&gt;p = inf; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;k == y-&gt;k) x-&gt;p = x-&gt;b &gt; y-&gt;b ? inf : -inf;</span><br><span class="line">    <span class="keyword">else</span> x-&gt;p = <span class="built_in">div</span>((y-&gt;b - x-&gt;b), (x-&gt;k - y-&gt;k));</span><br><span class="line">    <span class="keyword">return</span> x-&gt;p &gt;= y-&gt;p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll k, ll b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">insert</span>(&#123;k, b, <span class="number">0</span>&#125;), y = z++, x = y;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isect</span>(y, z)) z = <span class="built_in">erase</span>(z);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="built_in">begin</span>() &amp;&amp; <span class="built_in">isect</span>(--x, y)) <span class="built_in">isect</span>(x, y = <span class="built_in">erase</span>(y));</span><br><span class="line">    <span class="keyword">while</span> ((y = x) != <span class="built_in">begin</span>() &amp;&amp; (--x)-&gt;p &gt;= y-&gt;p) <span class="built_in">isect</span>(x, <span class="built_in">erase</span>(y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">qry</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Cmp = <span class="number">1</span>; <span class="keyword">auto</span> l = *<span class="built_in">lower_bound</span>(&#123;<span class="number">0</span>, <span class="number">0</span>, x&#125;); Cmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l.k * x + l.b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何删除一条直线"><a class="header-anchor" href="#如何删除一条直线">¶</a>如何删除一条直线</h3><p>删除操作不好做（类似并查集），我们可以离线后把每条直线的存活时间塞到线段树上的log个节点上（即线段树分治），对每个节点维护一个凸壳，然后对于一个询问就是线段树上包含该点的节点的凸壳上的最大值的最大值给出所有直线再建凸壳，可以利用andrew来实现（排序后，从前往后用栈维护），询问最值一次二分即可（没必要三分）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gym101482G 距离转化 三分 思维</title>
      <link href="/2020/08/29/gym101482g-ju-chi-zhuan-hua-san-fen-si-wei/"/>
      <url>/2020/08/29/gym101482g-ju-chi-zhuan-hua-san-fen-si-wei/</url>
      
        <content type="html"><![CDATA[<p>给定二维平面上n个点的坐标，让你找一个点，最小化所有点到这个点的曼哈顿距离之和，并且要求每个点到该点的曼哈顿距离不能超过d$n \leq 100000,d \leq 2\times 10^9$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>如果没有d的限制，答案就是这n个点x坐标的中位数和y坐标的中位数。加上d的限制后，对于每个点都有一个菱形的限制区域，所以最后的可行域就是这n个点限制的菱形区域的并，菱形不好处理，我们转化成切比雪夫距离后就变成了正方形，维护L，R，D，U，那么两个正方形的并就是max(L)，min®，max(D)，min(U)。曼哈顿距离中x、y两维是独立的，而每一维又是一个凹函数，所以在可行域范围内三分套三分即可。给定一个点的坐标，计算n个点到这个点的曼哈顿距离和可以通过二分$O(\log n)$解决。(x,y) -&gt; (x+y,x-y) 原坐标系的曼哈顿距离-&gt;新坐标系的切比雪夫距离(x,y) -&gt; ((x+y)/2,(x-y)/2) 原坐标系的切比雪夫距离-&gt;新坐标系的曼哈顿距离我们维护的LRDU是在切比雪夫坐标系中，而三分的范围是在曼哈顿坐标中的，所以x的三分范围应该是[(L+D)/2,(R+U)/2]，确定了x后，$L\leqx+y \leq R,D\leq x-y \leq U$，那么y的三分范围就是[max(L-x,x-U),min(R-x,x-D)]了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, x[N], y[N], d;</span><br><span class="line">ll U, D, L, R, prex[N], prey[N];</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">upper_bound</span>(x+<span class="number">1</span>, x+n+<span class="number">1</span>, a) - x - <span class="number">1</span>, q = <span class="built_in">upper_bound</span>(y+<span class="number">1</span>, y+n+<span class="number">1</span>, b) - y - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> a*p - prex[p] + b*q - prey[q] - (n-p)*a + (prex[n] - prex[p]) - (n-q)*b + (prey[n] - prey[q]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll l = <span class="built_in">max</span>(x-U, L-x), r = <span class="built_in">min</span>(x-D, R-x), ans = LINF;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    ll mid = (<span class="number">2</span>*l+r)/<span class="number">3</span>, mmid = (<span class="number">2</span>*r+l+<span class="number">2</span>)/<span class="number">3</span>;</span><br><span class="line">    ll fmid = <span class="built_in">f</span>(x, mid), fmmid = <span class="built_in">f</span>(x, mmid);</span><br><span class="line">    <span class="keyword">if</span>(fmid&lt;=fmmid)</span><br><span class="line">    &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, fmid);</span><br><span class="line">      r = mmid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, fmmid);</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, x+i, y+i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">    U = LINF, D = -LINF, L = -LINF, R = LINF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      ll cx = x[i] + y[i], cy = x[i] - y[i];</span><br><span class="line">      U = <span class="built_in">min</span>(U, cy+d);</span><br><span class="line">      D = <span class="built_in">max</span>(D, cy-d);</span><br><span class="line">      L = <span class="built_in">max</span>(L, cx-d);</span><br><span class="line">      R = <span class="built_in">min</span>(R, cx+d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(D&gt;U||L&gt;R)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x+<span class="number">1</span>, x+n+<span class="number">1</span>); <span class="built_in">sort</span>(y+<span class="number">1</span>, y+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) prex[i] = prex[i<span class="number">-1</span>] + x[i], prey[i] = prey[i<span class="number">-1</span>] + y[i];</span><br><span class="line">    ll l = (L+D)/<span class="number">2</span>, r = (R+U)/<span class="number">2</span>, ans = LINF;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">      ll mid = (<span class="number">2</span>*l+r)/<span class="number">3</span>, mmid = (<span class="number">2</span>*r+l+<span class="number">2</span>)/<span class="number">3</span>;</span><br><span class="line">      ll fmid = <span class="built_in">cal</span>(mid), fmmid = <span class="built_in">cal</span>(mmid);</span><br><span class="line">      <span class="keyword">if</span>(fmid&lt;=fmmid)</span><br><span class="line">      &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, fmid);</span><br><span class="line">        r = mmid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, fmmid);</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>min_25筛</title>
      <link href="/2020/08/28/min_25-shai/"/>
      <url>/2020/08/28/min_25-shai/</url>
      
        <content type="html"><![CDATA[<p>当f$f(i)$是一个积性函数，且$f(p)$是一个关于p的低阶多项式，$f(p^k)$是一个容易计算的式子，那么就可以利用该亚线性筛，快速算出$\sum_{i=1}^nf(i)$，$n \leq 10^{11}$</p><h3 id="第一步"><a class="header-anchor" href="#第一步">¶</a>第一步</h3><p>利用另一个函数$g(n,j)$，快速计算出f在质数处的前缀和</p><p>$g(n, j) = \sum \limits_{i=1}^n [i \ is \ prime || minp &gt; p_j] i^k$</p><p>表示$\leq n$中的所有质数以及最小质因子<strong>大于</strong>第j小质数$p_j$​的所有数的k次方和，因为f(p)是一个关于p的多项式，这样我们把这个多项式拆成单项式，再取不同的k，而当$p_j$​等于最后一个小于等于$\sqrt n​$的质因子时，$g(n, j)$就表示小于等于n的所有质数的k次方和了。一个数的最小质因子一定是$\leq \sqrt n$​的考虑从$g(n, j-1)$转移到$g(n, j)$时，只需要去掉最小质因子$=p_j$​的所有合数即可</p><p>$g(n, j) = g(n, j-1) -p_j^k(g(\frac{n}{p_j}, j-1) - g(p_{j-1}, j-1))$</p><p>其中$g(p_{j-1}, j-1)$表示前$j-1$个质数的k次方和，可以在线性筛的时候预处理出来在转移的时候我们只需要用到$\lfloor \dfrac{n}{x} \rfloor$处的取值，而这种值的个数是$O(\sqrt n)$级别的，可以利用一个id1数组和一个id2数组映射一下，对于$\leq \sqrt n$​的数，存在id1里，对于其他数存在id2中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ll w[M], g1[M], g2[M];</span><br><span class="line"><span class="type">int</span> id1[M], id2[M];</span><br><span class="line"><span class="keyword">auto</span> id = [&amp;](ll x) &#123; <span class="keyword">return</span> x&lt;=B ? id1[x] : id2[n/x]; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(ll _n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">  n = _n, B = <span class="built_in">sqrt</span>(n) + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">getprime</span>(B);</span><br><span class="line">  <span class="keyword">for</span>(ll l=<span class="number">1</span>, r, v; l&lt;=n; l=r+<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    v = n/l, r = n/v;</span><br><span class="line">    w[++sz] = v; g1[sz] = <span class="built_in">prex1</span>(v); g2[sz] = <span class="built_in">prex2</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(v&lt;=B) id1[v] = sz; <span class="keyword">else</span> id2[r] = sz;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=pc; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=sz&amp;&amp;<span class="number">1ll</span>*pr[i]*pr[i]&lt;=w[j]; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> t = <span class="built_in">id</span>(w[j]/pr[i]);</span><br><span class="line">      g1[j] = ((g1[j] - (g1[t] - sp1[i<span class="number">-1</span>])*<span class="built_in">x1</span>(pr[i]))%mod + mod)%mod;</span><br><span class="line">      g2[j] = ((g2[j] - (g2[t] - sp2[i<span class="number">-1</span>])*<span class="built_in">x2</span>(pr[i]))%mod + mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这一步我们就可以求f在质数处的前缀和了，如果要快速统计质数个数，答案就是$g_{id(n)}$​</p><h3 id="第二步"><a class="header-anchor" href="#第二步">¶</a>第二步</h3><p>同样的，设$S(n,k)$表示求所有质因子大于$p_k$​的数(大于$p_k$​的质数也算)的函数f之和，答案就是$S(n,0)$</p><p>$S(n,x) = g(n) - sp_x + \sum\limits_{p_k^e \leq n \land k&gt;x} f(p_k^e)S(\frac{n}{p_k^e} + [e \neq 1])$</p><p>其中$g(n)-sp_x$​表示大于$p_k$​的质数的函数f之和，这在第一步中已经预处理出来，再枚举合数中最小质因子的大小以及幂次，递归处理即可，注意我们在所有计算中都是不统计1处的答案的，所以当$e\gt 1$时，要额外算上$f(p_k^e)$)处的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">go</span><span class="params">(ll x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pr[k]&gt;=x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> t = <span class="built_in">id</span>(x); ll ans = (<span class="built_in">f</span>(g1[t]-sp1[k], g2[t]-sp2[k])%mod + mod)%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=k+<span class="number">1</span>; i&lt;=pc&amp;&amp;<span class="number">1ll</span>*pr[i]*pr[i]&lt;=x; i++)</span><br><span class="line">    <span class="keyword">for</span>(ll pp=pr[i], e=<span class="number">1</span>; pp&lt;=x; e++, pp=pp*pr[i])</span><br><span class="line">      ans = (ans + <span class="built_in">fp</span>(pp%mod)*(<span class="built_in">go</span>(x/pp, i)+(e!=<span class="number">1</span>)))%mod;</span><br><span class="line">  <span class="keyword">return</span> (ans+mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的答案就是go(n, 0)+f(1)了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gym102501H Pseudo-Random Number Generator 循环节</title>
      <link href="/2020/08/27/gym102501h-pseudo-random-number-generator-xun-huan-jie/"/>
      <url>/2020/08/27/gym102501h-pseudo-random-number-generator-xun-huan-jie/</url>
      
        <content type="html"><![CDATA[<p>给定一个数列的递推方式，求其前n项中偶数的个数$M=1ull&lt;&lt;40$$s0=0x600DCAFE$$s_{n+1} = (s_n + (s_n &gt;&gt; 20) + 12345)%M$$n \lt 2^{63}$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>因为要模M，所以猜想有循环节找循环节的方式是用链表的判环算法（快慢指针）快慢指针同时位于起点，然后快指针一次走两步，慢指针一次走一步，若两者相遇说明有环，此时让一个指针从起点开始，一个指针从相遇点开始，一次各走一步，当两者相遇，该点就是入环点以下代码返回入环点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ull <span class="title">findloop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ull fst = <span class="number">0x600DCAFE</span>, slw = <span class="number">0x600DCAFE</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    slw = <span class="built_in">nxt</span>(slw);</span><br><span class="line">    fst = <span class="built_in">nxt</span>(<span class="built_in">nxt</span>(fst));</span><br><span class="line">    <span class="keyword">if</span>(fst==slw) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  slw = <span class="number">0x600DCAFE</span>;</span><br><span class="line">  <span class="keyword">while</span>(slw!=fst) slw = <span class="built_in">nxt</span>(slw), fst = <span class="built_in">nxt</span>(fst);</span><br><span class="line">  <span class="keyword">return</span> slw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道入环点后，让一个指针在起点走至该点的步数就是循环节开始的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ull x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ull s = <span class="number">0x600DCAFE</span>; ll len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(s!=x) len++, s = <span class="built_in">nxt</span>(s);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让一个指针从入环点下一个开始再走至入环点的步数+1就是循环节的长度（环长）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">g</span><span class="params">(ull x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ull s = <span class="built_in">nxt</span>(x); ll len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(s!=x) len++, s = <span class="built_in">nxt</span>(s);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果是st = 350125310, loop = 182129209这样还是过不了，我们可以利用分段打表，将前st项每隔1e6个数记录一下前缀答案，循环节也每隔1e6个数记录一下前缀答案，此外还要记录一下该点对应处的数列的取值。这样对于整块我们可以直接得到答案，而后面不完整的块再暴力一下即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p5488 差分与前缀和</title>
      <link href="/2020/08/25/p5488-chai-fen-yu-qian-zhui-he-2/"/>
      <url>/2020/08/25/p5488-chai-fen-yu-qian-zhui-he-2/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>快速求一个数列a的k阶差分或者k阶前缀和$n \leq 10^5,k\leq 10^{2333},mod=1004535809$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>将数列a看成OGF:$F(x) = \sum \limits_{i=0}^{\infty}a_ix^i$作一次前缀和相当于乘以$\sum \limits_{i=0}^{\infty} x^i =\dfrac{1}{1-x}$作一次差分相当于乘以$(1-x)$利用二项式定理：$\dfrac{1}{(1-x)^k} =(1-x)^{-k} = \sum \limits_{i=0}^{\infty} \dfrac{(-k)^{\underline{i}}}{i!}(-x)^i = \sum \limits_{i=0}^{\infty} \dfrac{(k+i-1)^{\underline{i}}}{i!}x^i$线性递推出前n项的系数，然后和a作一次卷积即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>, mod = <span class="number">1004535809</span>, gen = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n, k, t, a[N], b[N], inv[N];</span><br><span class="line"><span class="type">int</span> up, l, rev[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) k = (<span class="number">1ll</span>*k*<span class="number">10</span> + c - <span class="number">48</span>)%mod, c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">powmod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  up = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(up&lt;=n) up &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;up; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> gn = <span class="built_in">powmod</span>(gen, (mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">-1</span>) gn = <span class="built_in">powmod</span>(gn, mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;up; j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>,g=<span class="number">1</span>; k&lt;i; k++,g=<span class="number">1ll</span>*g*gn%mod)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x = a[j+k], y = <span class="number">1ll</span>*g*a[j+k+i]%mod;</span><br><span class="line">      a[j+k] = (x+y)%mod, a[j+k+i] = (x-y+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(op==<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> invup = <span class="built_in">powmod</span>(up, mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) a[i] = <span class="number">1ll</span>*a[i]*invup%mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) inv[i] = <span class="number">1ll</span>*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">  <span class="built_in">read</span>(k);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(t) <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) b[i] = (<span class="number">-1ll</span>*b[i<span class="number">-1</span>]*(k-i+<span class="number">1</span>)%mod*inv[i]%mod+mod)%mod;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) b[i] = <span class="number">1ll</span>*b[i<span class="number">-1</span>]*(k+i<span class="number">-1</span>)%mod*inv[i]%mod;</span><br><span class="line">  <span class="built_in">init</span>(<span class="number">2</span>*n<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">NTT</span>(a, <span class="number">1</span>); <span class="built_in">NTT</span>(b, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) a[i] = <span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">  <span class="built_in">NTT</span>(a, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, a[i], <span class="string">&quot; \n&quot;</span>[i==n<span class="number">-1</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨氏矩阵(杨表）</title>
      <link href="/2020/08/25/yang-shi-ju-zhen-yang-biao/"/>
      <url>/2020/08/25/yang-shi-ju-zhen-yang-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="杨图"><a class="header-anchor" href="#杨图">¶</a>杨图</h2><p>对于n的一个划分$\lambda=(\lambda_1 \geq \lambda_2 \ldots) \vdash n$，杨图第$i$行有$\lambda_i$​个方块</p><h2 id="标准杨表"><a class="header-anchor" href="#标准杨表">¶</a>标准杨表</h2><p>将1-n这n个数填入一个杨图$\lambda$的每一个方块中，使得从上到下，从左到右数字都递增</p><h2 id="近似杨表"><a class="header-anchor" href="#近似杨表">¶</a>近似杨表</h2><p>将n个不同的数字填入杨图中存在一种插入算法RSK，从第一行开始，每次替换当前行第一个大于自己的数（如果有相同数字就替换第一个大于等于自己的数），并将替换的数去插入下一行，若找不到这样一个数，则将该数插入到该行末尾并结束</p><h2 id="钩子定理"><a class="header-anchor" href="#钩子定理">¶</a>钩子定理</h2><p>$h_{i,j}$​定义为(i,j)这个格子下面的格子数+右边的格子数+1对于$\lambda \vdash n$，有$f^\lambda = \dfrac{n!}{\prod h_{i,j}}$表示$\lambda$对应的杨图的填法</p><h2 id="Robinson–Schensted-correspondence"><a class="header-anchor" href="#Robinson–Schensted-correspondence">¶</a>Robinson–Schensted correspondence</h2><p>一个1到n个数的排列和一对相同形状的标准杨表一一对应$\sum \limits_{\lambda \vdash n} (f^\lambda)^2$</p><h2 id="n个元素的杨氏矩阵的个数"><a class="header-anchor" href="#n个元素的杨氏矩阵的个数">¶</a>n个元素的杨氏矩阵的个数</h2><p>$f_n = f_{n-1} + (n-1)f_{n-2}$​</p><h2 id="杨表与LIS"><a class="header-anchor" href="#杨表与LIS">¶</a>杨表与LIS</h2><p>将一个排列按序用RSK算法插入到杨表中，则杨表第一行的长度等于其LIS长度（构建的杨表从上到下，从左到右递增）将杨表的比较方式取反($\lt$变$\geq$,$gt$变$\leq$)，所得杨表的形状为原杨表的转置(仅形状而言)杨表第一列的长度等于最长不上升子序列长度(考虑转置)杨表前k列的长度和等于LIS$\leq k$的k-LIS的长度(利用Dilworth定理，等价于划分出k个不相交的最长不上升子序列)</p><h2 id="P3774-CTSC2017-最长上升子序列"><a class="header-anchor" href="#P3774-CTSC2017-最长上升子序列">¶</a>P3774 [CTSC2017]最长上升子序列</h2><p>给定一个长为n的序列a，q次询问a的某个前缀的最长k-LIS的长度$n\leq 50000, q \leq 200000$对于每个询问的答案就是将a的这个前缀依次插入杨表后，前k列长度的和考虑离线询问后动态维护前k列长度和每次插入的复杂度是$O(n\log n)$的我们可以只维护杨表的前$\sqrt n$​行，然后反转比较方式，再维护这个杨表的转置的前$\sqrt n$​行(等价于维护了原杨表的前$\sqrt n$​列，当这一列的长度超过$\sqrt n$​时，表明这个元素在原杨表中没有维护到，所以在这里维护即可)，显然每个元素的行或列的下标至少有一个$\leq \sqrt n$​，所以这样是正确的复杂度为$O(n\sqrt n \log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, M = <span class="number">255</span>;</span><br><span class="line"><span class="type">int</span> n, qq, blo, a[N], c[N], ans[<span class="number">4</span>*N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; YT[M], YT2[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qry</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> m, k, idx;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> qry&amp; oth) &#123; <span class="keyword">return</span> m &lt; oth.m; &#125;</span><br><span class="line">&#125;q[<span class="number">4</span>*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) c[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) ans += c[i];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, x=v; i&lt;blo; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(YT[i].<span class="built_in">empty</span>() || YT[i].<span class="built_in">back</span>()&lt;x)</span><br><span class="line">    &#123;</span><br><span class="line">      YT[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">      <span class="built_in">upd</span>(YT[i].<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(YT[i][<span class="built_in">lower_bound</span>(YT[i].<span class="built_in">begin</span>(), YT[i].<span class="built_in">end</span>(), x)-YT[i].<span class="built_in">begin</span>()], x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, x=v; i&lt;blo; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(YT2[i].<span class="built_in">empty</span>() || YT2[i].<span class="built_in">back</span>()&gt;=x)</span><br><span class="line">    &#123;</span><br><span class="line">      YT2[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">      <span class="keyword">if</span>((<span class="type">int</span>)YT2[i].<span class="built_in">size</span>()&gt;=blo) <span class="built_in">upd</span>(i, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(YT2[i][<span class="built_in">upper_bound</span>(YT2[i].<span class="built_in">begin</span>(), YT2[i].<span class="built_in">end</span>(), x, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())-YT2[i].<span class="built_in">begin</span>()], x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;qq);</span><br><span class="line">  blo = <span class="built_in">sqrt</span>(n) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=qq; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].m, &amp;q[i].k), q[i].idx = i;</span><br><span class="line">  <span class="built_in">sort</span>(q+<span class="number">1</span>, q+qq+<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> pre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=qq; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span>(pre&lt;=q[i].m) <span class="built_in">add</span>(a[pre]), <span class="built_in">add2</span>(a[pre]), pre++;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=qq &amp;&amp; q[j].m==q[i].m)</span><br><span class="line">    &#123;</span><br><span class="line">      ans[q[j].idx] = <span class="built_in">ask</span>(q[j].k);</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    i = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=qq; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4484-BJWC2018-最长上升子序列"><a class="header-anchor" href="#P4484-BJWC2018-最长上升子序列">¶</a>P4484 [BJWC2018]最长上升子序列</h2><p>求长度为n的随机排列的LIS的长度的期望$n \leq 28$<s>暴力跑前几个然后oeis</s>我们只需要枚举n的所有整数划分$\lambda$，然后利用钩子公式计算出相应的$f^\lambda$，那么所有排列的LIS长度的和是$\sum\limits_{\lambda \vdash n} (f^\lambda)^2 \lambda_1$​，再除以排列数$n!$即可n的整数划分个数$p(n) \approx \frac{1}{4n\sqrt 3}exp(\pi\sqrt{\frac{2n}{3}})$复杂度$O(p(n))$，大概能跑$\leq 63$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, N = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll inv[N], ans;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">powmod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x)</span><br><span class="line">  &#123;</span><br><span class="line">    ll cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) cur = cur*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;y; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=a[i]; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> R = a[i] - j, D = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;y; k++)</span><br><span class="line">          <span class="keyword">if</span>(a[k]&gt;=j) D++;</span><br><span class="line">        cur = cur*inv[R+D]%mod;</span><br><span class="line">      &#125;</span><br><span class="line">    ans = (ans + cur*cur%mod*a[<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=x; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(y!=<span class="number">1</span> &amp;&amp; i&gt;a[y<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    a[y] = i;</span><br><span class="line">    <span class="built_in">dfs</span>(x-i, y+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) inv[i] = <span class="built_in">powmod</span>(i, mod<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">dfs</span>(n, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) ans = ans*inv[i]%mod;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求不相交的LIS"><a class="header-anchor" href="#求不相交的LIS">¶</a>求不相交的LIS</h2><p>考虑$dp_{i,j}$​表示第一个LIS的最后一个元素的值为i，第二个LIS的最后一个元素的值为j，朴素转移的复杂度是$O(n^3)$，利用树状数组可以优化到$O(n^2\log n)$此外也可以用费用流如果询问的是不相交LIS的长度，只要维护出杨表的前两行即可，然后答案就是前两行的长度和$O(2n\log n)$，对于k不相交LIS，可以做到$O(kn\log n)$hdu5406</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">YT</span></span><br><span class="line">&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; t[<span class="number">3</span>];</span><br><span class="line">  <span class="built_in">YT</span>() &#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>; i++) t[i].<span class="built_in">clear</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, x=v; i&lt;=<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(t[i].<span class="built_in">empty</span>() || t[i].<span class="built_in">back</span>()&lt;=x)</span><br><span class="line">      &#123;</span><br><span class="line">        t[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">swap</span>(t[i][<span class="built_in">upper_bound</span>(t[i].<span class="built_in">begin</span>(), t[i].<span class="built_in">end</span>(), x)-t[i].<span class="built_in">begin</span>()], x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p[i].first, &amp;p[i].second);</span><br><span class="line">  <span class="built_in">sort</span>(p+<span class="number">1</span>, p+n+<span class="number">1</span>, [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; y) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x.first==y.first) <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">    <span class="keyword">return</span> x.first &gt; y.first;</span><br><span class="line">  &#125;);</span><br><span class="line">  YT T;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) T.<span class="built_in">add</span>(p[i].second);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">int</span>(T.t[<span class="number">1</span>].<span class="built_in">size</span>() + T.t[<span class="number">2</span>].<span class="built_in">size</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环矩阵</title>
      <link href="/2020/08/25/xun-huan-ju-zhen/"/>
      <url>/2020/08/25/xun-huan-ju-zhen/</url>
      
        <content type="html"><![CDATA[<p>矩阵的第i行是其上一行循环右移的结果</p><h2 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h2><p>循环矩阵的线性运算及乘积仍是循环矩阵循环矩阵的逆矩阵以及转置矩阵仍是循环矩阵循环矩阵乘法满足交换律</p><h2 id="优势"><a class="header-anchor" href="#优势">¶</a>优势</h2><p>由于两个循环矩阵的乘法的结果仍然是一个循环矩阵，所以可以$O(n^2)$求得结果的第一行，这样就可以得到其他各行的结果，将矩阵乘法的复杂度下降了一级若下标从0开始：$c[1][(i+j)$ % $n] += a[1][i] * b[1][j]$若下标从1开始：$c[1][(i+j-2)$ % $(n+1)] += a[1][i] * b[1][j]$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cirmat</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mat[N];</span><br><span class="line">    <span class="built_in">cirmat</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">cirmat</span>(<span class="type">int</span> _) : <span class="built_in">n</span>(_) &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="built_in">cirmat</span>() &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123; mat[<span class="number">0</span>] = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">cirmat <span class="keyword">operator</span> * (cirmat a, cirmat b)</span><br><span class="line">&#123;</span><br><span class="line">  cirmat res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      (res.mat[(i+j<span class="number">-2</span>)%n+<span class="number">1</span>] += <span class="number">1ll</span>*a.mat[i]*b.mat[j]%mod) %= mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">cirmat <span class="keyword">operator</span> ^ (cirmat a, ll x)</span><br><span class="line">&#123;</span><br><span class="line">  cirmat res; res.<span class="built_in">one</span>();</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;<span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bzoj2510-弱题"><a class="header-anchor" href="#bzoj2510-弱题">¶</a>bzoj2510 弱题</h2><p>有m个带标号球，标号范围为1-n，每次操作等概率选择一个球，使得该球的标号加1（如果是n，就变成1）问k次操作后，各个标号球的个数的期望$n \leq 1000,m \leq 10^9,k \leq INT\_MAX$转移矩阵是一个循环矩阵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cirmat</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> mat[N];</span><br><span class="line">  <span class="built_in">cirmat</span>() &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123; mat[<span class="number">0</span>] = <span class="number">1.0</span>; &#125;</span><br><span class="line">&#125;a, b;</span><br><span class="line">cirmat <span class="keyword">operator</span> * (cirmat a, cirmat b)</span><br><span class="line">&#123;</span><br><span class="line">  cirmat res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">      res.mat[(i+j)%n] += a.mat[i]*b.mat[j];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">cirmat <span class="keyword">operator</span> ^ (cirmat a, <span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">  cirmat res; res.<span class="built_in">one</span>();</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;<span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a.mat[i]);</span><br><span class="line">  b.mat[<span class="number">0</span>] = <span class="number">1.0</span> - <span class="number">1.0</span>/m, b.mat[<span class="number">1</span>] = <span class="number">1.0</span>/m;</span><br><span class="line">  b = b ^ k;</span><br><span class="line">  a = a * b;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, a.mat[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客14532-没有名字"><a class="header-anchor" href="#牛客14532-没有名字">¶</a>牛客14532 没有名字</h2><p>转移是一个循环矩阵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">ll m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cirmat</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mat[N];</span><br><span class="line">  <span class="built_in">cirmat</span>() &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123; mat[<span class="number">1</span>] = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;a, b;</span><br><span class="line">cirmat <span class="keyword">operator</span> * (cirmat a, cirmat b)</span><br><span class="line">&#123;</span><br><span class="line">  cirmat res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      (res.mat[(i+j<span class="number">-2</span>)%n+<span class="number">1</span>] += <span class="number">1ll</span>*a.mat[i]*b.mat[j]%mod) %= mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">cirmat <span class="keyword">operator</span> ^ (cirmat a, ll x)</span><br><span class="line">&#123;</span><br><span class="line">  cirmat res; res.<span class="built_in">one</span>();</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;<span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a.mat[i]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> dis = <span class="built_in">min</span>(i<span class="number">-1</span>, n+<span class="number">1</span>-i);</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span> || dis&gt;=k) b.mat[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> b.mat[i] = k - dis;</span><br><span class="line">  &#125;</span><br><span class="line">  b = b ^ m;</span><br><span class="line">  a = a * b;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, a.mat[i], <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，利用FFT还可以将循环矩阵乘法优化到$O(n\log n)$，还不会，先咕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小割相关</title>
      <link href="/2020/08/16/zui-xiao-ge-xiang-guan/"/>
      <url>/2020/08/16/zui-xiao-ge-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="最小割的方案"><a class="header-anchor" href="#最小割的方案">¶</a>最小割的方案</h2><p>跑一遍最大流，记录从s出发能到达的点集S，不能到达的点集为T，则跨越S和T的满流边（残留网络中容量=0）是最小割中的边</p><h2 id="可行边与必须边"><a class="header-anchor" href="#可行边与必须边">¶</a>可行边与必须边</h2><p>可行边：属于所有可能的最小割集的并集中的边必须边：属于所有可能的最小割集的交集中的边跑一遍最大流，然后对残余网络（容量大于0的边）跑一遍tarjan如果该边还有容量，不属于最小割集，所以既不是可行边也不是必须边如果某条边连接的两个点分属于两个scc，则为可行边如果某条边连接的两个点一个与S同在一个scc，一个与T同在一个scc，则为必须边</p><h2 id="求边数最少的最小割"><a class="header-anchor" href="#求边数最少的最小割">¶</a>求边数最少的最小割</h2><p>设原图总边数=M让原图的每一条边的权值w变成$(M+1)w+1$再跑最大流即可</p><h2 id="每条边有两个权值，在最小化第一个权值的割后，找一个第二个权值字典序最小的割"><a class="header-anchor" href="#每条边有两个权值，在最小化第一个权值的割后，找一个第二个权值字典序最小的割">¶</a>每条边有两个权值，在最小化第一个权值的割后，找一个第二个权值字典序最小的割</h2><p>先随便求一个最小割，将这些边按照第二个权值排序，判断该边是否是可行边，如果是就选择，割掉一条边需要利用退流操作，具体做法是对于边(u,v)，让u向S跑一遍最大流，再让T向v跑一遍最大流，最后让(u,v)这条边及其反边的残余流量置0，即w=0</p><h2 id="最小割树"><a class="header-anchor" href="#最小割树">¶</a>最小割树</h2><p>求任意两点间的最小割本质只有$O(n)$种，建出最小割树后，u，v两点的最小割等于路径上的最小边权建树方法：跑n次最大流每次随机取两个点，求它们的最小割，将图分为两部分，在这两个集合间连一条边权为最小割的边，然后分治处理两个集合。这样最后会得到一棵树。则两个点之间的最小割大小为其树上唯一路径的最小值。每次网络流的流量要复原，所以用变量fw记录每条边已经流过的流量，变量w记录容量保持不变，当fw=w时说明该边满流，复原只需要清零fw即可求路径最小值没必要倍增，因为点数不会很大，直接建出树，以每个点为根bfs一次即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">505</span>, M = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt, head[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> next, to, w, fw;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[++cnt] = &#123;head[u], v, w, <span class="number">0</span>&#125;;</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n, m, s, t;</span><br><span class="line">  <span class="type">int</span> dep[N], cur[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    cnt = <span class="number">1</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> cap)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(u, v, cap);</span><br><span class="line">    <span class="built_in">add</span>(v, u, cap);</span><br><span class="line">    m += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s); dep[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dep[v]&amp;&amp;e[i].fw&lt;e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">          dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> used = flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">      cur[u] = i;</span><br><span class="line">      <span class="type">int</span> v = e[i].to;</span><br><span class="line">      <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="built_in">dfs</span>(v,<span class="built_in">min</span>(flow,e[i].w-e[i].fw));</span><br><span class="line">        e[i].fw += low; e[i^<span class="number">1</span>].fw -= low;</span><br><span class="line">        flow -= low;</span><br><span class="line">        <span class="keyword">if</span>(!flow) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used - flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">go</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxflow = <span class="number">0</span>; s = x, t = y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=cnt; i++) e[i].fw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) maxflow += <span class="built_in">dfs</span>(s,INF);</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;MF;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GHT</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pt[N], col[N], tmpt[N], cnt, cut[N][N];</span><br><span class="line">  vector&lt;pii&gt; G[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    col[u] = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next)</span><br><span class="line">      <span class="keyword">if</span>(e[i].fw&lt;e[i].w &amp;&amp; col[e[i].to]!=cnt)</span><br><span class="line">        <span class="built_in">dfs</span>(e[i].to);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = pt[l], y = pt[l+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> cutw = MF.<span class="built_in">go</span>(x, y);</span><br><span class="line">    ++cnt; <span class="built_in">dfs</span>(x); <span class="type">int</span> p = l, q = r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++)</span><br><span class="line">      <span class="keyword">if</span>(col[pt[i]]==cnt) tmpt[p++] = pt[i];</span><br><span class="line">      <span class="keyword">else</span> tmpt[q--] = pt[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) pt[i] = tmpt[i];</span><br><span class="line">    G[x].<span class="built_in">pb</span>(&#123;y, cutw&#125;); G[y].<span class="built_in">pb</span>(&#123;x, cutw&#125;);</span><br><span class="line">    <span class="built_in">build</span>(l, p<span class="number">-1</span>); <span class="built_in">build</span>(q+<span class="number">1</span>, r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> *dis)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) dis[i] = <span class="number">-1</span>;</span><br><span class="line">    dis[s] = INF;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">sz</span>(q))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">        <span class="keyword">if</span>(~dis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v] = <span class="built_in">min</span>(dis[u], w);</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  MF.<span class="built_in">init</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    MF.<span class="built_in">addedge</span>(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">iota</span>(T.pt+<span class="number">1</span>, T.pt+n+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  T.<span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) T.<span class="built_in">bfs</span>(i, T.cut[i]);</span><br><span class="line">  <span class="type">int</span> q; cin &gt;&gt; q;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    cout &lt;&lt; T.cut[u][v] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数拆分</title>
      <link href="/2020/08/15/zheng-shu-chai-fen/"/>
      <url>/2020/08/15/zheng-shu-chai-fen/</url>
      
        <content type="html"><![CDATA[<h2 id="不能相等"><a class="header-anchor" href="#不能相等">¶</a>不能相等</h2><p>将正整数n划分成不能相等的若干个正整数的和的方案数由于不能相等，所以划分成的数字个数不超过$\sqrt n$​设$f_{i,j}$​表示将i划分成j个不同数字的和的方案数$f_{i,j} = f_{i-j,j} + f_{i-j,j-1}$​$O(n\sqrt n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, B = <span class="number">350</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, f[N][B];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (x+y&gt;=mod) ? x+y-mod : x+y; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i &amp;&amp; j&lt;B; j++)</span><br><span class="line">      f[i][j] = <span class="built_in">add</span>(f[i-j][j], f[i-j][j<span class="number">-1</span>]);</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;B; j++) ans = <span class="built_in">add</span>(ans, f[n][j]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="能相等"><a class="header-anchor" href="#能相等">¶</a>能相等</h2><p>将正整数n划分成若干正整数的和的方案数设定阈值$B=\sqrt n$对于&lt;B的部分，直接做完全背包对于&gt;=B的部分，选择的数字个数不超过B设$f_{i,j}$​表示将i划分成j个不同数字的和的方案数$f_{i,j} = f_{i-B,j-1} + f_{i-j,j}$$O(n\sqrt n)O$ 但只能解决单次询问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, B = <span class="number">350</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, f0[N], f1[N], f[N][B];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) a-=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> (a+b&gt;=mod) ? a+b-mod : a+b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  f0[<span class="number">0</span>] = f1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;B &amp;&amp; j&lt;=n; j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=j; i&lt;=n; i++)</span><br><span class="line">      f0[i] = <span class="built_in">Add</span>(f0[i], f0[i-j]);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=B; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=B; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      f[i][j] = <span class="built_in">Add</span>(f[i-B][j<span class="number">-1</span>], f[i-j][j]);</span><br><span class="line">      f1[i] = <span class="built_in">Add</span>(f1[i], f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) <span class="built_in">add</span>(ans, <span class="built_in">Mul</span>(f0[i], f1[n-i]));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五边形数$\frac{n(3n-1)}{2}$欧拉函数$\phi(n) = \prod \limits_{i=1}^{\infty}(1-x^i) = \prod\limits_{i=-\infty}^{\infty}(-1)^ix^{\frac{i(3i-1)}{2}}$​即展开后只留下幂次为广义五边形数的项考虑整数拆分的生成函数$F(x) = \sum\limits_{i=1}^{\infty} P(i)x^i =\prod \limits_{i=1}^{\infty}(1+x^i+x^{2i}…)= \prod\limits_{i=1}^{\infty}\frac{1}{1-x^i}$​即$F(x)\phi(x)=1$可以得到$P(n)-P(n-1)-P(n-2)+P(n-5)+P(n-7)-…=0$容易发现P(n)可由$n-\dfrac{i(3*i-1)}{2}$​以及$n-\dfrac{i(3*i+1)}{2}$​更新得到由于五边形数是$n^2$级别增长的，所以可以$O(n\sqrt n)$递推得到$P(1)\dots P(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>, B = <span class="number">350</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, i, j, f[B], g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(f[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">2</span>]=<span class="number">2</span>,f[<span class="number">3</span>]=<span class="number">5</span>,f[<span class="number">4</span>]=<span class="number">7</span>,i=<span class="number">5</span>; f[i<span class="number">-1</span>]&lt;n; i++) f[i] = <span class="number">3</span> + <span class="number">2</span>*f[i<span class="number">-2</span>] - f[i<span class="number">-4</span>];</span><br><span class="line">  <span class="keyword">for</span>(g[<span class="number">0</span>]=i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; f[j]&lt;=i; j++)</span><br><span class="line">      <span class="keyword">if</span>((j+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>&amp;<span class="number">1</span>) g[i] = (g[i] + g[i-f[j]])%mod;</span><br><span class="line">      <span class="keyword">else</span> g[i] = (g[i]-g[i-f[j]]+mod)%mod;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (g[n]&lt;<span class="number">0</span>) ? g[n]+mod : g[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>沈阳的I题是询问n个点深度不超过2的树的个数，显然是个n-1的整数拆分，然而$n \leq 5\times10^5$</p><ol><li><p>$O(n\sqrt n)$取模优化，g数组开成longlong，这样对于$g_i$​只要在最后取一次模即可，因为最多根号次加法所以不会爆longlongcachemiss优化，$g_i$​用变量x代替，这样可以一定程度上减少cache的miss循环优化，大力循环展开然后就能过了</p></li><li><p>$O(n\log n)$更快也更简单，只需要对$\phi$求个逆即可</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平面图</title>
      <link href="/2020/08/13/ping-mian-tu/"/>
      <url>/2020/08/13/ping-mian-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h2><p>画在平面上，任意两条边除顶点外无交点包围一个面的边的条数称为该面的次数</p><h2 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h2><p>欧拉公式：n - m + r = 2点数-边数+面数=2点数$n \geq 3$的平面图的边数$m \leq 3n-6$ (边数是线性的)</p><h2 id="对偶图"><a class="header-anchor" href="#对偶图">¶</a>对偶图</h2><p>每个面为一个顶点，对于平面图上的每条边（一定只与两个面相连），用边连接这两个面对应的顶点平面图最小割=对偶图最短路（对偶图的边权相当于割掉平面图一条边的代价，所以维护对偶图的连通性，等价于维护平面图的非连通性）G的面数等于G的点数， G与G的边数相同(每个面为一个点，每条边也对应了一条边)</p><h2 id="P4001-ICPC-Beijing-2006-狼抓兔子"><a class="header-anchor" href="#P4001-ICPC-Beijing-2006-狼抓兔子">¶</a>P4001 [ICPC-Beijing 2006]狼抓兔子</h2><p>求网格图的最小割网格图显然是平面图，转成对偶图后跑最短路即可<s>然后对偶图难建还比网络流慢</s></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line">vector&lt;pii&gt; G[<span class="number">2</span>*N*N];</span><br><span class="line">ll dis[<span class="number">2</span>*N*N];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">2</span>*N*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, (T+<span class="number">1</span>)*<span class="built_in">sizeof</span>(ll));</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, (T+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  priority_queue&lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt;&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>, s));</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">top</span>().se; q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)</span><br><span class="line">      &#123;</span><br><span class="line">        dis[v] = dis[u] + w;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">mp</span>(dis[v], v));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  S = <span class="number">0</span>, T = (<span class="number">2</span>*n<span class="number">-2</span>)*(m<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">auto</span> id = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>||y==m) <span class="keyword">return</span> S;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>*n<span class="number">-1</span>||y==<span class="number">0</span>) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*(m<span class="number">-1</span>) + y;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = <span class="built_in">id</span>(<span class="number">2</span>*i<span class="number">-2</span>, j), v = <span class="built_in">id</span>(<span class="number">2</span>*i<span class="number">-1</span>, j), w; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">      G[u].<span class="built_in">emplace_back</span>(v, w); G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = <span class="built_in">id</span>(<span class="number">2</span>*i<span class="number">-1</span>, j<span class="number">-1</span>), v = <span class="built_in">id</span>(<span class="number">2</span>*i, j), w; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">      G[u].<span class="built_in">emplace_back</span>(v, w); G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = <span class="built_in">id</span>(<span class="number">2</span>*i<span class="number">-1</span>, j), v = <span class="built_in">id</span>(<span class="number">2</span>*i, j), w; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">      G[u].<span class="built_in">emplace_back</span>(v, w); G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">Dijkstra</span>(S);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dis[T]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客多校2-Interval"><a class="header-anchor" href="#牛客多校2-Interval">¶</a>牛客多校2 Interval</h2><p>初始有一个区间$[1,n]$对于一个区间$[l,r]$(l&lt;r)，可以变换成$[l+1,r]$,$[l,r-1]$,$[l−1,r]$,$[l,r+1]$现在给定m种方式，可以花费一定的代价限制某种变换，问最少花费多少代价使得区间$[1,n]$无法变换成长度为1的区间$n \leq 500$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>考虑网络流最小割建图，对每个区间建一个点，每种变换连边流量为INF，如果某种变换被限制，则连边流量为cost，表示割掉这条边的代价。点数是$n^2$,边数也是$n^2$的发现这是一个平面图，所以转成对偶图跑最短路就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pil = pair&lt;<span class="type">int</span>,ll&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T, idx[N][N], tot;</span><br><span class="line">ll dis[N*N];</span><br><span class="line"><span class="type">bool</span> vis[N*N];</span><br><span class="line">vector&lt;pil&gt; G[N*N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  G[u].<span class="built_in">emplace_back</span>(v, w);</span><br><span class="line">  G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, (tot+<span class="number">1</span>)*<span class="built_in">sizeof</span>(ll));</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, (tot+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  priority_queue&lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt;&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>, s));</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">top</span>().se; q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> v = it.fi; ll w = it.se;</span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)</span><br><span class="line">      &#123;</span><br><span class="line">        dis[v] = dis[u] + w;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">mp</span>(dis[v], v));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">      idx[i][j] = ++tot;</span><br><span class="line">  S = <span class="number">0</span>; T = ++tot;</span><br><span class="line">  <span class="keyword">auto</span> id = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> S;</span><br><span class="line">    <span class="keyword">if</span>(y==n) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">return</span> idx[x][y];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">addedge</span>(<span class="built_in">id</span>(i<span class="number">-1</span>, j), <span class="built_in">id</span>(i, j), LINF);</span><br><span class="line">      <span class="built_in">addedge</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i, j+<span class="number">1</span>), LINF);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">addedge</span>(<span class="built_in">id</span>(i, i), <span class="built_in">id</span>(i<span class="number">-1</span>, i<span class="number">-1</span>), LINF);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, c;</span><br><span class="line">    <span class="type">char</span> dir;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; dir &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(dir==<span class="string">&#x27;L&#x27;</span>) <span class="built_in">addedge</span>(<span class="built_in">id</span>(l, r<span class="number">-1</span>), <span class="built_in">id</span>(l, r), c);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">addedge</span>(<span class="built_in">id</span>(l<span class="number">-1</span>, r<span class="number">-1</span>), <span class="built_in">id</span>(l, r<span class="number">-1</span>), c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Dijkstra</span>(S);</span><br><span class="line">  cout &lt;&lt; (dis[T]&gt;=LINF ? <span class="number">-1</span> : dis[T]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性规划 单纯型算法</title>
      <link href="/2020/08/11/xian-xing-gui-hua-dan-chun-xing-suan-fa/"/>
      <url>/2020/08/11/xian-xing-gui-hua-dan-chun-xing-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>n个变量$x_1,…,x_n$​，m个线性约束，形如$\sum \limits_{i=1}^na_{ij}x_i \leq b_j$​,要求确定这n个变量的值，$\max z =\sum\limits_{i=1}^n c_ix_i$单纯型可以被卡到指数级，但一般情况下速度较快，相比于MCMF，代码更短，而且更直观以下用矩阵形式表达（规定小写为列向量，大写为矩阵）</p><h3 id="标准形式"><a class="header-anchor" href="#标准形式">¶</a>标准形式</h3><p>最大化$c^Tx$，满足约束$Ax\leq b,x_i \geq 0$</p><h3 id="松弛形式"><a class="header-anchor" href="#松弛形式">¶</a>松弛形式</h3><p>最大化$c^Tx$，满足约束$Ax=b,x_i \geq 0$只要对每个标准形式的约束条件增加一个变量$x_{n+i} \geq 0$即可</p><h3 id="对偶问题"><a class="header-anchor" href="#对偶问题">¶</a>对偶问题</h3><p>最小化$b^Tx$，满足约束$A^Tx \leq c,x_i \geq 0$目标函数的系数c与约束条件右边的系数b交换，并将约束系数矩阵转置，最大化与最小化互换，改变不等式号</p><p>$a_{00}=-z,a_{0i}=c_i,a_{i0}=b_i$m行n列，表示n个变量，m个约束，单纯型使用的是松弛形式，只不过没有显示表示出来当约束系数$a_{ij}$​为0，1，-1（全幺模矩阵）时用以下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N][M], q[M];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a[l][e] = <span class="number">1</span>; <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n; j++) <span class="keyword">if</span>(a[l][j]) q[++p] = j;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, t=<span class="number">0</span>; i&lt;=m; i++)</span><br><span class="line">    <span class="keyword">if</span>(i!=l &amp;&amp; (t=a[i][e]))</span><br><span class="line">    &#123;</span><br><span class="line">      a[i][e] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=p; j++) a[i][q[j]] -= t*a[l][q[j]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, e = <span class="number">0</span>, mn = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      <span class="keyword">if</span>(a[<span class="number">0</span>][j]&gt;<span class="number">0</span>) &#123; e = j; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(!e) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">      <span class="keyword">if</span>(a[i][e]&gt;<span class="number">0</span> &amp;&amp; a[i][<span class="number">0</span>]&lt;mn) mn = a[i][<span class="number">0</span>], l = i;</span><br><span class="line">    <span class="built_in">assert</span>(l);</span><br><span class="line">    <span class="built_in">cal</span>(l, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，原问题或者对偶问题中至少有一个零解是可行解，所以不需要init，否则需要先通过init找到一组初始解，再进行simplex优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>, INF = <span class="number">1e15</span>;</span><br><span class="line"><span class="type">int</span> n, m, type, id[M*<span class="number">2</span>], q[M];</span><br><span class="line"><span class="type">double</span> a[N][M], ans[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pivot</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">swap</span>(id[l+n], id[e]);</span><br><span class="line">  <span class="type">double</span> t = a[l][e]; a[l][e] = <span class="number">1.0</span>; <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n; j++) a[l][j] /= t;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n; j++) <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[l][j])&gt;eps) q[++p] = j;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=m; i++)</span><br><span class="line">    <span class="keyword">if</span>(i!=l &amp;&amp; <span class="built_in">fabs</span>(a[i][e])&gt;eps)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">double</span> t = a[i][e]; a[i][e] = <span class="number">0.0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=p; j++) a[i][q[j]] -= t*a[l][q[j]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">      <span class="keyword">if</span>(a[i][<span class="number">0</span>]&lt;-eps &amp;&amp; (!l || (<span class="built_in">rand</span>()&amp;<span class="number">1</span>))) l = i;</span><br><span class="line">    <span class="keyword">if</span>(!l) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      <span class="keyword">if</span>(a[l][j]&lt;-eps &amp;&amp; (!e || (<span class="built_in">rand</span>()&amp;<span class="number">1</span>))) e = j;</span><br><span class="line">    <span class="keyword">if</span>(!e) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Infeasible&quot;</span>), <span class="literal">false</span>; <span class="comment">//无解</span></span><br><span class="line">    <span class="built_in">pivot</span>(l, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">simplex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, e = <span class="number">0</span>; <span class="type">double</span> w = eps;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) <span class="comment">//选择最大的那个（更快找到最优解），或者选择第一个大于0的（可以防止死循环）</span></span><br><span class="line">      <span class="keyword">if</span>(a[<span class="number">0</span>][j]&gt;w) w = a[<span class="number">0</span>][j], e = j;</span><br><span class="line">    <span class="keyword">if</span>(!e) <span class="keyword">break</span>;</span><br><span class="line">    w = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">      <span class="keyword">if</span>(a[i][e]&gt;eps &amp;&amp; a[i][<span class="number">0</span>]/a[i][e]&lt;w)</span><br><span class="line">        w = a[i][<span class="number">0</span>]/a[i][e], l = i;</span><br><span class="line">    <span class="keyword">if</span>(!l) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Unbounded&quot;</span>), <span class="literal">false</span>;<span class="comment">//解无界</span></span><br><span class="line">    <span class="built_in">pivot</span>(l, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">iota</span>(id+<span class="number">1</span>, id+n+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">init</span>() &amp;&amp; <span class="built_in">simplex</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.8f\n&quot;</span>, -a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) ans[id[n+i]] = a[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(type) <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%.8f &quot;</span>, ans[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性规划转费用流：列出标准形式，添加松弛变量转化为松弛型每个式子与前一个式子相减，如果每个变量只出现两次，且系数一正一负，就可以转化为费用流对于每个等式新建一个点，如果等式中右边常数b为正数，从源点s向该点连边（b,0），否则该点向汇点连边（-b,0）。对每个变量（包括添加的用来松弛的变量）从它系数为正的等式代表的点向它系数为负的等式代表的点连边（INF，c），c为目标函数中的系数</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分散层叠算法(Fractional Cascading)</title>
      <link href="/2020/08/07/fen-san-ceng-die-suan-fa-fractional-cascading/"/>
      <url>/2020/08/07/fen-san-ceng-die-suan-fa-fractional-cascading/</url>
      
        <content type="html"><![CDATA[<p>给定k个长度为n有序数组L，要求<strong>在线</strong>q次回答每个数组中$\geq x$的最小的数$k\leq 100,n\leq 10^4, q\leq 3\times 10^5$离线的话可以整体二分在线用该算法时间复杂度为$O(k+\log n)$，空间复杂度为$O(n)$用一个$k\times n$的二维数组M，M[i]的每一位记录三个信息，｛键值，在L[i]中后继的位置，在M[i+1]中后继的位置｝考虑从后往前构造，M[k]=L[k]由于是有序的，利用归并$O(n)$合并L[i]和M[i+1]，注意对于M[i+1]只合并偶数位置（节省空间）对于查询，先利用一次二分在M[1]中找到后继的位置，此时该位的第二个信息就表示了在L[1]数组中的答案，而该位的第三个信息表示了在M[2]中后继的位置，注意由于是间隔插入，所以需要和该位置的前一个位置取优。这样只需要一次二分，然后各数组间利用保存的信息（指针）可以$O(1)$转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k, q, d;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;q, &amp;d);</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">L</span>(k, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L[i][j]);</span><br><span class="line">  vector&lt;vector&lt;pair&lt;<span class="type">int</span>,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;&gt; <span class="built_in">M</span>(k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    M[k<span class="number">-1</span>].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(L[k<span class="number">-1</span>][i], <span class="built_in">mp</span>(i, <span class="number">0</span>)));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;n &amp;&amp; b&lt;<span class="built_in">sz</span>(M[i+<span class="number">1</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(L[i][a]&lt;=M[i+<span class="number">1</span>][b].first) M[i].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(L[i][a], <span class="built_in">mp</span>(a, b))), a++;</span><br><span class="line">      <span class="keyword">else</span> M[i].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(M[i+<span class="number">1</span>][b].first, <span class="built_in">mp</span>(a, b))), b += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;n) M[i].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(L[i][a], <span class="built_in">mp</span>(a, b))), a++;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;<span class="built_in">sz</span>(M[i+<span class="number">1</span>])) M[i].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(M[i+<span class="number">1</span>][b].first, <span class="built_in">mp</span>(a, b))), b += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> lstans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> _=<span class="number">1</span>; _&lt;=q; _++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    x ^= lstans;</span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">lower_bound</span>(M[<span class="number">0</span>].<span class="built_in">begin</span>(), M[<span class="number">0</span>].<span class="built_in">end</span>(), <span class="built_in">mp</span>(x, <span class="built_in">mp</span>(<span class="number">0</span>, <span class="number">0</span>))) - M[<span class="number">0</span>].<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> curans = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx&lt;k &amp;&amp; p&lt;<span class="built_in">sz</span>(M[idx]))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(M[idx][p].second.first&lt;n) curans ^= L[idx][M[idx][p].second.first];</span><br><span class="line">      <span class="keyword">if</span>(idx&lt;k<span class="number">-1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> nxtp = M[idx][p].second.second;</span><br><span class="line">        <span class="keyword">if</span>(nxtp<span class="number">-1</span>&lt;<span class="built_in">sz</span>(M[idx+<span class="number">1</span>]) &amp;&amp; M[idx+<span class="number">1</span>][nxtp<span class="number">-1</span>].first&gt;=x) --nxtp;</span><br><span class="line">        p = nxtp;</span><br><span class="line">      &#125;</span><br><span class="line">      ++idx;</span><br><span class="line">    &#125;</span><br><span class="line">    lstans = curans;</span><br><span class="line">    <span class="keyword">if</span>(_%d==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, curans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kosaraju求强连通分量</title>
      <link href="/2020/08/07/kosaraju-qiu-qiang-lian-tong-fen-liang/"/>
      <url>/2020/08/07/kosaraju-qiu-qiang-lian-tong-fen-liang/</url>
      
        <content type="html"><![CDATA[<p>反图的强连通分量和原图相同按照反图的逆后序方向遍历原图即可逆后序方向：先遍历与该点相连的节点，最后将该点入栈，栈的反序为逆后序利用bitset可以优化到$O(n^2/32)$，适合稠密图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Kosaraju</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ord[N], tp, num[N], scc;</span><br><span class="line">  bitset&lt;N&gt; tag, G[N], rG[N], t;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) G[i].<span class="built_in">reset</span>(), rG[i].<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    tag[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((t=rG[u]&amp;tag).<span class="built_in">any</span>())</span><br><span class="line">      <span class="built_in">dfs</span>(t._Find_first());</span><br><span class="line">    ord[++tp] = u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    num[u] = scc;</span><br><span class="line">    tag[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((t=G[u]&amp;tag).<span class="built_in">any</span>())</span><br><span class="line">      <span class="built_in">dfs2</span>(t._Find_first());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">gao</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    tp = scc = <span class="number">0</span>;</span><br><span class="line">    tag.<span class="built_in">set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(tag[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">    tag.<span class="built_in">set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">      <span class="keyword">if</span>(tag[ord[i]])</span><br><span class="line">      &#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        <span class="built_in">dfs2</span>(ord[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅行 有向图两点可达性</title>
      <link href="/2020/08/06/lu-xing-you-xiang-tu-liang-dian-ke-da-xing/"/>
      <url>/2020/08/06/lu-xing-you-xiang-tu-liang-dian-ke-da-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>给出一张随机生成的有向图，多次询问x点能否到达y点$n \leq 10^5,m \leq n + 5000,q \leq 3\times 10^5$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>跑一遍tarjan缩点成DAG设置根号个标记点，然后暴力跑出这些标记点能够到达的点，用bitset记录对于每个询问从x暴力dfs，遇到标记点则返回标记点选择度数最大的根号个复杂度：O(能过)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">405</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N], DAG[N];</span><br><span class="line">vector&lt;pii&gt; edges;</span><br><span class="line"><span class="type">int</span> n, m, _;</span><br><span class="line"><span class="type">int</span> dfn[N], num[N], low[N], id, tot, sta[N], top, deg[N], idx[N];</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line"><span class="type">int</span> vis[N], spe[N];</span><br><span class="line">bitset&lt;N&gt; bit[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  in[u] = <span class="number">1</span>;</span><br><span class="line">  low[u] = dfn[u] = ++id;</span><br><span class="line">  sta[++top] = u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(in[v]) low[u] = <span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(low[u]==dfn[u])</span><br><span class="line">  &#123;</span><br><span class="line">    tot++;</span><br><span class="line">    <span class="keyword">while</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> tmp = sta[top--];</span><br><span class="line">      in[tmp] = <span class="number">0</span>;</span><br><span class="line">      num[tmp] = tot;</span><br><span class="line">      <span class="keyword">if</span>(tmp==u) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(spe[u]) &#123; bit[t] |= bit[spe[u]]; <span class="keyword">return</span>; &#125;</span><br><span class="line">  vis[u] = t;</span><br><span class="line">  bit[t].<span class="built_in">set</span>(u);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : DAG[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[v]==t) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : edges)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = num[it.fi], v = num[it.se];</span><br><span class="line">    <span class="keyword">if</span>(u!=v) DAG[u].<span class="built_in">pb</span>(v), deg[u]++, deg[v]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> lim = (<span class="type">int</span>)<span class="built_in">sqrt</span>(tot) + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">iota</span>(idx+<span class="number">1</span>, idx+tot+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">sort</span>(idx+<span class="number">1</span>, idx+tot+<span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> deg[x] &gt; deg[y];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lim; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(idx[i], i);</span><br><span class="line">    spe[idx[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(spe[s]) <span class="keyword">return</span> bit[spe[s]].<span class="built_in">test</span>(t);</span><br><span class="line">  vis[s] = tt;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> ss : DAG[s])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[ss]==tt) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs2</span>(ss, t, tt)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> u, v;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">  ++u, ++v;</span><br><span class="line">  <span class="keyword">if</span>(num[u]==num[v]) <span class="built_in">puts</span>(<span class="string">&quot;Good&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">puts</span>((<span class="built_in">dfs2</span>(num[u], num[v], t) ? <span class="string">&quot;Good&quot;</span> : <span class="string">&quot;Bad&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    ++u, ++v;</span><br><span class="line">    G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">    edges.<span class="built_in">emplace_back</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">prework</span>();</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=_; i++) <span class="built_in">solve</span>(<span class="number">400</span>+i);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括号序列问题</title>
      <link href="/2020/07/30/gua-hao-xu-lie-wen-ti/"/>
      <url>/2020/07/30/gua-hao-xu-lie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="前置结论"><a class="header-anchor" href="#前置结论">¶</a>前置结论</h2><p>定义左括号’(‘为+1，右括号’)'为-1，作前缀和得到一个序列p当且仅当$p_n = 0 \wedge \forall i \ p_i &gt;=0$时，该括号序列合法</p><p>取$mn = \min_{i=1}^n p_i$​，则该括号序列的最长合法括号子序列的长度为$n - p_n + 2mn$考虑位置pos，其中$p_{pos}=mn$，则在$1…pos$中，有-mn个右括号失配，在$pos+1…n$中有$p_n-mn$个左括号失配</p><p>一个长度为n，右括号个数为m，对应的序列p的最小值为t的括号序列的个数有$\binom{n}{n-m-t} - \binom{n}{n-m-t+1}$先考虑对应的序列p的最小值不小于t的方案数：利用计算卡特兰数的方法，所有减去不合法。其中所有即$\binom{n}{m}$。不合法的即序列p的最小值是&lt;=t-1的，考虑位置pos，其中$p_{pos}=t-1$，则在$1…pos$中左括号比右括号少$−(t−1)$个，$pos+1…n$中左括号比右括号多$n−2m−(t−1)$，将$1…pos$的左右括号翻转，则$1…n$中左括号比右括号多$n−2m−2(t−1)$个，容易发现不合法的括号序列与左括号比右括号多$n−2m−2(t−1)$个的括号序列一一对应，所以不合法即为$\binom{n}{n-m-t+1}$那么对应的序列p的最小值不小于t+1的方案数为$\binom{n}{m} - \binom{n}{n-m-t}$则对应的序列p的最小值为t的方案数为$\binom{n}{n-m-t} - \binom{n}{n-m-t+1}$</p><p>一个括号序列循环移位后合法的方案数：</p><ul><li>若左括号数不等于右括号数，显然无解</li><li>ans = p中最小值出现的次数，若$p_{pos} = mn$，则将$1…pos$移到后面，$pos+1…n$移到前面则合法</li></ul><h2 id="洛谷p6689-序列"><a class="header-anchor" href="#洛谷p6689-序列">¶</a>洛谷p6689 序列</h2><h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>一个长度为n，初始全为’(‘的括号序列，给定参数k，每次随机在[1,n]选择一个位置然后翻转该位置的括号，当翻转了一个’('，就让k-1，重复直至k=0。询问最后生成的括号序列的最长合法子序列的期望长度$n, k&lt;=5\times 10^3$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>知道一个括号序列的左右括号的个数以及其对应的序列p的最小值就可以得到该括号序列的最长合法子序列的长度。先求出长度为n的括号序列中有m个右括号的概率，再枚举序列p的最小值即可解决，这是两个独立的问题。首先概率dp：$f_{ij}$表示当前参数为i，已经有j个右括号的概率$f_{ij} = \dfrac{n-j+1}{n}\sum_{k=j-1}^{n} f_{ik}\prod_{l=j}^{k}\dfrac{l}{n}$$f_{ij}$​可以由$j-1…n$个右括号的情况转移过来，相当于先连续将x个右括号变成左括号，然后再将1个左括号变成右括号$\dfrac{f_{0m}}{\binom{n}{m}}$​​就等于生成一个有m个右括号的括号序列的概率最后枚举这个括号序列的最小值，然后依据上面的公式计算即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a = <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) a-=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) <span class="keyword">return</span> a-mod; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a-=b; <span class="keyword">if</span>(a&lt;<span class="number">0</span>) a+=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a-=b; <span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> a+mod; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="type">int</span> n, k, f[N][N], fac[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">powmod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) <span class="built_in">mul</span>(ans, a);</span><br><span class="line">    <span class="built_in">mul</span>(a, a);</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fac[i] = <span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">  inv[n] = <span class="built_in">powmod</span>(fac[n], mod<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i] = <span class="number">1ll</span>*inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a&lt;b||b&lt;<span class="number">0</span>||a&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span>*fac[a]*inv[b]%mod*inv[a-b]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="type">int</span> invn = <span class="built_in">powmod</span>(n, mod<span class="number">-2</span>);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">init</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> sum = f[i<span class="number">-1</span>][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=n; j&gt;=<span class="number">1</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">mul</span>(sum, <span class="built_in">Mul</span>(j, invn));</span><br><span class="line">      <span class="built_in">add</span>(sum, f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">      f[i][j] = <span class="built_in">Mul</span>(<span class="built_in">Mul</span>(invn, (n-j+<span class="number">1</span>)), sum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">mul</span>(f[k][i], <span class="built_in">powmod</span>(<span class="built_in">comb</span>(n, i), mod<span class="number">-2</span>));</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> cal = [](<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)-&gt;<span class="type">int</span> <span class="comment">//长度为x的括号序列，有y个右括号，对应序列p的最小值为z的方案数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Sub</span>(<span class="built_in">comb</span>(x, x-y-z), <span class="built_in">comb</span>(x, x-y-z+<span class="number">1</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">//枚举右括号个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>; j&lt;=n&amp;&amp;<span class="built_in">min</span>(i, n-i)&gt;=j/<span class="number">2</span>; j+=<span class="number">2</span>) <span class="comment">//枚举最长合法子序列的长度为j，则此时p序列的mn=(j-2i)/2</span></span><br><span class="line">      <span class="built_in">add</span>(ans, <span class="built_in">Mul</span>(<span class="built_in">Mul</span>(j, f[k][i]), <span class="built_in">cal</span>(n, i, (j<span class="number">-2</span>*i)/<span class="number">2</span>)));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D2-The-World-Is-Just-a-Programming-Task-Hard-Version"><a class="header-anchor" href="#D2-The-World-Is-Just-a-Programming-Task-Hard-Version">¶</a>D2. The World Is Just a Programming Task (Hard Version)</h2><h3 id="题意-s2"><a class="header-anchor" href="#题意-s2">¶</a>题意</h3><p>给定一个括号序列，要求交换其中两个位置的括号，使得该括号序列循环移位后合法的方案数最多$n&lt;=3\times 10^5$</p><h4 id="做法-s2"><a class="header-anchor" href="#做法-s2">¶</a>做法</h4><p>由上面结论可得，就是要最大化该括号序列对应的p序列的最小值的个数显然交换两个相同的括号是没有意义的当交换一个左括号和一个右括号时，相当于对这段区间的p序列-2当交换一个右括号和一个左括号时，相当于对这段区间的p序列+2显然区间+2只会使最小值个数减少下面考虑区间-2：如果操作的区间中包含了原来最小值的某个位置，显然答案不会更优所以设$pos_1,…,pos_x$​为p序列最小值所处的位置，那么操作的区间只可能是$(pos1,pos2)…$，也可能是$(pos_x,pos_1)$，准确来说是对$[pos_1,pos_x]+2$，相当于是对$(posx,n]$，$[1,pos_1)-2(posx​,n]$，$[1,pos1​)−2$最优的情况只有两种：</p><ul><li>让最小值变成mn-1，只要统计出以上区间中等于mn+1的最多个数即可（显然操作区间越大越好，即$[pos_i, pos_{i+1}]$）</li><li>让最小值仍为mn，需要统计出以上区间中连续的且<strong>不包含mn+1</strong>的然后mn+2值最多的个数，还要再加上原本等于mn的个数（在以上每个操作区间中作尺取法即可，遇见mn+1就让计数器清空，否则不断往右移动）以上两者取优即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, p[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; (s+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) p[i] = (p[i<span class="number">-1</span>] + (s[i]==<span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line">  <span class="keyword">if</span>(p[n]) &#123; cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="type">int</span> mn = *<span class="built_in">min_element</span>(p+<span class="number">1</span>, p+n+<span class="number">1</span>);</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(p[i]==mn) vec.<span class="built_in">pb</span>(i);</span><br><span class="line">  <span class="type">int</span> ans = <span class="built_in">sz</span>(vec);</span><br><span class="line">  pii pos = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">sz</span>(vec)<span class="number">-1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> j = vec[i] + <span class="number">1</span>, k = vec[i+<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;k) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>, tmp = <span class="number">0</span>, st = <span class="number">0</span>;</span><br><span class="line">    pii pp = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> _=j; _&lt;=k; _++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(p[_]==mn+<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ++one;</span><br><span class="line">        tmp = st = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p[_]==mn+<span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ++tmp;</span><br><span class="line">        <span class="keyword">if</span>(!st) st = _;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(tmp&gt;two)</span><br><span class="line">      &#123;</span><br><span class="line">        two = tmp;</span><br><span class="line">        pp = &#123;st, _%n+<span class="number">1</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(one&gt;ans) ans = one, pos = &#123;j, k%n+<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(two+<span class="built_in">sz</span>(vec)&gt;ans) ans = two+<span class="built_in">sz</span>(vec), pos = pp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>, tmp = <span class="number">0</span>, st = <span class="number">0</span>;</span><br><span class="line">  pii pp = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> _=vec.<span class="built_in">back</span>()%n+<span class="number">1</span>; _!=vec.<span class="built_in">front</span>(); _=_%n+<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p[_]==mn+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++one;</span><br><span class="line">      tmp = st = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p[_]==mn+<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++tmp;</span><br><span class="line">      <span class="keyword">if</span>(!st) st = _;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;two)</span><br><span class="line">    &#123;</span><br><span class="line">      two = tmp;</span><br><span class="line">      pp = &#123;st, _%n+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(one&gt;ans) ans = one, pos = &#123;vec.<span class="built_in">back</span>()%n+<span class="number">1</span>, vec.<span class="built_in">front</span>()&#125;;</span><br><span class="line">  <span class="keyword">if</span>(two+<span class="built_in">sz</span>(vec)&gt;ans) ans = two+<span class="built_in">sz</span>(vec), pos = pp;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; pos.fi &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pos.se &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷7月月赛</title>
      <link href="/2020/07/27/luo-gu-7-yue-yue-sai/"/>
      <url>/2020/07/27/luo-gu-7-yue-yue-sai/</url>
      
        <content type="html"><![CDATA[<h2 id="P6685-可持久化动态仙人掌的直径问题"><a class="header-anchor" href="#P6685-可持久化动态仙人掌的直径问题">¶</a>P6685 可持久化动态仙人掌的直径问题</h2><h3 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h3><p>给定n, m，求满足$x^m \leq n$的正整数x个数，$n\leq 10^9, m\leq 10^9$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><ul><li>m=1, ans = n</li><li>m&gt;=2时显然答案很小， <s>所以随便怎么搞就行</s> ，如果二分的话注意下界从2开始(因为这个t了好几发👀)</li></ul><h2 id="P6686-混凝土数学"><a class="header-anchor" href="#P6686-混凝土数学">¶</a>P6686 混凝土数学</h2><h3 id="题目-s2"><a class="header-anchor" href="#题目-s2">¶</a>题目</h3><p>给定n根木棍的长度$a_i$​，求选择三根构成等腰三角形的方案数(无序对)</p><h3 id="做法-s2"><a class="header-anchor" href="#做法-s2">¶</a>做法</h3><p>显然排序后枚举腰长x然后二分$\lt 2x$的数的个数即可</p><h2 id="P6687-论如何玩转-Excel-表格"><a class="header-anchor" href="#P6687-论如何玩转-Excel-表格">¶</a>P6687 论如何玩转 Excel 表格</h2><h3 id="题目-s3"><a class="header-anchor" href="#题目-s3">¶</a>题目</h3><p>$2 \times n$的网格，不重复的填入$1 \sim 2n$，现在有一种操作，每次可以选择$2 \times 2$的正方形区域然后旋转$180^\circ$，问从给定网格到目标网格的最少操作次数，或输出无解$n&lt;=10^6$</p><p>$$\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix} \quad$$</p><p>$$\begin{bmatrix} 4 &amp; 3 \\ 2 &amp; 1 \end{bmatrix} \quad$$</p><h3 id="做法-s3"><a class="header-anchor" href="#做法-s3">¶</a>做法</h3><p>容易发现对同一个正方形区域操作两次等于不操作，操作一次相当于交换相邻两列，并且两行元素交换。所以不管怎么操作每列的两个元素是固定的，最多上下位置交换一下。考虑当前网格中第i列的两个元素在目标网格中第j列(如果两个元素在不同列，显然无解)，如果j-i为奇数则位置应该颠倒，偶数则位置应该相同。这样扫一遍就可以判定有没有解。可以发现最后就是要让第i列转移到第$p_i$​列，考虑一个排列，每次只能交换相邻两个元素，问使其有序最少需要的操作次数。答案为逆序对个数。设f为一个置换，$f(p) = 1,2,3,…,n$，则答案为$f^{-1}$的逆序对数，树状数组即可</p><h2 id="P6688-可重集"><a class="header-anchor" href="#P6688-可重集">¶</a>P6688 可重集</h2><h3 id="题目-s4"><a class="header-anchor" href="#题目-s4">¶</a>题目</h3><p>给定数组$a_i$​，支持单点修改，并多次询问区间[l1:r1]与区间[l2:r2]是否本质相同。其中本质相同只对这两个区间排序后，对应元素的差值均为整数k。$n&lt;=10^6$</p><h3 id="做法-s4"><a class="header-anchor" href="#做法-s4">¶</a>做法</h3><p>先说一下P3792 由乃与大母神原型和偶像崇拜这题，支持单点修改，并多次询问区间[l:r]在重排后是否是值域连续的。这两道题的特点都是一眼不可做，而解法是数据结构+哈希，所以不能保证一定正确。维护出区间最小值，区间最大值，区间和，区间平方和，然后判断即可从这题的思路容易想到通过维护区间和很容易得到这个差值k，然后再维护平方和？很不幸被出题人卡成了0pts。三次方？没啥用。。考虑设置一个数magic，然后维护$\sum magic^{a_i}$​，然后只要看$\sum_{i=l1}^{r1}magic^{a_i} * magic^k==\sum_{i=l2}^{r2}magic^{a_i}$由于很大要取模，magic和mod随便设就能过。。当然应该能卡上面的方法是把加法利用幂次转成乘法，另一种做法是利用sin。$sin(x+y) = sinxcosy + cosxsiny$$cos(x+y) = cosxcosy − sinxsiny$维护一下$\sum sinx$和$\sum cosx$，同样先利用区间和搞出k，然后用上面的公式判断即可，注意double比较用eps具体怎么维护可以看p6327，区间修改+区间sin和。本题是单点修改+区间sin和由于n是$10^6$级别，而且是单点修+区间查，所以树状数组即可当然以上只是部分可以通过的解法，仅仅是为了拓展一下思路（转成幂次，转成sin）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> magic = <span class="number">1919810</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a = <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) a-=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) <span class="keyword">return</span> a-mod; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a-=b; <span class="keyword">if</span>(a&lt;<span class="number">0</span>) a+=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a-=b; <span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> a+mod; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="keyword">namespace</span> IO</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">  <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,MAXSIZE,stdin),p1==p2) ? EOF : *p1++); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">gc</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) t = t*<span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">    t *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">out</span><span class="params">(T p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sta[<span class="number">70</span>], tp;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span>) &#123; p = -p; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">while</span>(p) sta[++tp] = p%<span class="number">10</span>, p/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(sta[tp--]+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="type">int</span> n, q, a[N], pw[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) <span class="built_in">add</span>(c[i], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) <span class="built_in">sub</span>(c[i], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) <span class="built_in">add</span>(ans, c[i]);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v, <span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) sum[i] += v*op;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) ans += sum[i];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(b&lt;N) <span class="keyword">return</span> pw[b];</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans*a%mod;</span><br><span class="line">    a = a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(q);</span><br><span class="line">  pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N; i++) pw[i] = <span class="built_in">Mul</span>(pw[i<span class="number">-1</span>], magic);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">ins</span>(i, pw[a[i]]);</span><br><span class="line">    <span class="built_in">upd</span>(i, a[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op; <span class="built_in">read</span>(op);</span><br><span class="line">    <span class="keyword">if</span>(!op)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x, y;</span><br><span class="line">      <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">      <span class="built_in">del</span>(x, pw[a[x]]);</span><br><span class="line">      <span class="built_in">upd</span>(x, a[x], <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">ins</span>(x, pw[a[x]=y]);</span><br><span class="line">      <span class="built_in">upd</span>(x, a[x], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">      <span class="built_in">read</span>(l1), <span class="built_in">read</span>(r1), <span class="built_in">read</span>(l2), <span class="built_in">read</span>(r2);</span><br><span class="line">      <span class="type">int</span> x = <span class="built_in">Sub</span>(<span class="built_in">ask</span>(r1), <span class="built_in">ask</span>(l1<span class="number">-1</span>)), y = <span class="built_in">Sub</span>(<span class="built_in">ask</span>(r2), <span class="built_in">ask</span>(l2<span class="number">-1</span>));</span><br><span class="line">      ll s1 = <span class="built_in">ask2</span>(r1) - <span class="built_in">ask2</span>(l1<span class="number">-1</span>), s2 = <span class="built_in">ask2</span>(r2) - <span class="built_in">ask2</span>(l2<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">if</span>((s2-s1)%(r1-l1+<span class="number">1</span>)) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ll k = (s2-s1)/(r1-l1+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>) k = -k, <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(x*<span class="built_in">powmod</span>(magic, k)%mod==y) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">namespace</span> IO</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">  <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,MAXSIZE,stdin),p1==p2) ? EOF : *p1++); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">gc</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) t = t*<span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">    t *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">out</span><span class="params">(T p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sta[<span class="number">70</span>], tp;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span>) &#123; p = -p; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">while</span>(p) sta[++tp] = p%<span class="number">10</span>, p/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(sta[tp--]+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="type">int</span> n, q, a[N];</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="type">double</span> snx[N], csx[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="keyword">return</span> (x&lt;-eps ? <span class="number">-1</span> : x&gt;eps); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v, <span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> snv = <span class="built_in">sin</span>(v), csv = <span class="built_in">cos</span>(v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i))</span><br><span class="line">  &#123;</span><br><span class="line">    sum[i] += v*op;</span><br><span class="line">    snx[i] += snv*op;</span><br><span class="line">    csx[i] += csv*op;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) ans += sum[i];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="keyword">operator</span> - (pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; a, pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; b) &#123; <span class="keyword">return</span> <span class="built_in">mp</span>(a.fi-b.fi, a.se-b.se); &#125;</span><br><span class="line"><span class="function">pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="title">ask2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> sn = <span class="number">0.0</span>, cs = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) sn += snx[i], cs += csx[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mp</span>(sn, cs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n); <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">upd</span>(i, a[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="built_in">read</span>(op);</span><br><span class="line">    <span class="keyword">if</span>(op)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">      <span class="built_in">read</span>(l1); <span class="built_in">read</span>(r1); <span class="built_in">read</span>(l2); <span class="built_in">read</span>(r2);</span><br><span class="line">      ll x = <span class="built_in">ask</span>(r1) - <span class="built_in">ask</span>(l1<span class="number">-1</span>);</span><br><span class="line">      ll y = <span class="built_in">ask</span>(r2) - <span class="built_in">ask</span>(l2<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">if</span>((y-x)%(r1-l1+<span class="number">1</span>)) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ll k = (y-x)/(r1-l1+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">ask2</span>(r1) - <span class="built_in">ask2</span>(l1<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> q = <span class="built_in">ask2</span>(r2) - <span class="built_in">ask2</span>(l2<span class="number">-1</span>);</span><br><span class="line">        <span class="type">double</span> snk = <span class="built_in">sin</span>(k), csk = <span class="built_in">cos</span>(k);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(q.fi-p.fi*csk-p.se*snk) || <span class="built_in">sgn</span>(q.se-p.se*csk+p.fi*snk)) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x, y;</span><br><span class="line">      <span class="built_in">read</span>(x); <span class="built_in">read</span>(y);</span><br><span class="line">      <span class="built_in">upd</span>(x, a[x], <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">upd</span>(x, a[x]=y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shift-and/or 字符串匹配算法</title>
      <link href="/2020/07/22/shift-andor-zi-fu-chuan-pi-pei-suan-fa/"/>
      <url>/2020/07/22/shift-andor-zi-fu-chuan-pi-pei-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="shift-and"><a class="header-anchor" href="#shift-and">¶</a>shift-and</h2><p>在串s中查找串t规定串s的长度为n，串t的长度为m，字符串下标从0开始bitset<m> B[26];预处理字符集中每个字母在串t中的出现的位置，各用一个bitset表示。B[s[i]-‘a’]表示的是s串中i位置与t串中哪些位置可以匹配bitset<m> D;在s中枚举位置i，D[j]=1仅当串t的前缀t[0…j]是串s的后缀s[i-j…i]当D[m-1]=1时表示一次匹配当枚举位置i+1，就要更新DD = (D&lt;&lt;1|1)&amp;B[s[i+1]-‘a’];复杂度$O(\frac{nm}{32})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shift_and</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">strlen</span>(s), m = <span class="built_in">strlen</span>(t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    B[s[i]-<span class="string">&#x27;A&#x27;</span>].<span class="built_in">set</span>(i);</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    D &lt;&lt;= <span class="number">1</span>; D.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line">    D &amp;= B[t[i]-<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(D[n<span class="number">-1</span>]) cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shift-or"><a class="header-anchor" href="#shift-or">¶</a>shift-or</h2><p>与shiftand的B和D含义都相反，B=0表示存在，D=0表示匹配，所以初始时B和D全为1，每次转移D = (D&lt;&lt;1|B[s[i]-‘a’])</p><p>在普通的字符串匹配中这两者的作用显然没有kmp强，复杂度劣势但是在可选字符匹配中很有用规定每个位置可以与多个字符相匹配，此时只要让这些字符的B的那个位置都置1即可</p><ul><li>hdu 5972 输出的时候令s[n+1]=0,然后puts(s[i-n+1])，再还原s[n+1]。如果先记录匹配位置最后双重for会T</li><li>hdu 5716</li><li>牛客多校2G题给定长度为n的数组a和长度为m的数组b，询问数组a中每一位都严格大于数组b的子段个数可以把这个问题当成一个可选字符匹配问题，对于每个a[i]可以与所有&lt;=a[i]的b[j]相匹配。考虑预处理出bitset<M> B[N]，表示a的每一位可以与b的哪些位相匹配，然后跑一遍shift-and即可。这样会MLE，随着a的增大，能够匹配的位置不断增加，所以本质不同的bitset只有m个，开成bitset<M> B[M]即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1.5e5</span> + <span class="number">5</span>, M = <span class="number">4e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, idx[N];</span><br><span class="line">pii a[N], b[M];</span><br><span class="line">bitset&lt;M&gt; B[M], D;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].fi), a[i].se = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i].fi), b[i].se = i;</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>); <span class="built_in">sort</span>(b+<span class="number">1</span>, b+m+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    B[i] = B[i<span class="number">-1</span>], B[i].<span class="built_in">set</span>(b[i].se);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=m &amp;&amp; a[i].fi&gt;=b[j].fi) ++j;</span><br><span class="line">    idx[a[i].se] = j<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    D &lt;&lt;= <span class="number">1</span>; D.<span class="built_in">set</span>(<span class="number">1</span>);</span><br><span class="line">    D &amp;= B[idx[i]];</span><br><span class="line">    <span class="keyword">if</span>(D[m]) ++ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑预处理bitset<N> B[i]表示b数组中第i位可以与a数组中哪些位相匹配。然后用一个全1的bitset<N>D，当D[i]=1时表示a数组中以i下标起始的长度为m的子段可以与b数组相匹配。只要枚举b数组中的所有位置让D &amp;= (B[i]&gt;&gt;(i-1))即可，如果B[i][j]=0，那么D[j-i+1]起始的子段就不可能与b数组相匹配，因为a[j]!=b[i]。以上方法也可以用于字符串匹配。在牛客多校这题中，利用该方法可以仅开一个bitset<N> B，因为在这里b数组下标的枚举顺序是任意的，所以我们可以对b排序后再枚举，然后利用尺取实现B的滚动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1.5e5</span> + <span class="number">5</span>, M = <span class="number">4e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, idx[N];</span><br><span class="line">pii a[N], b[M];</span><br><span class="line">bitset&lt;N&gt; B, D;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].fi), a[i].se = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i].fi), b[i].se = i;</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>); <span class="built_in">sort</span>(b+<span class="number">1</span>, b+m+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n-m+<span class="number">1</span>; i++) D.<span class="built_in">set</span>(i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=m, j=n; i; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; a[j].fi&gt;=b[i].fi) B.<span class="built_in">set</span>(a[j--].se);</span><br><span class="line">    D &amp;= (B&gt;&gt;(b[i].se<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)D.<span class="built_in">count</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀自动机和广义后缀自动机的一些疑问</title>
      <link href="/2020/07/17/hou-zhui-zi-dong-ji-he-guang-yi-hou-zhui-zi-dong-ji-de-yi-xie-yi-wen/"/>
      <url>/2020/07/17/hou-zhui-zi-dong-ji-he-guang-yi-hou-zhui-zi-dong-ji-de-yi-xie-yi-wen/</url>
      
        <content type="html"><![CDATA[<p>感觉sam，特别是parent树上的复杂度很玄学？！</p><ul><li><p>暴力跳parent树的复杂度是多少？第一种情况是建广义sam，然后每个串暴力跳parent标记，复杂度似乎是$n\sqrt n$​（维护多串的根号trick）第二种是sam上直接无脑暴力跳到某个长度范围内，一般情况是要写倍增的，但是我在2019徐州L、p4094上直接暴力跳也都过了，而且比倍增快（常数小）。。如果是aaaaa…的话parent树是链，应该能卡，所以还是要写倍增吧</p></li><li><p>trie上建广义sam正解是bfs的做法，但是需要显示的建出trie，如果不建会错，我认为是重边的影响（不确定）。如果直接dfs，复杂度会取决于trie上$\sum dep(leaf)$（15国家论文），感觉可以卡成$n^2$，然而我在2019徐州L、2019wfG上直接dfs建就过了，由于不用建trie，时间和空间上都挺优秀，目前还不知道是数据问题还是什么。p3346由于叶子只有20个，所以dfs肯定是对的。</p></li><li><p>广义sam能不能基数排序突然意识到广义sam基数排序后的结果与拓扑序可能有出入，不过我好几道exsam用基数排序得到的拓扑序去做也过了。。很迷还是老老实实把parent树建出来吧。</p></li><li><p>注意：线段树合并求endpos集合的时候，一定要新开点，否则可能会影响子树的信息。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kmp学习笔记</title>
      <link href="/2020/07/14/kmp-xue-xi-bi-ji/"/>
      <url>/2020/07/14/kmp-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="应用"><a class="header-anchor" href="#应用">¶</a>应用</h2><p>给定主串t和模式串s，求出s在t中的所有匹配位置求出一个串的所有前缀的最大border(next数组)</p><h2 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h2><p>前缀pre(s, l)：s长度为l的前缀(s[1…l])后缀suf(s, l)：s长度为l的后缀(s[|s|-l+1…|s|])周期period：s[i]=s[i+p]，$\forall i \in1…|s|-ps[i]=s[i+p]$，则p是s的周期border: pre(s, l) = suf(s, l)，则pre(s, l)是s的border</p><h2 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h2><p>若s有长为x的border，则|s|-x为s的一个周期。证明可以分成border相交和不相交两种情况最小周期=串长-最大borderborder具有传递性，串s的所有border可以用<code>nxt[|s|]，nxt[nxt[|s|]]...</code>表示<strong>Weak Periodicity Lemma</strong>p和q是s的周期，p+q&lt;=|s|，则gcd(p, q)也是s的周期<strong>Periodicity Lemma</strong>p和q是s的周期，p+q-gcd(p, q)&lt;=|s|，则gcd(p, q)也是s的周期(牛客多校1的签到是给出两个无限串各自的周期，要求比较这两个串的字典序大小，只需要比较前p+q-gcd(p,q)或者前p+q个字符，如果都相同，说明p和q都是各自的周期，两个串相等)</p><h2 id="求法"><a class="header-anchor" href="#求法">¶</a>求法</h2><p>nxt数组的求法可以当作是s串自己和自己匹配的过程。规定<code>nxt[0]=−1</code>，s串从0开始，nxt[i]表示s[0…i-1]的最大border考虑当前已经求出了nxt[0…i]，且nxt[i]=j，说明<code>s[i-j...i-1]=s[0...j-1]</code></p><ul><li><code>s[i]==s[j]</code>，<code>nxt[++i] = ++j</code></li><li><code>ss[i]!=s[j]</code>，此时我们需要不断往前跳nxt，直到找到一个border的后一个字符等于s[j]，然后转为第一种情况</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp_pre</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> n, <span class="type">int</span> nxt[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;s[i]!=s[j]) j = nxt[j];</span><br><span class="line">    nxt[++i] = ++j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串匹配的过程和求next数组的过程类似（模式串都是s，只不过主串变了）。规定s串为模式串，t为主串，下标均从0开始。先求出s串的next数组考虑当前t串匹配到i-1，s串匹配到j-1，说明<code>t[i-j...i-1]=s[0...j-1]</code></p><ul><li><code>t[i]=s[j]</code>，++i，++j。如果j&gt;|s|，说明找到一个匹配，记录下位置，让j=nxt[j]</li><li><code>t[i]!=s[j]</code>，j不断跳nxt直到找到一个border的后一个字符等于t[i]为止，然后转化为第一种情况</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp_work</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> n, <span class="type">char</span> t[], <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">kmp_pre</span>(s, n, nxt);</span><br><span class="line">  <span class="keyword">while</span>(i&lt;m)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;t[i]!=s[j]) j = nxt[j];</span><br><span class="line">    i++; j++;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">      ans++;</span><br><span class="line">      match[i-n] = <span class="number">1</span>;</span><br><span class="line">      j = nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><ul><li><p>p3375求出所有匹配位置+nxt数组</p></li><li><p>p5829引入一种失配树（和ac自动机的fail树类似）：按照next数组进行建树，next[i]作为i的父亲。显然每个点有且仅有一个父节点。容易发现每个点的所有祖先就是它的所有border，跳nxt的过程相当于不断往父亲走本题多次询问一个串s的某两个前缀的最大公共border。建出失配树后很直观的可以发现答案就是两个节点的LCA代表的前缀</p></li><li><p>p3435求每个前缀的最大周期。求最大周期相当于求最小border。放在失配树上就相当于找到每个点祖先中离根最近的那个。树上dp一下即可。也可以路径压缩。</p></li><li><p>poj2185一个n*m字符矩阵，求一个最小的子矩阵，使其重复多次后所得矩阵包含原矩阵。行列分开做一遍kmp，求出各自的最大border。按行做的时候，每一行的字符当作一个字符（hash一下，直接暴力也行）</p></li><li><p>p2375对s的所有前缀，求出长度不超过一半的border数量放到失配树上，倍增一下（border长度单减）（无脑+暴力）$O(n\log n)$$O(n)$做法：考虑在求解nxt数组的时候，再增加一个k指针，该指针和j指针一样，但是需要额外满足长度的限制，如果不满足继续跳nxt。i点的答案就是k点的答案的nxt前缀和（同时dp递推即可）</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = nxt[<span class="number">0</span>] = <span class="number">-1</span>, k = <span class="number">-1</span>;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(~j &amp;&amp; s[i]!=s[j]) j = nxt[j];</span><br><span class="line">    <span class="keyword">while</span>(~k &amp;&amp; s[i]!=s[k]) k = nxt[k];</span><br><span class="line">    nxt[++i] = ++j;</span><br><span class="line">    ++k;</span><br><span class="line">    dp[i] = dp[nxt[i]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*k&gt;i) k = nxt[k];</span><br><span class="line">    ans = ans*(dp[k]+<span class="number">1</span>)%mod; <span class="comment">//求的是每个点答案+1的连乘积</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>p3426对于字符串s，求一个最短的字符串t，其<strong>可重叠</strong>地重复数次后等于s显然t是s的一个border如果当前等价于s[1…i]，相当于t是pre(s, i)的一个border。所以这个t是s的某些前缀的border，而且这些前缀的位置的差值要&lt;=这个串t的长度。在失配树上考虑，答案是0到n这条链上的某个点x(s的某个border)，并且该点子树内所有点的位置的最大差值&lt;=x(x是其子树内的所有点的某个border)，如果最大差值&gt;x，那么这两个前缀间就不能通过x拼接而成。失配树上从0走到n，不断删去非子树内的点，用set或双向链表维护maxgap即可考虑dp[i]：s[1…i]的答案dp[i]要么等于i，要么等于dp[nxt[i]]等于dp[nxt[i]]的条件是nxt[i]…i-1间$\exists j \ dp[j] = dp[nxt[i]] \land i-j&lt;=dp[nxt[i]]$</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">  dp[i] = i;</span><br><span class="line">  <span class="keyword">if</span>(p[dp[nxt[i]]] &amp;&amp; i-p[dp[nxt[i]]]&lt;=dp[nxt[i]])</span><br><span class="line">    dp[i] = dp[nxt[i]];</span><br><span class="line">  p[dp[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>p3193给定一个长为m的字符串t，问能构造出多少个长为n的字符串s，使得t不是s的子串。$m&lt;=20, n&lt;=10^9$f[i][j]：s串构造到i，t串匹配到j的方案数先预处理出t串当前匹配到i，加一个字符后匹配到j的方案数g[i][j]，这个用kmp即可转移：$f[i][j] = \sum_{k=0}^{m-1} f[i-1][k] * g[k][j]$显然可以矩阵快速幂优化</li></ul><p>$\begin{bmatrix}f[i][0] &amp; \cdots &amp; f[i][m-1] \end{bmatrix} = \begin{bmatrix} f[i-1][0] &amp;\cdots &amp; f[i-1][m-1] \end{bmatrix} \begin{bmatrix} g[0][0] &amp; \cdots &amp;g[0][m-1] \\ \vdots &amp; \ddots &amp; \vdots \\ g[m-1][0] &amp; \cdots &amp; g[m-1][m-1]\\ \end{bmatrix}$</p><p>其中f[0][0]=1最后答案即为$g^n$的第一行的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">25</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, mod;</span><br><span class="line"><span class="type">int</span> g[N][N], nxt[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="type">int</span> mat[N][N];</span><br><span class="line">  <span class="built_in">matrix</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">matrix</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">n</span>(a), <span class="built_in">m</span>(b) &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">one</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">        mat[i][j] = (i==j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">matrix <span class="keyword">operator</span> * (matrix a, matrix b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">matrix <span class="title">res</span><span class="params">(a.n, b.m)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=a.n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=b.m; j++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=a.m; k++)</span><br><span class="line">        res.mat[i][j] = (res.mat[i][j]+a.mat[i][k]*b.mat[k][j])%mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">matrix <span class="keyword">operator</span> ^ (matrix a, ll x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">matrix <span class="title">res</span><span class="params">(a.n, a.m)</span></span>; res.<span class="built_in">one</span>();</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;<span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nxt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;m)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(~j &amp;&amp; s[i]!=s[j]) j = nxt[j];</span><br><span class="line">    nxt[++i] = ++j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">-1</span>; i&lt;m<span class="number">-1</span>; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(~j &amp;&amp; s[j]-<span class="string">&#x27;0&#x27;</span>!=k) j = nxt[j];</span><br><span class="line">      g[i+<span class="number">1</span>][j+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">  <span class="built_in">get_nxt</span>();</span><br><span class="line">  <span class="built_in">init_g</span>();</span><br><span class="line">  <span class="function">matrix <span class="title">f</span><span class="params">(m, m)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">      f.mat[i][j] = g[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">  f = f ^ n;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) ans = (ans + f.mat[<span class="number">1</span>][i])%mod;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D-Array 构造</title>
      <link href="/2020/06/18/d-array-gou-zao/"/>
      <url>/2020/06/18/d-array-gou-zao/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>给定两个数x和y，要求用最少的n个数，使得他们的异或和=x，求和=y</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>这道题在cf上有类似的</p><ul><li>x=y=0 输出0</li><li>x=y!=0 输出1</li><li>x&gt;y 输出-1</li><li>(y-x)&amp;1 输出-1</li><li>如果可以用(y+x)/2 和(y-x)/2，就输出2</li><li>否则输出3 x, (y-x)/2, (y-x)/2</li></ul><p>顺便记一下python多组输入(竟然跑了6s多。。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="keyword">if</span> x==y:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">0</span>) <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">else</span> <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> x&gt;y:</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> (y-x)&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> ((y+x)//<span class="number">2</span>) ^ ((y-x)//<span class="number">2</span>) == x:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛65</title>
      <link href="/2020/06/18/niu-ke-lian-xi-sai-65/"/>
      <url>/2020/06/18/niu-ke-lian-xi-sai-65/</url>
      
        <content type="html"><![CDATA[<h2 id="C-二维动点"><a class="header-anchor" href="#C-二维动点">¶</a>C 二维动点</h2><h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>平面上有n个点，每次可以选择一个与当前不重合的点，然后移动到两者<strong>直线</strong>上的任意一点，多次询问从原点到(x, y)最少的移动次数</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>大力分类讨论：</p><ul><li>(0, 0）是没有用的，如果出现需要去掉</li><li>如果平面上所有点到原点的连线是相同的，且询问点不在该连线上，输出-1</li><li>如果询问点与原点连成的直线上存在平面上的n个点中的至少一个，输出1，可以利用pair来存斜率，注意归约化处理</li><li>如果点数&gt;=3，输出2，只要有两条直线相交，就可以先移到交点，再移过去</li><li>当只有2个点时，考虑一种特殊情况（样例已经提示），原点+这2个点+询问点构成平行四边形，此时需要3次，先随便移到某个点处，再按上一条的做法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, q, x[N], y[N];</span><br><span class="line">map&lt;pii, <span class="type">int</span>&gt; cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"><span class="function">pii <span class="title">cal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = c - a, y = d - b;</span><br><span class="line">  <span class="built_in">assert</span>(x || y);</span><br><span class="line">  <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> f = <span class="built_in">sgn</span>(x)*<span class="built_in">sgn</span>(y);</span><br><span class="line">  <span class="type">int</span> t = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(x), <span class="built_in">abs</span>(y));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mp</span>(f*x/t, y/t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="type">int</span> m = n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    <span class="keyword">if</span>(!x[i]&amp;&amp;!y[i])</span><br><span class="line">    &#123;</span><br><span class="line">      m--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[<span class="built_in">cal</span>(<span class="number">0</span>, <span class="number">0</span>, x[i], y[i])]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(!a&amp;&amp;!b) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt.<span class="built_in">count</span>(<span class="built_in">cal</span>(<span class="number">0</span>, <span class="number">0</span>, a, b))) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sz</span>(cnt)&lt;=<span class="number">1</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m&gt;=<span class="number">3</span>) cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">cal</span>(<span class="number">0</span>, <span class="number">0</span>, x[<span class="number">1</span>], y[<span class="number">1</span>])==<span class="built_in">cal</span>(x[<span class="number">2</span>], y[<span class="number">2</span>], a, b) &amp;&amp; <span class="built_in">cal</span>(<span class="number">0</span>, <span class="number">0</span>, x[<span class="number">2</span>], y[<span class="number">2</span>])==<span class="built_in">cal</span>(x[<span class="number">1</span>], y[<span class="number">1</span>], a, b)) cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-最小公倍数"><a class="header-anchor" href="#D-最小公倍数">¶</a>D 最小公倍数</h2><h3 id="题意-s2"><a class="header-anchor" href="#题意-s2">¶</a>题意</h3><p>给出一个数n，要求拆分成k个数，定义拆分后的价值为该序列的所有子序列的lcm的<strong>种类数</strong> ，注意空序列的lcm=1</p><h3 id="做法-s2"><a class="header-anchor" href="#做法-s2">¶</a>做法</h3><p>因为答案要取模，所以感觉没法比较大小，所以在做题的时候以为是个构造。。。然后其实就是dp考虑数$p_1*p_2$​，显然没有拆成$p_1, p_2$​两个数优，因为它们的贡献是一样的，但是后者更小。所以最后一定是拆成若干个素数的幂次。考虑进行背包dp，因为各个素数的贡献其实是一样的，所以一定是从小往大选，前100多个素数的和就超过$10^5$了，如果当前这个素数选了k个，即选择了$p_1,p_2 … p_k$​，假设之前有x个不同的种类，那现在就有(k+1)*x个不同的种类。下面的问题是由于要取模，没法比较最后的大小了（毒瘤），一种方法是用double来存价值，并记录转移路径，最后在回溯的时候用longlong，并且取模，另一种是用<code>Pair&lt;double, long long&gt;</code>，前者利用log函数将乘法转为加法，后者存答案，即取模后的值，由于pair已经封装好了，所以直接取max即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, prime[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">pair&lt;<span class="type">double</span>,ll&gt; dp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getprime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=x; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) prime[++prime[<span class="number">0</span>]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=prime[<span class="number">0</span>]&amp;&amp;<span class="number">1ll</span>*prime[j]*i&lt;=x; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      vis[prime[j]*i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="built_in">getprime</span>(n);</span><br><span class="line">  <span class="type">int</span> cur = <span class="number">0</span>, tot = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(tot&lt;=prime[<span class="number">0</span>]&amp;&amp;cur+prime[tot]&lt;=n) cur += prime[tot++];</span><br><span class="line">  dp[<span class="number">0</span>].se = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;tot; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=n; j&gt;=prime[i]; j--)</span><br><span class="line">    &#123;</span><br><span class="line">      ll t = prime[i], s = t;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; s&lt;=j; s += (t*=prime[i]), k++)</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], <span class="built_in">mp</span>(dp[j-s].fi+<span class="built_in">log2</span>(k+<span class="number">1</span>), dp[j-s].se*(k+<span class="number">1</span>)%mod));</span><br><span class="line">    &#125;</span><br><span class="line">  pair&lt;<span class="type">double</span>, ll&gt; ans = &#123;<span class="number">0.0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">  cout &lt;&lt; ans.se &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-游走配对"><a class="header-anchor" href="#E-游走配对">¶</a>E 游走配对</h2><h3 id="题意-s3"><a class="header-anchor" href="#题意-s3">¶</a>题意</h3><p>无向图上，有q个蓝点，q个红点，要求将蓝点和红点进行配对，每次配对产生的费用是他们路径上经过的所有点权的和，此外一个点如果被经过了k次，那么它的点权是$a_i + (k-1)*b_i$​，问最小的配对费用</p><h3 id="做法-s3"><a class="header-anchor" href="#做法-s3">¶</a>做法</h3><p>数据量较小，MCMF。由于是点权，我们拆成入点和出点，点权放在入点到出点的边上，并且拆除q条边，每条边流量为1，费用为第i次经过产生的费用，再将源点与q个蓝点的入点相连，q个红点的出点与汇相连，原图的m条边，则将u的出点和v的入点相连，v的出点和u的入点相连，然后跑最小费用最大流算是网络流基础题了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>, M = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, q, m, x[N], y[N];</span><br><span class="line"><span class="type">int</span> cnt, head[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> next, to, w, f;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[++cnt] = &#123;head[u],v,w,f&#125;;</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MCMF</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n, m, s, t;</span><br><span class="line">  <span class="type">int</span> flow, cost;</span><br><span class="line">  <span class="type">bool</span> inq[N];</span><br><span class="line">  <span class="type">int</span> d[N], p[N], a[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n = n, <span class="keyword">this</span>-&gt;s = s, <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">    cnt = <span class="number">1</span>, m = <span class="number">0</span>, flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> cap,<span class="type">int</span> cost)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(u,v,cap,cost);</span><br><span class="line">    <span class="built_in">add</span>(v,u,<span class="number">0</span>,-cost);</span><br><span class="line">    m += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(inq,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>, a[s] = INF;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      inq[u] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(u==t) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(e[i].w&amp;&amp;d[v]&gt;d[u]+e[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">          d[v] = d[u] + e[i].f;</span><br><span class="line">          p[v] = i;</span><br><span class="line">          a[v] = <span class="built_in">min</span>(a[u],e[i].w);</span><br><span class="line">          <span class="keyword">if</span>(!inq[v])</span><br><span class="line">          &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">            inq[v] = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[t] != INF;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      flow += a[t];</span><br><span class="line">      cost += a[t] * d[t];</span><br><span class="line">      <span class="type">int</span> u = t;</span><br><span class="line">      <span class="keyword">while</span>(u!=s)</span><br><span class="line">      &#123;</span><br><span class="line">        e[p[u]].w -= a[t];</span><br><span class="line">        e[p[u]^<span class="number">1</span>].w += a[t];</span><br><span class="line">        u = e[p[u]^<span class="number">1</span>].to;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;MM;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">  MM.<span class="built_in">init</span>(<span class="number">2</span>*n+<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=q; j++)</span><br><span class="line">      MM.<span class="built_in">addedge</span>(i, n+i, <span class="number">1</span>, (j<span class="number">-1</span>)*b+a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> c, d;</span><br><span class="line">    cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    MM.<span class="built_in">addedge</span>(c+n, d, q, <span class="number">0</span>);</span><br><span class="line">    MM.<span class="built_in">addedge</span>(d+n, c, q, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) cin &gt;&gt; x[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) cin &gt;&gt; y[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    MM.<span class="built_in">addedge</span>(MM.s, x[i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    MM.<span class="built_in">addedge</span>(y[i]+n, MM.t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  MM.<span class="built_in">go</span>();</span><br><span class="line">  cout &lt;&lt; MM.cost &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforces1361</title>
      <link href="/2020/06/06/codeforces1361/"/>
      <url>/2020/06/06/codeforces1361/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><p>给定一张无向图，每个点有一个权值，如果访问u点，产生的价值是与u相连的所有点的点权的mex，给定价值序列，让你求访问顺序</p><p>显然只要按照权值从小到大访问，然后模拟一遍看是否合法即可。<s>我TM在排序里用了等于号，一直re，人快没了</s> sort的比较函数必须是偏序的</p><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>每个物品的权值为$p^{k_i}$​，给定$p$和$k_i$​，问将物品分成两堆，使权值和的差最小，问最小值。</p><p>可以看成一个p进制的数，每次将当前最高位丢入第一堆，然后用后面的数不断补给第二堆，直到与第一堆相等，然后重复即可。记录两堆相差的p的幂次即可，细节较多感觉最近写题的正确率有点低，总是犯些奇奇怪怪的错误，导致调的时候也很烦</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>用n个线段，每个线段的端点有权值a和b，要求将它们串成一个环，定义两条线段连接点处的权值为$highbit(a^b)$，环的价值为所有连接点处价值的最小值，问环的价值最大是多少</p><p>显然二分价值（由于只有20，直接从大到小枚举即可，考虑如何check。如果价值为x，说明连接点处两点权值的低x位是相同的，所以按照a&amp;((1&lt;&lt;k)-1) – b&amp;((1&lt;&lt;k)-1)建图，看是否存在欧拉回路即可我貌似不会欧拉回路怎么记录。。。随便从一点出发找出欧拉路径，看其长度是否为n，再看<strong>首尾连接点处的权值是否满足要求</strong>，注意在找路径前要先利用度数进行判断，否则找的路径会出问题（我也不知道为什么）对于欧拉图（存在欧拉回路），所有点度数一定都是偶数，且为连通图（可以不判断，因为如果找到的欧拉路径&lt;n就说明不连通）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], b[N], cur[N], in[N], out[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;pii&gt; G[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> pre)</span> <span class="comment">//找欧拉路径的板子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(cur[u]&lt;<span class="built_in">sz</span>(G[u]))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = G[u][cur[u]].fi, id = G[u][cur[u]].se;</span><br><span class="line">    ++cur[u];</span><br><span class="line">    <span class="keyword">if</span>(!vis[id])</span><br><span class="line">    &#123;</span><br><span class="line">      vis[id] = vis[id^<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//每条边正向和反向选其1，所以走了一个后，另一个也要标记</span></span><br><span class="line">      <span class="built_in">dfs</span>(v, id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pre!=<span class="number">-1</span>) path.<span class="built_in">pb</span>(pre);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">20</span>; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> c = (<span class="number">1</span>&lt;&lt;k) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=c; i++) G[i].<span class="built_in">clear</span>(), cur[i] = <span class="number">0</span>, in[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">2</span>*n+<span class="number">1</span>; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      G[a[i]&amp;c].<span class="built_in">emplace_back</span>(b[i]&amp;c, <span class="number">2</span>*i);</span><br><span class="line">      G[b[i]&amp;c].<span class="built_in">emplace_back</span>(a[i]&amp;c, <span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">      in[a[i]&amp;c]++, in[b[i]&amp;c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=c&amp;&amp;ok; i++)</span><br><span class="line">      <span class="keyword">if</span>(in[i]&amp;<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ok) <span class="keyword">continue</span>;</span><br><span class="line">    path.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(a[<span class="number">1</span>]&amp;c, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sz</span>(path)&lt;n) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(path[<span class="number">0</span>]%<span class="number">2</span>&amp;&amp;(a[(path[<span class="number">0</span>]<span class="number">-1</span>)/<span class="number">2</span>]&amp;c)!=(a[<span class="number">1</span>]&amp;c)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(path[<span class="number">0</span>]%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;(b[path[<span class="number">0</span>]/<span class="number">2</span>]&amp;c)!=(a[<span class="number">1</span>]&amp;c)) <span class="keyword">continue</span>;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : path)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(x&amp;<span class="number">1</span>) cout &lt;&lt; x<span class="number">-2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x<span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x<span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lyndon 分解</title>
      <link href="/2020/06/03/lyndon-fen-jie/"/>
      <url>/2020/06/03/lyndon-fen-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h3><p>Lyndon串：s是s所有后缀中字典序最小的（s是其所有循坏位移中最小的一个）Lyndon分解：Lyndon 分解是将字符串 s 分解成 $s=s_1s_2 \dots s_n$​,使得每个$s_i$​都是Lyndon串，且$s_i\geq s_{i+1}$</p><h3 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h3><p>Lyndon分解唯一，且每个字符串都存在Lyndon分解。</p><h3 id="Duval-算法"><a class="header-anchor" href="#Duval-算法">¶</a>Duval 算法</h3><p>$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> j = i, k = i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(k&lt;=n&amp;&amp;s[j]&lt;=s[k])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[j]&lt;s[k]) j = i;</span><br><span class="line">    <span class="keyword">else</span> j++;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">  &#123;</span><br><span class="line">    ans ^= i+k-j<span class="number">-1</span>;  <span class="comment">// [i:i+k-j-1]是某个分解的s_i</span></span><br><span class="line">    i += k-j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最小表示法只要对s+s进行Lyndon分解并找到最后一个分解的串的起点取长度n即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stern-Brocot 树与 Farey 序列</title>
      <link href="/2020/06/03/stern-brocot-shu-yu-farey-xu-lie/"/>
      <url>/2020/06/03/stern-brocot-shu-yu-farey-xu-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="Stern-Brocot-树"><a class="header-anchor" href="#Stern-Brocot-树">¶</a>Stern-Brocot 树</h2><h3 id="构造"><a class="header-anchor" href="#构造">¶</a>构造</h3><p>从两个最简单的分数开始： $\dfrac 01 \quad \dfrac 10$每次在相邻的两个分数$\dfrac {a}{b} \quad \dfrac{c}{d}$​中间插入一个分数$\dfrac{a+c}{b+d}$​即可</p><h3 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h3><ul><li><p>每一层的序列中，分数单调递增，即$\dfrac {a}{b} &lt; \dfrac{a+c}{b+d} &lt; \dfrac{c}{d}$这是一棵平衡树，中序遍历是有序的（建树、查找）</p></li><li><p>每个分数都是最简分数</p></li><li><p>可以表示出<strong>所有</strong>的最简分数，每个分数唯一</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">1</span>, <span class="type">int</span> c = <span class="number">1</span>, <span class="type">int</span> d = <span class="number">0</span>, <span class="type">int</span> level = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = a + c, y = b + d;</span><br><span class="line">  <span class="comment">// ... output the current fraction x/y</span></span><br><span class="line">  <span class="comment">// at the current level in the tree</span></span><br><span class="line">  <span class="built_in">build</span>(a, b, x, y, level + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">build</span>(x, y, c, d, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Farey序列"><a class="header-anchor" href="#Farey序列">¶</a>Farey序列</h2><p>Fi：把分母小于等于i的所有最简真分数按大小顺序排列形成的序列。可以通过SB树的方法类似构造长度：$L_i = L_{i-1} + \phi(i)$$L_i = 1 + \sum_{j=1}^n \phi(j)$分母每增大1，可以多phi(i)个最简真分数，即与i互质</p><p>求$f(x) = \dfrac{k}{x}$ 与 $g(x) = x^{\frac12}$​的交点的横坐标的最接近的分数，要求分母小于$10^5$相当于要找到最接近$k^\frac13$​的分数令初始分数为a = x-1, b = 1, c = x, d = 1然后在SB树上不断迭代靠近即可（类似二分的过程）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll x, k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    k = k*k;</span><br><span class="line">    <span class="keyword">while</span>(x*x*x&lt;k) x++;</span><br><span class="line">    <span class="keyword">if</span>(x*x*x==k) <span class="built_in">printf</span>(<span class="string">&quot;%lld/1\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ll a = x<span class="number">-1</span>, b = <span class="number">1</span>, c = x, d = <span class="number">1</span>, p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">      <span class="type">long</span> <span class="type">double</span> delta = <span class="built_in">min</span>(x*x*x-k, k-(x<span class="number">-1</span>)*(x<span class="number">-1</span>)*(x<span class="number">-1</span>));</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ll x = a + c, y = b + d;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;<span class="number">100000</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">double</span> tmp = (<span class="type">long</span> <span class="type">double</span>)x*x*x/(y*y*y);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(tmp-k)&lt;delta)</span><br><span class="line">        &#123;</span><br><span class="line">          delta = <span class="built_in">fabs</span>(tmp-k);</span><br><span class="line">          p = x, q = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;k) c = x, d = y;</span><br><span class="line">        <span class="keyword">else</span> a = x, b = y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YsOI2020 幼儿园 思维</title>
      <link href="/2020/06/02/ysoi2020you-er-yuan-si-wei/"/>
      <url>/2020/06/02/ysoi2020you-er-yuan-si-wei/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>给定有向图，n个点m条边，每条边有权值i，且恰好是1-m的一个排列，多次询问从x点只走$[l,r]$的边，且边权严格单调下降能否到达1号点，强制在线</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>限制了边权的范围$[l, r]$，我们可以先考虑$[1,r]$的时候怎么做，考虑dp[u]表示u号点与1连通需要的最小边权，从小到大枚举每一条边，如果该点与1相连，则dp[u]=w，否则如果dp[v]有值，则dp[u]=i，然后只要看dp[u]是不是小于r即可加入下界限制后，将dp[u]转化为与1连通时需要经过的最小边权<strong>最大</strong>是多少，如果该点与1相连，则dp[u]=i，否则dp[u]=max(dp[u],dp[v])，随着从小到大枚举边权dp，dp[u]是不断变大的，考虑按照枚举顺序建立主席树，每次单点更新u点的值，询问只要查询rt[r]版本的主席树中x点的值是否&gt;=l即可。相当于每个点处有很多单调递增的二维点（x坐标为边权，y坐标为dp），我们对每个点用vector存这些点，那么只要看x&lt;=r的最后一个点的y是否&gt;=l。</p><h3 id="思考"><a class="header-anchor" href="#思考">¶</a>思考</h3><p>严格单调下降的限制只要通过从小到大的顺序dp即可解决，对于既有上界又有下界的限制，考虑枚举上界，然后最大化下界即可</p><p>主席树写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, w, dp[N];</span><br><span class="line">pii edges[N];</span><br><span class="line"><span class="keyword">namespace</span> PSegTree</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ls(x) t[x].l</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rs(x) t[x].r</span></span><br><span class="line">  <span class="type">int</span> rt[N], tot;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, mx;</span><br><span class="line">  &#125;t[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t[++tot] = t[p];</span><br><span class="line">    p = tot;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">newnode</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">      t[p].mx = <span class="built_in">max</span>(t[p].mx, v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(<span class="built_in">ls</span>(p), l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">upd</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r, x, v);</span><br><span class="line">    t[p].mx = <span class="built_in">max</span>(t[<span class="built_in">ls</span>(p)].mx, t[<span class="built_in">rs</span>(p)].mx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> t[p].mx;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">ls</span>(p), l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PSegTree;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;w);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;edges[i].fi, &amp;edges[i].se);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = edges[i].fi, v = edges[i].se;</span><br><span class="line">    <span class="keyword">if</span>(v==<span class="number">1</span>) dp[u] = i;</span><br><span class="line">    <span class="keyword">else</span> dp[u] = <span class="built_in">max</span>(dp[u], dp[v]);</span><br><span class="line">    rt[i] = rt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">upd</span>(rt[i], <span class="number">1</span>, m, u, dp[u]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x, l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">if</span>(w) x ^= L, l ^= L, r ^= L;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>||<span class="built_in">ask</span>(rt[r], <span class="number">1</span>, m, x)&gt;=l) ++L, <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF893F Subtree Minimum Query 主席树trick</title>
      <link href="/2020/06/02/cf893f-subtree-minimum-query-zhu-xi-shu-trick/"/>
      <url>/2020/06/02/cf893f-subtree-minimum-query-zhu-xi-shu-trick/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>给定一棵有点权的树，每次询问点u子树中距离u&lt;=k的点的点权的最小值，要求在线回答</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>询问子树，考虑dfs序，即询问$[in[u]：out[u]]$$[dep[u]：dep[u]+k]$中的min{a}二维偏序，发现每个dfs序对应了一个点，按照深度建主席树，每个版本的主席树维护的是$[1,dep[u]]$这个深度前缀中dfs序区间的最小值，按照bfs深度顺序更新。询问的时候只要ask dep[u]+k版本的主席树中[in[u], out[u]]区间的最小值即可</p><p>一些不一定对的思考：线段树可以高效维护一段区间的信息，而主席树可以维护各个版本的线段树，每个版本维护的是它及其之前的所有版本的前缀信息，所以主席树可以维护二维的信息，通过转变维度，巧妙的利用某一维来建树可以解决很多问题。该题中最小值不可减，所以只能询问前缀，而不能询问rt[l]-rt[r]，但是在该dfs序中的点dep[u]都是符合条件的，所以没有问题。再说带修的主席树，由于主席树维护的是每个版本的前缀信息，所以在修改的时候需要修改后面每个版本的信息，所以考虑在外层套一个树状数组，此时树状数组中每棵主席树维护的不再是前缀信息了，不需要继承前一个版本(rt[i]=rt[i-1])，每次的查询和询问操作都只与log棵主席树相关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, r, a[N], in[N], out[N], dfn, dep[N];</span><br><span class="line"><span class="type">int</span> m, p, q, mxdep;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">namespace</span> PSegTree</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ls(x) t[x].l</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rs(x) t[x].r</span></span><br><span class="line">  <span class="type">int</span> rt[N], tot;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, mn;</span><br><span class="line">  &#125;t[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t[++tot] = t[p];</span><br><span class="line">    p = tot;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">newnode</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">      t[p].mn = <span class="built_in">min</span>(t[p].mn, v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(<span class="built_in">ls</span>(p), l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">upd</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r, x, v);</span><br><span class="line">    t[p].mn = <span class="built_in">min</span>(t[<span class="built_in">ls</span>(p)].mn, t[<span class="built_in">rs</span>(p)].mn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ql&amp;&amp;r&lt;=qr) <span class="keyword">return</span> t[p].mn;</span><br><span class="line">    <span class="type">int</span> ans = INF, mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(<span class="built_in">ls</span>(p), l, mid, ql, qr));</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PSegTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  in[u] = ++dfn;</span><br><span class="line">  dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">  mxdep = <span class="built_in">max</span>(mxdep, dep[u]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  out[u] = dfn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(r);</span><br><span class="line">  <span class="type">int</span> curd = <span class="number">0</span>;</span><br><span class="line">  rt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  t[<span class="number">0</span>].mn = INF;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">sz</span>(q))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;curd)</span><br><span class="line">    &#123;</span><br><span class="line">      rt[dep[u]] = rt[curd];</span><br><span class="line">      curd = dep[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">upd</span>(rt[dep[u]], <span class="number">1</span>, n, in[u], a[u]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">      <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;r);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    G[x].<span class="built_in">pb</span>(y); G[y].<span class="built_in">pb</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(r, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">  <span class="type">int</span> lstans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p, &amp;q);</span><br><span class="line">    p = (p+lstans)%n + <span class="number">1</span>;</span><br><span class="line">    q = (q+lstans)%n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lstans=<span class="built_in">ask</span>(rt[<span class="built_in">min</span>(mxdep, dep[p]+q)], <span class="number">1</span>, n, in[p], out[p]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6583 回首过去 数论+整除分块</title>
      <link href="/2020/06/02/p6583-hui-shou-guo-qu-shu-lun-zheng-chu-fen-kuai/"/>
      <url>/2020/06/02/p6583-hui-shou-guo-qu-shu-lun-zheng-chu-fen-kuai/</url>
      
        <content type="html"><![CDATA[<p>给定$n&lt;=10^{12}$询问$\sum_{x=1}^n \sum_{y=1}^n \left[ \dfrac{x}{y}\text{是有限小数}\right]$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>当真分数$\dfrac {x}{y}$​中分母y为$2^p5^q$的形式时才为有限小数即可以表示成$\dfrac {d*gcd(x, y)}{2^p5^qgcd(x,y)}$考虑枚举分母y，则可行的x的个数为$\left \lfloor \dfrac {n}{\zeta(y)} \right\rfloor$，$\zeta(y)$表示小于等于y的最大的不含2和5的因子的整数，相当于是gcd(x, y)这样是O(n)的，考虑改变枚举顺序枚举$\zeta(y)$，那么答案就是$\sum_{k=1}^n [2 \nmid k][5\nmid k] \left \lfloor \dfrac {n}{k} \right \rfloor g(\left \lfloor \dfrac{n}{k} \right \rfloor)$显然可以整除分块，其中g(i)代表小于等于i的且能表示成$2^p5^q$的数的个数（相当于是贡献次数）。然后可以通过容斥计算出区间内不被2和5整除的数的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - x/<span class="number">2</span> - x/<span class="number">5</span> + x/<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">g</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=x; i*=<span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>; j&lt;=x; j*=<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(i*j&gt;x) <span class="keyword">break</span>;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll l=<span class="number">1</span>,r; l&lt;=n; l=r+<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    r = <span class="built_in">min</span>(n, n/(n/l));</span><br><span class="line">    ans += (<span class="built_in">f</span>(r) - <span class="built_in">f</span>(l<span class="number">-1</span>))*(n/l)*<span class="built_in">g</span>(n/l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019ICPC 徐州</title>
      <link href="/2020/05/31/2019icpc-xu-zhou/"/>
      <url>/2020/05/31/2019icpc-xu-zhou/</url>
      
        <content type="html"><![CDATA[<h2 id="F"><a class="header-anchor" href="#F">¶</a>F</h2><p>暴力打表即可，不过在我电脑上跑的挺慢的。。</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>素数密度是不断变小的</p><h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><p>利用连续整数异或和的trick即可，只要小范围枚举左右两端点，中间一大段大概率可以是0</p><h2 id="E"><a class="header-anchor" href="#E">¶</a>E</h2><p>求出$\frac{Y!} {\prod {a_i}}$​是X的多少次方的倍数利用pollardrho求解X的所有素因子，然后求出各个阶乘中各素因子幂次的数量，乘法+，除法-，最后每个素因子取个min，注意负数和正数上下取整的问题</p><h2 id="H"><a class="header-anchor" href="#H">¶</a>H</h2><p>单点修改，区间询问该段区间最小的不能被表示的数洛谷p4587+修改先考虑不带修改的情况，对[l,r]内的数从小到大考虑，假设当前能够表示出[1,cur]的范围，如果询问[1,cur+1]的值等于cur，说明剩余的值都是大于等于cur+2的，此时cur+1是无法被表示出来的，所以break，容易发现该操作中cur的增长速度是fibnacci级别的，利用主席树完成二维数点问题。至于修改，在外层套一个树状数组即可，复杂度$O(n \log^3 n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>, up = <span class="number">2e5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, q, a[N];</span><br><span class="line"><span class="keyword">namespace</span> PSegTree</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ls(x) t[x].l</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rs(x) t[x].r</span></span><br><span class="line">  <span class="type">int</span> rt[N], tot;</span><br><span class="line">  <span class="type">int</span> lrt[N], rrt[N], lc, rc;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum;</span><br><span class="line">  &#125;t[N*<span class="number">128</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = ++tot;</span><br><span class="line">    t[p].sum += x*v;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">insert</span>(<span class="built_in">ls</span>(p), l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r, x, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">      ll ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) ans -= t[lrt[i]].sum;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) ans += t[rrt[i]].sum;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) lrt[i] = <span class="built_in">ls</span>(lrt[i]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) rrt[i] = <span class="built_in">ls</span>(rrt[i]);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ask</span>(l, mid, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ll ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) ans -= t[<span class="built_in">ls</span>(lrt[i])].sum;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) ans += t[<span class="built_in">ls</span>(rrt[i])].sum;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) lrt[i] = <span class="built_in">rs</span>(lrt[i]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) rrt[i] = <span class="built_in">rs</span>(rrt[i]);</span><br><span class="line">      <span class="keyword">return</span> ans + <span class="built_in">ask</span>(mid+<span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PSegTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) <span class="built_in">insert</span>(rt[i], <span class="number">1</span>, up, a[x], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  lc = rc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) lrt[++lc] = rt[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=r; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) rrt[++rc] = rt[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="number">1</span>, up, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">upd</span>(i, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">upd</span>(x, <span class="number">-1</span>);</span><br><span class="line">      a[x] = y;</span><br><span class="line">      <span class="built_in">upd</span>(x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ll cur = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ll sum = <span class="built_in">query</span>(x, y, <span class="built_in">min</span>((ll)up, cur+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(sum==cur) <span class="keyword">break</span>;</span><br><span class="line">        cur = sum;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, cur+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“科林明伦杯”哈尔滨理工大学第十届程序设计竞赛</title>
      <link href="/2020/05/31/ke-lin-ming-lun-bei-ha-er-bin-li-gong-da-xue-di-shi-jie-cheng-xu-she-ji-jing-sai/"/>
      <url>/2020/05/31/ke-lin-ming-lun-bei-ha-er-bin-li-gong-da-xue-di-shi-jie-cheng-xu-she-ji-jing-sai/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><p>给定一棵树，定义点对（s, t）间距离为<strong>路径上边权和+s和t的点权和</strong>dp记录每个点子树中到该点的最大和次大距离即可比赛的时候用树直径两次dfs的方法wa了，应该是有问题</p><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>给定n个数，每次可以选择一段区间，使区间-1，问最少几次操作可以使所有数变为1区间操作利用差分就可以转化成两次单点操作，再贪心考虑就很简单了</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><p>小学数学</p><h2 id="D"><a class="header-anchor" href="#D">¶</a>D</h2><p>条件概率，$P(A|B) = \frac {P(AB)} {P(B)}$P(AB):至少m枚硬币是反面，且恰好k枚硬币是正面同时发生，由于正面固定，所以反面为n-k，当$n-k&lt;m$时概率为0,否则为$C(n,k)/(2^n)$P(B):从m到n枚举反面硬币个数，$\sum_{i=m}^{n} C(n,i)/(2^n)$代入公式即可</p><h2 id="E"><a class="header-anchor" href="#E">¶</a>E</h2><p>简单贪心，从小到大去战胜，并且每次用刚好大于的那个</p><h2 id="F"><a class="header-anchor" href="#F">¶</a>F</h2><p>显然是个fibonacci，数据范围有点坑，我开了ull还是wa，改成py就过了😡😤</p><h2 id="G"><a class="header-anchor" href="#G">¶</a>G</h2><p>显然最大流</p><h2 id="H"><a class="header-anchor" href="#H">¶</a>H</h2><p>每增加一条边，最多可以与之前的所有直线都产生一个交点蜜汁数据范围，又要大数，不过py不香吗</p><h2 id="I"><a class="header-anchor" href="#I">¶</a>I</h2><p>给定n个数，定义n个数组，第i个数组为删去$a_i$​后形成的，问这n个数组字典序从大到小的排列顺序考虑相邻两个数$a_i, a_{i+1}$</p><ul><li>$a_i &lt; a_{i+1}$​ i比后面所有的都要劣</li><li>$a_i &gt; a_{i+1}$ i比后面所有的都要优</li><li>$a_i = a_{i+1}$​ i比i+1优考虑将相同的一起考虑，然后用两个栈来模拟即可</li></ul><h2 id="J"><a class="header-anchor" href="#J">¶</a>J</h2><p>问一个串中最长的与前缀相同的非前缀串的长度比赛的时候无脑二分+kmpnext[i]表示s[0:i]这个前缀与后缀相同的最长长度（前缀最长border），所以所有next取个max即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>厦门大学“网宿杯“17届程序设计竞赛决赛</title>
      <link href="/2020/05/31/sha-men-da-xue-wang-su-bei-17-jie-cheng-xu-she-ji-jing-sai-jue-sai/"/>
      <url>/2020/05/31/sha-men-da-xue-wang-su-bei-17-jie-cheng-xu-she-ji-jing-sai-jue-sai/</url>
      
        <content type="html"><![CDATA[<p>ABC签到</p><h2 id="F"><a class="header-anchor" href="#F">¶</a>F</h2><p>对小数据写个爆搜后很容易发现规律</p><h2 id="D"><a class="header-anchor" href="#D">¶</a>D</h2><p>利用扩展欧拉定理，$n*{a^n} \equiv n % p*{a^{n % (p-1)}}$令$j = n%(p-1)$, $i = n%p$, $j-i=k$我们枚举a的幂次j（从0到p-2），利用逆元算出i的值满足条件的$n = t(p-1)*p + kp + i$，t为整数，算出[1,x]范围内符合条件的t的个数即可</p><h2 id="E"><a class="header-anchor" href="#E">¶</a>E</h2><p>有向图，每条边权值为kx+b,问x在[0,H]范围内最短路最长是多少，容易发现从1到n的路径合并后还是一个kx+b，对于某一天，就相当于众多直线在该天的值中取min，可以发现这是一个上凸包，求最大值三分即可</p><h2 id="H"><a class="header-anchor" href="#H">¶</a>H</h2><p>对一个数做gcd的下降速度是很快的，每次至少减半，所以用线段树合理剪枝就能过，复杂度不会证。剪枝方法：</p><ul><li>区间最大值=1，说明该段区间所有值都是1，直接return</li><li>区间最大值=最小值=x，return</li></ul><p>只做第一个剪枝，很容易被所有数相等然后每次操作也等于该数的数据卡掉，加上第二个剪枝，就过了，是否正确不知</p><h2 id="I"><a class="header-anchor" href="#I">¶</a>I</h2><p>在森林中每次可以取走<strong>若干</strong>个根，初始是一棵1为根的树，不能操作者输比赛的时候看错题了，我以为每次只能取一个根首先叶子是必胜态，再考虑一个节点的所有儿子，如果都是必败态，那你就是必胜态。如果存在某个儿子是必胜态，你就是必败态，因为你取走该节点后，对手只要把所有是必胜态的节点的根取走，那你面对的所有节点都是必败态的了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p5903 树上k级祖先</title>
      <link href="/2020/05/30/p5903-shu-shang-k-ji-zu-xian/"/>
      <url>/2020/05/30/p5903-shu-shang-k-ji-zu-xian/</url>
      
        <content type="html"><![CDATA[<p>使用倍增每次可以在logn的时间内解决，而使用长链剖分，可以在O(nlogn)预处理后，O(1)回答询问，虽然在实践中相差无几，也不太可能要求O(1),但是长剖的这种做法以及预处理的方法还是很巧妙的</p><ul><li>预处理出倍增数组，长链的长度以及链顶节点，再预处理出每个数字的最高二级制位hb[i]，如果当前节点为链顶节点，预处理出其向上(跳fa)和向下(跳son)len[u]-1个节点</li><li>处理询问时，先利用倍增数组跳到(1&lt;&lt;hb[i])的祖先处，此时k’=k-(1&lt;&lt;hb[i]) &lt; (1&lt;&lt;hb[i])</li><li>当前所在的长链的长度一定是大于k’的，所以考虑跳到链顶，而后根据剩余的k选择向上还是向下跳，此时利用预处理出的up，dwn数组即可实现O(1)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, q, hb[N], fa[N][<span class="number">22</span>], rt;</span><br><span class="line"><span class="type">int</span> len[N], dep[N], top[N], son[N];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N], up[N], dwn[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x ^= x &lt;&lt; <span class="number">13</span>;</span><br><span class="line">  x ^= x &gt;&gt; <span class="number">17</span>;</span><br><span class="line">  x ^= x &lt;&lt; <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> s = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dep[u] = dep[fa[u][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; fa[v][i]; i++) fa[v][i+<span class="number">1</span>] = fa[fa[v][i]][i];</span><br><span class="line">    <span class="built_in">dfs1</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(len[v]&gt;len[son[u]]) son[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  len[u] = len[son[u]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top[u] = t;</span><br><span class="line">  <span class="keyword">if</span>(u==t)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=u; i&lt;len[u]; i++)</span><br><span class="line">      up[u].<span class="built_in">pb</span>(j), j = fa[j][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=u; i&lt;len[u]; i++)</span><br><span class="line">      dwn[u].<span class="built_in">pb</span>(j), j = son[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(son[u]) <span class="built_in">dfs2</span>(son[u], t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">    <span class="keyword">if</span>(v!=son[u])</span><br><span class="line">      <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!k) <span class="keyword">return</span> x;</span><br><span class="line">  x = fa[x][hb[k]], k -= (<span class="number">1</span>&lt;&lt;hb[k]);</span><br><span class="line">  k -= dep[x] - dep[top[x]], x = top[x];</span><br><span class="line">  <span class="keyword">return</span> k&gt;=<span class="number">0</span> ? up[x][k] : dwn[x][-k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;</span><br><span class="line">  hb[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; fa[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!fa[i][<span class="number">0</span>]) rt = i;</span><br><span class="line">    <span class="keyword">else</span> G[fa[i][<span class="number">0</span>]].<span class="built_in">pb</span>(i);</span><br><span class="line">    hb[i] = hb[i&gt;&gt;<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(rt); <span class="built_in">dfs2</span>(rt, rt);</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x = (<span class="built_in">get</span>(s)^ans)%n + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = (<span class="built_in">get</span>(s)^ans)%dep[x];</span><br><span class="line">    res ^= <span class="number">1ll</span>*i*(ans=<span class="built_in">ask</span>(x, k));</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小V和gcd树 带修主席树+树剖trick</title>
      <link href="/2020/05/26/xiao-v-he-gcd-shu-dai-xiu-zhu-xi-shu-shu-pou-trick/"/>
      <url>/2020/05/26/xiao-v-he-gcd-shu-dai-xiu-zhu-xi-shu-shu-pou-trick/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>给定一颗无根树，点有点权$a_i$​，边有边权$\gcd(a_i, a_j)$,要求支持两种操作：</p><ul><li>修改一个点的点权，相应边权也会更改</li><li>询问u-&gt;v路径上边权&lt;=k的数量</li></ul><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>因为修改某个点的点权，同时会修改其所有出边，直观的想法是考虑bfs树，然后转化为区间修改，但是每个儿子的修改是不同的，区间每个数对x取gcd（做不了）下面就需要一种树剖的trick，每次修改的时候，我们只修改父亲和重儿子的信息，而在询问的时候，对于一整条重链，可以保证信息是正确的，而每次跳到链顶，再修改一下该点（轻儿子）与父亲的信息即可，这样就转化为简单的单点修改了。考虑本题，可以将边权下放到深度大的点上，套用上述做法即可，而区间询问&lt;=k的数量就用带修主席树维护。</p><h3 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h3><p>modify:upd: u-&gt;fa[u] son[u]-&gt;uqueryask: u-&gt;top[u] upd: top[u]-&gt;fa[top[u]]u = fa[top[u]]ask: u-&gt;v(是重链)注意本题是把边权下放到了点权，所以u这个点的值应该去掉，所以询问的是dfn[u]+1-&gt;dfn[v]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e4</span> + <span class="number">5</span>, M = <span class="number">1e6</span> + <span class="number">5</span>, up = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, q, a[N], b[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> sz[N], top[N], son[N], dep[N], fa[N], dfn[N], idfn[N], tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dep[u] = dep[f] + <span class="number">1</span>; fa[u] = f;</span><br><span class="line">  sz[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v!=f)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">      sz[u] += sz[v];</span><br><span class="line">      <span class="keyword">if</span>(sz[v]&gt;sz[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top[u] = t;</span><br><span class="line">  dfn[u] = ++tot;</span><br><span class="line">  idfn[tot] = u;</span><br><span class="line">  <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[u], t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">    <span class="keyword">if</span>(v!=son[u]&amp;&amp;v!=fa[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> PSegTree</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ls(x) t[x].l</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rs(x) t[x].r</span></span><br><span class="line">  <span class="type">int</span> rt[N], tot;</span><br><span class="line">  <span class="type">int</span> lrt[N], rrt[N], lc, rc;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, cnt;</span><br><span class="line">  &#125;t[M*<span class="number">32</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = ++tot;</span><br><span class="line">    t[p].cnt += v;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">insert</span>(<span class="built_in">ls</span>(p), l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r, x, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(l&gt;k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) cnt -= t[lrt[i]].cnt;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) cnt += t[rrt[i]].cnt;</span><br><span class="line">      <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) lrt[i] = <span class="built_in">ls</span>(lrt[i]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) rrt[i] = <span class="built_in">ls</span>(rrt[i]);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ask</span>(l, mid, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> lcnt = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) lcnt -= t[<span class="built_in">ls</span>(lrt[i])].cnt;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) lcnt += t[<span class="built_in">ls</span>(rrt[i])].cnt;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) lrt[i] = <span class="built_in">rs</span>(lrt[i]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) rrt[i] = <span class="built_in">rs</span>(rrt[i]);</span><br><span class="line">      <span class="keyword">return</span> lcnt + <span class="built_in">ask</span>(mid+<span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PSegTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) <span class="built_in">insert</span>(rt[i], <span class="number">1</span>, up, val, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  lc = <span class="number">0</span>, rc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) lrt[++lc] = rt[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=r; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) rrt[++rc] = rt[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="number">1</span>, up, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="type">int</span> tmp = top[x];</span><br><span class="line">    <span class="keyword">if</span>(fa[tmp]&amp;&amp;b[tmp]!=__gcd(a[tmp], a[fa[tmp]]))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">upd</span>(dfn[tmp], b[tmp], <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">upd</span>(dfn[tmp], b[tmp]=__gcd(a[tmp], a[fa[tmp]]), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="built_in">query</span>(dfn[top[x]], dfn[x], k);</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="keyword">if</span>(x!=y) ans += <span class="built_in">query</span>(dfn[x]+<span class="number">1</span>, dfn[y], k);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    G[u].<span class="built_in">pb</span>(v); G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">2</span>; u&lt;=n; u++)</span><br><span class="line">    <span class="built_in">upd</span>(dfn[u], b[u]=__gcd(a[u], a[fa[u]]), <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u, x;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;x);</span><br><span class="line">      <span class="keyword">if</span>(fa[u])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">upd</span>(dfn[u], b[u], <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">upd</span>(dfn[u], b[u]=__gcd(x, a[fa[u]]), <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(son[u])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">upd</span>(dfn[son[u]], b[son[u]], <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">upd</span>(dfn[son[u]], b[son[u]]=__gcd(x, a[son[u]]), <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      a[u] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u, v, k;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;k);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queryt</span>(u, v, k));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小球与盒子</title>
      <link href="/2020/05/25/xiao-qiu-yu-he-zi/"/>
      <url>/2020/05/25/xiao-qiu-yu-he-zi/</url>
      
        <content type="html"><![CDATA[<p>n个球放进k个盒子，根据球是否相同、盒子是否相同、盒子是否可以为空，可以总结出8个模型。前置芝士：组合数、斯特林数、快速幂、贝尔数、整数拆分等</p><h2 id="球不同，盒子相同（不同），不能空盒"><a class="header-anchor" href="#球不同，盒子相同（不同），不能空盒">¶</a>球不同，盒子相同（不同），不能空盒</h2><p>盒子相同时为第二类斯特林数，不同时再乘以$k!$即可可以nk递推，可以容斥</p><h2 id="球不同，盒子不同，可以空盒"><a class="header-anchor" href="#球不同，盒子不同，可以空盒">¶</a>球不同，盒子不同，可以空盒</h2><p>每个球有k种方法 $k^n$</p><h2 id="球不同，盒子相同，可以空盒"><a class="header-anchor" href="#球不同，盒子相同，可以空盒">¶</a>球不同，盒子相同，可以空盒</h2><p>枚举空盒的数量，答案为第二类斯特林数一行求和也相当与是贝尔数</p><h2 id="球相同，盒子不同，不能空盒"><a class="header-anchor" href="#球相同，盒子不同，不能空盒">¶</a>球相同，盒子不同，不能空盒</h2><p>$x_1+x_2+\dots+x_n = k$的正整数解个数C(n-1, k-1)</p><h2 id="球相同，盒子不同，可以空盒"><a class="header-anchor" href="#球相同，盒子不同，可以空盒">¶</a>球相同，盒子不同，可以空盒</h2><p>$x_1+x_2+\dots+x_n = k$的非负整数解个数C(n+k-1, k-1)</p><h2 id="球相同，盒子相同，不能空盒"><a class="header-anchor" href="#球相同，盒子相同，不能空盒">¶</a>球相同，盒子相同，不能空盒</h2><p>整数n拆分成k份=用最大数为k拆分nD(n-k, k) 将n-k用$\le k$的数拆分</p><h2 id="球相同，盒子相同，可以空盒"><a class="header-anchor" href="#球相同，盒子相同，可以空盒">¶</a>球相同，盒子相同，可以空盒</h2><p>D(n, k) = D(n, k-1) + D(n-k, k)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树维护前缀最值问题</title>
      <link href="/2020/05/23/xian-duan-shu-wei-hu-qian-zhui-zui-zhi-wen-ti/"/>
      <url>/2020/05/23/xian-duan-shu-wei-hu-qian-zhui-zui-zhi-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="楼房重建"><a class="header-anchor" href="#楼房重建">¶</a>楼房重建</h2><p>有n栋房屋,问从1号楼往后看,最多能看到几栋楼,要求支持单点修改例:(1, 3, 2, 5, 4) 答案为3:(1, 3, 5)答案就是从1开始的严格前缀最大值的长度,考虑线段树维护,但是在pushup的时候,如果简单的将左右子树的答案相加,是不对的,因为左边的楼房高度会影响到右边.不妨考虑递归的进行pushup(也是某种启发,因为pushup一般都是O(1)合并的,但$O(\log n)$合并未尝不可?)线段树每个节点维护mx,len分别表示区间最大值(用于剪枝),<strong>只考虑</strong>该区间时的答案添加函数merge(v, p) 表示线段树上编号p节点管辖的区间在左边最大值为v的影响下产生的答案以下考虑几种情况:</p><ul><li>t[p]的最大值是小于v 此时没有贡献, <code>return 0</code>即可</li><li>p是叶子节点<code>return t[p].mx&gt;v</code>返回该节点代表的值与v的大小关系即可</li><li>考虑左右儿子为ls, rs 若<code>t[ls].mx&lt;=v</code>此时左区间无贡献,递归右区间即可,<code>return merge(v,rs)</code>.否则递归左区间,那么右区间的贡献是<code>t[p].len−t[ls].len</code>(注意不是t[rs].len)在pushup的时候,维护好mx,并让<code>t[p].len = t[ls].len + merge(t[ls].mx, rs)</code>即可</li></ul><h2 id="最简单的一道题"><a class="header-anchor" href="#最简单的一道题">¶</a>最简单的一道题</h2><p>西邮新生赛的一题,没人过我看到的时候就发现是跟楼房重建一样的trick,然而<s>调bug调了半天,wa了无数发</s>给定n个数,询问从第x个数往后的非严格前缀最小值的长度,要求支持区间加做法跟上题类似,注意在merge里面也要加上pushdown,在每次要访问一个点的左右儿子的时候,就应该下放该点的lazytag上一题的询问都是从1开始的,所以答案就是t[1].len,但本题是从x开始的,我的做法是把[x,n]在线段树上的区间提取出来,然后从左往右合并,区间数是log段,合并也是log的,复杂度是$n(\log^2 n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n, m, pos[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">namespace</span> SegTree</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, len;</span><br><span class="line">    ll mn, tag;</span><br><span class="line">  &#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setval</span><span class="params">(<span class="type">int</span> p, ll v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t[p].mn += v;</span><br><span class="line">    t[p].tag += v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">setval</span>(ls, t[p].tag); <span class="built_in">setval</span>(rs, t[p].tag);</span><br><span class="line">    t[p].tag = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> p)</span> <span class="comment">//重点</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">    <span class="keyword">if</span>(t[p].mn&gt;v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> t[p].mn&lt;=v;</span><br><span class="line">    <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(t[ls].mn&gt;v) <span class="keyword">return</span> <span class="built_in">merge</span>(v, rs);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">merge</span>(v, ls) + t[p].len - t[ls].len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t[p].mn = <span class="built_in">min</span>(t[ls].mn, t[rs].mn);</span><br><span class="line">    t[p].len = t[ls].len + <span class="built_in">merge</span>(t[ls].mn, rs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">      t[p].mn = a[l];</span><br><span class="line">      t[p].len = <span class="number">1</span>;</span><br><span class="line">      pos[l] = p;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid); <span class="built_in">build</span>(rs, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">setval</span>(p, v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(ls, x, y, v);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">upd</span>(rs, x, y, v);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">    &#123;</span><br><span class="line">      vec.<span class="built_in">pb</span>(p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">ask</span>(ls, x, y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">ask</span>(rs, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> SegTree;</span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> l, r, k;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      vec.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="built_in">ask</span>(<span class="number">1</span>, x, n);</span><br><span class="line">      <span class="type">int</span> ans = t[vec[<span class="number">0</span>]].len;</span><br><span class="line">      ll mn = t[vec[<span class="number">0</span>]].mn;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">sz</span>(vec); i++)</span><br><span class="line">      &#123;</span><br><span class="line">        ans += <span class="built_in">merge</span>(mn, vec[i]);</span><br><span class="line">        mn = <span class="built_in">min</span>(mn, t[vec[i]].mn);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy自小粉兔:</p><blockquote><p>但是，我们注意到一个很关键的性质：当v小于左子树的最大值时，右子树对当前节点的贡献，是通过减法计算的也就是说这个信息要满足一定程度上的可减性但是有很多信息是不满足可减性的，比如max,min、按位与、按位或等为了能让这种线段树适应更一般的情况，我们修改维护的信息的意义：仍然维护这个区间中的最大值。</p><p>此时并不是维护区间的答案，而是仅考虑该区间的影响后，却又只统计右子树的答案仅考虑该区间的影响后，却又只统计右子树的答案仅考虑该区间的影响后，却又只统计右子树的答案。也就是说令当前节点对应的区间为[l,r]，区间中点为 mid，则：维护的答案是，只考虑[l,r]时，在区间[mid+1,r]中的答案。</p></blockquote><p>线段树每个节点仍然维护mx[i], len[i],但对于叶节点len[i]无意义,再考虑merge(v, p)函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].mx = <span class="built_in">max</span>(t[ls].mx, t[rs].mx);</span><br><span class="line">  t[p].len = <span class="built_in">merge</span>(t[ls].mx, rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(t[p].mx&lt;=v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span> t[p].mn&gt;v;</span><br><span class="line">  <span class="keyword">if</span>(t[ls].mx&lt;=v) <span class="keyword">return</span> <span class="built_in">merge</span>(v, rs);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">merge</span>(v, ls) + t[p].len; <span class="comment">//避免了区间维护信息不可减的问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boruvka生成树算法</title>
      <link href="/2020/05/22/boruvka-sheng-cheng-shu-suan-fa/"/>
      <url>/2020/05/22/boruvka-sheng-cheng-shu-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>核心:每次从所有当前的连通块向其他连通块扩展出最小边,直至剩下一个连通块每进行一次操作,连通块数量减半 $O(m\log n)$ 取决于计算最小边的代价</p><h1>codechef spanning tree</h1><p>交互题,每次可以给出两个点集A,B进行询问,会返回两个集合间的最小边,要求询问的$\sum |A|&lt;=1e4, \sum |A|+|B|&lt;=2e6,n&lt;=1e3$,最后输出该图的最小生成树的权值和按照上述算法询问即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, fa[N], idx[N], mncost;</span><br><span class="line">pii mn[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; scc[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">  <span class="keyword">if</span>(u!=v)</span><br><span class="line">  &#123;</span><br><span class="line">    fa[u] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">ask</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">sz</span>(a) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n-<span class="built_in">sz</span>(a) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x : a)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(!vis[i]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="type">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mp</span>(v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fa[i] = i;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(fa[i]==i) idx[i] = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      scc[idx[<span class="built_in">find</span>(i)]].<span class="built_in">pb</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++) mn[i] = &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> cur = <span class="built_in">ask</span>(scc[i]);</span><br><span class="line">      <span class="keyword">if</span>(mn[i].fi==<span class="number">-1</span>) mn[i] = &#123;cur.se, cur.fi&#125;;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(cur.se&lt;mn[i].fi) mn[i] = &#123;cur.se, cur.fi&#125;;</span><br><span class="line">      scc[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(fa[i]==i &amp;&amp; <span class="built_in">merge</span>(i, mn[idx[i]].se))</span><br><span class="line">        mncost += mn[idx[i]].fi;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mncost &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>cf888G xormst</h1><p>一张完全图,点数2e5,每个点有点权$a_i$​,边$(i,j)$的权值为$a_i xor a_j$​,求该图的mst思考如何求出当前集合与其他集合的最小边权:建出01trie,每次把该集合的点权删除,然后逐个询问与该点权xor后的最小值取小,最后再插入还原即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize (<span class="string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target(<span class="string">&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="type">int</span> fa[N], idx[N], cnt, mnto[N], mnval[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; scc[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">  <span class="keyword">if</span>(u!=v)</span><br><span class="line">  &#123;</span><br><span class="line">    fa[u] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot, nxt[N*<span class="number">29</span>][<span class="number">2</span>], sz[N*<span class="number">29</span>][<span class="number">2</span>], id[N*<span class="number">29</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v, <span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">29</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> k = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!nxt[now][k]) nxt[now][k] = ++tot;</span><br><span class="line">    sz[now][k] += v;</span><br><span class="line">    now = nxt[now][k];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(v==<span class="number">1</span>) id[now] = idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">29</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> k = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sz[now][k]) now = nxt[now][k];</span><br><span class="line">    <span class="keyword">else</span> now = nxt[now][k^<span class="number">1</span>], ans |= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;ans, id[now]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> startTime = (<span class="type">double</span>)<span class="built_in">clock</span>();</span><br><span class="line">  <span class="comment">//mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="comment">//n = 2e5;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    fa[i] = i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    <span class="comment">//a[i] = abs(rnd()%(1&lt;&lt;30));</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">  n = <span class="built_in">unique</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>) - a - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">upd</span>(a[i], <span class="number">1</span>, i);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(fa[i]==i)</span><br><span class="line">      &#123;</span><br><span class="line">        idx[i] = ++cnt;</span><br><span class="line">        mnto[cnt] = mnval[cnt] = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//debug(cnt);</span></span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      scc[idx[<span class="built_in">find</span>(i)]].<span class="built_in">pb</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : scc[i]) <span class="built_in">upd</span>(a[x], <span class="number">-1</span>, x);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : scc[i])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = <span class="built_in">ask</span>(a[x]);</span><br><span class="line">        <span class="keyword">if</span>(mnto[i]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          mnval[i] = cur.fi;</span><br><span class="line">          mnto[i] = cur.se;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur.fi&lt;mnval[i])</span><br><span class="line">        &#123;</span><br><span class="line">          mnval[i] = cur.fi;</span><br><span class="line">          mnto[i] = cur.se;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : scc[i]) <span class="built_in">upd</span>(a[x], <span class="number">1</span>, x);</span><br><span class="line">      scc[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(fa[i]==i &amp;&amp; <span class="built_in">merge</span>(i, mnto[idx[i]]))</span><br><span class="line">        ans += mnval[idx[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  cerr &lt;&lt; ((<span class="type">double</span>)<span class="built_in">clock</span>() - startTime) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环鸽的数列</title>
      <link href="/2020/05/19/huan-ge-de-shu-lie/"/>
      <url>/2020/05/19/huan-ge-de-shu-lie/</url>
      
        <content type="html"><![CDATA[<p>区间加广义斐波那契数列大概有三种做法1.用特征方程求出通项,跑出根号的二次剩余后代入,变成区间加等比数列,线段树维护即可2.矩阵3.利用性质</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">9</span>, a = <span class="number">276601605</span>, b = <span class="number">691504013</span>, c = <span class="number">308495997</span>;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> n, m, x[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a = <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) a-=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) <span class="keyword">return</span> a-mod; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a-=b; <span class="keyword">if</span>(a&lt;<span class="number">0</span>) a+=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a-=b; <span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> a+mod; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">powmod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="built_in">Mul</span>(ans, a);</span><br><span class="line">    a = <span class="built_in">Mul</span>(a, a);</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line">  <span class="type">int</span> inv, pw[N];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, sum, tag;</span><br><span class="line">  &#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) pw[i] = <span class="built_in">Mul</span>(pw[i<span class="number">-1</span>], q)%mod;</span><br><span class="line">    inv = <span class="built_in">powmod</span>(q<span class="number">-1</span>, mod<span class="number">-2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setval</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(t[p].sum, <span class="built_in">Mul</span>(<span class="built_in">Mul</span>(v, <span class="built_in">Sub</span>(pw[t[p].r-t[p].l+<span class="number">1</span>], <span class="number">1</span>)), inv));</span><br><span class="line">    <span class="built_in">add</span>(t[p].tag, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t[p].sum = <span class="built_in">Add</span>(t[ls].sum, t[rs].sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">setval</span>(ls, t[p].tag); <span class="built_in">setval</span>(rs, <span class="built_in">Mul</span>(t[p].tag, pw[t[rs].l-t[ls].l]));</span><br><span class="line">    t[p].tag = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid); <span class="built_in">build</span>(rs, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">setval</span>(p, pw[l-x+<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(ls, x, y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">upd</span>(rs, x, y);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">    <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(ls, x, y));</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(rs, x, y));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;T1, T2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, x+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) sum[i] = <span class="built_in">Add</span>(sum[i<span class="number">-1</span>], x[i]);</span><br><span class="line">  T1.<span class="built_in">init</span>(b); T2.<span class="built_in">init</span>(c);</span><br><span class="line">  T1.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n); T2.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      T1.<span class="built_in">upd</span>(<span class="number">1</span>, l, r);</span><br><span class="line">      T2.<span class="built_in">upd</span>(<span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> ans = <span class="built_in">Mul</span>(<span class="built_in">Sub</span>(T1.<span class="built_in">ask</span>(<span class="number">1</span>, l, r), T2.<span class="built_in">ask</span>(<span class="number">1</span>, l, r)), a);</span><br><span class="line">      <span class="built_in">add</span>(ans, <span class="built_in">Sub</span>(sum[r], sum[l<span class="number">-1</span>]));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>525 美团杯2020 平行四边形</title>
      <link href="/2020/05/18/525-mei-tuan-bei-2020-ping-xing-si-bian-xing/"/>
      <url>/2020/05/18/525-mei-tuan-bei-2020-ping-xing-si-bian-xing/</url>
      
        <content type="html"><![CDATA[<p>给定n*n的棋盘,要求放置n个棋子,满足:</p><ul><li>x和y都是一个1-n的排列</li><li>任意四个棋子不构成平行四边形其中n+1是一个质数</li></ul><p>考虑n+1的原根g,则$g,g^2,g^3…g^n%(n+1)$各不相同$(1,g)…(n,g^n$%$(n+1))$即为答案无证明o.O</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">powmod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%m;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%m;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;=x; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ans -= ans / i;</span><br><span class="line">      <span class="keyword">while</span>(x%i==<span class="number">0</span>) x /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;<span class="number">1</span>) ans -= ans / x;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="type">int</span> c = <span class="built_in">phi</span>(n+<span class="number">1</span>), g = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(++g)</span><br><span class="line">  &#123;</span><br><span class="line">    ok = (<span class="built_in">powmod</span>(g, c, n+<span class="number">1</span>)==<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> tmpc = c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;=tmpc&amp;&amp;ok; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(tmpc%i==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span>(tmpc%i==<span class="number">0</span>) tmpc /= i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">powmod</span>(g, c/i, n+<span class="number">1</span>)==<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmpc&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">powmod</span>(g, c/tmpc, n+<span class="number">1</span>)==<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ok) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = g;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, ans);</span><br><span class="line">    ans = ans*g%(n+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客挑战赛40</title>
      <link href="/2020/05/16/niu-ke-tiao-zhan-sai-40/"/>
      <url>/2020/05/16/niu-ke-tiao-zhan-sai-40/</url>
      
        <content type="html"><![CDATA[<h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><p>给定1e6个随机生成的数,多次询问,给定y,问是否存在一个数x满足x^y在二进制下1的个数&lt;=3</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>因为最多只有3个二进制位不同,考虑将二进制每16位分成4组,满足条件的x与y一定在某一组中的16位完全相同,所以查找该组中的数,又由于数字随机,每次查找的次数期望为$4*(2^{20} / 2^{16})$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5236 【模板】静态仙人掌</title>
      <link href="/2020/05/15/p5236-mo-ban-jing-tai-xian-ren-zhang/"/>
      <url>/2020/05/15/p5236-mo-ban-jing-tai-xian-ren-zhang/</url>
      
        <content type="html"><![CDATA[<p>每条边最多在一个简单环上的图每个环都是一个点双(方点),可以很方便的用圆方树来维护</p><p>求仙人掌图上两点间的最短路注意仙人掌上的圆方树的建法:每个简单环新建一个方点,环上每个点与方点连边,权值为到起点的最短距离,如果u是割点,向v连边权值为原图的边权(两个圆点连边)</p><h1>做法</h1><p>先建出圆方树考虑u和v在树上的LCA:</p><ul><li>p为圆点,则答案就是树上两点的距离</li><li>p为方点,找出p的两个儿子a(u的祖先),b(v的祖先),a和b处在一个环上,答案是dis(a,b)+dis(a,u)+dis(b,v),注意dis(a,b)要取min</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], clk, cnt, s[N], sum[N];</span><br><span class="line">vector&lt;pii&gt; G[N], T[N];</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> LOG = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">20</span>], dep[N], dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=LOG; i++)</span><br><span class="line">    fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : T[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    dis[v] = dis[u] + w;</span><br><span class="line">    dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">    fa[v][<span class="number">0</span>] = u;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(dep[fa[y][i]]&gt;=dep[x]) y = fa[y][i];</span><br><span class="line">  <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">  <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findcir</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ++cnt;</span><br><span class="line">  <span class="type">int</span> x = v, pre = w, pw = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x!=fa[u][<span class="number">0</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    sum[x] = pre;</span><br><span class="line">    pre += s[x];</span><br><span class="line">    x = fa[x][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  sum[cnt] = sum[u];</span><br><span class="line">  sum[u] = <span class="number">0</span>;</span><br><span class="line">  x = v;</span><br><span class="line">  <span class="keyword">while</span>(x!=fa[u][<span class="number">0</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    pw = <span class="built_in">min</span>(sum[x], sum[cnt]-sum[x]);</span><br><span class="line">    T[cnt].<span class="built_in">pb</span>(&#123;x, pw&#125;);</span><br><span class="line">    T[x].<span class="built_in">pb</span>(&#123;cnt, pw&#125;);</span><br><span class="line">    x = fa[x][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dfn[u] = low[u] = ++clk;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">    &#123;</span><br><span class="line">      fa[v][<span class="number">0</span>] = u;</span><br><span class="line">      s[v] = w;</span><br><span class="line">      <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    <span class="keyword">if</span>(low[v]&gt;dfn[u])</span><br><span class="line">    &#123;</span><br><span class="line">      T[u].<span class="built_in">pb</span>(&#123;v, w&#125;);</span><br><span class="line">      T[v].<span class="built_in">pb</span>(&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(fa[v][<span class="number">0</span>]==u||dfn[v]&lt;=dfn[u]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">findcir</span>(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> t = x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(dep[fa[fa[t][i]][<span class="number">0</span>]]&gt;=dep[y]) t = fa[t][i];</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">  cnt = n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    G[u].<span class="built_in">pb</span>(&#123;v, w&#125;); G[v].<span class="built_in">pb</span>(&#123;u, w&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="type">int</span> z = <span class="built_in">LCA</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span>(z&lt;=n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[u]+dis[v]<span class="number">-2</span>*dis[z]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x = <span class="built_in">find</span>(u, z), y = <span class="built_in">find</span>(v, z);</span><br><span class="line">      <span class="keyword">if</span>(sum[x]&gt;sum[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">      <span class="type">int</span> ans = dis[u]-dis[x]+dis[v]-dis[y]+<span class="built_in">min</span>(sum[y]-sum[x], sum[x]+sum[z]-sum[y]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5495 Dirichlet 前缀和</title>
      <link href="/2020/05/15/p5495-dirichlet-qian-zhui-he/"/>
      <url>/2020/05/15/p5495-dirichlet-qian-zhui-he/</url>
      
        <content type="html"><![CDATA[<p>$b_k = \sum_{i \mid k} a_i$求数组b考虑下标i和j,对其质因数分解,当且仅当i的所有质因数的幂次&lt;=j的,i才是j的因数,可以有贡献发现这个实际上就是一个关于质因子分解后的指数的高维前缀和，使用类似FMT的方法就可以了复杂度$O(n\log \log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=prime[<span class="number">0</span>]; i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; <span class="number">1ll</span>*j*prime[i]&lt;=n; j++)</span><br><span class="line">    b[j*prime[i]] += b[j];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圆方树</title>
      <link href="/2020/05/15/yuan-fang-shu/"/>
      <url>/2020/05/15/yuan-fang-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h2><p>点双联通分量:不存在割点/任意两点间有至少两条点不重复路径特殊:两个点一条边每条边属于一个点双,每个割点可以属于多个点双圆方树中原图的每个点对应一个圆点,一个点双对应一个方点对于每一个点双连通分量，它对应的方点向这个点双连通分量中的每个圆点连边每个点双形成一个“菊花图”，多个“菊花图”通过原图中的割点连接在一起(因为点双的分隔点是割点)</p><h2 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h2><p>圆点只和方点相连,方点只和圆点相连度数大于1的圆点是原图的割点圆方树是无根树,无论取哪个点为根开始dfs见树,形态都一样</p><h2 id="建树"><a class="header-anchor" href="#建树">¶</a>建树</h2><p>注意两倍空间建完树栈中可能还有点,注意多组数据清空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[N], T[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  low[u] = dfn[u] = ++clk;</span><br><span class="line">  stk[++top] = u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">      <span class="keyword">if</span>(low[v]&gt;=dfn[u])</span><br><span class="line">      &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x!=v; top--)</span><br><span class="line">        &#123;</span><br><span class="line">          x = stk[top];</span><br><span class="line">          T[cnt].<span class="built_in">pb</span>(x);</span><br><span class="line">          T[x].<span class="built_in">pb</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        T[cnt].<span class="built_in">pb</span>(u);</span><br><span class="line">        T[u].<span class="built_in">pb</span>(cnt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4169 [Violet]天使玩偶/SJY摆棋子 kdtree</title>
      <link href="/2020/05/14/p4169-violettian-shi-wan-ou-sjy-bai-qi-zi-kdtree/"/>
      <url>/2020/05/14/p4169-violettian-shi-wan-ou-sjy-bai-qi-zi-kdtree/</url>
      
        <content type="html"><![CDATA[<p>要求维护二维平面,支持插点,询问点集中两点的最小曼哈顿距离</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>kdtree维护不断循环按照其中一维构建二叉树每个点维护子树中的最大最小坐标(最大矩形),然后大力剪枝本题有插入操作,所以可能会退化为链,需要定期重构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,MAXSIZE,stdin),p1==p2) ? EOF : *p1++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">gc</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) t = t*<span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">  t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m, rt, ans;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> alpha = <span class="number">0.75</span>;</span><br><span class="line"><span class="type">int</span> D, pool[N], top, tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x[k];</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> point &amp;oth) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x[D] &lt; oth.x[D];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;a[N], cur;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mx[k], mn[k];</span><br><span class="line">  <span class="type">int</span> l, r, sz;</span><br><span class="line">  point tp;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(top) <span class="keyword">return</span> pool[top--];</span><br><span class="line">  <span class="keyword">return</span> ++tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mn[i] = t[p].mx[i] = t[p].tp.x[i];</span><br><span class="line">    <span class="keyword">if</span>(l) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[l].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[l].mx[i]);</span><br><span class="line">    <span class="keyword">if</span>(r) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[r].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[r].mx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  t[p].sz = t[l].sz + t[r].sz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">newnode</span>(), mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  D = d;</span><br><span class="line">  <span class="built_in">nth_element</span>(a+l, a+mid, a+r+<span class="number">1</span>);</span><br><span class="line">  t[p].tp = a[mid];</span><br><span class="line">  t[p].l = <span class="built_in">build</span>(l, mid<span class="number">-1</span>, (d+<span class="number">1</span>)%k);</span><br><span class="line">  t[p].r = <span class="built_in">build</span>(mid+<span class="number">1</span>, r, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t[p].l) <span class="built_in">rebuild</span>(t[p].l, num);</span><br><span class="line">  a[num+t[t[p].l].sz+<span class="number">1</span>] = t[p].tp, pool[++top] = p;</span><br><span class="line">  <span class="keyword">if</span>(t[p].r) <span class="built_in">rebuild</span>(t[p].r, num+t[t[p].l].sz+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(alpha*t[p].sz&lt;t[t[p].l].sz||alpha*t[p].sz&lt;t[t[p].r].sz)</span><br><span class="line">    <span class="built_in">rebuild</span>(p, <span class="number">0</span>), p = <span class="built_in">build</span>(<span class="number">1</span>, t[p].sz, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p)</span><br><span class="line">  &#123;</span><br><span class="line">    p = <span class="built_in">newnode</span>();</span><br><span class="line">    t[p].tp = cur;</span><br><span class="line">    t[p].l = t[p].r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cur.x[d]&gt;t[p].tp.x[d]) <span class="built_in">insert</span>(t[p].r, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">insert</span>(t[p].l, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="built_in">pushup</span>(p); <span class="built_in">test</span>(p, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.x[i]&lt;t[p].mn[i]) ans += (t[p].mn[i]-cur.x[i]);</span><br><span class="line">    <span class="keyword">if</span>(cur.x[i]&gt;t[p].mx[i]) ans += (cur.x[i]-t[p].mx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(point a, point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    ans += <span class="built_in">abs</span>(a.x[i]-b.x[i]);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ans = <span class="built_in">min</span>(ans, <span class="built_in">dis</span>(t[p].tp, cur));</span><br><span class="line">  <span class="type">int</span> dl = INF, dr = INF;</span><br><span class="line">  <span class="keyword">if</span>(t[p].l) dl = <span class="built_in">getdis</span>(t[p].l);</span><br><span class="line">  <span class="keyword">if</span>(t[p].r) dr = <span class="built_in">getdis</span>(t[p].r);</span><br><span class="line">  <span class="keyword">if</span>(dl&lt;dr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dl&lt;ans) <span class="built_in">ask</span>(t[p].l);</span><br><span class="line">    <span class="keyword">if</span>(dr&lt;ans) <span class="built_in">ask</span>(t[p].r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dr&lt;ans) <span class="built_in">ask</span>(t[p].r);</span><br><span class="line">    <span class="keyword">if</span>(dl&lt;ans) <span class="built_in">ask</span>(t[p].l);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n); <span class="built_in">read</span>(m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">read</span>(a[i].x[<span class="number">0</span>]), <span class="built_in">read</span>(a[i].x[<span class="number">1</span>]);</span><br><span class="line">  rt = <span class="built_in">build</span>(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="built_in">read</span>(op); <span class="built_in">read</span>(cur.x[<span class="number">0</span>]); <span class="built_in">read</span>(cur.x[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">insert</span>(rt, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ans = INF;</span><br><span class="line">      <span class="built_in">ask</span>(rt);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4211 LCA 离线+树剖</title>
      <link href="/2020/05/14/p4211-lca-chi-xian-shu-pou/"/>
      <url>/2020/05/14/p4211-lca-chi-xian-shu-pou/</url>
      
        <content type="html"><![CDATA[<p>给定一棵1为根的树, 多次查询$\sum_{i=l}^{r} dep[LCA(i,z)]$</p><h1>做法</h1><p>只需把l-r的每个点到根的路径+1,然后查询z到根的路径的和即可考虑离线差分询问并按右端点排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">201314</span>;</span><br><span class="line"><span class="type">int</span> n, m, ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qry</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r, coef, z, id;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> qry &amp;oth) &#123;</span><br><span class="line">    <span class="keyword">return</span> r &lt; oth.r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u += v;</span><br><span class="line">  <span class="keyword">if</span>(u&gt;=mod) u -= mod;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> sz[N], top[N], son[N], dep[N], fa[N], dfn[N], idfn[N], tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, sum, tag;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setval</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">add</span>(t[p].sum, v*(t[p].r-t[p].l+<span class="number">1</span>));</span><br><span class="line">  <span class="built_in">add</span>(t[p].tag, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].sum = t[p&lt;&lt;<span class="number">1</span>].sum;</span><br><span class="line">  <span class="built_in">add</span>(t[p].sum, t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setval</span>(p&lt;&lt;<span class="number">1</span>, t[p].tag); <span class="built_in">setval</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, t[p].tag);</span><br><span class="line">  t[p].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].l = l, t[p].r = r;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setval</span>(p, v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>, x, y, v);</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y, v);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dep[u] = dep[f] + <span class="number">1</span>; fa[u] = f;</span><br><span class="line">  sz[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">    sz[u] += sz[v];</span><br><span class="line">    <span class="keyword">if</span>(sz[v]&gt;sz[son[u]]) son[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top[u] = t;</span><br><span class="line">  dfn[u] = ++tot;</span><br><span class="line">  idfn[tot] = u;</span><br><span class="line">  <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[u], t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">    <span class="keyword">if</span>(v!=son[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>, dfn[top[x]], dfn[x], v);</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="built_in">upd</span>(<span class="number">1</span>, dfn[x], dfn[y], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">askt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]));</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(<span class="number">1</span>, dfn[x], dfn[y]));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">    G[u+<span class="number">1</span>].<span class="built_in">pb</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, z; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;z);</span><br><span class="line">    q[++tot] = &#123;l, <span class="number">-1</span>, z+<span class="number">1</span>, i&#125;;</span><br><span class="line">    q[++tot] = &#123;r+<span class="number">1</span>, <span class="number">1</span>, z+<span class="number">1</span>, i&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(q+<span class="number">1</span>, q+tot+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">upd</span>(<span class="number">1</span>, dfn[<span class="number">1</span>], dfn[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> pre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(pre&lt;=q[i].r)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">updt</span>(<span class="number">1</span>, pre, <span class="number">1</span>);</span><br><span class="line">      ++pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(ans[q[i].id], q[i].coef*<span class="built_in">askt</span>(<span class="number">1</span>, q[i].z));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (ans[i]+mod)%mod);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6514 [QkOI#R1] Quark and Strings</title>
      <link href="/2020/05/14/p6514-qkoir1-quark-and-strings/"/>
      <url>/2020/05/14/p6514-qkoir1-quark-and-strings/</url>
      
        <content type="html"><![CDATA[<p>要求维护n个字符串,每次在区间[l,r]加一个字符,或询问区间[l,r]的字符串的最长公共子序列的长度</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>本质就是每次插入一条[l,r]的线段,或询问左端点&lt;=l&amp;&amp;右端点&gt;=r的线段的个数,转化后就是一个二维数点的模型,cdq分治,树套树,kdt都可以解决</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> alpha = <span class="number">0.75</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,MAXSIZE,stdin),p1==p2) ? EOF : *p1++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">gc</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) t = t*<span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">  t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> D, pool[N], top, tot, rt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x[k];</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> point &amp;oth) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x[D] &lt; oth.x[D];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;a[N], cur;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mx[k], mn[k];</span><br><span class="line">  <span class="type">int</span> l, r, sz;</span><br><span class="line">  point tp;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(top) <span class="keyword">return</span> pool[top--];</span><br><span class="line">  <span class="keyword">return</span> ++tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mn[i] = t[p].mx[i] = t[p].tp.x[i];</span><br><span class="line">    <span class="keyword">if</span>(l) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[l].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[l].mx[i]);</span><br><span class="line">    <span class="keyword">if</span>(r) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[r].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[r].mx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  t[p].sz = t[l].sz + t[r].sz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">newnode</span>(), mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  D = d;</span><br><span class="line">  <span class="built_in">nth_element</span>(a+l, a+mid, a+r+<span class="number">1</span>);</span><br><span class="line">  t[p].tp = a[mid];</span><br><span class="line">  t[p].l = <span class="built_in">build</span>(l, mid<span class="number">-1</span>, d^<span class="number">1</span>);</span><br><span class="line">  t[p].r = <span class="built_in">build</span>(mid+<span class="number">1</span>, r, d^<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t[p].l) <span class="built_in">rebuild</span>(t[p].l, num);</span><br><span class="line">  a[num+t[t[p].l].sz+<span class="number">1</span>] = t[p].tp, pool[++top] = p;</span><br><span class="line">  <span class="keyword">if</span>(t[p].r) <span class="built_in">rebuild</span>(t[p].r, num+t[t[p].l].sz+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(alpha*t[p].sz&lt;t[t[p].l].sz||alpha*t[p].sz&lt;t[t[p].r].sz)</span><br><span class="line">  <span class="built_in">rebuild</span>(p, <span class="number">0</span>), p = <span class="built_in">build</span>(<span class="number">1</span>, t[p].sz, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p)</span><br><span class="line">  &#123;</span><br><span class="line">    p = <span class="built_in">newnode</span>();</span><br><span class="line">    t[p].tp = cur;</span><br><span class="line">    t[p].l = t[p].r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cur.x[d]&gt;t[p].tp.x[d]) <span class="built_in">insert</span>(t[p].r, d^<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">insert</span>(t[p].l, d^<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">pushup</span>(p); <span class="built_in">test</span>(p, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].mx[<span class="number">0</span>]&lt;=cur.x[<span class="number">0</span>]&amp;&amp;t[p].mn[<span class="number">1</span>]&gt;=cur.x[<span class="number">1</span>]) <span class="keyword">return</span> t[p].sz;</span><br><span class="line">  <span class="keyword">if</span>(t[p].mn[<span class="number">0</span>]&gt;cur.x[<span class="number">0</span>]||t[p].mx[<span class="number">1</span>]&lt;cur.x[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tp.x[<span class="number">0</span>]&lt;=cur.x[<span class="number">0</span>]&amp;&amp;t[p].tp.x[<span class="number">1</span>]&gt;=cur.x[<span class="number">1</span>]) ++ans;</span><br><span class="line">  ans += <span class="built_in">ask</span>(t[p].l) + <span class="built_in">ask</span>(t[p].r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n, q;</span><br><span class="line">  <span class="built_in">read</span>(n); <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="built_in">read</span>(op); <span class="built_in">read</span>(cur.x[<span class="number">0</span>]); <span class="built_in">read</span>(cur.x[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">insert</span>(rt, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(rt));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4148 简单题 kdtree</title>
      <link href="/2020/05/14/p4148-jian-dan-ti-kdtree/"/>
      <url>/2020/05/14/p4148-jian-dan-ti-kdtree/</url>
      
        <content type="html"><![CDATA[<p>维护矩形,支持加点,询问矩形和,强制在线</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>不强制在线可以cdq,强制在线就只能kdtree了每个节点维护最大矩形,以及子树内所有点权值的和对于询问,如果当前节点的最大矩形在询问矩形内部,直接返回sum,如果不相交,返回0,否则继续递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,MAXSIZE,stdin),p1==p2) ? EOF : *p1++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">gc</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) t = t*<span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">  t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> alph = <span class="number">0.75</span>;</span><br><span class="line"><span class="type">int</span> rt, pool[N], top, tot, D;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x[k], w;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (point &amp;oth) &#123;</span><br><span class="line">    <span class="keyword">return</span> x[D] &lt; oth.x[D];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;a[N], cur;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, mx[k], mn[k], sum, sz;</span><br><span class="line">  point tp;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(top) <span class="keyword">return</span> pool[top--];</span><br><span class="line">  <span class="keyword">return</span> ++tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mn[i] = t[p].mx[i] = t[p].tp.x[i];</span><br><span class="line">    <span class="keyword">if</span>(l) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[l].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[l].mx[i]);</span><br><span class="line">    <span class="keyword">if</span>(r) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[r].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[r].mx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  t[p].sz = t[l].sz + t[r].sz + <span class="number">1</span>;</span><br><span class="line">  t[p].sum = t[l].sum + t[r].sum + t[p].tp.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">newnode</span>(), mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  D = d;</span><br><span class="line">  <span class="built_in">nth_element</span>(a+l, a+mid, a+r+<span class="number">1</span>);</span><br><span class="line">  t[p].tp = a[mid];</span><br><span class="line">  t[p].l = <span class="built_in">build</span>(l, mid<span class="number">-1</span>, (d+<span class="number">1</span>)%k);</span><br><span class="line">  t[p].r = <span class="built_in">build</span>(mid+<span class="number">1</span>, r, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t[p].l) <span class="built_in">rebuild</span>(t[p].l, num);</span><br><span class="line">  a[num+t[t[p].l].sz+<span class="number">1</span>] = t[p].tp, pool[++top] = p;</span><br><span class="line">  <span class="keyword">if</span>(t[p].r) <span class="built_in">rebuild</span>(t[p].r, num+t[t[p].l].sz+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(alph*t[p].sz&lt;t[t[p].l].sz||alph*t[p].sz&lt;t[t[p].r].sz)</span><br><span class="line">    <span class="built_in">rebuild</span>(p, <span class="number">0</span>), p = <span class="built_in">build</span>(<span class="number">1</span>, t[p].sz, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> X1, <span class="type">int</span> Y1, <span class="type">int</span> X2, <span class="type">int</span> Y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> X1&gt;=x1&amp;&amp;Y1&gt;=y1&amp;&amp;X2&lt;=x2&amp;&amp;Y2&lt;=y2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">out</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> X1, <span class="type">int</span> Y1, <span class="type">int</span> X2, <span class="type">int</span> Y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> X2&lt;x1||X1&gt;x2||Y1&gt;y2||Y2&lt;y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">in</span>(x1, y1, x2, y2, t[p].mn[<span class="number">0</span>], t[p].mn[<span class="number">1</span>], t[p].mx[<span class="number">0</span>], t[p].mx[<span class="number">1</span>])) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">out</span>(x1, y1, x2, y2, t[p].mn[<span class="number">0</span>], t[p].mn[<span class="number">1</span>], t[p].mx[<span class="number">0</span>], t[p].mx[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">in</span>(x1, y1, x2, y2, t[p].tp.x[<span class="number">0</span>], t[p].tp.x[<span class="number">1</span>], t[p].tp.x[<span class="number">0</span>], t[p].tp.x[<span class="number">1</span>])) ans += t[p].tp.w;</span><br><span class="line">  ans += <span class="built_in">ask</span>(t[p].l, x1, y1, x2, y2) + <span class="built_in">ask</span>(t[p].r, x1, y1, x2, y2);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p)</span><br><span class="line">  &#123;</span><br><span class="line">    p = <span class="built_in">newnode</span>();</span><br><span class="line">    t[p].tp = cur;</span><br><span class="line">    t[p].l = t[p].r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cur.x[d]&gt;t[p].tp.x[d]) <span class="built_in">insert</span>(t[p].r, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">insert</span>(t[p].l, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="built_in">pushup</span>(p); <span class="built_in">test</span>(p, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="type">int</span> lstans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="built_in">read</span>(op);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">read</span>(cur.x[<span class="number">0</span>]), <span class="built_in">read</span>(cur.x[<span class="number">1</span>]), <span class="built_in">read</span>(cur.w);</span><br><span class="line">      cur.x[<span class="number">0</span>] ^= lstans, cur.x[<span class="number">1</span>] ^= lstans, cur.w ^= lstans;</span><br><span class="line">      <span class="built_in">insert</span>(rt, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> a, b, c, d;</span><br><span class="line">      <span class="built_in">read</span>(a), <span class="built_in">read</span>(b), <span class="built_in">read</span>(c), <span class="built_in">read</span>(d);</span><br><span class="line">      a ^= lstans, b ^= lstans, c ^= lstans, d ^= lstans;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lstans=<span class="built_in">ask</span>(rt, a, b, c, d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces1349</title>
      <link href="/2020/05/13/codeforces1349/"/>
      <url>/2020/05/13/codeforces1349/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a class="header-anchor" href="#A">¶</a>A</h2><h3 id="题意"><a class="header-anchor" href="#题意">¶</a>题意</h3><p>给定n个数$a_i$​,求$gcd{(lcm(a_i,a_j))}$</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>考虑gcd和lcm的本质,gcd就是所有数个质因子幂次取min,而lcm是取max所以答案就是各质因子幂次的次大值(<s>不会维护</s>)考虑a[i]对答案的贡献,就是$lcm(a_i, sufgcd_{i+1})$sufgcd为后缀gcd最后各个数贡献取gcd即可</p><h2 id="B"><a class="header-anchor" href="#B">¶</a>B</h2><h3 id="题意-s2"><a class="header-anchor" href="#题意-s2">¶</a>题意</h3><p>给定n个数$a_i$​,每次操作可以选定一个连续子段,并把所有数变为中位数(第$\lfloor \frac{n+1}{2}\rfloor$大的数),问能否通过若干次操作使整个数列所有数都是k</p><h3 id="做法-s2"><a class="header-anchor" href="#做法-s2">¶</a>做法</h3><p>1.如果没有k,无解2.n=1,看是不是k3.如果有一段连续的k(&gt;=2),则一定有解,因为每次都可以至少向左右延拓一步.考虑到两个&gt;=k的数可以把一个&lt;k的数变成&gt;=k.而一个=k数可以把一个&gt;k的数变成k只要<strong>存在两个</strong>&gt;=k的数的位置差&lt;2则一定有解(首先变成3个&gt;=k的数,然后不断延拓即可)</p><h2 id="C"><a class="header-anchor" href="#C">¶</a>C</h2><h3 id="题意-s3"><a class="header-anchor" href="#题意-s3">¶</a>题意</h3><p>一个黑白格,在每一秒,若一个格子与上下左右的格子颜色不同,它的颜色不改变,否则改变.问某个格子t秒后的颜色</p><h3 id="做法-s3"><a class="header-anchor" href="#做法-s3">¶</a>做法</h3><p>如果该格子与四周某格子颜色相同,那么它就一直会改变,否则它会保持不变x秒后,再一直改变,x为距离该格子最近的一直改变的格子的曼哈顿距离,多源bfs预处理即可.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p5107 矩阵快速幂+倍增+卡常</title>
      <link href="/2020/05/13/p5107-ju-zhen-kuai-su-mi-bei-zeng-qia-chang/"/>
      <url>/2020/05/13/p5107-ju-zhen-kuai-su-mi-bei-zeng-qia-chang/</url>
      
        <content type="html"><![CDATA[<p>带行和列的矩阵模板记得初始化行列,注意左乘还是右乘注意到询问很多,所以先预处理好倍增矩阵,(倍数不一定要是2,如果预处理复杂度比较低,可以增大倍数b)增大倍数,预处理复杂度提升,但询问复杂度降低,可以考虑制衡两者询问可以按从小到大的顺序排序,可以减少一些运算可以把矩阵乘法的for进行循环展开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">55</span>, M = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, m, q, qry[M], idx[M], res[M];</span><br><span class="line">ll inv[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  ll mat[N][N];</span><br><span class="line">  <span class="built_in">matrix</span>() &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="built_in">matrix</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">n</span>(a), <span class="built_in">m</span>(b) &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">one</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">        mat[i][j] = (i==j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;b[<span class="number">32</span>];</span><br><span class="line">matrix <span class="keyword">operator</span> * (matrix a, matrix b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">matrix <span class="title">res</span><span class="params">(a.n, b.m)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=a.n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=b.m; j++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=a.m; k++)</span><br><span class="line">        res.mat[i][j] = (res.mat[i][j]+a.mat[i][k]*b.mat[k][j]%mod)%mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">matrix <span class="keyword">operator</span> ^ (matrix a, ll x)</span><br><span class="line">&#123;</span><br><span class="line">  matrix res; res.<span class="built_in">one</span>();</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;<span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">  <span class="function">matrix <span class="title">a</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a.mat[i][<span class="number">1</span>]);</span><br><span class="line">  b[<span class="number">0</span>].n = b[<span class="number">0</span>].m = n;</span><br><span class="line">  b[<span class="number">0</span>].<span class="built_in">one</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    b[<span class="number">0</span>].mat[v][u]++;</span><br><span class="line">  &#125;</span><br><span class="line">  inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) inv[i] = (mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) d += b[<span class="number">0</span>].mat[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) b[<span class="number">0</span>].mat[i][j] = b[<span class="number">0</span>].mat[i][j]*inv[d]%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">31</span>; i++) b[i] = b[i<span class="number">-1</span>]*b[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, qry+i);</span><br><span class="line">  <span class="built_in">iota</span>(idx+<span class="number">1</span>, idx+q+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">sort</span>(idx+<span class="number">1</span>, idx+q+<span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> qry[x] &lt; qry[y];</span><br><span class="line">  &#125;);</span><br><span class="line">  matrix ans = a;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> tmp = qry[idx[i]] - qry[idx[i<span class="number">-1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">31</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">      <span class="keyword">if</span>((tmp&gt;&gt;j)&amp;<span class="number">1</span>) ans = b[j]*ans;</span><br><span class="line">    ll Res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) Res ^= ans.mat[i][<span class="number">1</span>];</span><br><span class="line">    res[idx[i]] = Res%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四维偏序 cdq套cdq</title>
      <link href="/2020/05/13/si-wei-pian-xu-cdq-tao-cdq/"/>
      <url>/2020/05/13/si-wei-pian-xu-cdq-tao-cdq/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a class="header-anchor" href="#问题">¶</a>问题</h2><p>求解&lt;=a&amp;&amp;&lt;=b&amp;&amp;&lt;=c&amp;&amp;&lt;=d的四元组数量</p><h2 id="过程"><a class="header-anchor" href="#过程">¶</a>过程</h2><p>1.有四元组相同需要先合并(unique)2.对第一维排序3.cdq1,<strong>先把左半部分标记为LEFT,右半部分标记为RIGHT</strong>,然后对第二维按序归并4.cdq2,对第三维按序归并,第四维用数据结构(如bit)维护,<strong>只对左边标记为LEFT的进行修改,对右边标记为RIGHT的进行查询</strong>注:有时也可以直接sort,多一个logcdq1中的归并数组最好和cdq2不同,否则在cdq2结束后记得还原为cdq1中的顺序排序一定要彻底,否则会wa</p><h2 id="例题"><a class="header-anchor" href="#例题">¶</a>例题</h2><p>hdu5126立方体加点,立方体数点把加点看作修改操作,数点利用容斥拆成8个询问.修改和查询按照时间有序,是一个四维偏序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> q, c[N], tot, ans[N], id[N];</span><br><span class="line"><span class="type">bool</span> isq[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=tot; i+=(i&amp;-i)) c[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) ans += c[i];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">item</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x, y, z, t, coef;</span><br><span class="line">  <span class="type">bool</span> tag;</span><br><span class="line">&#125;p[N], tmp[N], tmp2[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(item a, item b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.x==b.x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y==b.y) <span class="keyword">return</span> a.z==b.z ? a.t &lt; b.t : a.z &lt; b.z;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">CDQ2</span>(l, mid); <span class="built_in">CDQ2</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="type">int</span> i = l, j = mid+<span class="number">1</span>, k = l;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp[i].z&lt;=tmp[j].z)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!tmp[i].tag&amp;&amp;!tmp[i].coef) <span class="built_in">upd</span>(tmp[i].t, <span class="number">1</span>);</span><br><span class="line">      tmp2[k++] = tmp[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(tmp[j].tag&amp;&amp;tmp[j].coef) ans[tmp[j].t] += <span class="built_in">ask</span>(tmp[j].t<span class="number">-1</span>)*tmp[j].coef;</span><br><span class="line">      tmp2[k++] = tmp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!tmp[i].tag&amp;&amp;!tmp[i].coef) <span class="built_in">upd</span>(tmp[i].t, <span class="number">1</span>);</span><br><span class="line">    tmp2[k++] = tmp[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp[j].tag&amp;&amp;tmp[j].coef) ans[tmp[j].t] += <span class="built_in">ask</span>(tmp[j].t<span class="number">-1</span>)*tmp[j].coef;</span><br><span class="line">    tmp2[k++] = tmp[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=mid; i++) <span class="keyword">if</span>(!tmp[i].tag&amp;&amp;!tmp[i].coef) <span class="built_in">upd</span>(tmp[i].t, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) tmp[i] = tmp2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">CDQ1</span>(l, mid); <span class="built_in">CDQ1</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=mid; i++) p[i].tag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>; i&lt;=r; i++) p[i].tag = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> i = l, j = mid+<span class="number">1</span>, k = l;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i].y&lt;=p[j].y) tmp[k++] = p[i++];</span><br><span class="line">    <span class="keyword">else</span> tmp[k++] = p[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=mid) tmp[k++] = p[i++];</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=r) tmp[k++] = p[j++];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) p[i] = tmp[i];</span><br><span class="line">  <span class="built_in">CDQ2</span>(l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">  tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">    ans[i] = isq[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">      p[++tot] = &#123;x, y, z, i, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x1, y1, z1, x2, y2, z2;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;z1, &amp;x2, &amp;y2, &amp;z2);</span><br><span class="line">      isq[i] = <span class="number">1</span>;</span><br><span class="line">      p[++tot] = &#123;x2, y2, z2, i, <span class="number">1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x1<span class="number">-1</span>, y2, z2, i, <span class="number">-1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x2, y1<span class="number">-1</span>, z2, i, <span class="number">-1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x2, y2, z1<span class="number">-1</span>, i, <span class="number">-1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x1<span class="number">-1</span>, y1<span class="number">-1</span>, z2, i, <span class="number">1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x2, y1<span class="number">-1</span>, z1<span class="number">-1</span>, i, <span class="number">1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x1<span class="number">-1</span>, y2, z1<span class="number">-1</span>, i, <span class="number">1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x1<span class="number">-1</span>, y1<span class="number">-1</span>, z1<span class="number">-1</span>, i, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(p+<span class="number">1</span>, p+tot+<span class="number">1</span>, cmp);</span><br><span class="line">  <span class="built_in">CDQ1</span>(<span class="number">1</span>, tot);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">    <span class="keyword">if</span>(isq[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p5621四维LIS树状数组维护第四维的dp前缀max,第四维要离散化,同时相同的四元组要合并<strong>注意</strong>此题要先cdq左半部分,然后统计左对右的答案,再cdq右半部分.而上一题是先cdq左右,最后再统计答案(其实也可以按本题的流程,但本题不可以这样,因为本质是一个dp,必须从左到右,而统计没这个要求).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> id[N], lsh[N];</span><br><span class="line">ll c[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=m; i+=(i&amp;-i)) c[i] = <span class="built_in">max</span>(c[i], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=m; i+=(i&amp;-i)) c[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) ans = <span class="built_in">max</span>(ans, c[i]);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">item</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a, b, c, d, id;</span><br><span class="line">  <span class="type">bool</span> t;</span><br><span class="line">  ll mx, val;</span><br><span class="line">&#125;p[N], tmp[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(item x, item y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x.a==y.a)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x.b==y.b) <span class="keyword">return</span> x.c==y.c ? x.d &lt; y.d : x.c &lt; y.c;</span><br><span class="line">    <span class="keyword">return</span> x.b &lt; y.b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(item x, item y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.b==y.b&amp;&amp;x.c==y.c&amp;&amp;x.d==y.d) <span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">  <span class="keyword">if</span>(x.b==y.b) <span class="keyword">return</span> x.c==y.c ? x.d &lt; y.d : x.c &lt; y.c;</span><br><span class="line">  <span class="keyword">return</span> x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp3</span><span class="params">(item x, item y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.c==y.c&amp;&amp;x.d==y.d) <span class="keyword">return</span> x.a==y.a ? x.b &lt; y.b : x.a &lt; y.a;</span><br><span class="line">  <span class="keyword">return</span> x.c==y.c ? x.d &lt; y.d : x.c &lt; y.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">CDQ2</span>(l, mid);</span><br><span class="line">  <span class="built_in">sort</span>(p+l, p+mid+<span class="number">1</span>, cmp3);</span><br><span class="line">  <span class="built_in">sort</span>(p+mid+<span class="number">1</span>, p+r+<span class="number">1</span>, cmp3);</span><br><span class="line">  <span class="type">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; p[i].c&lt;=p[j].c)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!p[i].t) <span class="built_in">upd</span>(p[i].d, p[i].mx);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p[j].t) p[j].mx = <span class="built_in">max</span>(p[j].mx, <span class="built_in">ask</span>(p[j].d)+p[j].val);</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=mid; i++) <span class="keyword">if</span>(!p[i].t) <span class="built_in">clear</span>(p[i].d);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) tmp[id[p[i].id]] = p[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) p[i] = tmp[i];</span><br><span class="line">  <span class="built_in">CDQ2</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">CDQ1</span>(l, mid);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=mid; i++) p[i].t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>; i&lt;=r; i++) p[i].t = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">sort</span>(p+l, p+r+<span class="number">1</span>, cmp2);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) id[p[i].id] = i;</span><br><span class="line">  <span class="built_in">CDQ2</span>(l, r);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) tmp[p[i].id] = p[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) p[i] = tmp[i];</span><br><span class="line">  <span class="built_in">CDQ1</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;p[i].a, &amp;p[i].b, &amp;p[i].c, &amp;p[i].d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;p[i].val);</span><br><span class="line">    lsh[i] = p[i].d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(lsh+<span class="number">1</span>, lsh+n+<span class="number">1</span>);</span><br><span class="line">  m = <span class="built_in">unique</span>(lsh+<span class="number">1</span>, lsh+n+<span class="number">1</span>) - lsh - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    p[i].d = <span class="built_in">lower_bound</span>(lsh+<span class="number">1</span>, lsh+m+<span class="number">1</span>, p[i].d) - lsh;</span><br><span class="line">  <span class="type">int</span> tot = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">sort</span>(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmp1);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i].a!=p[i<span class="number">-1</span>].a||p[i].b!=p[i<span class="number">-1</span>].b||p[i].c!=p[i<span class="number">-1</span>].c||p[i].d!=p[i<span class="number">-1</span>].d) p[++tot] = p[i];</span><br><span class="line">    <span class="keyword">else</span> p[tot].val += <span class="built_in">max</span>(p[i].val, <span class="number">0ll</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  n = tot;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p[i].id = i;</span><br><span class="line">    p[i].mx = p[i].val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CDQ1</span>(<span class="number">1</span>, n);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) ans = <span class="built_in">max</span>(ans, p[i].mx);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chef and Bitwise Product 贪心+位运算</title>
      <link href="/2020/05/11/chef-and-bitwise-product-tan-xin-wei-yun-suan/"/>
      <url>/2020/05/11/chef-and-bitwise-product-tan-xin-wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<p>给两个数x,y($x, y &lt;= 10^{12}$),要求找到一个数z,最大化(x&amp;z)*(y&amp;z)同时最小化z,且$L\leq z\leq R$,L和R由题目给出($L, R \leq 10^{12}$)</p><h1>做法</h1><p>先不考虑上下界限制,那么z全取1肯定最优,再加入上界限制,然而并不是取R最优,比如x = 7, y = 12, l = 0, r = 8, 此时z=7可以想到一种贪心的做法,让R的某一位1变成0,然后让R的低位全变1,然后交一发会发现0分其实这个时候已经可以最大化(x&amp;z)*(y&amp;z),下面要最小化z,可以发现如果x和y的某一位同时为0,此时z的该位为1也没用.所以只要在保证&gt;=下界的情况下通过该条件最小化z即可.另外好像要特判一下下界为最优解的情况.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">15</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll x, y, l, r;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;l, &amp;r);</span><br><span class="line">  ll ans = (x&amp;r)*(y&amp;r), z = r;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">40</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> b = (r&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">      ll c = (r&gt;&gt;(i+<span class="number">1</span>)&lt;&lt;(i+<span class="number">1</span>)) + (<span class="number">1ll</span>&lt;&lt;i) - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">40</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> aa = (x&gt;&gt;i)&amp;<span class="number">1</span>, bb = (y&gt;&gt;i)&amp;<span class="number">1</span>, cc = (c&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!aa &amp;&amp; !bb &amp;&amp; cc)</span><br><span class="line">          <span class="keyword">if</span>((c^(<span class="number">1ll</span>&lt;&lt;i))&gt;=l) c ^= (<span class="number">1ll</span>&lt;&lt;i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(c&lt;l) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>((x&amp;c)*(y&amp;c)&gt;ans || (((x&amp;c)*(y&amp;c))==ans&amp;&amp;c&lt;z)) ans = (x&amp;c)*(y&amp;c), z = c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!ans) z = l;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Land 双栈trick</title>
      <link href="/2020/05/11/binary-land-shuang-zhan-trick/"/>
      <url>/2020/05/11/binary-land-shuang-zhan-trick/</url>
      
        <content type="html"><![CDATA[<p>要求动态维护一个01矩阵,支持:1.从顶部删除一行2.从尾部添加一行3.询问当前顶部某列到尾部某列的合法路径数其中合法路径数定义为,每次只能从[i,j]−&gt;[i,j−1]or[i,j]or[i,j+1],且要求两点同为0或1矩阵列数=20,操作数=3e5</p><h1>做法</h1><p>显然路径数可以通过简单dp求得,从尾部添加一行也很简单,可以O(col)求得,但是删除操作很麻烦,必须全部重算.此时就有一个trick了,当要求的是双端队列操作,但是只有添加可以快速做,那就可以用两个对顶栈来操作.开口向上的为s1,开口向下的为s2尾部添加就让s2的栈指针++,并且O(col)更新顶部删除就让s1的栈指针–,注意如果s1的栈指针为0,就把s2的所有值搬到s1,此时就相当于给s1添加,s2删除.列数很少,我们直接保存所有可能的$n^2$个答案,然后每次修改也都是$n^2$的.询问的话, $n^2$处理下对顶处部分答案的合并即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">3e5</span> + <span class="number">5</span>, M = <span class="number">25</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, q, sta[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2</span>][N][M][M];</span><br><span class="line">string p[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = sta[idx];</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        dp[idx][x][i][j] = (i==j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        dp[idx][x][i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">-1</span>; k&lt;=j+<span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(k&lt;<span class="number">1</span>||k&gt;n||p[idx][x<span class="number">-1</span>][k<span class="number">-1</span>]!=p[idx][x][j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">          dp[idx][x][i][j] += dp[idx][x<span class="number">-1</span>][i][k];</span><br><span class="line">          <span class="keyword">if</span>(dp[idx][x][i][j]&gt;=mod) dp[idx][x][i][j] -= mod;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    string op;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; p[<span class="number">1</span>][++sta[<span class="number">1</span>]];</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(sta[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span>(sta[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">          p[<span class="number">0</span>][++sta[<span class="number">0</span>]] = p[<span class="number">1</span>][sta[<span class="number">1</span>]--];</span><br><span class="line">          <span class="built_in">upd</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sta[<span class="number">0</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> a, b;</span><br><span class="line">      cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">      <span class="keyword">if</span>(sta[<span class="number">0</span>]==<span class="number">0</span>) cout &lt;&lt; dp[<span class="number">1</span>][sta[<span class="number">1</span>]][a][b] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(sta[<span class="number">1</span>]==<span class="number">0</span>) cout &lt;&lt; dp[<span class="number">0</span>][sta[<span class="number">0</span>]][b][a] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>; j&lt;=i+<span class="number">1</span>; j++)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">1</span>||j&gt;n||p[<span class="number">0</span>][<span class="number">1</span>][i<span class="number">-1</span>]!=p[<span class="number">1</span>][<span class="number">1</span>][j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            ans += <span class="number">1ll</span>*dp[<span class="number">0</span>][sta[<span class="number">0</span>]][i][a]*dp[<span class="number">1</span>][sta[<span class="number">1</span>]][j][b]%mod;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;=mod) ans -= mod;</span><br><span class="line">          &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buying a New String AC自动机</title>
      <link href="/2020/05/11/buying-a-new-string-ac-zi-dong-ji/"/>
      <url>/2020/05/11/buying-a-new-string-ac-zi-dong-ji/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串A,B,再给出n个字符串$s_i$​,每个$s_i$​有价值$b_i$​,让你从A中取一个子串(可空),再从B中取一个子串(可空),拼接成串C,定义C的价值为$\sum cnt_i©⋅b_i$.$cnt_i$​表示$s_i$​在C中作为子串出现的次数.要求输出最大的价值.<strong>Constraints</strong>$1≤T≤10$$1≤|A|,|B|≤10^3$$1≤N≤10^4$$1≤|S_i|≤26$ for each valid i$1≤b_i≤10^5$ for each valid i$A,B,S_1,S_2,…,S_N$​ contain only lowercase English letters$S_1,S_2,…,S_N$​ are pairwise distinctthe sum of |A| over all test cases does not exceed $2⋅10^3$the sum of |B| over all test cases does not exceed $2⋅10^3$the sum of N over all test cases does not exceed $2⋅10^4$</p><h1>做法</h1><p>简单的贪心可以发现,肯定是取A的某个前缀和B的某个后缀拼接.此题的关键$|S_i|$很小,如果大了我不知道还能不能做了.利用这点我们可以先预处理出A的每个前缀的价值和B的每个后缀的价值,这个用ac自动机处理,然后枚举前缀i和后缀j拼接,此时C中没有算的影响就是拼接处前后26个字母的价值,可以从后缀的起点开始在ac自动机上走25步,每次暴力跳fail统计下答案,最后取个max.这样还是会t,复杂度是$O(|A|^2 * 26^2)$大概6e9,每次跳fail是O(26)的,那就再建个fail树,预处理下把这个O(26)去掉就过了.</p><pre><code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">char</span> a[N], b[N], rb[N];</span><br><span class="line"><span class="type">char</span> s[N][<span class="number">30</span>], rs[N][<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> n, val[N];</span><br><span class="line">ll pre[N], suf[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ACA</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> nxt[N][<span class="number">26</span>], fail[N], len[N], cnt, end[N];</span><br><span class="line">  ll tmp[N][<span class="number">30</span>];</span><br><span class="line">  vector &lt;<span class="type">int</span>&gt; to[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      fail[i] = end[i] = len[i] = <span class="number">0</span>;</span><br><span class="line">      to[i].<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++)</span><br><span class="line">        nxt[i][j] = tmp[i][j+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> v, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span>(!nxt[p][k]) nxt[p][k] = ++cnt;</span><br><span class="line">      p = nxt[p][k];</span><br><span class="line">    &#125;</span><br><span class="line">    end[p] = v; len[p] = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(nxt[k][i])</span><br><span class="line">        &#123;</span><br><span class="line">          fail[nxt[k][i]] = nxt[fail[k]][i];</span><br><span class="line">          q.<span class="built_in">push</span>(nxt[k][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> nxt[k][i] = nxt[fail[k]][i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">(<span class="type">char</span> *s, ll *v, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      p = nxt[p][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=p; j; j=fail[j])</span><br><span class="line">        v[i] += end[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len[u]; i&gt;<span class="number">0</span>; i--) tmp[u][i] += end[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : to[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">26</span>; i&gt;<span class="number">0</span>; i--) tmp[v][i] += tmp[u][i];</span><br><span class="line">      <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;ac, ac2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a, b);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">strlen</span>(a), y = <span class="built_in">strlen</span>(b);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;y; i++) rb[i] = b[y-i<span class="number">-1</span>];</span><br><span class="line">  ac.<span class="built_in">clear</span>(); ac2.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s[i], val+i);</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">strlen</span>(s[i]);</span><br><span class="line">    ac.<span class="built_in">insert</span>(s[i], val[i], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;t; j++) rs[i][j] = s[i][t-j<span class="number">-1</span>];</span><br><span class="line">    ac2.<span class="built_in">insert</span>(rs[i], val[i], t);</span><br><span class="line">  &#125;</span><br><span class="line">  ac.<span class="built_in">build</span>(); ac2.<span class="built_in">build</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;x; i++) pre[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;y; i++) suf[i] = <span class="number">0</span>;</span><br><span class="line">  ac.<span class="built_in">go</span>(a, pre, x); ac2.<span class="built_in">go</span>(rb, suf, y);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;x; i++) pre[i] += pre[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;y; i++) suf[i] += suf[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=ac.cnt; i++) ac.to[ac.fail[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">  ac.<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;x; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p = ac.nxt[p][a[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;y; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      ll cur = pre[i] + suf[y-j<span class="number">-1</span>];</span><br><span class="line">      <span class="type">int</span> pp = p;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">25</span>&amp;&amp;j+k&lt;y; k++)</span><br><span class="line">      &#123;</span><br><span class="line">        pp = ac.nxt[pp][b[j+k]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        cur += ac.tmp[pp][k+<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cur&gt;ans) ans = cur;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Not a real world problem 最小割+方案</title>
      <link href="/2020/05/11/not-a-real-problem-zui-xiao-ge-fang-an/"/>
      <url>/2020/05/11/not-a-real-problem-zui-xiao-ge-fang-an/</url>
      
        <content type="html"><![CDATA[<p>有h*w的网格,每个点有权值h[i][j], 有n个粒子,告诉你每个点的坐标(x,y),权值的绝对值$\left| p[i]\right|$,定义价值为$\sum p[i]*h[x[i]][y[i]] + \sum p[i]*p[j]$(如果i点和j点相邻)问如何分配p的正负号可以最大化价值,并输出方案</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>这种分配到两个集合,然后定义一下价值并最大化的可以考虑转化为最小割,s代表+号,t代表-号,那么对于每个粒子i:s-&gt;i,权值为p[i]*h[x[i]][y[i]](表示如果割掉,则p为负号,会<strong>损失</strong>这么多),同理i-&gt;t,权值为-p[i]*h[x[i]][y[i]],注意不能有负权,所以全加一个偏移量offset.再考虑相邻点,如果符号相同有一种收获x,符号不同有一种收获y.其实只要从i向j连边x-y,从j向i也连边x-y.可以默认两者符号相同收获x,那么如果割掉i与j间的边,说明两者分别属于s和t,损失x-y.建完图最大流,输出方案只要从源点走权值&gt;0的边,所有经过的点就是属于s的(即符号为正)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> h, w, n, p[maxn], a[maxn][maxn], x[maxn], y[maxn], state[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> cnt, head[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> next, to, w;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[++cnt].next = head[u];</span><br><span class="line">  e[cnt].to = v;</span><br><span class="line">  e[cnt].w = w;</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n, m, s, t;</span><br><span class="line">  <span class="type">int</span> dep[N], cur[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;s = s, <span class="keyword">this</span>-&gt;t = t, <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    cnt = <span class="number">1</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> cap)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(u,v,cap);</span><br><span class="line">    <span class="built_in">add</span>(v,u,<span class="number">0</span>);</span><br><span class="line">    m += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s); dep[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dep[v]&amp;&amp;e[i].w&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> used = flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">      cur[u] = i;</span><br><span class="line">      <span class="type">int</span> v = e[i].to;</span><br><span class="line">      <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="built_in">dfs</span>(v,<span class="built_in">min</span>(flow,e[i].w));</span><br><span class="line">        e[i].w -= low; e[i^<span class="number">1</span>].w += low;</span><br><span class="line">        flow -= low;</span><br><span class="line">        <span class="keyword">if</span>(!flow) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used - flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) maxflow += <span class="built_in">dfs</span>(s,INF);</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (e[i].w&gt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[e[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">        state[e[i].to] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(e[i].to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;MF;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;h, &amp;w, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=h; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=w; j++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, x+i, y+i, p+i);</span><br><span class="line">  MF.<span class="built_in">init</span>(n+<span class="number">2</span>, <span class="number">0</span>, n+<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> ans = n*<span class="number">100000</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    state[i] = <span class="number">0</span>;</span><br><span class="line">    MF.<span class="built_in">addedge</span>(MF.s, i, p[i]*a[x[i]][y[i]]+<span class="number">100000</span>);</span><br><span class="line">    MF.<span class="built_in">addedge</span>(i, MF.t, -p[i]*a[x[i]][y[i]]+<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">abs</span>(x[i]-x[j])+<span class="built_in">abs</span>(y[i]-y[j])&lt;=<span class="number">1</span>)</span><br><span class="line">        MF.<span class="built_in">addedge</span>(i, j, <span class="number">2</span>*p[i]*p[j]), MF.<span class="built_in">addedge</span>(j, i, <span class="number">2</span>*p[i]*p[j]), ans += p[i]*p[j];</span><br><span class="line">  &#125;</span><br><span class="line">  ans -= MF.<span class="built_in">go</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  MF.<span class="built_in">dfs</span>(MF.s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(state[i]) <span class="built_in">printf</span>(<span class="string">&quot;1%c&quot;</span>, <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1%c&quot;</span>, <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting Vases 思维</title>
      <link href="/2020/05/11/sorting-vases-si-wei/"/>
      <url>/2020/05/11/sorting-vases-si-wei/</url>
      
        <content type="html"><![CDATA[<p>给定一个n的排列p,每次可以任意交换两个位置,花费为1,然后又给定m组交换,花费为0(可以任意次使用),问使该排列p有序的最小花费.(n&lt;=18, m&lt;=18)</p><h3 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h3><p>先考虑m=0,此时只要让每个数直接向目标位置交换即可,答案为n-环的个数再考虑m,既然可以任意交换,那就相当于这些位置是等价的,可以维护出每个等价的集合,然后直接全排列枚举每个集合,让p通过m=0的方式转换成该排列,最后取最小值.这样交的话其实只会tle一个点.如果某个集合的大小&gt;10,全排列枚举显然t.但是我们并不需要枚举每个集合的排列,因为前几个数归位后,最后一个集合的数自然就归位了.所以我们不枚举最大的集合就可以了,这样我们枚举的集合的大小最多只有9,9!(362880)完全可以接受.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, p[N], pos[N], x[N], y[N];</span><br><span class="line"><span class="type">int</span> tmpp[N];</span><br><span class="line"><span class="type">int</span> f[N], ans;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==f[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">  <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">  f[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    tmpp[i] = p[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span>(pos[tmpp[j]]&amp;&amp;pos[tmpp[j]]!=j)</span><br><span class="line">    &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="built_in">swap</span>(tmpp[j], tmpp[pos[tmpp[j]]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="built_in">sz</span>(vec))</span><br><span class="line">  &#123;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">cal</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">idx</span><span class="params">(sz(vec[x]))</span></span>;</span><br><span class="line">  <span class="built_in">iota</span>(<span class="built_in">all</span>(idx), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">sz</span>(vec[x]); i++)</span><br><span class="line">      pos[vec[x][i]] = vec[x][idx[i]];</span><br><span class="line">    <span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">  &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(<span class="built_in">all</span>(idx)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  ans = n - <span class="number">1</span>;</span><br><span class="line">  vec.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p+i);</span><br><span class="line">    f[i] = i;</span><br><span class="line">    pos[i] = <span class="number">0</span>;</span><br><span class="line">    rt[i].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, x+i, y+i);</span><br><span class="line">    <span class="built_in">merge</span>(x[i], y[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">find</span>(i);</span><br><span class="line">    rt[r].<span class="built_in">pb</span>(i);</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, <span class="built_in">sz</span>(rt[r]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> tag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(f[i]==i &amp;&amp; <span class="built_in">sz</span>(rt[i])&lt;mx) vec.<span class="built_in">pb</span>(rt[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[i]==i &amp;&amp; <span class="built_in">sz</span>(rt[i])==mx)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!tag) tag = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> vec.<span class="built_in">pb</span>(rt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Triple Sort 思维+构造</title>
      <link href="/2020/05/11/triple-sort-si-wei-gou-zao/"/>
      <url>/2020/05/11/triple-sort-si-wei-gou-zao/</url>
      
        <content type="html"><![CDATA[<p>给定一个排列p,定义一种操作方式是,选择三个下标a,b,c,然后让p[c]=p[b],p[b]=p[a],p[a]=p[c](循环右移一位),下标a,b,c的大小关系任意,但必须两两不同.要求用k次操作让p有序,输出一种合法解(不要求最小化),无解输出-1$n&lt;=2e5, k&lt;=\lfloor \frac{n}{2} \rfloor$</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>先考虑一下n=3的时候,可以发现该操作会形成两个等价类,{(1, 2, 3), (3, 1, 2), (2, 3, 1)}、 {(3, 2, 1), (1, 3, 2), (2, 1, 3)},因此第二个集合中的排列就不可能排成有序. <s>然而这好像没什么用</s>.从k的大小入手,k&lt;=n/2,说明每次操作至少要让两个元素归位,每次只要操作(i, p[i], p[p[i]])即可,但是有可能i==p[p[i]],即为一个二元环.下面考虑{2, 1, 4, 3}这个排列,它由两个二元环组成,可以发现只要操作(2,3,4),(1,2,3)即可,就是说两个二元环可以通过两次操作排成有序.所以我们只要先对长度大于2的环进行操作,然后把二元环存起来.最后如果二元环有偶数个,两两解决,否则无解.如果二元环有奇数个,则逆序对数有奇数个,而可以发现该操作每次只能变化偶数个逆序对,其实就对应了上面的两个等价类.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, k, a[N], p[N], b[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(x!=y); <span class="built_in">assert</span>(y!=z); <span class="built_in">assert</span>(x!=z);</span><br><span class="line">  <span class="type">int</span> tmp = a[z];</span><br><span class="line">  a[z] = a[y];</span><br><span class="line">  p[a[y]] = z;</span><br><span class="line">  a[y] = a[x];</span><br><span class="line">  p[a[x]] = y;</span><br><span class="line">  a[x] = tmp;</span><br><span class="line">  p[tmp] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    p[a[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  vector &lt;array&lt;<span class="type">int</span>,3&gt;&gt; op;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i!=p[i])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x = p[i], y = i, z = a[i];</span><br><span class="line">      <span class="keyword">if</span>(z==x) <span class="keyword">continue</span>;</span><br><span class="line">      op.<span class="built_in">pb</span>(&#123;y, z, x&#125;);</span><br><span class="line">      <span class="built_in">upd</span>(y, z, x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vector &lt;pii&gt; loop;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(i!=p[i] &amp;&amp; p[i]==a[i] &amp;&amp; !vis[p[i]])</span><br><span class="line">    &#123;</span><br><span class="line">      loop.<span class="built_in">pb</span>(&#123;i, p[i]&#125;);</span><br><span class="line">      vis[i] = vis[p[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">sz</span>(loop)&amp;<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">sz</span>(loop); i+=<span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a = loop[i].fi, b = loop[i].se, c = loop[i+<span class="number">1</span>].fi, d = loop[i+<span class="number">1</span>].se;</span><br><span class="line">    op.<span class="built_in">pb</span>(&#123;b, c, d&#125;);</span><br><span class="line">    <span class="built_in">upd</span>(b, c, d);</span><br><span class="line">    op.<span class="built_in">pb</span>(&#123;a, b, c&#125;);</span><br><span class="line">    <span class="built_in">upd</span>(a, b, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">sz</span>(op)&gt;k || !<span class="built_in">is_sorted</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>)) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sz</span>(op) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : op) <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, it[<span class="number">0</span>], it[<span class="number">1</span>], it[<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客算法周周练5</title>
      <link href="/2020/05/06/niu-ke-suan-fa-zhou-zhou-lian-5/"/>
      <url>/2020/05/06/niu-ke-suan-fa-zhou-zhou-lian-5/</url>
      
        <content type="html"><![CDATA[<p>题不错,所以做了下.</p><h1>A 多彩的树</h1><p>给定一棵树,每个点有一种颜色,问恰好包含i种颜色的路径的数量(i从1-k) $k&lt;=10$看见路径信息统计,想到点分治,k很小,状压即可.我们用<code>num[1&lt;&lt;10]</code>的桶记录这种状态的路径的数量然后考虑怎么合并两条路径:<code>num[i|j] = cnt[i] * cnt[j]</code>朴素暴力是$O(n*4^k)$的,5秒应该过不了很容易发现这是个或运算卷积,FWT优化一下即可.但是要注意当i==j的时候<code>num[i|j] = cnt[i] * (cnt[i]-1)/2 + cnt[i]</code>(选两个合并,以及和空路径合并(减不合法路径时不包含)),然后注意到FWT中算的是<code>cnt[i] * cnt[i] + 2*cnt[i]</code>,所以还要减掉一个cnt[i].由于是点权所以要注意些细节问题,特别是减掉不合法路径的时候,然后这题就做完了其实可以直接状压包含的颜色数,然后找到只包含这样颜色的连通块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, two = (mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, k, a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line">ll pw[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> rt, sz[N], dp[N], mxsz;</span><br><span class="line">ll mask[<span class="number">1</span>&lt;&lt;<span class="number">10</span>], num[<span class="number">1</span>&lt;&lt;<span class="number">10</span>], tmp[<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(ll *a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>;d&lt;n;d&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=d&lt;&lt;<span class="number">1</span>,i=<span class="number">0</span>;i&lt;n;i+=m)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;d;j++)</span><br><span class="line">      &#123;</span><br><span class="line">        ll x = a[i+j], y = a[i+j+d];</span><br><span class="line">        a[i+j+d] = (x+y)%mod;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IFWT</span><span class="params">(ll *a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>;d&lt;n;d&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=d&lt;&lt;<span class="number">1</span>,i=<span class="number">0</span>;i&lt;n;i+=m)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;d;j++)</span><br><span class="line">      &#123;</span><br><span class="line">        ll x = a[i+j], y = a[i+j+d];</span><br><span class="line">        a[i+j+d] = (y-x+mod)%mod;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findroot</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dp[u] = <span class="number">0</span>, sz[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[v]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">findroot</span>(v, u);</span><br><span class="line">    dp[u] = <span class="built_in">max</span>(dp[u],sz[v]);</span><br><span class="line">    sz[u] += sz[v];</span><br><span class="line">  &#125;</span><br><span class="line">  dp[u] = <span class="built_in">max</span>(dp[u],mxsz-sz[u]);</span><br><span class="line">  <span class="keyword">if</span>(dp[u]&lt;dp[rt]) rt = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  d |= (<span class="number">1</span>&lt;&lt;a[u]);</span><br><span class="line">  mask[d]++;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[v]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">getdis</span>(v, u, d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calcu</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(mask, <span class="number">0</span>, <span class="built_in">sizeof</span>(mask));</span><br><span class="line">  <span class="keyword">if</span>(!d) mask[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">getdis</span>(u, <span class="number">0</span>, d);</span><br><span class="line">  <span class="comment">// for(int i=0; i&lt;(1&lt;&lt;k); i++)</span></span><br><span class="line">  <span class="comment">// for(int j=0; j&lt;(1&lt;&lt;k); j++)</span></span><br><span class="line">  <span class="comment">// if(!d) (num[i|j] += mask[i]*mask[j]%mod)%=mod;</span></span><br><span class="line">  <span class="comment">// else (num[i|j] -= mask[i]*mask[j]%mod)%=mod;</span></span><br><span class="line">  <span class="comment">// for(int i=0; i&lt;(1&lt;&lt;k); i++)</span></span><br><span class="line">  <span class="comment">// num[i] -= mask[i]%=mod;</span></span><br><span class="line">  <span class="built_in">memcpy</span>(tmp, mask, <span class="built_in">sizeof</span>(mask));</span><br><span class="line">  <span class="built_in">FWT</span>(tmp, <span class="number">1</span>&lt;&lt;k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;k); i++) tmp[i] = tmp[i]*tmp[i]%mod;</span><br><span class="line">  <span class="built_in">IFWT</span>(tmp, <span class="number">1</span>&lt;&lt;k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;k); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!d) (num[i] += tmp[i] - mask[i]) %= mod;</span><br><span class="line">    <span class="keyword">else</span> (num[i] -= tmp[i] + mask[i]) %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">calcu</span>(u, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">calcu</span>(v, <span class="number">1</span>&lt;&lt;a[u]);</span><br><span class="line">    mxsz = sz[v], rt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">findroot</span>(v, u);</span><br><span class="line">    <span class="built_in">solve</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=k; i++) pw[i] = pw[i<span class="number">-1</span>]*<span class="number">131</span>%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    a[i]--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    G[u].<span class="built_in">pb</span>(v); G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  dp[<span class="number">0</span>] = mxsz = n;</span><br><span class="line">  <span class="built_in">findroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">solve</span>(rt);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;(<span class="number">1</span>&lt;&lt;k); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> j = __builtin_popcount(i);</span><br><span class="line">    (ans += pw[j]*num[i]%mod) %= mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ans&lt;<span class="number">0</span>) ans += mod;</span><br><span class="line">  ans = ans*two%mod;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>B 求幂</h1><p>给定n(n&lt;=1e6),问满足a^b = c^d的四元有序组个数,其中a,b,c,d在1-n之间有一个结论是各个非完全平方数的所有幂次组成的集合是没有交集的,考虑按此划分,显然不同集合间没有贡献.考虑一个集合中的两个元素a^b和a^c,令d=max(b,c)/__gcd(b,c),则有n/d组元素(ab,x∗d,ac,y),1&lt;=x&lt;=n/d.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  ll ans = <span class="number">1ll</span>*n*n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    vector&lt;pii&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(ll j=i, k=<span class="number">1</span>; j&lt;=n; j*=i, k++)</span><br><span class="line">    &#123;</span><br><span class="line">      vis[j] = <span class="number">1</span>;</span><br><span class="line">      tmp.<span class="built_in">pb</span>(&#123;j, k&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ll cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">sz</span>(tmp); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="built_in">sz</span>(tmp); j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> x = tmp[i].se/__gcd(tmp[i].se, tmp[j].se), y = tmp[j].se/__gcd(tmp[i].se, tmp[j].se);</span><br><span class="line">        cur += n/<span class="built_in">max</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(cur&gt;=mod) cur -= mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (ans + cur)%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ans&lt;<span class="number">0</span>) ans += mod;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>C 序列最小化</h1><p>给定一个1-n的排列,每次可以选择k个连续的数将其变成最小的那个数,问最少经过几次操作使序列最小.最后肯定都变成了1,第一次操作肯定包含了1这个位置,所以枚举第一次操作的左右端点,则后面的操作一定是左右延伸.</p><h1>D 小雨坐地铁</h1><p>m条地铁线路,n个车站,第i条地铁线路花费a[i],经过c[i]个车站,每站花费b[i]元,问从s站到t站的最小花费.如果有多条地铁经过同一个车站,可以换乘.对于某个车站,如果存在于多个地铁线路中,其实是不同的状态,所以对于每个地铁线路中的车站我们都用一个新点来表示.这样就可以进行建图跑最短路了.对于某条线路中的车站,依次连<strong>双向边</strong>,权值为b[i] (表示继续乘坐) ,再向经过该车站的其他线路中的该车站所代表的点连<strong>单向边</strong>,权值为a[i] (表示换乘).由于s和t代表的点有多个,所以加上超源和超汇.超源向每个地铁线路中的s连<strong>单向边</strong>,权值为a[i], 每个地铁线路中的t向超汇连<strong>单向边</strong>,权值为0.注意s=t的时候,需要特判,因为以上建图方法,如果没有地铁线路通过s,则超源和s不连通,如果从超源跑dij,会输出-1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e3</span> + <span class="number">5</span>, M = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, t, a[N], b[N], c[N], idx[<span class="number">505</span>][N], tot;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p[N], q[N];</span><br><span class="line">vector&lt;pii&gt; G[M];</span><br><span class="line">ll dis[M];</span><br><span class="line"><span class="type">bool</span> vis[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,(tot+<span class="number">1</span>)*<span class="built_in">sizeof</span>(ll));</span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="number">0</span>,(tot+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  priority_queue &lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt;&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>,s));</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">top</span>().se; q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)</span><br><span class="line">      &#123;</span><br><span class="line">        dis[v] = dis[u] + w;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">mp</span>(dis[v],v));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">  <span class="keyword">if</span>(s==t)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tot = m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, a+i, b+i, c+i);</span><br><span class="line">    q[i].<span class="built_in">resize</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;x : q[i])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      p[x].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> pre = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : q[i])</span><br><span class="line">    &#123;</span><br><span class="line">      ++tot;</span><br><span class="line">      idx[i][x] = tot;</span><br><span class="line">      G[pre].<span class="built_in">emplace_back</span>(tot, b[i]);</span><br><span class="line">      G[tot].<span class="built_in">emplace_back</span>(pre, b[i]);</span><br><span class="line">      pre = tot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++tot;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : q[i])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(x==t) G[idx[i][x]].<span class="built_in">emplace_back</span>(tot, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(x==s) G[<span class="number">0</span>].<span class="built_in">emplace_back</span>(idx[i][x], a[i]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k : p[x])</span><br><span class="line">        G[idx[i][x]].<span class="built_in">emplace_back</span>(idx[k][x], a[k]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">Dijkstra</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(dis[tot]==LINF) dis[tot] = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dis[tot]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>E 简单瞎搞题</h1><p>有100个数,每个数$x_i$​有$l_i\sim r_i$​的范围(&lt;=100),问$\sum x_i^2$​的种类数一眼bitset的优化,但仔细算了下1e6*100*100/32,似乎不太行,想了一会别的方法没想出,看了眼别人的代码,然后发现就是bitset😐,<s>只能说明牛客机子牛逼</s></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">bitset &lt;N&gt; f;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//100 * 100 * 1e6 / 32</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    bitset &lt;N&gt; nextf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=l; j&lt;=r; j++) nextf |= f&lt;&lt;(j*j);</span><br><span class="line">    f = nextf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f.<span class="built_in">count</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu5876 边权为1的无向图的补图最短路</title>
      <link href="/2020/05/03/hdu5876-bian-quan-wei-1-de-wu-xiang-tu-de-bu-tu-zui-duan-lu/"/>
      <url>/2020/05/03/hdu5876-bian-quan-wei-1-de-wu-xiang-tu-de-bu-tu-zui-duan-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>因为边权是1,所以考虑bfs.用set s1存储当前还未访问过的点,对于队首u,枚举其出点v,若v在s1中,则将其从s1 erase,并insert入s2,则此时在s1中的所有点都和u在补图中直接相连,所以将它们入队即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, dis[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) G[i].<span class="built_in">clear</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) dis[i] = <span class="number">-1</span>;</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  set &lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(i!=s) s1.<span class="built_in">insert</span>(i);</span><br><span class="line">  queue &lt;<span class="type">int</span>&gt; q; q.<span class="built_in">push</span>(s);</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">sz</span>(q))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> it = s1.<span class="built_in">find</span>(v);</span><br><span class="line">      <span class="keyword">if</span>(it!=s1.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        s2.<span class="built_in">insert</span>(v);</span><br><span class="line">        s1.<span class="built_in">erase</span>(it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : s1) dis[it] = dis[u] + <span class="number">1</span>, q.<span class="built_in">push</span>(it);</span><br><span class="line">    <span class="built_in">swap</span>(s1, s2); s2.<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    G[u].<span class="built_in">pb</span>(v); G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">  <span class="built_in">bfs</span>(s);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(i!=s)</span><br><span class="line">    &#123;</span><br><span class="line">      j++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, dis[i], <span class="string">&quot; \n&quot;</span>[j==n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforces1348 E dp</title>
      <link href="/2020/05/02/codeforces1348-e-dp/"/>
      <url>/2020/05/02/codeforces1348-e-dp/</url>
      
        <content type="html"><![CDATA[<p>有n组物品,每组物品有两种,一种a个,一种b个.定义合成方式为<strong>同种</strong>k个,或者<strong>同组</strong>k个.问最多合成多少次</p><h1>做法</h1><p>对于每一组,最多只有s(s&lt;k)个第一种与k-s个第二种进行同组组合,其余都用在同种的合成方式上.考虑 dp[i][j]: 前i组物品第一种有j个多余的情况下,最多合成的次数.对于该状态,相应的第二种就有$\sum_i(a_i+b_i) - k*dp_{ij} - j = B$考虑转移: 枚举dp[i-1][j], 再枚举当前组的同组组合状态s个第一种,k-s个第二种, 则:max{$dp[i][(j+a_i-s)$%$k]$, $dp[i−1][j] + (j+a_i-s)/k + (B+b_i-(k-s))/k$}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">12</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">ll dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; <span class="keyword">if</span>(x&lt;y) x = y; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  ll pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;k; j++)</span><br><span class="line">      dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;k; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">cmax</span>(dp[i][(j+a)%k], dp[i<span class="number">-1</span>][j] + (j+a)/k + (pre-dp[i<span class="number">-1</span>][j]*k-j+b)/k);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">0</span>; s&lt;=k; s++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;a || k-s&gt;b) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">cmax</span>(dp[i][(j+a-s)%k], dp[i<span class="number">-1</span>][j] + (j+a-s)/k + (pre-dp[i<span class="number">-1</span>][j]*k-j+b-(k-s))/k + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre += a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) <span class="built_in">cmax</span>(ans, dp[n][i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JOI2019 Final 独特的城市 思维+长剖</title>
      <link href="/2020/04/30/joi2019-final-du-te-de-cheng-shi-si-wei-chang-pou/"/>
      <url>/2020/04/30/joi2019-final-du-te-de-cheng-shi-si-wei-chang-pou/</url>
      
        <content type="html"><![CDATA[<p>给定一棵树,定义城市y为x的独特城市,当且仅当对于任意的z,$dis(x, y) \neq dis(x, z)$,每个点有个值,问对于每个城市的所有独特城市的值的种类数.</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>x的所有独特的城市一定位于距离x最远的点到x的链上(直径的某个端点).所以考虑以直径的两个端点各求解一次(取max)在dfs的过程中用栈存储对于当前点u合法的答案.在u点时,栈中所有与u距离&lt;=u的<strong>次长链</strong>的答案都不合法,直接弹出,再将u入栈,利用长链剖分,先解决重儿子.长链解决后,栈中所有与u距离&lt;=该长链的点弹出.然后依次解决u的各个轻儿子即可(注意如果u不在栈中,要加入u).u子树解决后,如果u在栈中,弹出.每次入栈和出栈用一个桶来统计答案即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, c[N], cnt[N], cur;</span><br><span class="line"><span class="type">int</span> s, t, mxlen, son[N], son2[N], len[N], dep[N];</span><br><span class="line"><span class="type">int</span> sta[N], top, ans[N];</span><br><span class="line"><span class="type">int</span> head[N], tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> to, next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[++tot].next = head[u];</span><br><span class="line">  e[tot].to = v;</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dis&gt;mxlen)</span><br><span class="line">  &#123;</span><br><span class="line">    mxlen = dis;</span><br><span class="line">    t = u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u, dis+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  s = t;</span><br><span class="line">  mxlen = t = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">  son[u] = son2[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">    <span class="keyword">if</span>(len[v]&gt;len[son[u]]) son2[u] = son[u], son[u] = v;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len[v]&gt;len[son2[u]]) son2[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  len[u] = len[son[u]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cnt[c[u]]++;</span><br><span class="line">  <span class="keyword">if</span>(cnt[c[u]]==<span class="number">1</span>) cur++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cnt[c[u]]--;</span><br><span class="line">  <span class="keyword">if</span>(!cnt[c[u]]) cur--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top &amp;&amp; dep[u]-dep[sta[top]]&lt;=len[son2[u]]) <span class="built_in">del</span>(sta[top--]);</span><br><span class="line">  <span class="built_in">add</span>(sta[++top]=u);</span><br><span class="line">  <span class="keyword">if</span>(son[u]) <span class="built_in">dfs3</span>(son[u], u);</span><br><span class="line">  <span class="keyword">while</span>(top &amp;&amp; dep[u]-dep[sta[top]]&lt;=len[son[u]]) <span class="built_in">del</span>(sta[top--]);</span><br><span class="line">  ans[u] = <span class="built_in">max</span>(ans[u], cur);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(v==fa || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(sta[top]!=u) <span class="built_in">add</span>(sta[++top]=u);</span><br><span class="line">    <span class="built_in">dfs3</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(sta[top]==u) <span class="built_in">del</span>(sta[top--]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="built_in">addedge</span>(u, v); <span class="built_in">addedge</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, c+i);</span><br><span class="line">  <span class="built_in">find</span>();</span><br><span class="line">  <span class="built_in">dfs2</span>(s, <span class="number">0</span>); <span class="built_in">dfs3</span>(s, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(t, <span class="number">0</span>); <span class="built_in">dfs3</span>(t, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforces1307F</title>
      <link href="/2020/04/29/codeforces1307f/"/>
      <url>/2020/04/29/codeforces1307f/</url>
      
        <content type="html"><![CDATA[<p>无向图上有r个关键点,一个人每次只能连续走k步,多次询问u和v两点能否到达.</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>如果两点间距离$\leq k$,就用并查集合并,所以考虑对r个关键点进行多源bfs,但是注意到这样会使得任意两个距离$\leq 2\times k$的点都可达,考虑<strong>拆点</strong>,将每条边拆成u-&gt;n+i-&gt;v,然后多源bfs k步即可.对于每个询问,如果u和v距离$\leq 2\times k$,显然可以,否则两个点各自向对方走k步(u-&gt;lca-&gt;v),此时两个点肯定不会相遇(因为距离$&gt;2\times k$),最后看两个点是否在一个集合中即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> LOG = <span class="number">19</span>;</span><br><span class="line"><span class="type">int</span> n, k, r, sp[N], step[N], f[N];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">22</span>], dep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=LOG; i++)</span><br><span class="line">    fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">    fa[v][<span class="number">0</span>] = u;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(dep[fa[y][i]]&gt;=dep[x]) y = fa[y][i];</span><br><span class="line">  <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">  <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>((d&gt;&gt;i)&amp;<span class="number">1</span>) x = fa[x][i];</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==f[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">  <span class="keyword">if</span>(x!=y) f[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>*n; i++) f[i] = i, step[i] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=r; i++) q.<span class="built_in">push</span>(sp[i]), step[sp[i]] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">sz</span>(q))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(step[u]&gt;=k) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">merge</span>(u, v);</span><br><span class="line">      <span class="keyword">if</span>(step[v]==<span class="number">-1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        step[v] = step[u] + <span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">(<span class="type">int</span> &amp;u, <span class="type">int</span> v, <span class="type">int</span> w, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]-dep[w]&gt;=k) u = <span class="built_in">up</span>(u, k);</span><br><span class="line">  <span class="keyword">else</span> u = <span class="built_in">up</span>(v, dep[v]-k+dep[u]<span class="number">-2</span>*dep[w]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> w = <span class="built_in">LCA</span>(u, v);</span><br><span class="line">  <span class="keyword">if</span>(dep[u]+dep[v]<span class="number">-2</span>*dep[w]&lt;=<span class="number">2</span>*k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">walk</span>(u, v, w, k); <span class="built_in">walk</span>(v, u, w, k);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">find</span>(u)==<span class="built_in">find</span>(v)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;r);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    G[u].<span class="built_in">pb</span>(n+i); G[v].<span class="built_in">pb</span>(n+i);</span><br><span class="line">    G[n+i].<span class="built_in">pb</span>(u); G[n+i].<span class="built_in">pb</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=r; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sp[i]);</span><br><span class="line">  dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="type">int</span> q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ok</span>(u, v)) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uoj207 LCT维护子树信息+随机化</title>
      <link href="/2020/04/29/uoj207-lct-wei-hu-zi-shu-xin-xi-sui-ji-hua/"/>
      <url>/2020/04/29/uoj207-lct-wei-hu-zi-shu-xin-xi-sui-ji-hua/</url>
      
        <content type="html"><![CDATA[<p>给定一棵树,要求支持加边删边,并维护一个点对集合,支持加入和删除点对,并询问一条边是否在所有集合中的点对间的路径上.</p><h2 id="做法"><a class="header-anchor" href="#做法">¶</a>做法</h2><p>考虑询问路径x和y:当x为根且集合中每个点对的其中一个都在y子树内时合法.给子树内每个点对随机一个权值,然后维护子树的异或和信息,当y子树内的异或和等于整个集合的异或和时合法.由于动态加边和删边所以用lct维护,对于子树信息,只要额外维护一下每个点虚儿子的异或和信息即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> id, n, m, tot, w[N];</span><br><span class="line">pii p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LCT</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ch[N][<span class="number">2</span>], fa[N], rev[N];</span><br><span class="line">  <span class="type">int</span> sum[N], sum2[N], val[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = fa[x] = rev[x] = <span class="number">0</span>;</span><br><span class="line">    sum[x] = sum2[x] = val[x] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getch</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">noroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>]==x || ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x) sum[x] = sum[ch[x][<span class="number">0</span>]] ^ sum[ch[x][<span class="number">1</span>]] ^ sum2[x] ^ val[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[x])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(ch[x][<span class="number">0</span>]) <span class="built_in">reverse</span>(ch[x][<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span>(ch[x][<span class="number">1</span>]) <span class="built_in">reverse</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">      rev[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushall</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">noroot</span>(x)) <span class="built_in">pushall</span>(fa[x]);</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x], z = fa[y], chx = <span class="built_in">getch</span>(x), chy = <span class="built_in">getch</span>(y);</span><br><span class="line">    fa[x] = z;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">noroot</span>(y)) ch[z][chy] = x;</span><br><span class="line">    ch[y][chx] = ch[x][chx^<span class="number">1</span>];</span><br><span class="line">    fa[ch[x][chx^<span class="number">1</span>]] = y;</span><br><span class="line">    ch[x][chx^<span class="number">1</span>] = y;</span><br><span class="line">    fa[y] = x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="built_in">pushup</span>(z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">pushall</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> f=fa[x]; f=fa[x], <span class="built_in">noroot</span>(x); <span class="built_in">rotate</span>(x))</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">noroot</span>(f)) <span class="built_in">rotate</span>(<span class="built_in">getch</span>(x) == <span class="built_in">getch</span>(f) ? f : x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; x; x=fa[y=x])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">splay</span>(x);</span><br><span class="line">      sum2[x] ^= sum[ch[x][<span class="number">1</span>]] ^ sum[y];</span><br><span class="line">      ch[x][<span class="number">1</span>] = y;</span><br><span class="line">      <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">makeroot</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="built_in">reverse</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findroot</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) <span class="built_in">pushdown</span>(x), x = ch[x][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">makeroot</span>(x);</span><br><span class="line">    <span class="built_in">access</span>(y); <span class="built_in">splay</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">makeroot</span>(x);</span><br><span class="line">    <span class="built_in">makeroot</span>(y);</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    sum2[y] ^= sum[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">split</span>(x,y);</span><br><span class="line">    fa[x] = ch[y][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="type">int</span> all;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="number">114514</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;id, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    T.<span class="built_in">link</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> y, u, v;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;y, &amp;u, &amp;v);</span><br><span class="line">      T.<span class="built_in">cut</span>(x, y); T.<span class="built_in">link</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> y;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">      p[++tot] = &#123;x, y&#125;;</span><br><span class="line">      w[tot] = <span class="built_in">rand</span>();</span><br><span class="line">      T.<span class="built_in">makeroot</span>(x); T.val[x] ^= w[tot];</span><br><span class="line">      T.<span class="built_in">makeroot</span>(y); T.val[y] ^= w[tot];</span><br><span class="line">      all ^= w[tot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      T.<span class="built_in">makeroot</span>(p[x].fi); T.val[p[x].fi] ^= w[x];</span><br><span class="line">      T.<span class="built_in">makeroot</span>(p[x].se); T.val[p[x].se] ^= w[x];</span><br><span class="line">      all ^= w[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> y;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">      T.<span class="built_in">split</span>(x, y);</span><br><span class="line">      <span class="keyword">if</span>(T.sum[x]==all) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
