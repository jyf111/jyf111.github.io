<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>竞赛图</title>
      <link href="/2022/06/20/jing-sai-tu/"/>
      <url>/2022/06/20/jing-sai-tu/</url>
      
        <content type="html"><![CDATA[<p>若竞赛图存在环，则一定存在三元环。</p><p>大小为$n$($n&gt;1$)的强连通块，大小为$[3,n]$的简单环均存在。</p><p>任意竞赛图都有哈密顿路径（经过每个点一次的路径，不要求回到出发点）。</p><p><strong>增量构造</strong>：对于第$i$个点，要么放在第一个，要么从后往前找到第一个满足$j\rightarrow i$的，然后插在$j$的后面。</p><p>竞赛图存在哈密顿回路的充要条件是强联通。</p><p>先构造哈密顿路径，然后构造哈密顿回路。</p><p>维护链$v_1,\dots,v_k,\dots,v_i$​，其中$v_k\rightarrow<br>v_1$​，然后考虑扩展到节点$i+1$来扩大环：</p><ol><li>$v_{i+1}\rightarrow v_1$​，直接扩大</li><li>找到最小的$j$，满足$v_{i+1}\rightarrow v_{j} (j\le k)$，然后修改路径为$v_{i+1},v_j,\dots,v_k,v_1,\dots,v_{j-1},v_{k+1},\dots,v_i$</li><li>直接考虑下一个节点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">gao</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; npath;</span><br><span class="line">  <span class="comment">// 哈密顿路</span></span><br><span class="line">  npath.<span class="built_in">push_back</span>(path.<span class="built_in">front</span>());</span><br><span class="line">  <span class="type">int</span> sz = path.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;sz; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (G[path[i]][npath.<span class="built_in">front</span>()]) npath.<span class="built_in">insert</span>(npath.<span class="built_in">begin</span>(), path[i]);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j=(<span class="type">int</span>)npath.<span class="built_in">size</span>()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[npath[j]][path[i]]) &#123;</span><br><span class="line">          npath.<span class="built_in">insert</span>(npath.<span class="built_in">begin</span>()+j+<span class="number">1</span>, path[i]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 哈密顿回路</span></span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;sz; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (G[npath[i]][npath[<span class="number">0</span>]]) k = i;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=k; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[npath[i]][npath[j]]) &#123;</span><br><span class="line">          vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">          tmp.<span class="built_in">push_back</span>(npath[i]);</span><br><span class="line">          tmp.<span class="built_in">insert</span>(tmp.<span class="built_in">end</span>(), npath.<span class="built_in">begin</span>()+j, npath.<span class="built_in">begin</span>()+k+<span class="number">1</span>);</span><br><span class="line">          tmp.<span class="built_in">insert</span>(tmp.<span class="built_in">end</span>(), npath.<span class="built_in">begin</span>(), npath.<span class="built_in">begin</span>()+j);</span><br><span class="line">          tmp.<span class="built_in">insert</span>(tmp.<span class="built_in">end</span>(), npath.<span class="built_in">begin</span>()+k+<span class="number">1</span>, npath.<span class="built_in">begin</span>()+i);</span><br><span class="line">          tmp.<span class="built_in">insert</span>(tmp.<span class="built_in">end</span>(), npath.<span class="built_in">begin</span>()+i+<span class="number">1</span>, npath.<span class="built_in">end</span>());</span><br><span class="line">          <span class="built_in">swap</span>(tmp, npath);</span><br><span class="line">          k = i;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">swap</span>(path, npath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强连通缩点后呈链状，拓扑序小的点向所有拓扑序大的点连边（因此可以直接根据强连通分量判断任意两点间的可达性）。</p><p><strong>Dirac定理</strong>：$n$阶($n\ge3$)<strong>无向</strong>简单图，任意不相邻的两个顶点$v_i,v_j$​，均有$d(v_i)+d(v_j)\ge<br>n$，则存在哈密顿回路。</p><p>先不断从首尾扩展，得到极大的路径$s,v_1,\dots,v_k,t$，若$s$和$t$有边则得到回路，否则一定存在$s\rightarrow<br>v_{i+1},t\rightarrow<br>v_i$​（鸽巢原理），构造得到回路$s,v_{i+1},\dots,t,v_i,\dots,s$。如果该回路长度小于$n$，剩余点一定与回路中的某个点有边相连，从该处将环断开，然后重复扩展即可。</p><p>$n$阶($n\ge2$)<strong>无向</strong>简单图，任意不相邻的两个顶点$v_i,v_j$​，均有$d(v_i)+d(v_j)\ge<br>n-1$，则存在哈密顿通路。</p><p>$n$阶($n\ge3$)<strong>无向</strong>简单图，任意顶点$v_i$​，均有$d(v_i)\ge<br>\frac{n}{2}$​，则存在哈密顿回路。</p><p><strong>兰道定理</strong>：将竞赛图的出度从小到大排序得到比分序列$s$，满足以下条件则合法：</p><p>$\forall 1\leq k \leq n,\sum \limits_{i&#x3D;1}^k s_i \geq<br>\binom{k}{2}$，且$k&#x3D;n$时必须取等号。</p><p>先构造序列$a&#x3D;(0,1,\dots,n-1)$，此时$a$的前缀小于$s$，后缀大于$s$（因为$a$和$s$的总和相同），然后找到第一个$a_l&lt;<br>s_l$​，以及最后一个$a_u&#x3D;a_l$​（为了保证修改后$a$仍然有序），再找到第一个$a_v&gt;<br>s_v$​，则$a_u&lt;s_u\le s_v&lt;a_v$​，即$a_v\ge<br>a_u+2$，若$v\rightarrow u$，或$v\rightarrow p,p\rightarrow<br>u$，就将相应边进行翻转，这样不断调整，最终$a&#x3D;s$。</p><p>强连图竞赛图计数：$g_i&#x3D;f_i-\sum_{j&#x3D;1}^{i-1}\binom{i}{j}g_jf_{i-j}$​，即枚举拓扑序最小的强连通分量的大小。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oneTBB 并行编程框架</title>
      <link href="/2022/05/21/onetbb-bing-xing-bian-cheng-kuang-jia/"/>
      <url>/2022/05/21/onetbb-bing-xing-bian-cheng-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/oneapi-src/oneTBB.git</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>make过程中可能出现如下问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c++: fatal error: Killed signal terminated program cc1plus</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><p>原因就是内存太小了，减小并行度或者临时换页 （<a href="https://blog.csdn.net/weixin_44796670/article/details/121234446">参考</a>）</p><h3 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tbb::tick_count::<span class="built_in">now</span>();</span><br><span class="line">tick_count t0 = tick_count::<span class="built_in">now</span>();</span><br><span class="line">tick_count t1 = tick_count::<span class="built_in">now</span>();</span><br><span class="line"><span class="built_in">printf</span>(“work took %g seconds\n”,(t1-t0).<span class="built_in">seconds</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">std::cerr &lt;&lt; std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(end - start).<span class="built_in">count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>只记时一次，容易出现波动</p><p>使用<code>google benchmark</code>，可以跑多次求平均值</p><h3 id="控制运行的线程数"><a href="#控制运行的线程数" class="headerlink" title="控制运行的线程数"></a>控制运行的线程数</h3><p>Thread local storage：<code>thread_local</code>表明该变量的作用域是线程，每个线程都有一份拷贝。</p><p>对于TBB而言，你不知道任务和线程之间的对应关系。</p><p><code>enumerable_thread_specific</code>：provides thread local storage that acts like an<br>STL container with one element per thread. The container permits iterating<br>over the elements using the usual STL iteration idioms. Any thread can iterate<br>over all the local copies, seeing the other threads local<br>data.（每个线程有一份拷贝，并且所有拷贝被组织成一个容器，可以顺序遍历容器来结合最终结果）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">ets_vector_t</span> = enumerable_thread_specific&lt;vector&lt;<span class="type">int</span>&gt;&gt;;</span><br><span class="line"><span class="function"><span class="type">ets_vector_t</span> <span class="title">partial</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="number">10</span>, [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="type">ets_vector_t</span>::reference local = partial.<span class="built_in">local</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span>&amp; x : local) x = <span class="number">20</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : partial)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j) sum[j] += it[j];</span><br></pre></td></tr></table></figure><p>用法就是包装一个tbb::enumerable_thread_specific，然后在内部使用local得到自己的那份拷贝，此外可以遍历整个容器，得到每一份拷贝。（如果该线程第一次调用local，就会创建一份，否则会使用自己已经创建的那份）</p><p>可以使用<code>size()</code>得到有几个拷贝，但是该容器只支持顺序遍历，不能随机访问(不支持<code>[]</code>)。所以如果指定线程想查看对方的私有拷贝，这是不行的，你既不知道它的下标，也没办法直接访问</p><p><code>combinable</code>：provides thread local storage for holding per-thread<br>subcomputations that will later be reduced to a single result. Each thread can<br>only see its local data or, after calling combine, the combined data.<br>（用于存储中间结果，只能看到自己的数据）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">combinable&lt;vector&lt;<span class="type">int</span>&gt;&gt; partial&#123;[]()&#123;<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N); &#125;&#125;;</span><br><span class="line"><span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="number">10</span>, [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; local = partial.<span class="built_in">local</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(N)</span></span>;</span><br><span class="line">partial.<span class="built_in">combine_each</span>([&amp;](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) sum[i] += a[i];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>combinable需要传入一个lambda，在local中会调用，用于初始化。</p><p>通过combine_each将每份拷贝的结果合并起来。</p><p>note：个人感觉这两者差不多，combine_each其实就等价于顺序遍历拷贝构成的容器</p><hr><p>Task</p><p><code>parallel_invoke(f1,f2...)</code>（隐式的task spawning和barrier）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task_group g;</span><br><span class="line">g.<span class="built_in">run</span>(f1);</span><br><span class="line">g.<span class="built_in">run</span>(f2);</span><br><span class="line">...</span><br><span class="line">g.<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure><p><code>run_and_wait(f)</code>：we avoid the overhead of enqueueing-schedulingdequeuing<br>steps, and second, we avoid the potential stealing that can happen while the<br>task is in the queue.</p><p><code>cancel()</code></p><p>如果有大量任务，线性spawn不如递归spawn（满二叉的形式）</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parallel_for</span>(<span class="number">0</span>, n, [](<span class="type">int</span> i) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, n), [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; range r) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">parallel_reduce</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, n), init,  <span class="comment">// 规约</span></span><br><span class="line">  [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; range r, <span class="keyword">auto</span> pre) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  [&amp;](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="comment">// combine</span></span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">parallel_scan</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, n), init,  <span class="comment">// 前缀规约</span></span><br><span class="line">  [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; range r, <span class="keyword">auto</span> pre, <span class="type">bool</span> is_final_scan) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_final_scan) &#123;</span><br><span class="line">        <span class="comment">// write</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [&amp;](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="comment">// combine</span></span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>并行过滤：考虑对一个vector执行一个过滤条件。我目前认为最好的写法是先resize足够大的空间，然后通过一个atomic记录结果vector的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> local_base = res_size.<span class="built_in">fetch_add</span>(local_size);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; local_size; i++) res[local_base + i] = local_res[i];</span><br></pre></td></tr></table></figure><p>POD_vector(?)：上述情况中必须先resize，不能reserve，而resize的一个问题是会对所有元素做一遍memset，有时候这是很多余的，所以可以通过一些trick避免这个初始化的过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于调试的c++日志库-spdlog</title>
      <link href="/2022/05/20/yong-yu-diao-shi-de-cri-zhi-ku-spdlog/"/>
      <url>/2022/05/20/yong-yu-diao-shi-de-cri-zhi-ku-spdlog/</url>
      
        <content type="html"><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/gabime/spdlog.git</span><br></pre></td></tr></table></figure><p>header-only 所以直接include头文件即可，当然也可以install成静态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(xxx</span><br><span class="line">PRIVATE</span><br><span class="line">  spdlog/<span class="keyword">include</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>日志级别：info、warn、error、critical</p><p>mt后缀表示多线程（multi threaded），st后缀表示单线程</p><blockquote><p>spdlog takes the “include what you need” approach - your code should include<br>the features that actually needed.</p></blockquote><p>输出使用fmt库，类似python</p><p>编译器log过滤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_DEBUG</span></span><br><span class="line"></span><br><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::debug); <span class="comment">// or spdlog::set_level(spdlog::level::trace);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SPDLOG_LOGGER_TRACE</span>(file_logger , <span class="string">&quot;Some trace message that will not be evaluated.&#123;&#125; ,&#123;&#125;&quot;</span>, <span class="number">1</span>, <span class="number">3.23</span>);</span><br><span class="line"><span class="built_in">SPDLOG_LOGGER_DEBUG</span>(file_logger , <span class="string">&quot;Some Debug message that will be evaluated.. &#123;&#125; ,&#123;&#125;&quot;</span>, <span class="number">1</span>, <span class="number">3.23</span>);</span><br><span class="line"><span class="built_in">SPDLOG_DEBUG</span>(<span class="string">&quot;Some debug message to default logger that will be evaluated&quot;</span>);</span><br></pre></td></tr></table></figure><p>set level</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::info); <span class="comment">// Set global log level to info</span></span><br><span class="line">spdlog::<span class="built_in">debug</span>(<span class="string">&quot;This message should not be displayed!&quot;</span>);</span><br><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::trace); <span class="comment">// Set specific logger&#x27;s log level</span></span><br><span class="line">spdlog::<span class="built_in">debug</span>(<span class="string">&quot;This message should be displayed..&quot;</span>);</span><br><span class="line">```cpp</span><br><span class="line"></span><br><span class="line">backtrace</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// Backtrace support</span></span><br><span class="line"><span class="comment">// Loggers can store in a ring buffer all messages (including debug/trace) for later inspection.</span></span><br><span class="line"><span class="comment">// When needed, call dump_backtrace() to see what happened:</span></span><br><span class="line">spdlog::<span class="built_in">enable_backtrace</span>(<span class="number">10</span>); <span class="comment">// create ring buffer with capacity of 10 messages</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  spdlog::<span class="built_in">debug</span>(<span class="string">&quot;Backtrace message &#123;&#125;&quot;</span>, i); <span class="comment">// not logged..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// e.g. if some error happened:</span></span><br><span class="line">spdlog::<span class="built_in">dump_backtrace</span>(); <span class="comment">// log them now!</span></span><br></pre></td></tr></table></figure><p>shutdown</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release all spdlog resources, and drop all loggers in the registry.</span></span><br><span class="line"><span class="comment">// This is optional (only mandatory if using windows + async log).</span></span><br><span class="line">spdlog::<span class="built_in">shutdown</span>();</span><br></pre></td></tr></table></figure><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><blockquote><p>Each logger contains a vector of one or more<br><code>std::shared_ptr&lt;spdlog::sink&gt;</code>.</p><p>On each log call (if the log level is right) the logger will call the<br><code>sink(log_msg)</code> function on each of them.</p></blockquote><p>spdlog会默认创建一个全局的logger（stdout、color、mt），直接使用<code>spdlog::info(..)</code>调用的就是该logger</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_default_logger</span>(some_other_logger);</span><br><span class="line">spdlog::<span class="built_in">info</span>(<span class="string">&quot;Use the new default logger&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> console = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;some_unique_name&quot;</span>); <span class="comment">// create logger</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> file_logger = spdlog::<span class="built_in">rotating_logger_mt</span>(<span class="string">&quot;file_logger&quot;</span>, <span class="string">&quot;logs/mylogfile&quot;</span>, <span class="number">1048576</span> * <span class="number">5</span>, <span class="number">3</span>); <span class="comment">// rotate 3个文件循环log</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_sink_mt&gt;();</span><br><span class="line"><span class="keyword">auto</span> my_logger= std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;mylogger&quot;</span>, sink); <span class="comment">// manually,不会register</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;spdlog::sink_ptr&gt; sinks;</span><br><span class="line">sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_sink_st&gt;());</span><br><span class="line">sinks.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::daily_file_sink_st&gt;(<span class="string">&quot;logfile&quot;</span>, <span class="number">23</span>, <span class="number">59</span>));</span><br><span class="line"><span class="keyword">auto</span> combined_logger = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;name&quot;</span>, <span class="built_in">begin</span>(sinks), <span class="built_in">end</span>(sinks)); <span class="comment">// one log and multiple sink</span></span><br><span class="line"><span class="comment">//register it if you need to access it globally</span></span><br><span class="line">spdlog::<span class="built_in">register_logger</span>(combined_logger);</span><br></pre></td></tr></table></figure><h3 id="sink"><a href="#sink" class="headerlink" title="sink"></a>sink</h3><p>log和sink都分别由st和mt</p><p>logger的功能由sink决定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logger：</span><br><span class="line">spdlog::rotating_logger_mt</span><br><span class="line">spdlog::daily_logger_mt</span><br><span class="line">spdlog::basic_logger_mt</span><br><span class="line">spdlog::stdout_logger_mt</span><br><span class="line">spdlog::stderr_logger_st</span><br><span class="line">spdlog::stdout_color_mt</span><br><span class="line">spdlog::stderr_color_st</span><br><span class="line">-----------------------</span><br><span class="line">sink：</span><br><span class="line">example：spdlog::sinks::rotating_file_sink_mt</span><br></pre></td></tr></table></figure><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><blockquote><p>spdlog maintains a global (per process) registry of the created loggers.</p><p>The purpose is for loggers to be accessed easily from anywhere in the<br>project without passing them around.（避免参数传递）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">get</span>(<span class="string">&quot;logger_name&quot;</span>); <span class="comment">// 内部有lock，最好使用一个变量保存</span></span><br><span class="line">spdlog::<span class="built_in">register_logger</span>(some_logger);</span><br><span class="line">spdlog::<span class="built_in">drop</span>(<span class="string">&quot;logger_name&quot;</span>);</span><br><span class="line"><span class="comment">//or remove them all</span></span><br><span class="line">spdlog::<span class="built_in">drop_all</span>()</span><br></pre></td></tr></table></figure><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_pattern</span>(<span class="string">&quot;*** [%H:%M:%S %z] [thread %t] %v ***&quot;</span>); <span class="comment">// global to all</span></span><br><span class="line">some_logger-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">some_logger-&gt;<span class="built_in">sinks</span>()[<span class="number">0</span>]-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google benchmark</title>
      <link href="/2022/05/07/google-benchmark/"/>
      <url>/2022/05/07/google-benchmark/</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/google/benchmark.git</span><br><span class="line"><span class="built_in">cd</span> benchmark</span><br><span class="line">cmake -E make_directory <span class="string">&quot;build&quot;</span></span><br><span class="line">cmake -E <span class="built_in">chdir</span> <span class="string">&quot;build&quot;</span> cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES=on -DCMAKE_BUILD_TYPE=Release ../</span><br><span class="line">cmake --build <span class="string">&quot;build&quot;</span> --config Release</span><br><span class="line"></span><br><span class="line">cmake -E <span class="built_in">chdir</span> <span class="string">&quot;build&quot;</span> ctest --build-config Release</span><br><span class="line"></span><br><span class="line">sudo cmake --build <span class="string">&quot;build&quot;</span> --config Release --target install</span><br></pre></td></tr></table></figure><h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(benchmark REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(xxx</span><br><span class="line">PRIVATE</span><br><span class="line">  benchmark::benchmark</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeFunction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">max</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BM_SomeFunction</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123; <span class="comment">// a wrapper</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">    <span class="built_in">SumeFunction</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK</span>(BM_SomeFunction);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK_MAIN</span>();</span><br></pre></td></tr></table></figure><p>也可以自己定义main函数，只需要在最后加上以下两行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::benchmark::<span class="built_in">Initialize</span>(&amp;argc, argv);</span><br><span class="line">::benchmark::<span class="built_in">RunSpecifiedBenchmarks</span>();</span><br></pre></td></tr></table></figure><p>官方对整型变量的支持比较好，有各种range的传参方式。<br>如果需要传入其他变量，需要使用CAPTURE，传参方式类似emplace_back之类的<br>Iterations可以指定迭代次数<br>Unit指定时间单位（默认是ns）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BENCHMARK_CAPTURE</span>(BM_xxx, xxx_test, arg)</span><br><span class="line">  -&gt;<span class="built_in">Iterations</span>(<span class="number">5</span>)</span><br><span class="line">  -&gt;<span class="built_in">Unit</span>(benchmark::kMillisecond);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>固定区间最值查询</title>
      <link href="/2021/09/28/gu-ding-qu-jian-zui-zhi-cha-xun/"/>
      <url>/2021/09/28/gu-ding-qu-jian-zui-zhi-cha-xun/</url>
      
        <content type="html"><![CDATA[<p>对于一维，用单调队列就可以解决。<br>二维的话，先对每一列做一遍，然后压缩成一维<br>更高维同理。。。</p><p>这里主要记录一下前k优最值的记录<br>例如现在要求固定区间的最小值和次小值。我们只需要维护两个单增队列。每当移动r指针，先维护第一个队列的单调性，弹出的元素塞到第二个队列中。那么次大值就是第一个栈中的次大值或者第二个栈中的最大值。</p><p>另外可以采用双栈模拟队列的方式，栈中存的是pair(当前元素大小，栈底到当前元素的最小值)。同理对于k小值只要修改second为k维的tuple即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>析合树（permutation tree）</title>
      <link href="/2021/09/13/xi-he-shu-permutation-tree/"/>
      <url>/2021/09/13/xi-he-shu-permutation-tree/</url>
      
        <content type="html"><![CDATA[<p>仅限于解决<strong>排列</strong>中与连续段相关的问题，局限性比较大，虽然平凡序列也能做，但是会复杂很多<br>一些定义：<br>段：该区间排序后值域连续<br>本原段：与其它连续段只有包含和相离的关系，没有相交关系<br>儿子排列：各个儿子离散化后的编号形成的排列<br>合点：儿子排列为顺序或逆序（叶子也认为是合点）<br>析点：不是合点的节点</p><ul><li>合点的儿子序列的任意子区间都是一个连续段</li><li>析点的儿子序列的任意长度大于1的子区间都不是连续段（否则该区间就是一个本原段）</li></ul><p>析合树就是由若干本原段构成，且每个本原段是合点和析点中的一种。<br>增量构造$O(n\log n)$，维护前$i$个结点的栈，然后考虑当前结点$P_i$​</p><ol><li>栈顶为合点且可以成为它的儿子</li><li>栈的某个后缀可以生成一个合点作为父亲</li><li>栈的某个后缀可以生成一个析点作为父亲</li></ol><p>最主要的一个辅助工具是快速查询$[j,i]$这个区间是否是连续段，由于是排列，所以只需要检查$Q_j&#x3D;\max\limits_{i\le<br>k\le j}P_k-\min\limits_{i\le k\le j}P_k-(i-j)&#x3D;<br>0$，又注意到$Q_j\ge<br>0$，因此用单调栈和线段树维护Q，值为0的点就可以作为连续段的左端点。</p><p>代码解释：<br>节点数要开两倍<br>$id_i$​：表示排列中第i个数在析合树中的编号<br>$L_i,R_i$​：编号为i的点在排列中对应的下标范围<br>$SL_i$​：编号为i的点当前最靠右（最后加入）的儿子的LLL<br>$type_i$​：编号为i的点的类型，1表示合点，0表示析点<br>$rt$：析合树的根节点<br>$cnt$：析合树的节点数<br>$askmn$：单点查询一个点的Q，用于检查是否为连续段<br>$askpos$：找到最靠左的可以与当前右端点构成连续段下标<br>对于当前点$i$，先维护好Q序列</p><ol><li>如果能与栈顶最右的儿子形成连续段就作为它的儿子（此时栈顶必然是合点，因为析点不可能有子区间是连续段）</li><li>如果能与栈顶构成连续段，则生成一个合点</li><li>否则如果某个后缀是连续段，就生成一个析点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ptree &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = N&lt;&lt;<span class="number">1</span>, LOG = <span class="number">17</span>;</span><br><span class="line"><span class="type">int</span> id[M], L[M], R[M], SR[M], type[M], rt, cnt;</span><br><span class="line"><span class="type">int</span> stk[M], stk1[M], stk2[M], tp, tp1, tp2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; G[x].<span class="built_in">push_back</span>(y); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(tp1 &amp;&amp; a[i]&lt;=a[stk1[tp1]]) &#123;</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>, stk1[tp1<span class="number">-1</span>]+<span class="number">1</span>, stk1[tp1], a[stk1[tp1]]);</span><br><span class="line">      --tp1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>, stk1[tp1]+<span class="number">1</span>, i, -a[i]);</span><br><span class="line">    stk1[++tp1] = i;</span><br><span class="line">    <span class="keyword">while</span>(tp2 &amp;&amp; a[i]&gt;=a[stk2[tp2]]) &#123;</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>, stk2[tp2<span class="number">-1</span>]+<span class="number">1</span>, stk2[tp2], -a[stk2[tp2]]);</span><br><span class="line">      --tp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>, stk2[tp2]+<span class="number">1</span>, i, a[i]);</span><br><span class="line">    stk2[++tp2] = i;</span><br><span class="line">    id[i] = ++cnt;</span><br><span class="line">    L[cnt] = R[cnt] = i;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">askpos</span>(<span class="number">1</span>), now = cnt;</span><br><span class="line">    <span class="keyword">while</span>(tp &amp;&amp; L[stk[tp]]&gt;=pos) &#123;</span><br><span class="line">      <span class="keyword">if</span>(type[stk[tp]] &amp;&amp; <span class="built_in">askmn</span>(<span class="number">1</span>, SR[stk[tp]])==<span class="number">0</span>) &#123;</span><br><span class="line">        R[stk[tp]] = i, SR[stk[tp]] = L[now], <span class="built_in">add</span>(stk[tp], now), now = stk[tp--];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">askmn</span>(<span class="number">1</span>, L[stk[tp]])==<span class="number">0</span>) &#123;</span><br><span class="line">        type[++cnt] = <span class="number">1</span>;</span><br><span class="line">        L[cnt] = L[stk[tp]], R[cnt] = i, SR[cnt] = L[now];</span><br><span class="line">        <span class="built_in">add</span>(cnt, stk[tp--]), <span class="built_in">add</span>(cnt, now);</span><br><span class="line">        now = cnt;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">add</span>(++cnt, now);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="built_in">add</span>(cnt, stk[tp--]);</span><br><span class="line">        &#125; <span class="keyword">while</span>(tp &amp;&amp; <span class="built_in">askmn</span>(<span class="number">1</span>, L[stk[tp]])!=<span class="number">0</span>);</span><br><span class="line">        L[cnt] = L[stk[tp]], R[cnt] = i, <span class="built_in">add</span>(cnt, stk[tp--]);</span><br><span class="line">        now = cnt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++tp] = now;</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  rt = stk[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//namespace Ptree</span></span><br></pre></td></tr></table></figure><ul><li><p>Codeforces 526F – Pudding Monsters<br>  查询一个排列的连续段个数，显然只需要完成Q序列的维护即可</p></li><li><p>CERC 17 Problem I – Instrinsic Interval<br>  给出一个排列，每次查询给出$l,r$，问你最短的包含该区间的连续段的左右端点<br>  我们先求出LCA，如果是析点，说明答案只能是LCA的左右端点；否则可以在儿子序列中找到一个最小的包含$l,r$的子区间，实质上利用倍增跳到LCA的儿子即可</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu 6356 反向ST表/线段树剪枝</title>
      <link href="/2021/09/07/hdu-6536-fan-xiang-st-biao-xian-duan-shu-jian-zhi/"/>
      <url>/2021/09/07/hdu-6536-fan-xiang-st-biao-xian-duan-shu-jian-zhi/</url>
      
        <content type="html"><![CDATA[<p>给出m次区间取max的操作(l,r,v)，问你最后数组的状态(初始均为0)，操作通过随机的方式给出。</p><p>区间取max，可以用sgbt来做，不过注意到本题操作随机(既然是随机给出的，必然有它的用意)，所以可以用剪枝的方式：维护区间最大值和最小值，当前最大值比v还小就是区间覆盖，最小值比v还大就直接reutrn。</p><p>此外还有一种反向ST表的操作，我们可以先得到高层ST表的状态，然后再从高到低递推出底层的状态即可。当然这种方式有很大的限制，感觉只适用于区间取最值，只有最后一次询问的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">uint x, y, z, w;</span><br><span class="line"><span class="function">uint <span class="title">rng61</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = x^(x&lt;&lt;<span class="number">11</span>);</span><br><span class="line">  x = x^(x&gt;&gt;<span class="number">4</span>);</span><br><span class="line">  x = x^(x&lt;&lt;<span class="number">5</span>);</span><br><span class="line">  x = x^(x&gt;&gt;<span class="number">14</span>);</span><br><span class="line">  w = x^(y^z);</span><br><span class="line">  x = y;</span><br><span class="line">  y = z;</span><br><span class="line">  z = w;</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">if</span>(x&lt;y) x = y; &#125;</span><br><span class="line"><span class="type">int</span> st[N][<span class="number">18</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%u%u%u&quot;</span>, &amp;n, &amp;m, &amp;x, &amp;y, &amp;z);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n; j++) st[i][j] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">    uint f0 = <span class="built_in">rng61</span>(), f1 = <span class="built_in">rng61</span>(), f2 = <span class="built_in">rng61</span>();</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">min</span>(f0%n+<span class="number">1</span>, f1%n+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">max</span>(f0%n+<span class="number">1</span>, f1%n+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> v = f2%(<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">31</span> - __builtin_clz(r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Max</span>(st[l][k], v);</span><br><span class="line">    <span class="built_in">Max</span>(st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k], v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">16</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;(j+<span class="number">1</span>))<span class="number">-1</span>&lt;=n; i++) &#123;</span><br><span class="line">      <span class="built_in">Max</span>(st[i][j], st[i][j+<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">Max</span>(st[i+(<span class="number">1</span>&lt;&lt;j)][j], st[i][j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) ans ^= <span class="number">1ll</span>*i*st[i][<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj2724 蒲公英 区间众数+强制在线</title>
      <link href="/2021/09/03/bzoj2724-pu-gong-ying-qu-jian-zhong-shu-qiang-zhi-zai-xian/"/>
      <url>/2021/09/03/bzoj2724-pu-gong-ying-qu-jian-zhong-shu-qiang-zhi-zai-xian/</url>
      
        <content type="html"><![CDATA[<p>可以离线的话怎么做？<br>首先想到的肯定是莫队，不过删除操作有点棘手。目前只有两个想法：1.无脑上回滚莫队。2.再加一个分块来维护出现次数，移动O(1)，查询$O(\sqrt<br>n)$。不过感觉都没有在线简单</p><p>分块之后，如果维护的信息可以递推，我们可以很方便的维护出任意两个块之间的信息。本题就是任意两个块之间的众数，这是很容易的，而且是$O(\frac{N^2}{B})$的。<br>可以发现答案肯定要么是上面这个，要么是两个边缘块中出现的数字。所以我们只需要枚举边缘块的数字来进行更新即可。一种显然的想法就是对每个数字进行二分来求解出现次数，这样是$O(MB\log<br>N)$的，需要对B进行权衡。另外一种很妙的思路，考虑到两个边缘块对答案的贡献最多是$2B$，那我直接O(1)去check贡献能不能再+1，这样就是$O(MB)$的了(注：M是询问次数，N是数字个数，B是块大小，根据均值不等式使两个复杂度相等，选择最优的B即可，当然具体实现时只要大致估计一个常数即可)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e4</span> + <span class="number">5</span>, B = <span class="number">250</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], v[N], tot;</span><br><span class="line"><span class="type">int</span> f[B][B], g[B][B], cnt[N];</span><br><span class="line"><span class="type">int</span> blo, num, bl[N], l[B], r[B], pos[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lsh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> tmp[N];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) tmp[i] = a[i];</span><br><span class="line">  <span class="built_in">sort</span>(tmp+<span class="number">1</span>, tmp+n+<span class="number">1</span>);</span><br><span class="line">  tot = <span class="built_in">unique</span>(tmp+<span class="number">1</span>, tmp+n+<span class="number">1</span>) - tmp - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> pre = a[i];</span><br><span class="line">    a[i] = <span class="built_in">lower_bound</span>(tmp+<span class="number">1</span>, tmp+tot+<span class="number">1</span>, a[i]) - tmp;</span><br><span class="line">    v[a[i]] = pre;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; i++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y=x; y&lt;=num; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l[y]; i&lt;=r[y]; i++) &#123;</span><br><span class="line">      <span class="type">int</span> cur = a[i];</span><br><span class="line">      cnt[cur]++;</span><br><span class="line">      <span class="keyword">if</span>(!res || cnt[cur]&gt;cnt[res] || (cnt[cur]==cnt[res] &amp;&amp; cur&lt;res)) &#123;</span><br><span class="line">        res = cur;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][y] = res;</span><br><span class="line">    g[x][y] = cnt[res];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  blo = <span class="built_in">sqrt</span>(n);</span><br><span class="line">  num = (n+blo<span class="number">-1</span>)/blo;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) bl[i] = (i<span class="number">-1</span>)/blo + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=num; i++) l[i] = (i<span class="number">-1</span>)*blo + <span class="number">1</span>, r[i] = i*blo;</span><br><span class="line">  r[num] = n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=num; i++) <span class="built_in">build</span>(i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    p[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    pos[i] = (<span class="type">int</span>)p[a[i]].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(bl[x]+<span class="number">1</span>&lt;=bl[y]<span class="number">-1</span>) res = f[bl[x]+<span class="number">1</span>][bl[y]<span class="number">-1</span>], cnt = g[bl[x]+<span class="number">1</span>][bl[y]<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=<span class="built_in">min</span>(r[bl[x]], y); i++) &#123;</span><br><span class="line">    <span class="type">int</span> nxt = (a[i]&lt;res ? cnt : cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(pos[i]+nxt<span class="number">-1</span>&lt;(<span class="type">int</span>)p[a[i]].<span class="built_in">size</span>() &amp;&amp; p[a[i]][pos[i]+nxt<span class="number">-1</span>]&lt;=y) &#123;</span><br><span class="line">      res = a[i];</span><br><span class="line">      cnt = nxt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(bl[x]!=bl[y]) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l[bl[y]]; i&lt;=y; i++) &#123;</span><br><span class="line">      <span class="type">int</span> nxt = (a[i]&lt;res ? cnt : cnt+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span>(pos[i]-nxt+<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; p[a[i]][pos[i]-nxt+<span class="number">1</span>]&gt;=x) &#123;</span><br><span class="line">        res = a[i];</span><br><span class="line">        cnt = nxt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="built_in">lsh</span>();</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> lstans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    l = (l + lstans - <span class="number">1</span>)%n + <span class="number">1</span>, r = (r + lstans - <span class="number">1</span>)%n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="built_in">swap</span>(l, r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lstans = v[<span class="built_in">qry</span>(l, r)]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一下各种软件的配置</title>
      <link href="/2021/08/29/ji-lu-yi-xia-ge-chong-ruan-jian-de-pei-zhi/"/>
      <url>/2021/08/29/ji-lu-yi-xia-ge-chong-ruan-jian-de-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>为了方便管理，统一放到D:\environment目录下</p><h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p><a href="https://www.jianshu.com/p/ee1ccb0a3062">https://www.jianshu.com/p/ee1ccb0a3062</a> 照这个做即可<br>gcc&#x2F;g++ 8.1.0</p><h2 id="Clang以及Clangd"><a href="#Clang以及Clangd" class="headerlink" title="Clang以及Clangd"></a>Clang以及Clangd</h2><p><a href="https://www.cnblogs.com/FrankOu/p/14215850.html">https://www.cnblogs.com/FrankOu/p/14215850.html</a></p><h2 id="sublime-text"><a href="#sublime-text" class="headerlink" title="sublime text"></a>sublime text</h2><p>sublime的配色我比较喜欢，而且很轻量，用于写一些算法竞赛题和一些简单的python、shell脚本<br>官网有最新的4版本<br>fontsize改成10.5左右比较舒服<br>ctrl+x 删除当前行<br><a href="https://blog.csdn.net/qq_39599067/article/details/81270330">https://blog.csdn.net/qq_39599067/article/details/81270330</a> 代码片段配置<br><a href="https://jingyan.baidu.com/article/cb5d6105ae0c44005c2fe0f1.html">https://jingyan.baidu.com/article/cb5d6105ae0c44005c2fe0f1.html</a> 括号高亮<br><a href="https://blog.csdn.net/qq_43816826/article/details/108406114">https://blog.csdn.net/qq_43816826/article/details/108406114</a> repl python快捷键配置<br><a href="https://segmentfault.com/a/1190000004463984">https://segmentfault.com/a/1190000004463984</a> AdvancedNewFile<br>c++17 build system<br>似乎在c++17中bits&#x2F;stdc++.h有点问题？（当然linux下没问题），所以还是用c++14吧，懒得折腾了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;g++&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-Wall&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-std=c++17&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file_regex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;working_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;file_path&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;selector&quot;</span><span class="punctuation">:</span> <span class="string">&quot;source.c, source.c++&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span><span class="string">&quot;cp936&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;variants&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RunInCommand&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;cmd&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/c&quot;</span><span class="punctuation">,</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-Wall&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-std=c++17&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;&amp;&amp;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;start&quot;</span><span class="punctuation">,</span> <span class="string">&quot;cmd&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/c&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125; &amp; echo.&amp;pause&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>file icon插件：美化作用<br>trailingspace：检测行末多余空格<br>sublimelinter：静态检查<br>sublimelinter-clang<br>clang-format：格式化<br>lsp：language server port</p><h2 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h2><p>写markdown<br>直接下载即可</p><h2 id="Adobe-Acrobat"><a href="#Adobe-Acrobat" class="headerlink" title="Adobe Acrobat"></a>Adobe Acrobat</h2><p>pdf reader</p><h2 id="Velocity"><a href="#Velocity" class="headerlink" title="Velocity"></a>Velocity</h2><p>离线文档</p><h2 id="DeepL"><a href="#DeepL" class="headerlink" title="DeepL"></a>DeepL</h2><p>翻译<br>ctrl+q</p><h2 id="CopyQ"><a href="#CopyQ" class="headerlink" title="CopyQ"></a>CopyQ</h2><p>剪贴板<br>ctrl+shift+q：去除换行符</p><h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021中国大学生程序设计竞赛（CCPC）- 网络选拔赛</title>
      <link href="/2021/08/28/2021-zhong-guo-da-xue-sheng-cheng-xu-she-ji-jing-sai-ccpc-wang-luo-xuan-ba-sai/"/>
      <url>/2021/08/28/2021-zhong-guo-da-xue-sheng-cheng-xu-she-ji-jing-sai-ccpc-wang-luo-xuan-ba-sai/</url>
      
        <content type="html"><![CDATA[<p>hdu的服务器有点问题，体验比较差<br>感觉打的中规中矩，不过能排到前50还是比较惊讶，估计受题目风格以及服务器问题的影响。（看来大部分队伍受网络的影响挺大的，而且听说有多道疑似原题，要重赛了，不过也无所谓）</p><h2 id="1001"><a href="#1001" class="headerlink" title="1001"></a>1001</h2><p>简单的分类讨论，解不等式即可</p><h2 id="1002"><a href="#1002" class="headerlink" title="1002"></a>1002</h2><p>队友过的，暴力</p><h2 id="1006"><a href="#1006" class="headerlink" title="1006"></a>1006</h2><p>构造题，发现$x^2+(x+3)^2-(x+1)^2-(x+2)^2&#x3D;4$后，根据模4的值分别构造即可</p><h2 id="1007"><a href="#1007" class="headerlink" title="1007"></a>1007</h2><p>枚举$g(x)$，转成二次函数，剩下的就是二分加取整的琐碎问题</p><h2 id="1008"><a href="#1008" class="headerlink" title="1008"></a>1008</h2><p>我先想了一个看上去很可行的解法，不过最后统计答案复杂度会炸<br>最后队友给出正解，考虑求解$v(l,r)\leq<br>x$的区间个数，从大到小枚举gcd，然后抠出所有gcd的倍数，考虑相邻两个数形成的区间$[L,R]$，则以$[1,L]$中的点为左端点时，右端点必须满足小于R，才有可能使得$v(l,r)\le<br>x$，然后就是一个前缀取min，整体求sum的segment beats了。（事实上由于维护的序列是单调的，也可以二分+区间覆盖来做，<br><del>然而我写T了</del> ，可能是我写挂了，也可能是卡了3log，而sgbt更趋近于单个log，看了题解，直接在线段树上二分就行了，我在外面套个二分是该t）</p><h2 id="1009"><a href="#1009" class="headerlink" title="1009"></a>1009</h2><p>前缀和+map 类似于求多少个子区间的和为0，只不过扩展成二维的了</p><h2 id="1011"><a href="#1011" class="headerlink" title="1011"></a>1011</h2><p>队友过的，没参与</p><h2 id="1012"><a href="#1012" class="headerlink" title="1012"></a>1012</h2><p>考虑dp来求解，当求解完$dp_x$​，枚举所有$p \mid<br>x$，让$[dp_{x+1},dp_{x+p-1}]$与$dp_x+1$取min即可。容易发现只要对每个x，考虑在质数集中<strong>最大</strong>的x的因子即可，又容易发现这个$dp$是单增的，所以不断维护当前覆盖到的最大右端点即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在debian8上使用支持c++17的g++版本</title>
      <link href="/2021/06/22/zai-debian8-shang-shi-yong-zhi-chi-c17-de-gban-ben/"/>
      <url>/2021/06/22/zai-debian8-shang-shi-yong-zhi-chi-c17-de-gban-ben/</url>
      
        <content type="html"><![CDATA[<p>最近调试编译器遇到一个比较矛盾的事情。cpp文件通过我的compiler转成arm汇编，然后通过qemu-<br>arm的debian虚拟机上的g++将arm文件汇编、链接后转成可执行文件就可以跑结果了。<br>然而我的compiler用了一些c++17的特性（optional、stringview），debian8最新只有g++4.9.2，没法支持c++17。我只能在本地转成arm汇编再传上去测试，效率太低。我想把两个过程都放到debian上，然后写个脚本一键测试。于是有两种选择</p><ul><li>把代码的c++17相关删了🤡</li><li>让虚拟机支持-std&#x3D;c++17</li></ul><p>显然还是要努力试一下后者。<br>看了一下debian9有g++6，debian10有g++8。我一开始以为要把整个系统都升级，结果大半夜跑了2个小时还没完，等不了就ctrl+c了，然后发现虚拟机坏了，gg。<br>第二天重下了虚拟机，重新来过。尝试了一下直接装debian10的g++到debian8上。具体做法就是在镜像源里加了buster，（8的别名是jessie，9的别名是stretch，10的别名是buster）。然后apt-<br>get update，apt-get install g++，它会自动帮你把各种依赖都安装升级。<br><img src="/../post-images/1624337438397.png"><br>然后就能愉快的跑了<br><img src="/../post-images/1624337477434.png"><br><img src="/../post-images/1624337482828.png"><br>最后记得apt-get autoremove清理下旧版本</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsl</title>
      <link href="/2021/04/09/wsl/"/>
      <url>/2021/04/09/wsl/</url>
      
        <content type="html"><![CDATA[<p>wsl和vmware之间切换需要在powershell中输入以下命令并重启（需要管理员权限）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off/auto</span><br></pre></td></tr></table></figure><p>wsl位于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\这里是你自己的user的名字\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\rootfs</span><br></pre></td></tr></table></figure><p>通过如下方式可以将wsl从c盘移动到d盘<br><a href="https://blog.csdn.net/w851685279/article/details/108904106?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&spm=1001.2101.3001.4242">https://blog.csdn.net/w851685279/article/details/108904106?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm&#x3D;1001.2101.3001.4242</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环</title>
      <link href="/2021/03/28/yue-se-fu-huan/"/>
      <url>/2021/03/28/yue-se-fu-huan/</url>
      
        <content type="html"><![CDATA[<p>n个人（编号从0开始），从1开始依次报数，报到k的那个人退出，并继续循环报数，问最后剩下的人的编号<br>这个问题还是要从递归的角度去考虑<br>设$f_{n-1}$​表示n个人时最后剩下的那个人<br>那么对于n个人的情况，第一个出局的人是k-1，之后就相当于是从k开始的n-1个人的约瑟夫环问题<br>所以很容易得到递推式$f_n &#x3D; (f_{n-1} + k)%n$<br>同样的如果要求第m个出局的人，也可以用上述公式$f_{n,m}&#x3D;(f_{n-1,m-1}+k)%n$<br>对于$k \ll n$的情况，考虑$f_{i+x-1}&#x3D;(f_{i-1}+x*k)%(i+x-1)$，当$f_{i-1}+x*k\leq i+x-1$时不会取模，所以快速递推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">J</span><span class="params">(ll n, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  ll ans = <span class="number">0</span>, i = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">  &#123;</span><br><span class="line">    ll cnt = (i-ans<span class="number">-2</span>)/(k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!cnt)</span><br><span class="line">    &#123;</span><br><span class="line">      ans = (ans + k)%i;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(i+cnt&gt;n)</span><br><span class="line">      &#123;</span><br><span class="line">        ans = (ans + k*(n-i+<span class="number">1</span>))%n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        i += cnt;</span><br><span class="line">        ans = (ans + k*cnt)%i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外对于k&#x3D;2的特殊情况，可以考虑当n为2的幂次的时候答案就是1，所以当n为$2^x+y$的形式时，答案为$2*y+1$</p><p>求第x个人是第几个死的（0下标）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n, ll k, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n)</span><br><span class="line">  &#123;</span><br><span class="line">    x = (x+n)%n;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n) x += (k-x<span class="number">-1</span>+n<span class="number">-1</span>)/n*n;</span><br><span class="line">    <span class="keyword">if</span>((x+<span class="number">1</span>)%k==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ans += (x+<span class="number">1</span>)/k;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(k&gt;n)</span><br><span class="line">      &#123;</span><br><span class="line">        ans += x/k;</span><br><span class="line">        ll tmp = x;</span><br><span class="line">        x = x-(x/n+<span class="number">1</span>)*(x/k)+(x+n)/n*n-k;</span><br><span class="line">        n -= tmp/k;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ans += n/k;</span><br><span class="line">        x = x-x/k;</span><br><span class="line">        x += n-n/k*k;</span><br><span class="line">        n -= n/k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-k bfs</title>
      <link href="/2021/03/24/1-k-bfs/"/>
      <url>/2021/03/24/1-k-bfs/</url>
      
        <content type="html"><![CDATA[<p>考虑一个单源最短路径问题，但是图的边权范围是1-k，k不大，那就可以用以下方法<br>本质上在一个队列中同时最多只有k+1种不同的dis的取值，因此只需要用k+1个队列来维护即可，当前队列为空时，就循环移位找到下一个非空的队列即可<br>复杂度为$O(nk+m)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q[K+<span class="number">1</span>];</span><br><span class="line">q[<span class="number">0</span>].<span class="built_in">push</span>(s);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>, inq = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(inq&gt;<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span>(q[idx].<span class="built_in">empty</span>()) idx = (idx+<span class="number">1</span>)%(k+<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> u = q[idx].<span class="built_in">front</span>(); q[dx].<span class="built_in">pop</span>();</span><br><span class="line">  inq--;</span><br><span class="line">  <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u]) &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(d[v]&gt;d[u]+w) &#123;</span><br><span class="line">      d[v] = d[u] + w;</span><br><span class="line">      q[d[v]%(k+<span class="number">1</span>)].<span class="built_in">push</span>(v);</span><br><span class="line">      ++inq;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拟阵</title>
      <link href="/2021/03/22/ni-zhen/"/>
      <url>/2021/03/22/ni-zhen/</url>
      
        <content type="html"><![CDATA[<p>$M(S,I)$表示一个拟阵，其中I是S的某些子集的集合，满足这些子集在某种定义下是独立的<br>一个拟阵M需要满足如下三个性质：</p><ul><li>空集属于I</li><li>若集合A属于I，则A的任意一个子集也属于I（遗传性）</li><li>若集合A属于I，任意一个size大于A的属于I的集合B中总能找到元素加入A，使其仍在I中（交换性）</li></ul><p>满足以上定义的最好的解释例子就是线性无关向量组。<br>基：最大独立集，即I中size最大的那个子集<br>环：最小的非独立集，去掉任意元素后就是一个独立集</p><p>典型的拟阵：</p><ul><li>uniform matroid：size≤k\leq k≤k的子集</li><li>linear matroid：线性无关的子集</li><li>colorful matroid：每个元素有一种颜色，如果一个集合中所有元素颜色各不相同就独立</li><li>graphic matroid：每个元素是一条边，一个集合中的边没有环就独立</li><li>上一个拟阵的对偶拟阵：对于一个集合，保留在S中且不在该集合中的所有边后，整个图连通则独立。注：必须是删边，如果是考虑集合中的边连通的话，显然不满足遗传性。</li></ul><p>拟阵交<br>考虑现在有两个拟阵（其中的一个独立集本质上就代表着满足了某种约束的集合），那么我们要求同时满足这两个拟阵的约束条件下的最大独立集，这时候就要用到拟阵交了。<br>该算法的流程是不断维护当前的共同独立集I，然后尝试加入一个新的元素s：<br>定义一种交换图，对于任意两个元素x，y，若满足$x\in I, y \notin<br>I,I-\{x\}+\{y\}\in<br>{I_1}$​，就从x向y连一条有向边；若满足$x\in I, y<br>\notin I,I-\{x\}+\{y\}\in<br>{I_2}$​，就从y向x连一条有向边。简单说来就是如果把I中的某个元素x替换成没有选的某个元素y后，如果该独立集符合$I_1$​的定义，就加一条$x\rightarrow<br>y$的边，如果符合$I_2$​的定义，就加一条$x \leftarrow y$的边。<br>对于所有不在I中的元素x，若$I+\{x\}\in I_1$​，则源点S向其连边<br>对于所有不在I中的元素x，若$I+\{x\}\in I_2$​，则其向汇点T连边<br>然后从S向T跑一遍<strong>最短路</strong>，如果有这样的路径就把路径上的所有元素的状态取反（对称差）<br>上述过程称为一次增广<br>不断进行增广操作就可以得到最大独立集了<br>复杂度为$O(r^2n(C_1+C_2))$，其中r为秩，$C_1$​和$C_2$​分别表示M1和M2检查当前集合是否为独立集的调用次数<br>再考虑如果每个元素是带权的话，其实也很简单，如果一个元素当前在I，就把它的权值定为$-w$，否则定为$w$，然后跑最长路就可以得到最大权独立集了。<br>上述算法的一个瓶颈其实是在检查是否为独立集上，这点一定要仔细实现。要支持加入一个元素判断是否还是独立集，删除一个元素并加入一个元素判断是否是独立集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">aug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> S = n, T = n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(in[i])</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) <span class="keyword">if</span>(!in[j])</span><br><span class="line">    &#123;</span><br><span class="line">      in[i] = <span class="number">0</span>, in[j] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(m1.<span class="built_in">check</span>(in)) G[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">      <span class="keyword">if</span>(m2.<span class="built_in">check</span>(in)) G[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">      in[i] = <span class="number">1</span>, in[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(!in[i])</span><br><span class="line">  &#123;</span><br><span class="line">    in[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m1.<span class="built_in">check</span>(in)) G[S].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(m2.<span class="built_in">check</span>(in)) G[i].<span class="built_in">push_back</span>(T);</span><br><span class="line">    in[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n+<span class="number">2</span>, -inf)</span>, <span class="title">pre</span><span class="params">(n+<span class="number">2</span>)</span>, <span class="title">inq</span><span class="params">(n+<span class="number">2</span>)</span></span>;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(S), dis[S] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    inq[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;n) cost = in[u] ? -w[u] : w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(dis[v]&lt;dis[u]+cost)</span><br><span class="line">      &#123;</span><br><span class="line">        dis[v] = dis[u] + cost;</span><br><span class="line">        pre[v] = u;</span><br><span class="line">        <span class="keyword">if</span>(!inq[v]) q.<span class="built_in">push</span>(v), inq[v] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pre[T]==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x=pre[T]; x!=S; x=pre[x]) in[x] ^= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n个数，每个数可以任意+1,-1</title>
      <link href="/2021/03/18/n-ge-shu-mei-ge-shu-ke-yi-ren-yi-1-1/"/>
      <url>/2021/03/18/n-ge-shu-mei-ge-shu-ke-yi-ren-yi-1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="变成非降序列的最小代价"><a href="#变成非降序列的最小代价" class="headerlink" title="变成非降序列的最小代价"></a>变成非降序列的最小代价</h2><p>显然对于第i个数如果要变就变成之前已经出现过的数，所以离散化后dp即可，$O(n^2)$<br>考虑当前数y，以及之前的最大值x，如果$y&lt;x$，此时需要将x变小，y变大，容易发现不管怎么调整代价都是y-<br>x，这边的策略是直接把y变成x。<br>考虑y之前的最大值z，如果$z\leq x$，显然没有问题，否则我们也不用关心改成了什么，因为现在最大值变成了z，那就尽可能减小<br>所以用一个大根堆，如果当前数小于堆顶，就把堆顶变成当前数</p><h2 id="变成严格降序列"><a href="#变成严格降序列" class="headerlink" title="变成严格降序列"></a>变成严格降序列</h2><p>对每个数减去下标后，套用上面的做法，一个小trick</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双栈模拟队列</title>
      <link href="/2021/03/12/shuang-zhan-mo-ni-dui-lie/"/>
      <url>/2021/03/12/shuang-zhan-mo-ni-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h2><p>支持push和pop操作</p><p>使用两个对顶栈stk1和stk2，push操作就直接加到stk2的尾部，pop操作就从stk1中弹出，如果stk1为空，就把stk2中的所有元素依次pop后push入stk1</p><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>支持push_front、push_back、pop_front、pop_back操作</p><p>同样用两个对顶栈来实现，但是如果pop_front和pop_back操作交替进行，使用上面的方法就会TLE。考虑均摊的思想，如果在pop时该栈空了，就把另一个栈栈底的$\frac<br>n2$​个元素push过去</p><h2 id="摊还"><a href="#摊还" class="headerlink" title="摊还"></a>摊还</h2><p>考虑现在总共有n个物品，然后在m个位置可能会消耗物品，我们可以把这n个物品均分到这m个位置，如果某个位置的物品被消耗完说明物品数至少减少了$\frac<br>1m$​，之后我们统计当前物品的数量后再进行均分。<br>$T(n)&#x3D;T(\frac{n(m-1)}{m})+O(n)$<br>$T(n)&#x3D;O(n)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纳什均衡</title>
      <link href="/2021/03/08/na-shi-jun-heng/"/>
      <url>/2021/03/08/na-shi-jun-heng/</url>
      
        <content type="html"><![CDATA[<p>甲乙两人进行一个博弈，有AB两种选择，而他们的组合选择会对应某种收益（双方均知道这些组合选择的后果），而每个人不知道对方如何选择，所以每个人会选择自己期望意义下有最大收益的那个（即对方选A或选B两种情况综合之下）。<br>现在站在甲的角度去考虑，有以下几种情况：</p><ul><li>乙选A的时候我选A比B更优，乙选B的时候我选A还是比B更优，那么毫无疑问我会选择A</li><li>同理可能选择B完全优于选择A</li></ul><p>同样的，站在乙的角度也会出现这两种情况。此时另外一者能够想到对方的选择，而自己只能在这个前提下选择更优的一种<br>当然也可能出现，某种情况下A优，某种情况下B优，这时候就涉及到一种混合策略，假设我有p的概率选择A，(1-p)的概率选择B，为了利益最大化，那么我要使得对方在选A或选B的时候自己期望得到的收益相同，即$pV(A,<br>A) + (1-p)V(B, A) &#x3D; pV(A, B) + (1-p)V(B,<br>B)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用dp解决各个本质不同方案的平方和</title>
      <link href="/2021/03/05/li-yong-dp-jie-jue-ge-ge-ben-zhi-bu-tong-fang-an-de-ping-fang-he/"/>
      <url>/2021/03/05/li-yong-dp-jie-jue-ge-ge-ben-zhi-bu-tong-fang-an-de-ping-fang-he/</url>
      
        <content type="html"><![CDATA[<p>前提：如果只是简单的求和，可以利用dp[s]来解决<br>那么再加一维，dp[s1][s2]，然后在转移的时候当且仅当下一个状态两者相同才转移，这样得到的结果就是平方和，可以发现这实际上是在对s1和s2这两种状态作匹配，如果某种状态有x个，那么这两者之间就会匹配$x^2$次<br>同理，继续加维，可以得到更高次方和的结果</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间k次覆盖 费用流模型</title>
      <link href="/2021/02/28/qu-jian-k-ci-fu-gai-fei-yong-liu-mo-xing/"/>
      <url>/2021/02/28/qu-jian-k-ci-fu-gai-fei-yong-liu-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>各出n个带权区间，让你保留最多的区间，使得数轴上的每个点最多被覆盖了k次</p><p>建立超源0，超汇maxv+1<br>i和i+1连一条费用为0，流量为k的边<br>对于每个区间，s向t+1连一条费用为-w，流量为1的边<br>跑一遍最小费用流即可<br>容易发现这个图是个dag，可以直接dp求出势能h后跑dijkstra</p><p>gym102759F<br>区间2次覆盖板子，卡了spfa</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">namespace</span> MCMF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>, M = <span class="number">1e6</span> + <span class="number">5</span>, inf = <span class="number">1e9</span>;</span><br><span class="line">  <span class="type">const</span> ll linf = <span class="number">1e18</span>;</span><br><span class="line">  <span class="type">int</span> cnt, head[N];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> next, to, w;</span><br><span class="line">    ll f;</span><br><span class="line">  &#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w, ll f)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    e[++cnt] = &#123;head[u], v, w, f&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> n, s, t;</span><br><span class="line">  <span class="type">int</span> flow;</span><br><span class="line">  <span class="type">int</span> p[N], a[N];</span><br><span class="line">  ll d[N], h[N], cost;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _n, <span class="type">int</span> _s, <span class="type">int</span> <span class="type">_t</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    n = _n, s = _s, t = <span class="type">_t</span>;</span><br><span class="line">    cnt = <span class="number">1</span>, flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, (n+<span class="number">1</span>)&lt;&lt;<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> cap, ll cost)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(u, v, cap, cost), <span class="built_in">addedge</span>(v, u, <span class="number">0</span>, -cost);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getH</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) h[i] = linf;</span><br><span class="line">    h[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s; i&lt;t; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=head[i]; j; j=e[j].next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = e[j].to;</span><br><span class="line">        <span class="keyword">if</span>(e[j].w &amp;&amp; h[v]&gt;h[i]+e[j].f) h[v] = h[i] + e[j].f;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) d[i] = linf;</span><br><span class="line">    d[s] = <span class="number">0</span>, a[s] = inf;</span><br><span class="line">    priority_queue&lt;pli, vector&lt;pli&gt;, greater&lt;pli&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> cur = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="type">int</span> u = cur.se;</span><br><span class="line">      <span class="keyword">if</span>(cur.fi&gt;d[u]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        ll w = e[i].f + h[u] - h[v];</span><br><span class="line">        <span class="keyword">if</span>(e[i].w&amp;&amp;d[v]&gt;d[u]+w)</span><br><span class="line">        &#123;</span><br><span class="line">          p[v] = i;</span><br><span class="line">          a[v] = <span class="built_in">min</span>(a[u], e[i].w);</span><br><span class="line">          pq.<span class="built_in">push</span>(&#123;d[v]=d[u]+w, v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(d[i]&lt;linf) h[i] += d[i];</span><br><span class="line">      <span class="keyword">else</span> h[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> d[t]!=linf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">getH</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">Dijkstra</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      flow += a[t], cost += a[t]*h[t];</span><br><span class="line">      <span class="type">int</span> u = t;</span><br><span class="line">      <span class="keyword">while</span>(u!=s)</span><br><span class="line">      &#123;</span><br><span class="line">        e[p[u]].w -= a[t], e[p[u]^<span class="number">1</span>].w += a[t];</span><br><span class="line">        u = e[p[u]^<span class="number">1</span>].to;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  MCMF::<span class="built_in">init</span>(<span class="number">500002</span>, <span class="number">0</span>, <span class="number">500001</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> s, e; ll w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;s, &amp;e, &amp;w);</span><br><span class="line">    MCMF::<span class="built_in">add</span>(s, e+<span class="number">1</span>, <span class="number">1</span>, -w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MCMF::t; i++) MCMF::<span class="built_in">add</span>(i, i+<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  MCMF::<span class="built_in">go</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, -MCMF::cost);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Regular Contest 111</title>
      <link href="/2021/01/10/atcoder-regular-contest-111/"/>
      <url>/2021/01/10/atcoder-regular-contest-111/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>求$\lfloor \frac{10^n}{m} \rfloor$<br>$1\leq n \leq 10^{18},1\leq m \leq 10000$</p><p>把$x % y$改写成$\lfloor \frac{x}{y} \rfloor$<br>求出$p&#x3D;10^n % m$，再求出$q&#x3D;(10^n-p) % m^2$<br>那么答案就是$\frac{10^n-p}{m} - \frac{10^n-p-q}{m}$​，即$\frac{q}{m}$<br>快速幂即可</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>有n张牌，每张有两面，各有数字$a_i$​和$b_i$​，每张牌选择一面朝上，问你最多能有几种数字。</p><p>相当于给$a_i$​和$b_i$​连边，然后对于每个连通块如果是树，那就要少一种，否则全可以有<br>然后比赛时候我却只想到一个二分图的建法，甚至还在犹豫要不要用HK冲（太菜惹。。）<br>最后也是乱搞过去的，如果某个数字只有一张牌有，那就让翻，这样按照拓扑把这些贪心掉之后，剩下的每个数字都至少有两个牌有，那么这些数字都可以有（其实和题解的结论一样）</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>每个人有权值$a_i$​，有物品$p_i$​，且重$b_i$​，每次可以选择两个人交换他们的物品，问你最少多少次使得所有i满足$p_i&#x3D;i$，一个额外条件是如果$a_i&lt;&#x3D;b_i$​后这个人就不能再交换了。</p><p>可以任意交换，要最少次数，显然是考虑每个置换环<br>贪心的想肯定是先让$a_i$​小的人先归位，尽可能让$a_i$​大的人作中介<br>所以按照a排序后一个个换即可<br>题解说的是如果换不了就一定无解。我写的时候是如果一次换不了，就尝试让a最大的那个作中介，似乎不会出现这种情况？</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>一个无向图，让你给所有边定向，使得每个点可以达到的点数满足给定的数组$c$，保证存在解</p><p>因为一定有解，那么对于一条边，如果两个点的c不同，一定是让大的连向小的，所以只用考虑相等的。我当时想的是肯定是环，但是这样很难构造。其实本质就是让你把这个无向图定向成一个强连通的图。先跑出一个dfs树，然后对于树边从dfs序小的到大的，对于非树边从dfs序大的到小的即可。<br>我边的数组也只开了100，导致一直wa（不知道为什么不是re），自闭了</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>给定A,B,C,D，让你求有多少个正整数i满足$[A+Bi,A+Ci]$区间内没有D的倍数<br>显然区间长度$\geq D$的时候一定有D的倍数<br>所有i一定满足$\leq \lfloor \frac{D-2}{C-B} \rfloor$<br>其次就是$\lfloor \frac{A+Bi-1}{D} \rfloor&#x3D; \lfloor \frac{A+Ci}{D}<br>\rfloor$<br>又由于这两者最多相差1，所以只要求出$\sum \limits_{i&#x3D;1}^{up} \lfloor<br>\frac{A+Ci}{D} \rfloor - \lfloor \frac{A+Bi-1}{D}<br>\rfloor$，就是包含D的倍数的不合法区间了，用up减掉即可。这东西就是一个基本的类欧几里得了$\sum<br>\limits_{i&#x3D;0}^{n} \lfloor \frac{ai+b}{c} \rfloor$，套个板子即可</p><p>比赛就写ABC，D没写出来，E没看，感觉这次DE挺套路的，然后ABC我写的有点慢，BC也都是猜的结论不太敢写，想了好久</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018-2019 ACM-ICPC, Asia Jiaozuo Regional Contest gym102028</title>
      <link href="/2021/01/09/2018-2019-acm-icpc-asia-jiaozuo-regional-contest-gym102028/"/>
      <url>/2021/01/09/2018-2019-acm-icpc-asia-jiaozuo-regional-contest-gym102028/</url>
      
        <content type="html"><![CDATA[<p>前五题不难（银），第六题（B or H）都不会</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>真签到</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>初中题，有点烦<br>有两种情况，懒得写了</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>很容易打表找到规律</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>很直白的bfs，需要对给出的图进行一些转化（我的转化方法不太好，导致有点难写）</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p>横轴上有n个点，让你选择k个点，最大化他们两两之间距离的和<br>k从1~n都回答一遍<br>两个点一定是取最左和最右，三个点随便再取一个，四个点一定是取最左两个和最右两个，那么结论就很显然了</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>给定n个数，定义一个子区间的值为该区间的最大值，让你求所有本质不同的子区间的值的和<br>没有本质不同那就很模板了，单调栈或者笛卡尔树即可<br>但是本质不同就很棘手，想了想后缀自动机感觉做不了，又想了想单调栈和笛卡尔树感觉也不行，哈希也没法搞。<br>看到题解的后缀数组后就知道了。忘了本质不同还可以后缀数组了。<br>先想一下后缀数组是怎么求本质不同的串的，就是求出$height_i$​，那么对于从位置i开始的后缀，他会多统计$height_{rk_i}$​​个前缀，即从i开始，以$i$ ~ $i+height_{rk_i}-1$结束的这些区间的值重复算了，减掉即可<br>令$r_i &#x3D; i+height_{rk_i}-1$<br>先建出笛卡尔树，对于当前点u，当前范围为[L,R],则左子树内所有$r_i$​大于等于u的，都要减掉$a_u$​的贡献<br>即要求出左子树(包括u)内$\sum_{i&#x3D;L}^u max(r_i-u+1,0) -<br>\sum_{i&#x3D;L}^u max(r_i-R,0)$<br>可以用线段树合并来维护</p><p>这题发现了我sa板子的一个问题，在求height数组的时候要注意i+k和j+k的范围，否则在多组数据+数组是int的时候会挂掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;a[i+k]==a[j+k]) k++;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>有两种怪物，血量攻击力分别为$HP_A,ATK_A,HP_B,ATK_B$<br>第i回合你会先受到活着的怪物的攻击，然后你可以选择一只怪物造成i的伤害，让你最小化自己所受的伤害的同时最小化攻击序列的字典序（尽可能优先打A）<br>先考虑怎么最小化自己受到的伤害<br>定义f(t)表示最小的x，使得$\sum_{i&#x3D;1}^x \geq t$<br>一定是在$f(HP_A+HP_B)$回合以内，先优先打死A，或者先优先打死B<br>考虑先打死A，如果前$f(HP_A)$回合都用来打A，剩余回合打B也能把B打死那这就是最优的，否则假设缺了x点伤害，打A富余了y点伤害，必然有关系$y\geq<br>x$，为了让B尽可能靠后，只要在第y回合改成打B即可<br>考虑先打死B，先在前$f(HP_B)$回合都打B，后面打A，如果打B富余了x点伤害，我们让前$f(x+1)-1$个回合改成打A即可，如果A还缺了x的伤害，那就让前面最后一下打A延迟x回合</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>一个$n \times n$的棋盘，每一列上都一个棋子（且都不同行），现在有四种操作和两种询问</p><ul><li>L K：所有棋子同时向左移动k步，如果碰到边界就不动</li><li>R K：所有棋子同时向右移动k步，如果碰到边界就不动</li><li>U K：所有棋子同时向上移动k步，如果碰到边界就不动</li><li>D K：所有棋子同时向下移动k步，如果碰到边界就不动</li><li>询问初始第i个棋子现在的位置</li><li>询问有多少对棋子现在在同一个位置上</li></ul><p>$n \leq 3\times 10^5$<br>这种二维问题，一个想法就是行列分离做，这边显然也可以行列分离转成一维去思考<br>就考虑所有棋子在一条横轴上，可以同时左右移动k步<br>对于碰到过左边界的棋子，以后就永远在一起了，右边界也是这样<br>第一步左移k，那么1~k的棋子之后就相同了<br>另一个套路是n个棋子一起动不好维护，那么我们去维护边界，左移k，我们让左边界右移k就行了，这样$\leq$左边界的棋子都相当于是在左边界上，这样一来相当于是左右边界不断在向中间靠拢，因为不断移动下去合并的棋子就越来越多了。但是我们维护的并不是真实的左边界坐标，所以还需要维护一个变量d。左移就让d+k，右移就让d-k，则l-k和r-k就是真实的边界了，当然还需要保证真实边界在1~n范围内，因为碰到边界就不动了<br>这样横轴纵轴分别维护就可以解决第一个询问了，对于第二个询问，我们相当于是LRDU四个边界在不断的往中间压缩，由于初始行列均不同，要位于同一个格子，必须同在LR轴中的一个，UD轴的一个，用四个变量LD，LU，RD，RU分别维护一下，注意特判L&#x3D;R，D&#x3D;U的情况。具体维护的话，因为lrud这四个轴都是单调变化的，那么每次移动的时候判断一下当前碰到边界的点即可，注意不要重复统计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, ul, ur, dl, dr;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">ll C[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bound</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, d;</span><br><span class="line">  <span class="type">int</span> p[N], id[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; l = <span class="number">1</span>, r = n, d = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; p[x] = y, id[y] = x; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">movel</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r &amp;&amp; l+d-k&lt;<span class="number">1</span>) <span class="built_in">check</span>(id[++l]);</span><br><span class="line">    <span class="keyword">if</span>(l+d-k&gt;=<span class="number">1</span>) d -= k;</span><br><span class="line">    <span class="keyword">else</span> d = <span class="number">1</span> - l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mover</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r &amp;&amp; r+d+k&gt;n) <span class="built_in">check</span>(id[--r]);</span><br><span class="line">    <span class="keyword">if</span>(r+d+k&lt;=n) d += k;</span><br><span class="line">    <span class="keyword">else</span> d = n - r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[k]&lt;=l) <span class="keyword">return</span> l + d;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p[k]&gt;=r) <span class="keyword">return</span> r + d;</span><br><span class="line">    <span class="keyword">return</span> p[k] + d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;lr, ud;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(vis[id]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(lr.p[id]&lt;=lr.l &amp;&amp; ud.p[id]&lt;=ud.l) ul++, vis[id] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(lr.p[id]&lt;=lr.l &amp;&amp; ud.p[id]&gt;=ud.r) dl++, vis[id] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(lr.p[id]&gt;=lr.r &amp;&amp; ud.p[id]&lt;=ud.l) ur++, vis[id] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(lr.p[id]&gt;=lr.r &amp;&amp; ud.p[id]&gt;=ud.r) dr++, vis[id] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lr.l==lr.r &amp;&amp; ud.l==ud.r) <span class="keyword">return</span> C[ul+dl+ur+dr];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(lr.l==lr.r) <span class="keyword">return</span> C[ul+ur] + C[dl+dr];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ud.l==ud.r) <span class="keyword">return</span> C[ul+dl] + C[ur+dr];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> C[ul] + C[ur] + C[dl] + C[dr];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ul = ur = dl = dr = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">  lr.<span class="built_in">init</span>(n), ud.<span class="built_in">init</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    lr.<span class="built_in">set</span>(i, y); ud.<span class="built_in">set</span>(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">check</span>(lr.id[<span class="number">1</span>]), <span class="built_in">check</span>(lr.id[n]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ud.<span class="built_in">get</span>(k), lr.<span class="built_in">get</span>(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;!&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span>());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;L&#x27;</span>) lr.<span class="built_in">movel</span>(k);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>) lr.<span class="built_in">mover</span>(k);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;U&#x27;</span>) ud.<span class="built_in">movel</span>(k);</span><br><span class="line">      <span class="keyword">else</span> ud.<span class="built_in">mover</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N; i++) C[i] = <span class="number">1ll</span>*i*(i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 695 (Div. 2)</title>
      <link href="/2021/01/09/codeforces-round-695-div-2/"/>
      <url>/2021/01/09/codeforces-round-695-div-2/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>有n个数字，同时从0开始，按照0~9的顺序循环，每一秒变化一次。现在可以暂停某个数字的变化，然后距离它x的数字会在x秒后暂停变化，问所有数字都暂停后的最大数字是多少。<br>显然高位越大越好，发现操作第2个数字后可以使前三位为989，这样必然是最大的</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>给定一个数组a，如果$a_i&lt;a_{i-1},a_i&lt;a_{i+1}$​，或者$a_i&gt;a_{i-1},a_i&gt;a_{i+1}$​，则是坏的三元组，要求你至多修改一个数使坏的三元组个数最少<br>考虑修改一个数，只会影响到以$a_{i-1},a_i,a_{i+1}$​这三个数为中心的三元组，在最优的情况下，$a_i$​的取值必然是$a_{i-2},a_{i-1},a_i,a_{i+1},a_{i+2},inf,-inf$这七种之一，暴力枚举一下（这边没细想，不知道只取$a_{i-1}$​或$a_{i+1}$​行不行）</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>有三个多重集，定义一种操作是，选择某个多重集中的数x，另一个多重集中的数y，然后删除这两个数，把x-y放到x所在的多重集中，让你最大化最后剩下的那个数的值<br>我们可以让x去减掉所有的y，再让z去减掉x，那就相当于只损失了一个x<br>先枚举剩下的那个数在哪个多重集中，必然是让最小的那个数当作x的角色，再考虑怎么去掉同一集合中的其他数t，可以选择另外两个多重集中的最小值mn，然后让t和mn中的较小者充当x的角色，这样损失就是$\min(t,mn)$。<br>所以最小损失就是该多重集的最小值，以及该多重集的次小值和其余两个多重集的最小值中的最小值的和<br>（有点绕。。）</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>一个人初始在1~n的任意一点，然后每次可以向左或者向右走一步，走k步后就形成一条路径$c_0,c_1,…,c_k$​，定义该路径的价值为$\sum_{i&#x3D;0}^k<br>a_{c_i}$​​，求所有不同的路径的价值和，要求支持单点修改$a_i$​<br>先求出$dp_{i,j}$​表示第i步在j的方案数，我们可以发现这个dp的转移正向和反向是相同的，那么到$dp_k$​的时候$dp_{i,j}$​的贡献就相当于$dp_{k-i,j}$​，所以随便维护一下前缀和就可以$O(1)$带修了</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>给一棵带点权的无根树，一个点u作为根是合法的，仅当对于其它任意点v，u到v的路径上的点权均不同<br>可以用换根dp来做<br>固定1为根，先dfs一遍跑出$dp_u$​，表示只考虑u的子树时，以u为根是否合法。这个很简单，只要u的所有儿子v合法，且u的点权在子树中没有出现过即可。<br>再考虑求出$dp2_u$​，表示考虑除去u的子树后的部分，以u为根是否合法。首先u的点权只能在u的子树当中出现，u的父亲fa的点权也只能在u的子树中出现，$dp2_{fa}$​要合法。此外对于fa，除去u点后其余儿子的dp要都是1。满足以上所有条件，$dp2_u$​就是1。<br>最后当$dp_u&#x3D;1$且$dp2_u&#x3D;1$时，表明u是合法的<br>具体实现需要用map启发式合并</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC Central Russia Regional Contest (CRRC 19) gym102780</title>
      <link href="/2021/01/09/icpc-central-russia-regional-contest-crrc-19-gym102780/"/>
      <url>/2021/01/09/icpc-central-russia-regional-contest-crrc-19-gym102780/</url>
      
        <content type="html"><![CDATA[<p>除了两道题没什么人过外比较简单</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>小学数学</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>初中物理</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>模拟题，带一点点推理</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>给定a,b，让你求一个x，满足$a^x&#x3D;x^b$<br>其中$2\leq a,b \leq 10000$<br>容易想到x可以表示$a^t$的形式<br>考虑$t\geq 1$的情况<br>$a^t &#x3D; tb$<br>可以直接暴力枚举t，幂次的增速是迅速的<br>考虑$t\le 1$的情况<br>小数没法枚举了，但是可以找到a的因子d，使得d的幂次&#x3D;a，转而用d的幂次去表示x即可</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>给定一个字符串，两个人轮流操作，每次操作可以选择一种字母，然后删除一个或者二个或者全部，问谁赢。<br>可以把每种字母想成一堆石子，那就是一个只能取1个或2个或全部的NIM游戏，跑一下sg即可，其实直接手推也行</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>一个数n，两个轮流让其减1，减5，或者减13，问谁赢<br>跟F差不多，跑一下dp即可</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p>有一个$n \times n的网格，现在有一个特殊点，然后每次你可以进行三种询问</p><ul><li>询问某个点是不是特殊点</li><li>询问某条线段是否包含特殊点</li><li>询问某个三角形是否包含特殊点</li></ul><p>$n \leq 10^8$，询问次数不超过60<br>看到这个数据范围和询问次数就想到二分，x和y可以分开做，那么我们相当于要通过一次询问判断这个特殊点的坐标是小于x还是大于x。这边有个条件就是询问的点的坐标可以超过n，在$10^9$以内就行，那就很简单了，每次问一个右边的特别大的三角形，保证可以盖住大于x的这块矩形就可以了</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><p>让你用不超过5个数，使得它们的立方和等于x<br>$x\leq 10^{100000}$<br>考虑$(x-1)^3 + (x+1)^3 &#x3D; 2x^3 + 6x$<br>那如果x是6的倍数，让y&#x3D;x&#x2F;6，然后用y-1，y+1，-y, -y这四个数就可以表示出x了<br>其余按照%6讨论一下即可<br>比如x%6&#x3D;2，就先表示出x-8，再加个$2^3$即可</p><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><p>给定n个不同的数，每次可以交换相邻的两个数，问你最少交换几次，使得这n个数先减后增<br>从大到小考虑每个数，最大的数只能放在最左边或者最右边，然后似乎就有种$n^2$的dp了，但是仔细思考可以发现最大的数放在左边还是右边是不影响次大的数的，所以每个数贪心的放就行了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笛卡尔树</title>
      <link href="/2020/12/23/di-qia-er-shu/"/>
      <url>/2020/12/23/di-qia-er-shu/</url>
      
        <content type="html"><![CDATA[<p>类似treap，权值满足二叉搜索树，键值满足堆<br>一般用在序列上，以下标为权值，值为键值，利用单调栈可以$O(n)$建树<br>因为下标是单调递增的，所以只需要在单调栈中维护出最右链，在插入一个新点的时候，不断排掉大于自己值的点，然后自己成为栈顶的右儿子，排掉的最后一个点作其左儿子<br>有什么用呢<br>笛卡尔树上两个点的LCA就代表这个区间的RMQ<br>对一个点，它是其代表的区间的最值，左子树是左区间，右子树是右区间，这就形成了良好的递归性质，可以方便思考和解题</p><h2 id="P4755"><a href="#P4755" class="headerlink" title="P4755"></a>P4755</h2><p>定义点对(i,j)(i,j)(i,j)是好的，当且仅当$a_i*a_j \leq \max(a_i,…,a_j)$<br>显然可以启发式分治做，利用st表找到最值的位置，然后启发式遍历左右区间中小的那一边然后求最值即可。<br>其实这种思想放在笛卡尔树上也是一样的，dfs遍历，然后通过遍历小的那颗子树来统计答案。统计答案可以直接用动态开点线段树，然后线段树合并即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], sz[N];</span><br><span class="line"><span class="type">int64_t</span> ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, cnt;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> rt[N&lt;&lt;<span class="number">5</span>], tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].cnt = t[t[p].l].cnt + t[t[p].r].cnt; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) p = ++tot;</span><br><span class="line">  t[p].cnt++;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(t[p].l, l, mid, x);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">upd</span>(t[p].r, mid+<span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(r&lt;=v) <span class="keyword">return</span> t[p].cnt;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="built_in">ask</span>(t[p].l, l, mid, v);</span><br><span class="line">  <span class="keyword">if</span>(v&gt;mid) ans += <span class="built_in">ask</span>(t[p].r, mid+<span class="number">1</span>, r, v);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    t[x].cnt += t[y].cnt;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  t[x].l = <span class="built_in">merge</span>(t[x].l, t[y].l, l, mid);</span><br><span class="line">  t[x].r = <span class="built_in">merge</span>(t[x].r, t[y].r, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> st[N], ch[N][<span class="number">2</span>], top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    j = top;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;a[st[j]]&lt;a[i]) j--;</span><br><span class="line">    <span class="keyword">if</span>(j) ch[st[j]][<span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;top) ch[i][<span class="number">0</span>] = st[j+<span class="number">1</span>];</span><br><span class="line">    top = j;</span><br><span class="line">    st[++top] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p || l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(ch[p][<span class="number">0</span>], l, p<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">dfs</span>(ch[p][<span class="number">1</span>], p+<span class="number">1</span>, r);</span><br><span class="line">  sz[p] = sz[ch[p][<span class="number">0</span>]] + sz[ch[p][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]&lt;sz[ch[p][<span class="number">1</span>]]) <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=p<span class="number">-1</span>; i++) ans += <span class="built_in">ask</span>(rt[ch[p][<span class="number">1</span>]], <span class="number">1</span>, inf, a[p]/a[i]);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>; i&lt;=r; i++) ans += <span class="built_in">ask</span>(rt[ch[p][<span class="number">0</span>]], <span class="number">1</span>, inf, a[p]/a[i]);</span><br><span class="line">  rt[p] = <span class="built_in">merge</span>(rt[ch[p][<span class="number">0</span>]], rt[ch[p][<span class="number">1</span>]], <span class="number">1</span>, inf);</span><br><span class="line">  <span class="built_in">upd</span>(rt[p], <span class="number">1</span>, inf, a[p]);</span><br><span class="line">  ans += <span class="built_in">ask</span>(rt[p], <span class="number">1</span>, inf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="built_in">build</span>();</span><br><span class="line">  <span class="built_in">dfs</span>(st[<span class="number">1</span>], <span class="number">1</span>, n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客多校3-Sort-the-Strings-Revision"><a href="#牛客多校3-Sort-the-Strings-Revision" class="headerlink" title="牛客多校3 Sort the Strings Revision"></a>牛客多校3 Sort the Strings Revision</h2><p>有一个序列，第i个元素的值为$i % 10$，n次操作，每次将$p_i$​位置的值换成$d_i$​，其中$p_i$​为一个排列，问你操作前后共$n+1$个序列的字典序排名<br>显然越小的$p_i$​越占据主导地位，根据序列p建出笛卡尔树，然后如果$p_i&gt;d_i$​，说明修改后字典序更小，优先遍历右子树，反之优先遍历左子树。<br>有一个问题是如果$p_i&#x3D;d_i$​，此时就不知道左右子树哪个小了，可以人为的先让这样的$p_i$​取一个极大值，这样这些$p_i$​只可能在叶子节点了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, base = <span class="number">10000019</span>;</span><br><span class="line"><span class="type">int</span> n, p[N], d[N];</span><br><span class="line"><span class="type">int</span> st[N], ch[N][<span class="number">2</span>], rk[N], top, rnk;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) ch[i][<span class="number">0</span>] = ch[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    j = top;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; a[st[j]]&gt;a[i]) j--;</span><br><span class="line">    <span class="keyword">if</span>(j) ch[st[j]][<span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;top) ch[i][<span class="number">0</span>] = st[j+<span class="number">1</span>];</span><br><span class="line">    top = j;</span><br><span class="line">    st[++top] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r || p[rt]==mod)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) rk[i] = rnk++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p[rt]%<span class="number">10</span>&gt;d[rt]) <span class="built_in">dfs</span>(ch[rt][<span class="number">1</span>], rt+<span class="number">1</span>, r), <span class="built_in">dfs</span>(ch[rt][<span class="number">0</span>], l, rt);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">dfs</span>(ch[rt][<span class="number">0</span>], l, rt), <span class="built_in">dfs</span>(ch[rt][<span class="number">1</span>], rt+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> pseed, pa, pb, pmod;</span><br><span class="line">  <span class="type">int</span> dseed, da, db, dmod;</span><br><span class="line">  rnk = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;pseed, &amp;pa, &amp;pb, &amp;pmod);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;dseed, &amp;da, &amp;db, &amp;dmod);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) p[i] = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">swap</span>(p[pseed%(i+<span class="number">1</span>)], p[i]);</span><br><span class="line">    pseed = (<span class="number">1ll</span>*pseed*pa + pb)%pmod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    d[i] = dseed%<span class="number">10</span>;</span><br><span class="line">    dseed = (<span class="number">1ll</span>*dseed*da + db)%dmod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(d[i]==p[i]%<span class="number">10</span>) p[i] = mod;</span><br><span class="line">  <span class="built_in">build</span>(p);</span><br><span class="line">  <span class="type">int</span> rt = st[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">dfs</span>(rt, <span class="number">0</span>, n);</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, pw = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ans = (ans + <span class="number">1ll</span>*rk[i]*pw%mod)%mod;</span><br><span class="line">    pw = <span class="number">1ll</span>*pw*base%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛74</title>
      <link href="/2020/12/22/niu-ke-lian-xi-sai-74/"/>
      <url>/2020/12/22/niu-ke-lian-xi-sai-74/</url>
      
        <content type="html"><![CDATA[<p>ABCD都很一眼</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>看到题也想到思路了，然而写法复杂了，加上写错一个地方，再加上出题人数据范围不给下限，正整数包含0可还行，写了一个多小时<br>给定一个联通简单无向图，定义一种操作是，随机选择两个不同的点，将他们之间最短路径上的所有点都变成黑色，问你操作k次后黑色点的个数的期望<br>$n \leq 500$<br>思路很简单，考虑每个点变黑的概率是多少，一次操作变黑，就是枚举有多少对点，它们之间存在一条最短路经过该点。然后这题就没了<br>先跑一遍floyd，然后枚举i,j,k，如果dik+dkj&#x3D;dijd_{ik}+d_{kj}&#x3D;d_{ij}dik​+dkj​&#x3D;dij​，说明i和j的最短路中有k<br>我写复杂了，考虑以每个点为根的最短路径图，固定选根，那么要让第i个点变黑，就必须选择第i个点的后继可达点（最短路径图是个DAG，拓扑排序+bitset，复杂度其实有点炸，不过题目数据w存在0，这时候就不是DAG了，这做法就挂了）<br>另外我竟然在初始化时写出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G[i][j] = (i^j)*inf</span><br></pre></td></tr></table></figure><p>没多想把i!&#x3D;j改成了i^j，蠢了</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>一个n个节点的树，对其染至多m种颜色，定义一颗树是好的，当且仅当存在一条链使得端点是同色，且除端点外存在一个点与端点不同色。问染色方案数的期望（树的形态任意）<br>$n \leq 10^7 m \leq 10^7$<br>存在问题转成反问题，每条链都不合法，要么整条链同色，要么都不同色， <del>然后就不会了</del><br>按照dfs序来dp<br>$dp_{ij}$​表示考虑到dfs序为i的点时，已经染了j种颜色，且整棵树不合法<br>则$dp_{ij} &#x3D; dp_{i-1j} + dp_{i-1j-1}(m-j+1)$<br>要么和父亲同色，要么选择一种没出现过的颜色<br>容易发现所有形态树的染色方案树是相同的，所以答案等价于求一棵树的染色方案数<br>考虑这个式子的组合意义，就是i个有标号球，m个有标号盒子，然后放入其中的j个的方案数<br>可以直接求出来是$\binom{m}{j}\binom{i-1}{j-1}先从m个盒子里选j个，然后这j个任意排列，之后就是个隔板法了<br>最后的答案就是$m^n - \sum_{i&#x3D;1}^m dp_{ni}$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构模板整合</title>
      <link href="/2020/12/16/shu-ju-jie-gou-mo-ban-zheng-he/"/>
      <url>/2020/12/16/shu-ju-jie-gou-mo-ban-zheng-he/</url>
      
        <content type="html"><![CDATA[<h2 id="替罪羊树"><a href="#替罪羊树" class="headerlink" title="替罪羊树"></a>替罪羊树</h2><p>维护权值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> alpha = <span class="number">0.7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> val, sz, cnt;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + t[p].cnt; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bad</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> t[p].cnt &amp;&amp; t[p].sz*alpha&lt;<span class="built_in">max</span>(t[t[p].ls].sz, t[t[p].rs].sz); &#125;</span><br><span class="line"><span class="type">int</span> ord[N], top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(t[p].ls);</span><br><span class="line">  <span class="keyword">if</span>(t[p].cnt) ord[++top] = p;</span><br><span class="line">  <span class="built_in">dfs</span>(t[p].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, p = ord[mid];</span><br><span class="line">  t[p].ls = <span class="built_in">build</span>(l, mid<span class="number">-1</span>);</span><br><span class="line">  t[p].rs = <span class="built_in">build</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(p);</span><br><span class="line">  p = <span class="built_in">build</span>(<span class="number">1</span>, top);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = ++tot;</span><br><span class="line">  t[p].val = v, t[p].ls = t[p].rs = <span class="number">0</span>;</span><br><span class="line">  t[p].cnt = t[p].sz = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="built_in">newnode</span>(p, v);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v==t[p].val) t[p].cnt++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="built_in">ins</span>(t[p].ls, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">ins</span>(t[p].rs, v);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bad</span>(p)) <span class="built_in">rebuild</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v==t[p].val) t[p].cnt--;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="built_in">del</span>(t[p].ls, v);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">del</span>(t[p].rs, v);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">bad</span>(p)) <span class="built_in">rebuild</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Less</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v, <span class="type">bool</span> eq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].cnt&amp;&amp;v==t[p].val) <span class="keyword">return</span> t[t[p].ls].sz + t[p].cnt*eq;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="keyword">return</span> <span class="built_in">Less</span>(t[p].ls, v, eq);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> t[t[p].ls].sz + t[p].cnt + <span class="built_in">Less</span>(t[p].rs, v, eq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].ls, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(t[t[p].ls].sz+t[p].cnt&gt;=k) <span class="keyword">return</span> t[p].val;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].rs, k-t[p].cnt-t[t[p].ls].sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fhq-treap"><a href="#fhq-treap" class="headerlink" title="fhq treap"></a>fhq treap</h2><p>维护区间的（按size分裂），带有up、down以及fa的维护</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>|<span class="built_in">rand</span>(); &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> fa, key, sz;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = ++tot;</span><br><span class="line">  t[p].ls = t[p].rs = t[p].fa = <span class="number">0</span>;</span><br><span class="line">  t[p].key = <span class="built_in">rnd</span>();</span><br><span class="line">  t[p].sz = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> k, <span class="type">int</span> fx=<span class="number">0</span>, <span class="type">int</span> fy=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123; x = y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz)</span><br><span class="line">  &#123;</span><br><span class="line">    y = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].ls, x, t[p].ls, k, fx, p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    x = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].rs, t[p].rs, y, k-t[t[p].ls].sz<span class="number">-1</span>, p, fy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x) t[x].fa = fx;</span><br><span class="line">  <span class="keyword">if</span>(y) t[y].fa = fy;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) &#123; p = x|y; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">down</span>(x);</span><br><span class="line">    p = x;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].rs, t[p].rs, y);</span><br><span class="line">    t[t[p].rs].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">down</span>(y);</span><br><span class="line">    p = y;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].ls, x, t[p].ls);</span><br><span class="line">    t[t[p].ls].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downall</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">downall</span>(t[p].fa);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">downall</span>(p);</span><br><span class="line">  <span class="type">int</span> rk = t[t[p].ls].sz + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(t[p].fa)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t[t[p].fa].rs==p) rk += t[t[p].fa].sz - t[p].sz;</span><br><span class="line">    p = t[p].fa;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].ls, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k==t[t[p].ls].sz+<span class="number">1</span>) <span class="keyword">return</span> t[p].c;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].rs, k-t[t[p].ls].sz<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="splay"><a href="#splay" class="headerlink" title="splay"></a>splay</h2><p>维护区间，注意及时up，只需要在kth中down即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rt;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], sz[N], fa[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> l = ch[p][<span class="number">0</span>], r = ch[p][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> p = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  sz[p] = <span class="number">1</span>, fa[p] = f, ch[f][p&gt;f] = p;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">build</span>(l, p<span class="number">-1</span>, p); <span class="built_in">build</span>(p+<span class="number">1</span>, r, p);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x];</span><br><span class="line">    <span class="keyword">if</span>(fa[y]!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l<span class="number">-1</span>), y = <span class="built_in">kth</span>(rt, r+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="keyword">return</span> ch[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h2><p>维护边权：拆点<br>维护边双：每次加边，如果两端点已经连通，则用并查集缩起来，然后在access的时候，x&#x3D;fa[x]&#x3D;find(fa[x])</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], fa[N], rev[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">notrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>]==x || ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">swap</span>(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">  rev[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(rev[x])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">0</span>]) <span class="built_in">reverse</span>(ch[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">1</span>]) <span class="built_in">reverse</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushall</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">notrt</span>(x)) <span class="built_in">pushall</span>(fa[x]);</span><br><span class="line">  <span class="built_in">down</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">notrt</span>(y)) ch[z][ch[z][<span class="number">1</span>]==y] = x;</span><br><span class="line">    ch[y][k] = ch[x][!k]; fa[ch[x][!k]] = y;</span><br><span class="line">    ch[x][!k] = y, fa[y] = x, fa[x] = z;</span><br><span class="line">    <span class="built_in">up</span>(y), <span class="built_in">up</span>(x), <span class="built_in">up</span>(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pushall</span>(x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> f=fa[x]; f=fa[x], <span class="built_in">notrt</span>(x); <span class="built_in">rotate</span>(x))</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">notrt</span>(f)) <span class="built_in">rotate</span>(<span class="built_in">rs</span>(x) == <span class="built_in">rs</span>(f) ? f : x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; x; y=x, x=fa[x])</span><br><span class="line">    <span class="built_in">splay</span>(x), ch[x][<span class="number">1</span>] = y, <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">  <span class="built_in">reverse</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findrt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">  <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) <span class="built_in">down</span>(x), x = ch[x][<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">splay</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">makert</span>(x);</span><br><span class="line">  <span class="built_in">access</span>(y); <span class="built_in">splay</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">makert</span>(x);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">findrt</span>(y)!=x) fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">makert</span>(x);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">findrt</span>(y)==x&amp;&amp;fa[y]==x&amp;&amp;!ch[y][<span class="number">0</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    fa[y] = ch[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">up</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2174729</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span> &#123; <span class="type">int</span> next, v; ull k; &#125;e[M+<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> head[M], st[N], tp, sz;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(ull k)</span> </span>&#123; <span class="keyword">return</span> k % M; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; sz = <span class="number">0</span>; <span class="keyword">while</span>(tp) head[st[tp--]] = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(ull k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">f</span>(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = head[t]; p; p = e[p].next)</span><br><span class="line">      <span class="keyword">if</span>(e[p].k==k) <span class="keyword">return</span> e[p].v;</span><br><span class="line">    ++sz;</span><br><span class="line">    e[sz] = &#123;head[t], sz, k&#125;;</span><br><span class="line">    head[t] = sz; st[++tp] = t;</span><br><span class="line">    <span class="keyword">return</span> sz;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希set</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HashSet</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span> &#123; <span class="type">int</span> next; ull k; &#125;e[M+<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> head[M], st[N], tp, sz;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(ull k)</span> </span>&#123; <span class="keyword">return</span> k % M; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; sz = <span class="number">0</span>; <span class="keyword">while</span>(tp) head[st[tp--]] = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(ull k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = head[<span class="built_in">f</span>(k)]; p; p = e[p].next)</span><br><span class="line">      <span class="keyword">if</span>(e[p].k==k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(ull k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">get</span>(k)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">f</span>(k);</span><br><span class="line">    e[++sz] = &#123;head[t], k&#125;;</span><br><span class="line">    head[t] = sz; st[++tp] = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>gp_hash</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">custom_hash</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">uint64_t</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> FIXED_RANDOM = chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">return</span> x + FIXED_RANDOM;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">custom_hash</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">splitmix64</span><span class="params">(<span class="type">uint64_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// http://xorshift.di.unimi.it/splitmix64.c</span></span><br><span class="line">    x += <span class="number">0x9e3779b97f4a7c15</span>;</span><br><span class="line">    x = (x ^ (x &gt;&gt; <span class="number">30</span>)) * <span class="number">0xbf58476d1ce4e5b9</span>;</span><br><span class="line">    x = (x ^ (x &gt;&gt; <span class="number">27</span>)) * <span class="number">0x94d049bb133111eb</span>;</span><br><span class="line">    <span class="keyword">return</span> x ^ (x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">uint64_t</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> FIXED_RANDOM = chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">splitmix64</span>(x + FIXED_RANDOM);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">gp_hash_table&lt;ull, <span class="type">int</span>, custom_hash&gt;</span><br><span class="line">gp_hash_table&lt;ull, <span class="type">bool</span>&gt;</span><br><span class="line">gp_hash_table&lt;ull, null_type&gt;</span><br></pre></td></tr></table></figure><p>bitset压位(64位和32位速度差不多)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bitset</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> uint = <span class="type">uint32_t</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">32</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> uint up = numeric_limits&lt;uint&gt;::<span class="built_in">max</span>();</span><br><span class="line">  vector&lt;uint&gt; b; <span class="type">int</span> sz;</span><br><span class="line">  <span class="built_in">Bitset</span>(<span class="type">int</span> _sz=<span class="number">0</span>) &#123; sz = _sz; b.<span class="built_in">resize</span>((sz+B<span class="number">-1</span>)/B, <span class="number">0</span>); &#125;</span><br><span class="line">  Bitset <span class="keyword">operator</span> | (<span class="type">const</span> Bitset &amp;oth) <span class="type">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Bitset <span class="title">res</span><span class="params">(sz)</span></span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i+<span class="number">3</span>&lt;(<span class="type">int</span>)b.<span class="built_in">size</span>(); i+=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      res.b[i] = b[i] | oth.b[i];</span><br><span class="line">      res.b[i+<span class="number">1</span>] = b[i+<span class="number">1</span>] | oth.b[i+<span class="number">1</span>];</span><br><span class="line">      res.b[i+<span class="number">2</span>] = b[i+<span class="number">2</span>] | oth.b[i+<span class="number">2</span>];</span><br><span class="line">      res.b[i+<span class="number">3</span>] = b[i+<span class="number">3</span>] | oth.b[i+<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;(<span class="type">int</span>)b.<span class="built_in">size</span>())</span><br><span class="line">      res.b[i] = b[i] | oth.b[i], i++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; b[p/B] |= (<span class="number">1ull</span>&lt;&lt;(p%B)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; b[p/B] &amp;= (up^(<span class="number">1ull</span>&lt;&lt;(p%B))); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setv</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>&#123; (v ? <span class="built_in">set</span>(p) : <span class="built_in">reset</span>(p)); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(uint x, <span class="type">int</span> bit)</span> </span>&#123; <span class="keyword">return</span> (x&gt;&gt;bit)&amp;<span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getf0</span><span class="params">(uint x)</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;B; i++) <span class="keyword">if</span>(!<span class="built_in">get</span>(x, i)) <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getf1</span><span class="params">(uint x)</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;B; i++) <span class="keyword">if</span>(<span class="built_in">get</span>(x, i)) <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getl0</span><span class="params">(uint x)</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=B<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) <span class="keyword">if</span>(!<span class="built_in">get</span>(x, i)) <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getl1</span><span class="params">(uint x)</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=B<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) <span class="keyword">if</span>(<span class="built_in">get</span>(x, i)) <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findr0</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = x/B, q = x%B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q; i&lt;B; i++) <span class="keyword">if</span>(!<span class="built_in">get</span>(b[p], i)) <span class="keyword">return</span> x+i-q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>; i&lt;(<span class="type">int</span>)b.<span class="built_in">size</span>(); i++)</span><br><span class="line">      <span class="keyword">if</span>(b[i]!=up) <span class="keyword">return</span> x+B<span class="number">-1</span>-q+(i-p<span class="number">-1</span>)*B+<span class="built_in">getf0</span>(b[i])+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sz + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findr1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = x/B, q = x%B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q; i&lt;B; i++) <span class="keyword">if</span>(<span class="built_in">get</span>(b[p], i)) <span class="keyword">return</span> x+i-q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>; i&lt;(<span class="type">int</span>)b.<span class="built_in">size</span>(); i++)</span><br><span class="line">      <span class="keyword">if</span>(b[i]) <span class="keyword">return</span> x+B<span class="number">-1</span>-q+(i-p<span class="number">-1</span>)*B+<span class="built_in">getf1</span>(b[i])+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sz + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findl0</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = x/B, q = x%B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q; i&gt;=<span class="number">0</span>; i--) <span class="keyword">if</span>(!<span class="built_in">get</span>(b[p], i)) <span class="keyword">return</span> x+i-q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span>(b[i]!=up) <span class="keyword">return</span> x-q-(p<span class="number">-1</span>-i)*B-(B-<span class="built_in">getl0</span>(b[i]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findl1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = x/B, q = x%B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q; i&gt;=<span class="number">0</span>; i--) <span class="keyword">if</span>(<span class="built_in">get</span>(b[p], i)) <span class="keyword">return</span> x+i-q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span>(b[i]) <span class="keyword">return</span> x-q-(p<span class="number">-1</span>-i)*B-(B-<span class="built_in">getl1</span>(b[i]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Honorable Mention 平衡树+树状数组</title>
      <link href="/2020/12/13/honorable-mention-ping-heng-shu-shu-zhuang-shu-zu/"/>
      <url>/2020/12/13/honorable-mention-ping-heng-shu-shu-zhuang-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>给定一个排列$p_i$​，表示第i个人的排名，要求支持两种操作：</p><ul><li>第x个人的排名上升到y，显然原来y~rank(x)-1的人的排名就要下降1</li><li>问第x到第y个人中有多少人的排名在后40%</li></ul><p>我们发现第一个操作需要以排名为下标进行维护，而第二个操作又需要以编号为下标进行维护。似乎不太可做。<br>但是仔细想想，对于后40%，我们并不关心谁在前谁在后，我们只需要知道哪些人是在后40%<br>那么用一个树状数组，以编号为下标维护哪些人是后40%<br>然后用一个平衡树，以排名为下标来维护第一个操作。<br>当x的排名原先在后40%，然后提升后不再后40%，就需要对树状数组的x-1，然后对原来排名40%的那个在树状数组中+1。然后只需要将x这个节点删掉，再插到排名为y节点的前面就可以了。<br>还有一个问题，x的排名怎么求，我们以排名为下标怎么求排名呢。<br>容易发现对于每个编号在平衡树中的节点是一一对应的，所以我们用数组保存x是平衡树中的哪个节点，然后把它splay到根，则左儿子的size+1就是排名了。<br>最后不要忘记在splay中前后各插入一个哨兵！！</p><pre><code class="cpp">    #include &lt;bits/stdc++.h&gt;    using namespace std;    const int N = 5e4 + 5;    int n, q, p[N], rp[N];    int c[N];    void upd(int x, int v)    &#123;        for(int i=x; i&lt;=n; i+=(i&amp;-i)) c[i] += v;    &#125;    int ask(int x)    &#123;        int ans = 0;        for(int i=x; i&gt;0; i-=(i&amp;-i)) ans += c[i];        return ans;    &#125;    int rt;    int ch[N][2], sz[N], val[N], fa[N], id[N];    bool rs(int x) &#123; return ch[fa[x]][1]==x; &#125;    void up(int p) &#123; if(p) sz[p] = sz[ch[p][0]] + sz[ch[p][1]] + 1; &#125;    void bld(int l, int r, int f)    &#123;        if(l&gt;r) return;        int p = (l+r)&gt;&gt;1;        sz[p] = 1;        ch[p][0] = ch[p][1] = 0;        if(p&gt;=2&amp;&amp;p&lt;=n+1)        &#123;            val[p] = rp[p-1];            id[rp[p-1]] = p;        &#125;        fa[p] = f, ch[f][p&gt;f] = p;        if(l==r) return;        bld(l, p-1, p); bld(p+1, r, p);        up(p);    &#125;    void rotate(int x)    &#123;        int y = fa[x], z = fa[y], k = rs(x), w = ch[x][k^1];        ch[y][k] = w; fa[w] = y;        ch[z][rs(y)] = x; fa[x] = z;        ch[x][k^1] = y; fa[y] = x;        up(y); up(x);    &#125;    void splay(int x, int g=0)    &#123;        while(fa[x]!=g)        &#123;            int y = fa[x];            if(fa[y]!=g) (rs(x)==rs(y) ? rotate(y) : rotate(x));            rotate(x);        &#125;        if(!g) rt = x;    &#125;    int kth(int p, int k)    &#123;        if(ch[p][0]&amp;&amp;sz[ch[p][0]]&gt;=k) return kth(ch[p][0], k);        else if(sz[ch[p][0]]+1==k) return p;        else return kth(ch[p][1], k-sz[ch[p][0]]-1);    &#125;    int rnk(int p)    &#123;        splay(p);        return sz[ch[p][0]] + 1;    &#125;    void ins(int l, int r)    &#123;        int x = kth(rt, l-1), y = kth(rt, l+1);        splay(x); splay(y, x);        int z = ch[y][0];        ch[y][0] = 0; fa[z] = 0;        up(y); up(fa[y]);        int x2 = kth(rt, r-1), y2 = kth(rt, r);        splay(x2); splay(y2, x2);        ch[y2][0] = z; fa[z] = y2;        up(y2); up(fa[y2]);    &#125;    void solve()    &#123;        scanf(&quot;%d&quot;, &amp;n);        for(int i=1; i&lt;=n; i++)        &#123;            scanf(&quot;%d&quot;, p+i);            rp[p[i]] = i;        &#125;        scanf(&quot;%d&quot;, &amp;q);        int lim = n*0.6;        for(int i=1; i&lt;=n; i++) c[i] = 0;        for(int i=lim+1; i&lt;=n; i++) upd(rp[i], 1);        bld(1, n+2, 0);        rt = (n+3)&gt;&gt;1;        while(q--)        &#123;            int op, x, y; scanf(&quot;%d%d%d&quot;, &amp;op, &amp;x, &amp;y);            if(op==1)            &#123;                if(y&lt;=lim)                &#123;                    int rkx = rnk(id[x]) - 1;                    if(rkx&gt;lim)                    &#123;                        upd(x, -1);                        upd(val[kth(rt, lim+1)], 1);                    &#125;                    ins(rkx+1, y+1);                &#125;            &#125;            else printf(&quot;%d\n&quot;, ask(y)-ask(x-1));        &#125;    &#125;    int main()    &#123;        int _; scanf(&quot;%d&quot;, &amp;_);        while(_--) solve();        return 0;    &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rope 块状链表实现的STL容器</title>
      <link href="/2020/12/13/rope-kuai-zhuang-lian-biao-shi-xian-de-stl-rong-qi/"/>
      <url>/2020/12/13/rope-kuai-zhuang-lian-biao-shi-xian-de-stl-rong-qi/</url>
      
        <content type="html"><![CDATA[<p>crope &#x3D; rope（可以直接cin cout）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br></pre></td></tr></table></figure><p>可以较快速的解决区间移动、区间插入删除、区间翻转问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rp.<span class="built_in">push_back</span>(x); <span class="comment">// 在末尾插入 x</span></span><br><span class="line">rp.<span class="built_in">insert</span>(pos, x); <span class="comment">// 从pos 处插入一个数组x</span></span><br><span class="line">rp.<span class="built_in">erase</span>(pos, x); <span class="comment">// 从pos 处删除 x 个元素</span></span><br><span class="line">rp.<span class="built_in">length</span>(); <span class="comment">// 返回 rp 的大小</span></span><br><span class="line">rp.<span class="built_in">size</span>(); <span class="comment">// 同上</span></span><br><span class="line">rp.<span class="built_in">replace</span>(pos, x); <span class="comment">// 将 pos 处的元素替换成 x</span></span><br><span class="line">rp.<span class="built_in">substr</span>(pos, x); <span class="comment">// 从 pos 处开始提取 x 个元素</span></span><br><span class="line">rp.<span class="built_in">copy</span>(pos, x, s); <span class="comment">// 从 pos 处开始复制 x 个元素到 s(string or char*(末尾要手动加0)) 中</span></span><br><span class="line">rp[x]; <span class="comment">// 访问第 x 个元素</span></span><br><span class="line">rp.<span class="built_in">at</span>(x); <span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">operator</span>.+() <span class="comment">//拼接操作，很快速</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line">rope&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,m,k,l;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)s.<span class="built_in">push_back</span>(i);</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;k);</span><br><span class="line">    s=s.<span class="built_in">substr</span>(l<span class="number">-1</span>,k)+s.<span class="built_in">substr</span>(<span class="number">0</span>,l<span class="number">-1</span>)+s.<span class="built_in">substr</span>(l+k<span class="number">-1</span>,n+<span class="number">1</span>-k-l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line">rope&lt;<span class="type">int</span>&gt;a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,m,x,y;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    a.<span class="built_in">insert</span>(<span class="number">0</span>,a.<span class="built_in">substr</span>(x<span class="number">-1</span>,y));</span><br><span class="line">    a.<span class="built_in">erase</span>(x+y<span class="number">-1</span>,y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;a[i];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C、Shuffle Cards 区间移位 splay</title>
      <link href="/2020/12/12/cshuffle-cards-qu-jian-yi-wei-splay/"/>
      <url>/2020/12/12/cshuffle-cards-qu-jian-yi-wei-splay/</url>
      
        <content type="html"><![CDATA[<p>一个序列初始为1-n的排列，现在有m次操作，将一个区间移到最前面。<br>问所有操作结束后的序列是什么</p><p>突然发现没有写过区间平移的问题，然后去找了一道，然后就调了2小时，很难受。</p><p>罗列一下几个易错点：<br>pushup的时候最好特判一下p&#x3D;&#x3D;0，这时候就直接return，否则总感觉容易出问题<br>splay一个不好的地方就是要加哨兵，反正左后各加一个就完事了<br>偷懒把取区间写了个split，然后就导致了一个问题（bug根源）<br>当要提取的区间是一个空区间就会出现奇奇怪怪的问题（插入和删除的时候需要），因为这时候它会返回0，我就没办法维护我本来需要的返回节点的父亲了。<br>所以最好还是不要写split函数了😭</p><p>说一下区间平移怎么做<br>其实就是区间插入问题，先把一个区间提取出来，把这个区间删除掉，然后假设这个节点要插入到p（要注意前面这个区间删除带来的影响）节点的后面，那就把p转到根，p+1转到p的儿子，则把刚才提取的区间插到p+1的左儿子就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> rt;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], sz[N], fa[N], val[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(!x) <span class="keyword">return</span>; sz[x] = sz[ch[x][<span class="number">0</span>]] + sz[ch[x][<span class="number">1</span>]] + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> p = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  sz[p] = <span class="number">1</span>, fa[p] = f, val[p] = p;</span><br><span class="line">  ch[f][p&gt;f] = p;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">build</span>(l, p<span class="number">-1</span>, p), <span class="built_in">build</span>(p+<span class="number">1</span>, r, p);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x];</span><br><span class="line">    <span class="keyword">if</span>(fa[y]!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">go</span>(ch[p][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span>(val[p]&gt;=<span class="number">2</span> &amp;&amp; val[p]&lt;=n+<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, val[p]<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">go</span>(ch[p][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, n+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  rt = (n+<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    ++a;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">kth</span>(rt, <span class="number">1</span>), y = <span class="built_in">kth</span>(rt, a);</span><br><span class="line">    <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">    <span class="type">int</span> z = ch[y][<span class="number">0</span>];</span><br><span class="line">    fa[z] = <span class="number">0</span>;</span><br><span class="line">    ch[y][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">    <span class="type">int</span> tx = <span class="built_in">kth</span>(rt, b+<span class="number">1</span>), ty = <span class="built_in">kth</span>(rt, b+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">splay</span>(tx); <span class="built_in">splay</span>(ty, tx);</span><br><span class="line">    ch[ty][<span class="number">0</span>] = z;</span><br><span class="line">    fa[z] = ty;</span><br><span class="line">    <span class="built_in">up</span>(ty); <span class="built_in">up</span>(fa[ty]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">go</span>(rt);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2042 [NOI2005]维护数列</title>
      <link href="/2020/12/11/p2042-noi2005wei-hu-shu-lie/"/>
      <url>/2020/12/11/p2042-noi2005wei-hu-shu-lie/</url>
      
        <content type="html"><![CDATA[<p>大毒瘤题<br>区间插入，区间删除，区间覆盖，区间翻转，区间和，区间最大子段和</p><p>只说一下splay的话，区间插入和删除怎么做<br>插入：先把插入的所有节点按照中序遍历建成一棵平衡树，然后把l转到根，l+1转到l的儿子，那么直接把这颗平衡树的根作为l+1的左儿子即可<br>删除：同样的，把l-1转到根，r+1转到l-1的儿子，然后直接把r的左儿子变成0即可。这道题操作比较多，需要考虑空间回收。很简单，只要把这课丢掉的树遍历一下每个节点的编号塞到一个数组中，然后每次新开节点的时候，如果数组中有编号就直接取一个，否则再新开节点，不过复用节点要注意信息的清空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e6</span> + <span class="number">5</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], id[N];</span><br><span class="line"><span class="type">int</span> buc[N], tp;</span><br><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (tp ? buc[tp--] : ++tot); &#125;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], sz[N], val[N], sum[N], mx[N], lx[N], rx[N], fa[N];</span><br><span class="line"><span class="type">bool</span> same[N], rev[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> l = ch[p][<span class="number">0</span>], r = ch[p][<span class="number">1</span>];</span><br><span class="line">  sum[p] = sum[l] + sum[r] + val[p];</span><br><span class="line">  sz[p] = sz[l] + sz[r] + <span class="number">1</span>;</span><br><span class="line">  mx[p] = <span class="built_in">max</span>(&#123;mx[l], mx[r], rx[l]+lx[r]+val[p]&#125;);</span><br><span class="line">  lx[p] = <span class="built_in">max</span>(lx[l], sum[l]+val[p]+lx[r]);</span><br><span class="line">  rx[p] = <span class="built_in">max</span>(rx[r], sum[r]+val[p]+rx[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setv</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  val[p] = v, sum[p] = v*sz[p];</span><br><span class="line">  lx[p] = rx[p] = (sum[p]&gt;<span class="number">0</span> ? sum[p] : <span class="number">0</span>);</span><br><span class="line">  mx[p] = (sum[p]&gt;<span class="number">0</span> ? sum[p] : val[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setrev</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">swap</span>(ch[p][<span class="number">0</span>], ch[p][<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">swap</span>(lx[p], rx[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = ch[p][<span class="number">0</span>], r = ch[p][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(same[p])</span><br><span class="line">  &#123;</span><br><span class="line">    same[l] = <span class="number">1</span>, <span class="built_in">setv</span>(l, val[p]);</span><br><span class="line">    same[r] = <span class="number">1</span>, <span class="built_in">setv</span>(r, val[p]);</span><br><span class="line">    same[p] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(rev[p])</span><br><span class="line">  &#123;</span><br><span class="line">    rev[l] ^= <span class="number">1</span>, <span class="built_in">setrev</span>(l);</span><br><span class="line">    rev[r] ^= <span class="number">1</span>, <span class="built_in">setrev</span>(r);</span><br><span class="line">    rev[p] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x], z = fa[y];</span><br><span class="line">    <span class="keyword">if</span>(z!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l<span class="number">-1</span>), y = <span class="built_in">kth</span>(rt, r+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="keyword">return</span> ch[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makesame</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setv</span>(x, v), same[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setrev</span>(x), rev[x] ^= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rec</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> l = ch[x][<span class="number">0</span>], r = ch[x][<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">rec</span>(l); <span class="built_in">rec</span>(r);</span><br><span class="line">  buc[++tp] = x;</span><br><span class="line">  fa[x] = ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = <span class="number">0</span>, rev[x] = same[x] = <span class="number">0</span>;</span><br><span class="line">  sz[x] = val[x] = sum[x] = mx[x] = lx[x] = rx[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">rec</span>(ch[y][<span class="number">0</span>]); ch[y][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bld</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, p = id[mid];</span><br><span class="line">  val[p] = a[mid];</span><br><span class="line">  <span class="keyword">if</span>(f) fa[p] = id[f], ch[id[f]][mid&gt;f] = p;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    mx[p] = sum[p] = a[l];</span><br><span class="line">    same[p] = rev[p] = <span class="number">0</span>;</span><br><span class="line">    lx[p] = rx[p] = <span class="built_in">max</span>(a[l], <span class="number">0</span>);</span><br><span class="line">    sz[p] = <span class="number">1</span>;</span><br><span class="line">    ch[p][<span class="number">0</span>] = ch[p][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bld</span>(l, mid<span class="number">-1</span>, mid);</span><br><span class="line">  <span class="built_in">bld</span>(mid+<span class="number">1</span>, r, mid);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=r-l+<span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    id[i] = <span class="built_in">newnode</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bld</span>(<span class="number">1</span>, r-l+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l), y = <span class="built_in">kth</span>(rt, l+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="type">int</span> z = id[(r-l+<span class="number">2</span>)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">  fa[z] = y, ch[y][<span class="number">0</span>] = z;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  mx[<span class="number">0</span>] = -inf, a[<span class="number">1</span>] = -inf, a[n+<span class="number">2</span>] = inf;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i+<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n+<span class="number">2</span>; i++) id[i] = <span class="built_in">newnode</span>();</span><br><span class="line">  <span class="built_in">bld</span>(<span class="number">1</span>, n+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  rt = (n+<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> com[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, com);</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]!=<span class="string">&#x27;M&#x27;</span>||com[<span class="number">2</span>]!=<span class="string">&#x27;X&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    ++l, r = l + r - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>) <span class="built_in">ins</span>(l, r);</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>) <span class="built_in">del</span>(l, r);</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(com[<span class="number">2</span>]==<span class="string">&#x27;X&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mx[<span class="built_in">split</span>(<span class="number">2</span>, sz[rt]<span class="number">-1</span>)]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">        <span class="built_in">makesame</span>(l, r, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>) <span class="built_in">reverse</span>(l, r);</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;G&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum[<span class="built_in">split</span>(l, r)]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3215 [HNOI2011]括号修复 / [JSOI2011]括号序列</title>
      <link href="/2020/12/11/p3215-hnoi2011gua-hao-xiu-fu-jsoi2011gua-hao-xu-lie/"/>
      <url>/2020/12/11/p3215-hnoi2011gua-hao-xiu-fu-jsoi2011gua-hao-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>给定一个括号序列，要求支持下面的操作</p><ul><li>替换某个区间的所有括号为左括号或者右括号</li><li>将一个区间的括号进行翻转</li><li>将一个区间的括号进行反转，左括号&lt;-&gt;右括号</li><li>询问一个区间内至少改变几个括号才能成为一个合法的括号序列</li></ul><p>毒瘤题<br>不过我连询问的答案是什么都想错了（好菜啊）<br>先消掉合法的括号，最后肯定是))))((((的形式，维护区间前缀最小和后缀最大即可，由于有反转操作还要维护区间前缀最大和后缀最小。<br>感觉自己对平衡树维护的题还是不熟，每次都一堆错误。<br>最主要的问题就是忘记了本节点信息，主要是线段树的信息完全由子节点合并而来，但是在平衡树中本节点的信息是不包含在子节点中的。此外在建树的时候每个节点的信息都要记录下来，而不是像线段树一样只在叶子节点的时候记录，然后其余节点直接通过pushup得到即可，切记！！<br>然后就是下传标记的问题，主要是反转和覆盖操作的先后顺序会有影响，然后我竟然就不会了（不是和加法乘法一样吗， <del>好久没写了</del> ）<br>在覆盖的时候，可以把反转和翻转的标记清零。<br>在反转的时候，需要把覆盖的标记取反。<br>然后下传的时候先传反转，然后再传覆盖，因为这个时候肯定是先有反转再有覆盖的，否则覆盖会把反转的标记清掉。<br>顺便回忆一下加法和乘法标记，在乘法的时候要把加法标记也乘一下，在下传的时候先传乘法再传加法。<br>这种多标记的问题，最好对每个标记写一个函数，否则会很乱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">char</span> c[N];</span><br><span class="line"><span class="type">int</span> rt;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>], sz[N], val[N], fa[N], lmn[N], rmn[N], lmx[N], rmx[N], sum[N];</span><br><span class="line"><span class="type">int</span> rev[N], cov[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> l = ch[p][<span class="number">0</span>], r = ch[p][<span class="number">1</span>];</span><br><span class="line">  sz[p] = sz[l] + sz[r] + <span class="number">1</span>;</span><br><span class="line">  lmn[p] = <span class="built_in">min</span>(lmn[l], sum[l]+val[p]+lmn[r]);</span><br><span class="line">  lmx[p] = <span class="built_in">max</span>(lmx[l], sum[l]+val[p]+lmx[r]);</span><br><span class="line">  rmn[p] = <span class="built_in">min</span>(rmn[r], sum[r]+val[p]+rmn[l]);</span><br><span class="line">  rmx[p] = <span class="built_in">max</span>(rmx[r], sum[r]+val[p]+rmx[l]);</span><br><span class="line">  sum[p] = sum[l] + sum[r] + val[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setv</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  val[p] = v, sum[p] = v*sz[p];</span><br><span class="line">  lmn[p] = rmn[p] = <span class="built_in">min</span>(<span class="number">0</span>, sum[p]);</span><br><span class="line">  lmx[p] = rmx[p] = <span class="built_in">max</span>(<span class="number">0</span>, sum[p]);</span><br><span class="line">  cov[p] = v;</span><br><span class="line">  inv[p] = <span class="number">0</span>;</span><br><span class="line">  rev[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setrev</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">swap</span>(ch[p][<span class="number">0</span>], ch[p][<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">swap</span>(lmn[p], rmn[p]);</span><br><span class="line">  <span class="built_in">swap</span>(lmx[p], rmx[p]);</span><br><span class="line">  rev[p] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setinv</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">swap</span>(lmn[p], lmx[p]);</span><br><span class="line">  <span class="built_in">swap</span>(rmn[p], rmx[p]);</span><br><span class="line">  lmn[p] *= <span class="number">-1</span>;</span><br><span class="line">  lmx[p] *= <span class="number">-1</span>;</span><br><span class="line">  rmn[p] *= <span class="number">-1</span>;</span><br><span class="line">  rmx[p] *= <span class="number">-1</span>;</span><br><span class="line">  sum[p] *= <span class="number">-1</span>;</span><br><span class="line">  val[p] *= <span class="number">-1</span>;</span><br><span class="line">  inv[p] ^= <span class="number">1</span>;</span><br><span class="line">  cov[p] *= <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(inv[p])</span><br><span class="line">  &#123;</span><br><span class="line">    inv[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setinv</span>(ch[p][<span class="number">0</span>]); <span class="built_in">setinv</span>(ch[p][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cov[p])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setv</span>(ch[p][<span class="number">0</span>], cov[p]); <span class="built_in">setv</span>(ch[p][<span class="number">1</span>], cov[p]);</span><br><span class="line">    cov[p] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(rev[p])</span><br><span class="line">  &#123;</span><br><span class="line">    rev[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setrev</span>(ch[p][<span class="number">0</span>]); <span class="built_in">setrev</span>(ch[p][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> p = (l+r)&gt;&gt;<span class="number">1</span>, v = (c[p<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">  sz[p] = <span class="number">1</span>, sum[p] = val[p] = v;</span><br><span class="line">  fa[p] = f, ch[f][p&gt;f] = p;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    lmx[p] = rmx[p] = <span class="built_in">max</span>(<span class="number">0</span>, v);</span><br><span class="line">    lmn[p] = rmn[p] = <span class="built_in">min</span>(<span class="number">0</span>, v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>(l, p<span class="number">-1</span>, p); <span class="built_in">build</span>(p+<span class="number">1</span>, r, p);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x];</span><br><span class="line">    <span class="keyword">if</span>(fa[y]!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l<span class="number">-1</span>), y = <span class="built_in">kth</span>(rt, r+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="keyword">return</span> ch[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setv</span>(x, v);</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setrev</span>(x);</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setinv</span>(x);</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, n+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  rt = (n+<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> com[<span class="number">10</span>], cc[<span class="number">2</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, com, &amp;l, &amp;r);</span><br><span class="line">    ++l, ++r;</span><br><span class="line">    <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, cc);</span><br><span class="line">      <span class="built_in">replace</span>(l, r, (cc[<span class="number">0</span>]==<span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x = <span class="built_in">split</span>(l, r);</span><br><span class="line">      <span class="type">int</span> pmn = lmn[x], smx = rmx[x];</span><br><span class="line">      <span class="type">int</span> y = fa[x];</span><br><span class="line">      <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">      <span class="built_in">assert</span>(pmn&lt;=<span class="number">0</span>); <span class="built_in">assert</span>(smx&gt;=<span class="number">0</span>);</span><br><span class="line">      <span class="comment">//cout &lt;&lt; lmn[x] &lt;&lt; &#x27; &#x27; &lt;&lt; rmx[x] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((-pmn+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)+((smx+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>) <span class="built_in">reverse</span>(l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(com[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>) <span class="built_in">invert</span>(l, r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡树之splay</title>
      <link href="/2020/12/11/ping-heng-shu-zhi-splay/"/>
      <url>/2020/12/11/ping-heng-shu-zhi-splay/</url>
      
        <content type="html"><![CDATA[<p>伸展树的核心操作就是splay了，将每次访问的点splay到根节点（类似输入法，频繁打的词会比较靠前）。而正确的splay操作可以保证在将x旋转到根节点的过程中，沿途的所有父节点的深度都会至少减少一半，这种自我调整的特性保证了splay树在各种操作下均摊$O(\log n)$<br>rotate需要分3种情况，splay需要分6种情况比较麻烦，不再赘述（ <del>其实是不会</del> ），只给出代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">rs</span>(x), w = ch[x][k^<span class="number">1</span>];</span><br><span class="line">  ch[y][k] = w; fa[w] = y;</span><br><span class="line">  ch[z][<span class="built_in">rs</span>(y)] = x; fa[x] = z;</span><br><span class="line">  ch[x][k^<span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> g=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(fa[x]!=g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x];</span><br><span class="line">    <span class="keyword">if</span>(fa[y]!=g) (<span class="built_in">rs</span>(x)==<span class="built_in">rs</span>(y) ? <span class="built_in">rotate</span>(y) : <span class="built_in">rotate</span>(x));</span><br><span class="line">    <span class="built_in">rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!g) rt = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>splay(x,g)表示将x旋转到g的儿子处，当g&#x3D;0时即将x旋转到根。用splay来维护权值大小我觉得很麻烦，码量和常数都比较大，一般情况下用pbds或者fhq<br>treap替代即可。但是用splay来维护区间还是需要只要的。做法也很简单，如果要维护[l,r]，先把l-1旋转到根，再把r+1旋转到l-1的儿子，那么此时r+1的左子树就是要操作的[l,r]部分，直接对这个根节点打上相应的标记即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">kth</span>(rt, l<span class="number">-1</span>), y = <span class="built_in">kth</span>(rt, r+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">splay</span>(x); <span class="built_in">splay</span>(y, x);</span><br><span class="line">  <span class="keyword">return</span> ch[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pushdown操作只需要在kth函数中进行即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(ch[p][<span class="number">0</span>]&amp;&amp;sz[ch[p][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">0</span>], k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(sz[ch[p][<span class="number">0</span>]]+<span class="number">1</span>==k) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(ch[p][<span class="number">1</span>], k-sz[ch[p][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而pushup操作在每次进行split区间操作后都要执行，假设split返回的节点是x，那么就要pushup(y)以及pushup(fa[y])：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">split</span>(l, r), y = fa[x];</span><br><span class="line">  <span class="built_in">setv</span>(x, v);</span><br><span class="line">  <span class="built_in">up</span>(y); <span class="built_in">up</span>(fa[y]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实splay的所有操作都可以用fhq<br>treap来替代，不过在区间操作中要找到区间下标x的点这一功能还是splay方便，只需要把这个点splay到根就可以了，而treap则需要额外维护父亲，而自下而上找。<br>当然splay无可替代的地方就是LCT了，如果用treap就会多一个log。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5217 贫穷 fhq treap</title>
      <link href="/2020/12/07/p5217-pin-qiong-fhq-treap/"/>
      <url>/2020/12/07/p5217-pin-qiong-fhq-treap/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串序列<br>要求支持以下操作</p><ul><li>在x位置后插入一个字母</li><li>删除x位置的字母</li><li>翻转区间[x,y]</li><li>输出初始字符串序列第x个字母当前位置</li><li>输出当前字符串序列第x个字母</li><li>输出区间[x,y]字母种类数</li></ul><p>前三个很简单。<br>第四个要查节点号为x的字母的位置，由于是维护区间，按size分裂，所以自上而下找不了，只能额外维护父亲，然后自下而上找。由于第三个区间翻转操作，导致左右儿子可能会改变，所以要先到根节点把所有懒标记pushdown下来，再自下而上找才能正确<br>第五个就是查第k大（区间意义下），直接split和merge比较好，如果是从根递归着走，不要忘记pushdown<br>第六个状压维护一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>|<span class="built_in">rand</span>(); &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> mask, sz, fa, key, c;</span><br><span class="line">  <span class="type">bool</span> rev;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = ++tot;</span><br><span class="line">  t[p].ls = t[p].rs = t[p].fa = <span class="number">0</span>;</span><br><span class="line">  t[p].mask = <span class="number">1</span>&lt;&lt;c, t[p].c = c, t[p].key = <span class="built_in">rnd</span>();</span><br><span class="line">  t[p].sz = <span class="number">1</span>;</span><br><span class="line">  t[p].rev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + <span class="number">1</span>;</span><br><span class="line">  t[p].mask = t[t[p].ls].mask | t[t[p].rs].mask | (<span class="number">1</span>&lt;&lt;t[p].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t[p].rev)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">swap</span>(t[p].ls, t[p].rs);</span><br><span class="line">    t[t[p].ls].rev ^= <span class="number">1</span>;</span><br><span class="line">    t[t[p].rs].rev ^= <span class="number">1</span>;</span><br><span class="line">    t[p].rev = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> k, <span class="type">int</span> fx=<span class="number">0</span>, <span class="type">int</span> fy=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123; x = y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz)</span><br><span class="line">  &#123;</span><br><span class="line">    y = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].ls, x, t[p].ls, k, fx, p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    x = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].rs, t[p].rs, y, k-t[t[p].ls].sz<span class="number">-1</span>, p, fy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x) t[x].fa = fx;</span><br><span class="line">  <span class="keyword">if</span>(y) t[y].fa = fy;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) &#123; p = x|y; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">down</span>(x);</span><br><span class="line">    p = x;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].rs, t[p].rs, y);</span><br><span class="line">    t[t[p].rs].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">down</span>(y);</span><br><span class="line">    p = y;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].ls, x, t[p].ls);</span><br><span class="line">    t[t[p].ls].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downall</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">downall</span>(t[p].fa);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">downall</span>(p);</span><br><span class="line">  <span class="type">int</span> rk = t[t[p].ls].sz + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(t[p].fa)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t[t[p].fa].rs==p) rk += t[t[p].fa].sz - t[p].sz;</span><br><span class="line">    p = t[p].fa;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rk*(p==rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].ls, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k==t[t[p].ls].sz+<span class="number">1</span>) <span class="keyword">return</span> t[p].c;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].rs, k-t[t[p].ls].sz<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">newnode</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">merge</span>(rt, rt, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> opt[<span class="number">2</span>], c[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">    <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;k, c);</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">split</span>(rt, x, y, k);</span><br><span class="line">      z = <span class="built_in">newnode</span>(c[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">      <span class="built_in">merge</span>(x, x, z);</span><br><span class="line">      <span class="built_in">merge</span>(rt, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">split</span>(rt, x, y, k);</span><br><span class="line">      <span class="built_in">split</span>(x, x, z, k<span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">merge</span>(rt, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">split</span>(rt, x, y, r);</span><br><span class="line">      <span class="built_in">split</span>(x, z, x, l<span class="number">-1</span>);</span><br><span class="line">      t[x].rev ^= <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">merge</span>(x, z, x);</span><br><span class="line">      <span class="built_in">merge</span>(rt, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get</span>(k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> k;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, <span class="built_in">char</span>(<span class="built_in">kth</span>(rt, k)+<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">split</span>(rt, x, y, r);</span><br><span class="line">      <span class="built_in">split</span>(x, z, x, l<span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, __builtin_popcount(t[x].mask));</span><br><span class="line">      <span class="built_in">merge</span>(x, z, x);</span><br><span class="line">      <span class="built_in">merge</span>(rt, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡树之FHQ Treap</title>
      <link href="/2020/12/06/ping-heng-shu-zhi-fhq-treap/"/>
      <url>/2020/12/06/ping-heng-shu-zhi-fhq-treap/</url>
      
        <content type="html"><![CDATA[<p>treap，顾名思义tree+heap<br>既有平衡树的性质：左儿子权值&lt;本节点权值&lt;右儿子权值，中序遍历有序，且树高尽可能小<br>又有heap的性质：键值满足小根堆，左儿子的键值和右儿子的键值都大于本节点的键值<br>而FHQ Treap仅仅通过两个函数就能够进行维护，思想好懂，代码也很简洁。<br>更重要的是相比于之前的替罪羊树或者pbds这种只能维护大小关系的平衡树而言，它可以胜任splay拥有的维护区间的特质。<br>首先是普通的维护大小关系：<br>split函数，将一棵树按照给定的权值v划分成两棵树，并且保证第一棵树的权值均小于等于v，第二棵树的权值均大于v。<br>显然只要递归分裂的树，考虑当前节点的权值和给定的v的关系即可。<br>注意分裂的两个节点传引用。<br>merge函数，将两棵树合成一棵树，要求第一棵树的权值均小于等于第二棵树<br>同样是递归考虑，那么当前两棵树谁的根作为合并的树的根呢？按照权值来看都是可以的，但是为了保持平衡性，就要维护键值的小根堆性质，所以让键值小的那个节点作为根即可。<br>注意合并的那个节点要传引用。<br>由于split和merge都会改变父子关系，所以最后要pushup维护好子树的信息。<br>而对于普通平衡树所支持的插入、删除、第k大、排名、前驱、后继等等，只要基于split和merge两个函数就可以轻松实现，比较简单， <del>懒得写了</del><br>p6136：fhq treap 8.2s，替罪羊5.81s，不过fhq treap代码短点。当然两者都很好理解。一般情况下fhq<br>treap足以应对所有情况（除了LCT以及重度卡常题（紫荆花之恋？听说），所以splay还是得懂）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> val, key, sz;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> tot, rt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>)|<span class="built_in">rand</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = ++tot;</span><br><span class="line">  t[p].val = v, t[p].sz = <span class="number">1</span>;</span><br><span class="line">  t[p].ls = t[p].rs = <span class="number">0</span>;</span><br><span class="line">  t[p].key = <span class="built_in">rnd</span>();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123; a = b = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[p].val&lt;=v) &#123; a = p; <span class="built_in">split</span>(t[p].rs, t[a].rs, b, v); &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; b = p; <span class="built_in">split</span>(t[p].ls, a, t[b].ls, v); &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!a||!b) &#123; p = a|b; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[a].key&lt;t[b].key) &#123; p = a; <span class="built_in">merge</span>(t[p].rs, t[a].rs, b); &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; p = b; <span class="built_in">merge</span>(t[p].ls, a, t[b].ls); &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="built_in">newnode</span>(v);</span><br><span class="line">  <span class="built_in">split</span>(p, x, y, v);</span><br><span class="line">  <span class="built_in">merge</span>(x, x, z); <span class="built_in">merge</span>(p, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">split</span>(p, x, y, v); <span class="built_in">split</span>(x, x, z, v<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">merge</span>(z, t[z].ls, t[z].rs);</span><br><span class="line">  <span class="built_in">merge</span>(x, x, z); <span class="built_in">merge</span>(p, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].ls, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k==t[t[p].ls].sz+<span class="number">1</span>) <span class="keyword">return</span> t[p].val;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].rs, k-t[t[p].ls].sz<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Less</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v, <span class="type">bool</span> eq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">split</span>(p, x, y, v<span class="number">-1</span>+eq);</span><br><span class="line">  <span class="type">int</span> ans = t[x].sz;</span><br><span class="line">  <span class="built_in">merge</span>(p, x, y);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">int</span>(<span class="built_in">time</span>(<span class="number">0</span>)));</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, x; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">ins</span>(rt, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">    x ^= last;</span><br><span class="line">    <span class="keyword">switch</span>(op)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">ins</span>(rt, x); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">del</span>(rt, x); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: last = <span class="built_in">Less</span>(rt, x, <span class="number">0</span>) + <span class="number">1</span>; ans ^= last; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: last = <span class="built_in">kth</span>(rt, x); ans ^= last; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>: last = <span class="built_in">kth</span>(rt, <span class="built_in">Less</span>(rt, x, <span class="number">0</span>)); ans ^= last; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: last = <span class="built_in">kth</span>(rt, <span class="built_in">Less</span>(rt, x, <span class="number">1</span>)+<span class="number">1</span>); ans ^= last;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是维护区间，也很简单，改一下split和merge的定义即可。<br>split，给定一个树，把一棵树的前k个节点划分给一棵树，剩余节点划分给另一棵树<br>merge，将两棵树合并成一棵树，需要保证一棵树完全处在另一棵树的前面<br>写法和上面类似，不再赘述<br>考虑对区间[l,r]的操作怎么做：<br>先把rt的前r个节点split给x，其他的丢给y<br>再把x的前l-1个节点split给z<br>此时x就是[l,r]区间内所有节点构成的treap的根了，直接在根上打标记即可。<br>最后按照顺序z，x，y进行merge。<br>考虑pushup和pushdown在什么时候进行。<br>pushup是要维护当前子树的信息，因此需要在左右儿子改变后调用，而pushdown是为了下放赖在当前节点上的懒标记，所以要在左右儿子改变前调用，想清楚这两点就知道了，应该在split和merge进入子树前pushdown，在回溯上来之后再pushup。<br>p3391 文艺平衡树，区间翻转，显然只要把要操作的区间split出来然后在根上打一个翻转标记即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>|<span class="built_in">rand</span>(); &#125;</span><br><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> val, key, sz;</span><br><span class="line">  <span class="type">bool</span> tag;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">swap</span>(t[p].ls, t[p].rs);</span><br><span class="line">  <span class="keyword">if</span>(t[p].ls) t[t[p].ls].tag ^= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].rs) t[t[p].rs].tag ^= <span class="number">1</span>;</span><br><span class="line">  t[p].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = ++tot;</span><br><span class="line">  t[p].val = v;</span><br><span class="line">  t[p].sz = <span class="number">1</span>; t[p].tag = <span class="number">0</span>;</span><br><span class="line">  t[p].ls = t[p].rs = <span class="number">0</span>;</span><br><span class="line">  t[p].key = <span class="built_in">rnd</span>();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123; x = y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) &#123; y = p; <span class="built_in">split</span>(t[p].ls, x, t[p].ls, k); &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; x = p, <span class="built_in">split</span>(t[p].rs, t[p].rs, y, k-t[t[p].ls].sz<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) &#123; p = x|y; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t[x].tag) <span class="built_in">down</span>(x);</span><br><span class="line">    p = x;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].rs, t[x].rs, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t[y].tag) <span class="built_in">down</span>(y);</span><br><span class="line">    p = y;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].ls, x, t[y].ls);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">newnode</span>(v);</span><br><span class="line">  <span class="built_in">merge</span>(p, p, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="built_in">split</span>(rt, x, y, r);</span><br><span class="line">  <span class="built_in">split</span>(x, z, x, l<span class="number">-1</span>);</span><br><span class="line">  t[x].tag ^= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">merge</span>(x, z, x);</span><br><span class="line">  <span class="built_in">merge</span>(rt, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="built_in">print</span>(t[p].ls);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t[p].val);</span><br><span class="line">  <span class="built_in">print</span>(t[p].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">int</span>(<span class="built_in">time</span>(<span class="number">0</span>)));</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">ins</span>(rt, i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="built_in">rev</span>(l, r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(rt);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护区间信息的时候，一定要注意平衡树和线段树是不一样的，线段树只要左右儿子取优即可（因为本节点维护的区间是左右儿子维护的区间的并），而平衡树左右儿子维护的信息是不包含本节点的，所以还需要维护本节点的值，和该值再取优。<br>在维护区间的时候，就丧失了权值大小的比较了，那么如何知道编号为i的节点在区间中的哪个位置呢？<br>显然从根开始是不知道该走左还是右的。但是如果我们从i节点不断跳父亲直至根，然后不断维护小于你的节点个数就可以了，而treap的树高是$\log n$级别的，复杂度没问题。<br>要维护节点的父亲，一种简单的做法是在pushup的时候维护一下p的左右儿子的父亲为p，但这样子是有问题的，根节点的fa值是错误的，没法及时清零，当然如果只有一棵treap，且知道根节点的编号，就可以通过&#x3D;&#x3D;rt来判断，否则就应该在split和merge中维护fa：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> fx, <span class="type">int</span> fy, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123; x = y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz)</span><br><span class="line">  &#123;</span><br><span class="line">    y = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].ls, x, t[p].ls, fx, p, k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    x = p;</span><br><span class="line">    <span class="built_in">split</span>(t[p].rs, t[p].rs, y, p, fy, k-t[t[p].ls].sz<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x) t[x].fa = fx;</span><br><span class="line">  <span class="keyword">if</span>(y) t[y].fa = fy;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) &#123; p = x|y; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">  &#123;</span><br><span class="line">    p = x;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].rs, t[p].rs, y);</span><br><span class="line">    t[t[p].rs].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    p = y;</span><br><span class="line">    <span class="built_in">merge</span>(t[p].ls, x, t[p].ls);</span><br><span class="line">    t[t[p].ls].fa = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回编号为p的节点所在treap的根节点，以及在原数组中的下标：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">get</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> rk = t[t[p].ls].sz + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(t[p].fa)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p==t[t[p].fa].rs) rk += t[t[p].fa].sz - t[p].sz;</span><br><span class="line">    p = t[p].fa;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make_pair</span>(p, rk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡树之替罪羊树</title>
      <link href="/2020/12/06/ping-heng-shu-zhi-ti-zui-yang-shu/"/>
      <url>/2020/12/06/ping-heng-shu-zhi-ti-zui-yang-shu/</url>
      
        <content type="html"><![CDATA[<p>很简单的思路，在每次插入和删除的时候，检查一下左右子树是不是失衡，如果失衡就将整棵子树进行拍扁(中序遍历存到数组)，重构(每次以中心点为当前的根，然后递归左右区间)。<br>失衡的判定：当左子树或者右子树的大小超过了整个子树大小的某个比例alpha（一般定义在0.7~0.8）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bad</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> t[p].cnt &amp;&amp; t[p].sz*alpha&lt;<span class="built_in">max</span>(t[t[p].ls].sz, t[t[p].rs].sz); &#125;</span><br></pre></td></tr></table></figure><p>几个细节：</p><ul><li>删除的实现采用最简单的惰性删除，找到对应的节点后让cnt–即可，即使等于0也没有关系，因为在拍扁重构的时候可以把等于0的节点直接丢弃掉</li><li>由于插入删除的时候可能需要重构，因此一定要记得传引用</li><li>这种平衡树最大的特点就是好写加常数小(均摊mlogn)</li></ul><p>记住拍扁重构的思想应该就很容易手写了吧</p><p>前驱、后继、第k大、排名其实没必要每个都实现一个函数。只需要实现求第k大，然后求小于x的数的个数以及小于等于x的数的个数即可，只与后两者只有细微的差异，完全可以合并到一个函数中<br>洛谷模板p3369开O2 170ms：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> alpha = <span class="number">0.7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ls, rs;</span><br><span class="line">  <span class="type">int</span> val, sz, cnt;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> rt, tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].sz = t[t[p].ls].sz + t[t[p].rs].sz + t[p].cnt; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bad</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> t[p].cnt &amp;&amp; t[p].sz*alpha&lt;<span class="built_in">max</span>(t[t[p].ls].sz, t[t[p].rs].sz); &#125;</span><br><span class="line"><span class="type">int</span> ord[N], top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(t[p].ls);</span><br><span class="line">  <span class="keyword">if</span>(t[p].cnt) ord[++top] = p;</span><br><span class="line">  <span class="built_in">dfs</span>(t[p].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, p = ord[mid];</span><br><span class="line">  t[p].ls = <span class="built_in">build</span>(l, mid<span class="number">-1</span>);</span><br><span class="line">  t[p].rs = <span class="built_in">build</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(p);</span><br><span class="line">  p = <span class="built_in">build</span>(<span class="number">1</span>, top);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = ++tot;</span><br><span class="line">  t[p].val = v, t[p].ls = t[p].rs = <span class="number">0</span>;</span><br><span class="line">  t[p].cnt = t[p].sz = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="built_in">newnode</span>(p, v);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v==t[p].val) t[p].cnt++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="built_in">ins</span>(t[p].ls, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">ins</span>(t[p].rs, v);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bad</span>(p)) <span class="built_in">rebuild</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v==t[p].val) t[p].cnt--;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="built_in">del</span>(t[p].ls, v);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">del</span>(t[p].rs, v);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">bad</span>(p)) <span class="built_in">rebuild</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Less</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v, <span class="type">bool</span> eq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].cnt&amp;&amp;v==t[p].val) <span class="keyword">return</span> t[t[p].ls].sz + t[p].cnt*eq;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;t[p].val) <span class="keyword">return</span> <span class="built_in">Less</span>(t[p].ls, v, eq);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> t[t[p].ls].sz + t[p].cnt + <span class="built_in">Less</span>(t[p].rs, v, eq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k&lt;=t[t[p].ls].sz) <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].ls, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(t[t[p].ls].sz+t[p].cnt&gt;=k) <span class="keyword">return</span> t[p].val;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t[p].rs, k-t[p].cnt-t[t[p].ls].sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span>(n--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> t, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="built_in">ins</span>(rt, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>) <span class="built_in">del</span>(rt, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Less</span>(rt, x, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">kth</span>(rt, x));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">kth</span>(rt, <span class="built_in">Less</span>(rt, x, <span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">kth</span>(rt, <span class="built_in">Less</span>(rt, x, <span class="number">1</span>)+<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECPC 2019 Kickoff</title>
      <link href="/2020/12/04/ecpc-2019-kickoff/"/>
      <url>/2020/12/04/ecpc-2019-kickoff/</url>
      
        <content type="html"><![CDATA[<p>除了I没人过（没看），都不难<br>特别简单的略过</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>给三根木棍长度a,b,c，再给一个k，你可以选择<strong>一根</strong>木棍让它的长度最多延长k，问你这三根木棍构成的三角形的最大面积</p><p>考虑枚举延长的边，我们可以算出这条边的范围，然后利用余弦定理求出这条边对角的范围，最大化这个角的sin值即可</p><h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><p>n盆植物，第i盆初始高度为$h_i$​，生成速度为$g_i$​，问你最短第几天所有植物会形成非降序列</p><p>显然考虑相邻两盆，抽象成直线即可，要么是$[0,l]$,要么是$[r,\inf]$，维护l和r即可</p><h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>一个序列，只有’a’,’b’,’c’，且’b’最多一个，现在可以交换任意两个位置，问你满足相邻两个位置的字母要么相等，要么有一个是’b’</p><p>没有b的时候，显然只有全是a或者全是c才能满足<br>有1个b，只能是aaabcccc或者ccccbaaa的形式，取个min即可</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>给一个数n，初始有x&#x3D;0，每次操作从$[0, 2^n-1]$中随机选择一个数r，让$x&#x3D;x^r$，设期望p步后该数变为0，问期望步数的平方</p><p>答案就是$\sum_{i&#x3D;1}^{\infty}i^2(1-\frac{1}{2^n})^{i-1}\frac{1}{2^n}$</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p><img src="/../post-images/1607088246259.png"><br>给出一个序列，然后执行一次上述函数后，问你得到的序列<br>这个函数就是每次优先找到跟你与运算不等于0的数，如果没有这样的数，再找到第一个与运算等于0的。<br>考虑优化找这个数的过程<br>与不等于0，那肯定有一位你是1，它也是1。<br>用30个队列，每个队列存第i位为1的数的下标<br>那么如果当前进行到u，枚举30位，找到队列中第一个没访问过的数，取它们的最小数就是下一个数了。<br>显然访问过的数可以pop掉。如果没有这样的数了，剩下没访问过的显然跟你与运算都是0，用个链表维护即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], b[N], top;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q[<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> to[N], from[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">  vis[u] = <span class="number">1</span>; b[++top] = a[u]; to[from[u]] = to[u]; from[to[u]] = from[u];</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> nxt = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">30</span>; i++)</span><br><span class="line">      <span class="keyword">if</span>((a[u]&gt;&gt;i)&amp;<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q[i].<span class="built_in">empty</span>() &amp;&amp; vis[q[i].<span class="built_in">front</span>()]) q[i].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!q[i].<span class="built_in">empty</span>()) nxt = <span class="built_in">min</span>(nxt, q[i].<span class="built_in">front</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span>(nxt==n+<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(nxt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> nxt = to[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">while</span>(nxt&lt;=n &amp;&amp; vis[nxt]) nxt = to[nxt];</span><br><span class="line">  <span class="keyword">if</span>(nxt&lt;=n) <span class="built_in">dfs</span>(nxt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;sorting.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    <span class="comment">//a[i] = i;</span></span><br><span class="line">    to[i] = i + <span class="number">1</span>; from[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=<span class="number">30</span>; j++)</span><br><span class="line">      <span class="keyword">if</span>((a[i]&gt;&gt;j)&amp;<span class="number">1</span>) q[j].<span class="built_in">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, b[i], <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>有一个无向图，然后给你q个二元组(d,c)，表示在第d天之前访问过c，问你第0天的起点可能有几个<br>按照d升序给出，其中第i天你可以选择不动，也可以选择移到相邻的一个节点<br>$n \leq 2000,m\leq 10^4$</p><p>显然在每个点跑一遍bfs求出两两的最短路，相邻二元组的城市我们都走最短路，如果后面天数不够，只能往前面借，假设后面最多欠了x天，那么起点和$c_1$​的距离要满足$\leq d1-x$。<br>一个错误是我把bfs的距离初始化成-1，然后某些点和$c_1$​可能不连通，我也把它算作可行点了</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>还以为是道高深计算几何，然而是个数位dp<br>有两条斜率为$s_1,s_2$​,且都是2的幂次的过原点的直线，给定$x_l,x_r$​<br>让你求$\sum_{i&#x3D;x_l}^{x_r} (s_1i) \otimes (s_2i)$<br>首先可以转成前缀和，把下界限变成0，然后设$2^{k_1}&#x3D;s_1,2^{k_2}&#x3D;s_2$<br>把式子变成$\sum_{i&#x3D;0}^{n}(i&lt;&lt;k_1) \otimes<br>(i&lt;&lt;k_2)$<br>设$k_1&lt;k_2$​，去掉$k_1$​，$k_2$​变成$k&#x3D;k_2-k_1$​，最后答案乘上$2^{k_1}$​<br>则$\sum_{i&#x3D;0}^{n}i \otimes (i&lt;&lt;k)$<br>显然按位考虑<br>对于$[0,k-1]$位，我们只要统计$[0,n]$中那位等于1的数量<br>对于$[41-k,40]$位，我们也只要统计$[0,n]$中那位等于1的数量<br>对于$[k,40]$位，我们要统计$[0,n]$中x位不等于x-k位的数量<br>写两个数位dp就行了。。写完一个，cv一下改改就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll s1, s2, xl, xr;</span><br><span class="line">ll dp[<span class="number">45</span>][<span class="number">2</span>], dp2[<span class="number">45</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">45</span>], top;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> lim, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  ll &amp;x = dp[p][lim];</span><br><span class="line">  <span class="keyword">if</span>(~x) <span class="keyword">return</span> x;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> up = lim ? a[p] : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(p==t)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(up==<span class="number">1</span>) x = <span class="built_in">dfs</span>(p<span class="number">-1</span>, lim, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)</span><br><span class="line">      x = (x + <span class="built_in">dfs</span>(p<span class="number">-1</span>, lim&amp;&amp;i==up, t))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> lim, <span class="type">int</span> tv, <span class="type">int</span> t, <span class="type">int</span> t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  ll &amp;x = dp2[p][lim][tv];</span><br><span class="line">  <span class="keyword">if</span>(~x) <span class="keyword">return</span> x;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> up = lim ? a[p] : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p==t) x = (x + <span class="built_in">dfs2</span>(p<span class="number">-1</span>, lim&amp;&amp;i==up, i, t, t2))%mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p==t2 &amp;&amp; tv!=i) x = (x + <span class="built_in">dfs2</span>(p<span class="number">-1</span>, lim&amp;&amp;i==up, tv, t, t2))%mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p!=t2) x = (x + <span class="built_in">dfs2</span>(p<span class="number">-1</span>, lim&amp;&amp;i==up, tv, t, t2))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(<span class="type">int</span> k, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    ll n = x;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">      a[top++] = n&amp;<span class="number">1</span>;</span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top&lt;=<span class="number">40</span>) a[top++] = <span class="number">0</span>;</span><br><span class="line">    ans = (ans + (<span class="number">1ll</span>&lt;&lt;i)%mod*<span class="built_in">dfs</span>(top<span class="number">-1</span>, <span class="number">1</span>, i))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">41</span>-k; i&lt;=<span class="number">40</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    ll n = x;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">      a[top++] = n&amp;<span class="number">1</span>;</span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top&lt;=<span class="number">40</span>) a[top++] = <span class="number">0</span>;</span><br><span class="line">    ans = (ans + (<span class="number">1ll</span>&lt;&lt;(i+k))%mod*<span class="built_in">dfs</span>(top<span class="number">-1</span>, <span class="number">1</span>, i))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=k; i&lt;=<span class="number">40</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp2));</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    ll n = x;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">      a[top++] = n&amp;<span class="number">1</span>;</span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top&lt;=<span class="number">40</span>) a[top++] = <span class="number">0</span>;</span><br><span class="line">    ans = (ans + (<span class="number">1ll</span>&lt;&lt;i)%mod*<span class="built_in">dfs2</span>(top<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, i, i-k))%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> k1 = <span class="number">0</span>, k2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;s1, &amp;s2, &amp;xl, &amp;xr);</span><br><span class="line">  <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k1)&lt;s1) ++k1;</span><br><span class="line">  <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k2)&lt;s2) ++k2;</span><br><span class="line">  <span class="keyword">if</span>(k1&gt;k2) <span class="built_in">swap</span>(k1, k2);</span><br><span class="line">  <span class="type">int</span> k = k2 - k1;</span><br><span class="line">  <span class="keyword">if</span>(!k) &#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">  ll ans = (<span class="built_in">work</span>(k, xr) - <span class="built_in">work</span>(k, xl<span class="number">-1</span>) + mod)%mod;</span><br><span class="line">  ans = (<span class="number">1ll</span>&lt;&lt;k1)%mod*ans%mod;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;geometry.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>有一个无向图，然后给你一个某个点s到其他点最短路的数组d，且要求最短路至少要经过一条边<br>这个限制是为了防止$d_s&#x3D;0$，让你找到最小的满足条件的s</p><p>没有想到很好的做法，给出一种奇怪的做法<br>考虑以s为源点的距离数组构成的最短路图<br>如果这个距离数组是合法的，那么这个最短路图要满足是一个连通的DAG，且只有s的入度等于0<br>我们对每个点i，让$d_i&#x3D;0$，然后建出最短路图判断一下是否满足以上条件就知道i能不能是源点了<br>下面考虑加速以上做法<br>我们先把原数组的最短路图建出来，对于每个i，把和它有关的边去掉，然后让$d_i&#x3D;0$，再枚举和它相连的边建出新边即可。<br>那么对于原数组建出的最短路图中的某条边$(i,j)$(i&lt;j)来说，它存在于[1,i−1],[i+1,j−1]，[j+1,n][1,i-1],[i+1,j-1]，[j+1,n][1,i−1],[i+1,j−1]，[j+1,n]这三个区间<br>所以线段树分治即可，在叶子的时候再建出新边。注意维护连通块数量以及入度为0的点数<br>还需要注意要满足i的所有边的权值的最小值要是$d_i$​的一半</p><p>线段树分治在叶子不要忘记rollback<br><code>if(l==r)</code>不要return</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll s[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; G[N];</span><br><span class="line"><span class="type">int</span> fa[N], sz[N], undo[N*<span class="number">3</span>], top, scc, ans, deg[N], zcnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x!=fa[x]) x = fa[x];</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">  <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(sz[x]&gt;sz[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  undo[++top] = x;</span><br><span class="line">  --scc;</span><br><span class="line">  fa[x] = y;</span><br><span class="line">  sz[y] += sz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rollback</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top&gt;t)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x = undo[top];</span><br><span class="line">    sz[fa[x]] -= sz[x];</span><br><span class="line">    fa[x] = x;</span><br><span class="line">    ++scc;</span><br><span class="line">    --top;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; op[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> px, <span class="type">int</span> py)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">  &#123;</span><br><span class="line">    op[p].<span class="built_in">emplace_back</span>(px, py);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">ins</span>(p&lt;&lt;<span class="number">1</span>, l, mid, x, y, px, py);</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">ins</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, x, y, px, py);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(~ans) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> dfn = top;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : op[p])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">merge</span>(it.fi, it.se);</span><br><span class="line">    <span class="keyword">if</span>(!deg[it.se]) --zcnt;</span><br><span class="line">    ++deg[it.se];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> tmp = top, mn = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[l])</span><br><span class="line">    &#123;</span><br><span class="line">      mn = <span class="built_in">min</span>(mn, it.se);</span><br><span class="line">      <span class="keyword">if</span>(it.se==s[it.fi])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">merge</span>(l, it.fi);</span><br><span class="line">        <span class="keyword">if</span>(!deg[it.fi]) --zcnt;</span><br><span class="line">        ++deg[it.fi];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(scc==<span class="number">1</span> &amp;&amp; zcnt==<span class="number">1</span> &amp;&amp; mn*<span class="number">2</span>==s[l]) ans = l;</span><br><span class="line">    <span class="built_in">rollback</span>(tmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[l])</span><br><span class="line">      <span class="keyword">if</span>(it.se==s[it.fi])</span><br><span class="line">        <span class="keyword">if</span>(!(--deg[it.fi])) ++zcnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">go</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">go</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">rollback</span>(dfn);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : op[p])</span><br><span class="line">    <span class="keyword">if</span>(!(--deg[it.se])) ++zcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;hide.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, s+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    G[u].<span class="built_in">emplace_back</span>(v, w); G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line">  scc = n, ans = <span class="number">-1</span>, zcnt = n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[i])</span><br><span class="line">      <span class="keyword">if</span>(s[i]+it.se==s[it.fi])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> x = i, y = it.fi;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>) <span class="built_in">ins</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x<span class="number">-1</span>, i, it.fi);</span><br><span class="line">        <span class="keyword">if</span>(y&lt;n) <span class="built_in">ins</span>(<span class="number">1</span>, <span class="number">1</span>, n, y+<span class="number">1</span>, n, i, it.fi);</span><br><span class="line">        <span class="keyword">if</span>(x+<span class="number">1</span>&lt;y) <span class="built_in">ins</span>(<span class="number">1</span>, <span class="number">1</span>, n, x+<span class="number">1</span>, y<span class="number">-1</span>, i, it.fi);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="built_in">go</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次剩余</title>
      <link href="/2020/12/03/er-ci-sheng-yu/"/>
      <url>/2020/12/03/er-ci-sheng-yu/</url>
      
        <content type="html"><![CDATA[<p>给定n和奇素数p，求x满足x2≡n(mod p)x^2 \equiv n (mod \ p)x2≡n(mod p)</p><p>首先考虑有没有解，有解的n称为二次剩余，无解的n称为非二次剩余<br>根据费马小定理，当p为质数时，满足np≡n(mod p)n^p \equiv n (mod \ p)np≡n(mod p)<br>由于p是奇质数，则n2p−12≡1(mod p)n^{2\frac{p-1}{2}} \equiv 1 (mod \ p)n22p−1​≡1(mod p)<br>即np−12n^{\frac{p-1}{2}}n2p−1​为1在模p意义下开根的结果，只有1和-1两种可能<br>有欧拉准则，当np−12≡1n^{\frac{p-1}{2}} \equiv 1n2p−1​≡1时，n是二次剩余，否则是非二次剩余。<br>当n是二次剩余时，易得x2p−12≡xp−1≡1x^{2\frac{p-1}{2}} \equiv x^{p-1} \equiv<br>1x22p−1​≡xp−1≡1成立，必要性得到。<br>充分性以及非二次剩余的证明鸽了。</p><p>再考虑有解时有几个解，设两个不同的解x1,x2x_1,x_2x1​,x2​，则满足x12≡x22x_1^2 \equiv<br>x_2^2x12​≡x22​，即x12−x22≡(x1+x2)(x1−x2)≡0x_1^2-x_2^2 \equiv (x_1+x_2)(x_1-x_2)<br>\equiv 0x12​−x22​≡(x1​+x2​)(x1​−x2​)≡0，由于x1≠x2x_1 \neq<br>x_2x1​​&#x3D;x2​，只有可能x1和x2互为相反数，由于p是奇数，x1和x2的奇偶性一定不同，因此值一定不同。所以除0外每个二次剩余都对应两个解，且这两个解互为相反数。同样的，两个相反数对应了一个二次剩余，因此在[1,p−1][1,<br>p-1][1,p−1]中总共有p−12\frac{p-1}{2}2p−1​个二次剩余</p><p>最后考虑有解时怎么求。先找到一个a，满足a2−na^2-na2−n是非二次剩余，随机找即可，一次有12\frac{1}{2}21​的概率找到<br>令i2≡a2−ni^2 \equiv a^2-ni2≡a2−n<br>有(a+i)p+1≡n(a+i)^{p+1} \equiv n(a+i)p+1≡n</p><ul><li><p>ip≡i(a2−n)p−12≡−ii^p \equiv i(a^2-n)^{\frac{p-1}{2}} \equiv -iip≡i(a2−n)2p−1​≡−i</p></li><li><p>(a+b)p≡ap+bp(a+b)^p \equiv a^p+b^p(a+b)p≡ap+bp 考虑二项式定理<br>(a+i)p+1≡(ap+ip)(a+i)≡(a−i)(a+i)≡n(a+i)^{p+1} \equiv (a^p+i^p)(a+i) \equiv<br>(a-i)(a+i) \equiv n(a+i)p+1≡(ap+ip)(a+i)≡(a−i)(a+i)≡n<br>那么(a+i)p+12(a+i)^{\frac{p+1}{2}}(a+i)2p+1​就是一个解<br>由于a2−na^2-na2−n是非二次剩余，因此iii实际不存在，但是我们可以类似复数一样定义，然后定义乘法即可计算快速幂了，定义形如a+bia+bia+bi，则a+ia+ia+i就是a+1ia+1ia+1i<br>(a+bi)(c+di)≡(ac+bdi2+adi+bci)(a+bi)(c+di) \equiv<br>(ac+bdi^2+adi+bci)(a+bi)(c+di)≡(ac+bdi2+adi+bci)，把i2i^2i2用a2−na^2-na2−n代替即可</p><p>ll w, n, p;<br>struct Complex<br>{<br>ll x, y;<br>Complex(int _x,int _y) : x(_x), y(_y) {}<br>Complex operator * (const Complex &amp;b) const {<br>    return Complex(((x<em>b.x%p+y</em>b.y%p<em>w%p)%p+p)%p,((x</em>b.y%p+y<em>b.x%p)%p+p)%p);<br>}<br>};<br>ll powcp(Complex a,ll b,ll p)<br>{<br>Complex ans(1,0);<br>while(b)<br>{<br>    if(b&amp;1) ans &#x3D; ans</em>a;<br>    a &#x3D; a<em>a;<br>    b &gt;&gt;&#x3D; 1;<br>}<br>return ans.x;<br>}<br>ll solve(ll n,ll p)<br>{<br>n %&#x3D; p;<br>if(p&#x3D;&#x3D;2) return n;<br>if(powmod(n,(p-1)&#x2F;2,p)&#x3D;&#x3D;p-1) return -1; &#x2F;&#x2F;无解<br>ll a;<br>while(1)<br>{<br>    a &#x3D; rand()%p;<br>    w &#x3D; ((a</em>a%p-n)%p+p)%p;<br>    if(powmod(w,(p-1)&#x2F;2,p)&#x3D;&#x3D;p-1) break;<br>}<br>Complex x(a,1);<br>return powcp(x,(p+1)&#x2F;2,p);<br>}<br>srand(int(time(NULL)));<br>ll ans1 &#x3D; solve(n,p), ans2;<br>if(ans1&#x3D;&#x3D;-1) printf(“Hola!\n”);<br>else<br>{<br>ans2 &#x3D; p - ans1;<br>if(ans1&gt;ans2) swap(ans1,ans2);<br>if(ans1&#x3D;&#x3D;ans2) printf(“%lld\n”,ans1);<br>else printf(“%lld %lld\n”,ans1,ans2);<br>}</p></li></ul><p>上述做法由于要手写一个复数类，比较麻烦，而且常数也大，还有一种ToneLLi_Shanks算法<br>原理鸽了</p><pre><code>ll TS(ll n, ll p)&#123;    if(n==0) return 0;    if(p==2) return (n&amp;1) ? 1 : -1;    if(Pow(n, p&gt;&gt;1, p)!=1) return -1;    if(p&amp;2) return Pow(n, (p+1)&gt;&gt;2, p);    int s = __builtin_ctzll(p^1);    ll q = p&gt;&gt;s, z = 2;    for(; Pow(z, p&gt;&gt;1, p)==1; z++);    ll c = Pow(z, q, p);    ll r = Pow(n, (q+1)&gt;&gt;1, p);    ll t = Pow(n, q, p), tmp;    for(int m=s, i; t!=1; )    &#123;        for(i=0, tmp=t; tmp!=1; i++) tmp = tmp*tmp%p;        for(; i&lt;--m; ) c = c*c%p;        r = r*c%p;        c = c*c%p;        t = t*c%p;    &#125;    return r;&#125;void solve()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;p);    ll ans = TS(n, p);    if(ans==-1) puts(&quot;Hola!&quot;);    else if(!ans) puts(&quot;0&quot;);    else    &#123;        ll ans2 = p - ans;        if(ans&gt;ans2) swap(ans, ans2);        printf(&quot;%lld %lld\n&quot;, ans, ans2);    &#125;&#125;</code></pre><p>补充：<br>对于三次剩余<br>若p%3&#x3D;2p % 3 &#x3D; 2p%3&#x3D;2，则每个数都是三次剩余，并且有唯一解n2p−13n^{\frac{2p-1}{3}}n32p−1​<br>若p%3&#x3D;1p % 3 &#x3D; 1p%3&#x3D;1，则有p−13\frac{p-1}{3}3p−1​的数是三次剩余，且每个数有三个解</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020秦皇岛 J Jewel Splitting</title>
      <link href="/2020/12/03/2020-qin-huang-dao-j-jewel-splitting/"/>
      <url>/2020/12/03/2020-qin-huang-dao-j-jewel-splitting/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个长度为n的字符串，让你排成长为d，宽为$\lfloor \frac{n}{d}<br>\rfloor$的矩形，即将连续的长度d的子串作为一行，多余的n%d个丢弃，问有多少种不同的矩形，mod 998244353<br>$n \leq 3 \times 10^5$</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>显然不同的d互不影响，可以分开做<br>当$d \mid n$，就是一个可重集排列，用map来维护每种hash值出现的个数<br>当$d \nmid n$，那么我们可能会丢弃[1,n%d],[d+1,d+n%d]…[1,n%d],[d+1,d+n%d]…[1,n%d],[d+1,d+n%d]…，容易发现相邻两种只有两个字符串是不同的，因此动态维护即可。有个问题是，丢弃不同的区间，剩余的串的类型是一模一样的，即这个状态的map是一样的，这时候不能重复算，因此还要对每个时刻的map状态进行hash。<br>思路不难，但是卡常。不双hash会wa，双hash又tle🤡</p><p>字符串的rolling<br>hash的本质其实就是将这个字符串用base进制的数来表示，然后可以O(1)的求每个子区间的hash值（我好像到现在才明白字符串hash就是用base进制数来表示。。。）<br>考虑map的状态怎么求，就相对于有很多pairs，（hash，cnt）。<br>我的做法是把hash值丢到map里然后映射成小的编号，然后cnt就可以用数组来存了，然后map的状态就相当于第id[hash]位的值为cnt，用cnt*pw[id[hash]]来表示即可。<br>如果只要整个串的hash值，各个位的值用异或也是可以，这样可以快点。<br>然后就是双hash的值，用pair的话肯定会慢，这里用int存，然后高低位合并成一个ull即可。</p><p>通过这题测了一下各种map和set<br>unordered_set很没用，set和map比较稳定，unordered_map有时快有时慢，加了手写hash也慢，很不稳定。<br>所以一般情况下还是用set和map就行了，稳定log，unordered容易卡成n<br>如果要实现无序的set，不推荐unordered_set。<br>如果可以离线，那就vector<br>此外pbds的gp_hash_table很快，被卡map可以用这个代替unordered_map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line">gp_hash_table&lt;ull, <span class="type">int</span>&gt; id;</span><br><span class="line">gp_hash_table&lt;ull, <span class="type">bool</span>&gt; vis;</span><br><span class="line">gp_hash_table&lt;ull, null_type&gt; vis;</span><br><span class="line">```cpp</span><br><span class="line"></span><br><span class="line">无序set也可以用下面两个，测出来<span class="type">bool</span>快一点，null_type内存小点</span><br><span class="line">gp_hash_table封装的函数不多，只有下标、insert</span><br><span class="line">要实现count，要靠find==end</span><br><span class="line">所以最好开局部，不要开全局</span><br><span class="line"></span><br><span class="line">```plain</span><br><span class="line">map：<span class="number">2700</span>ms</span><br><span class="line">gp_hash_table：<span class="number">1700</span>ms</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">uint64_t</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, mod2 = <span class="number">1e9</span> + <span class="number">9</span>, base = <span class="number">19260817</span>;</span><br><span class="line"><span class="type">int</span> kase;</span><br><span class="line"><span class="type">int</span> n, fac[N&lt;&lt;<span class="number">1</span>], ifac[N&lt;&lt;<span class="number">1</span>], cnt[N&lt;&lt;<span class="number">1</span>], ans, tot;</span><br><span class="line"><span class="type">int</span> HSH, HSH2;</span><br><span class="line"><span class="comment">//map&lt;ull, int&gt; id;</span></span><br><span class="line">gp_hash_table&lt;ull, <span class="type">int</span>&gt; id;</span><br><span class="line">gp_hash_table&lt;ull, <span class="type">bool</span>&gt; vis;</span><br><span class="line"><span class="comment">//map&lt;int, bool&gt; vis;</span></span><br><span class="line"><span class="comment">//set&lt;int&gt; st;</span></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> pw[N&lt;&lt;<span class="number">1</span>], pw2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> hsh[N], hsh2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; x += y; <span class="keyword">if</span>(x&gt;=mod) x -= mod; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pw[<span class="number">0</span>] = pw2[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>*n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    pw[i] = <span class="number">1ll</span>*pw[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">    pw2[i] = <span class="number">1ll</span>*pw2[i<span class="number">-1</span>]*base%mod2;</span><br><span class="line">    fac[i] = <span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  ifac[n] = <span class="built_in">Pow</span>(fac[n], mod<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) ifac[i] = <span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    hsh[i] = (<span class="number">1ll</span>*hsh[i<span class="number">-1</span>]*base%mod + s[i])%mod;</span><br><span class="line">    hsh2[i] = (<span class="number">1ll</span>*hsh2[i<span class="number">-1</span>]*base%mod2 + s[i])%mod2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; x -= y; <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x += mod; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sub2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; x -= y; <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x += mod2; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Sub</span>(hsh[r], <span class="number">1ll</span>*hsh[l<span class="number">-1</span>]*pw[r-l+<span class="number">1</span>]%mod); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Sub2</span>(hsh2[r], <span class="number">1ll</span>*hsh2[l<span class="number">-1</span>]*pw2[r-l+<span class="number">1</span>]%mod2); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ull hv = (ull)<span class="built_in">get</span>(l, r)&lt;&lt;<span class="number">32</span>|<span class="built_in">get2</span>(l, r), p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> it = id.<span class="built_in">find</span>(hv);</span><br><span class="line">  <span class="keyword">if</span>(it==id.<span class="built_in">end</span>()) p = id[hv] = ++tot;</span><br><span class="line">  <span class="keyword">else</span> p = it-&gt;second;</span><br><span class="line">  HSH ^= <span class="number">1ll</span>*pw[p]*cnt[p]%mod;</span><br><span class="line">  HSH2 ^= <span class="number">1ll</span>*pw2[p]*cnt[p]%mod2;</span><br><span class="line">  ans = <span class="number">1ll</span>*ans*fac[cnt[p]]%mod*ifac[cnt[p] + v]%mod;</span><br><span class="line">  cnt[p] += v;</span><br><span class="line">  HSH ^= <span class="number">1ll</span>*pw[p]*cnt[p]%mod;</span><br><span class="line">  HSH2 ^= <span class="number">1ll</span>*pw2[p]*cnt[p]%mod2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(gp_hash_table&lt;ull, <span class="type">int</span>&gt; &amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  gp_hash_table&lt;ull, <span class="type">int</span>&gt; tmp;</span><br><span class="line">  table.<span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(gp_hash_table&lt;ull, <span class="type">bool</span>&gt; &amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  gp_hash_table&lt;ull, <span class="type">bool</span>&gt; tmp;</span><br><span class="line">  table.<span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; i++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//st.clear();</span></span><br><span class="line">  <span class="built_in">clear</span>(id); <span class="built_in">clear</span>(vis);</span><br><span class="line">  tot = HSH = HSH2 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  ans = fac[n/d];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n%d+<span class="number">1</span>; i&lt;=n; i+=d) <span class="built_in">upd</span>(i, i+d<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//vector&lt;pair&lt;ull, int&gt;&gt; lsh;</span></span><br><span class="line">  <span class="comment">//lsh.push_back(&#123;(ull)HSH&lt;&lt;32|HSH2, ans&#125;);</span></span><br><span class="line">  <span class="built_in">Add</span>(sum, ans); vis.<span class="built_in">insert</span>(&#123;(ull)HSH&lt;&lt;<span class="number">32</span>|HSH2, <span class="number">1</span>&#125;);</span><br><span class="line">  <span class="keyword">if</span>(n%d)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> m = n/d*d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i+=d)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">upd</span>(i, i+d<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">upd</span>(i+n%d, i+n%d+d<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">      <span class="comment">//lsh.push_back(&#123;(ull)HSH&lt;&lt;32|HSH2, ans&#125;);</span></span><br><span class="line">      <span class="keyword">if</span>(vis.<span class="built_in">find</span>((ull)HSH&lt;&lt;<span class="number">32</span>|HSH2)==vis.<span class="built_in">end</span>()) <span class="built_in">Add</span>(sum, ans), vis.<span class="built_in">insert</span>(&#123;(ull)HSH&lt;&lt;<span class="number">32</span>|HSH2, <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  sort(begin(lsh), end(lsh));</span></span><br><span class="line"><span class="comment">  for(int i=0; i&lt;(int)lsh.size(); )</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    int j = i + 1;</span></span><br><span class="line"><span class="comment">    while(j&lt;(int)lsh.size() &amp;&amp; lsh[j]==lsh[i])</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      //assert(lsh[j].second==lsh[i].second);</span></span><br><span class="line"><span class="comment">      ++j;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Add(sum, lsh[i].second);</span></span><br><span class="line"><span class="comment">    i = j;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//for(int i=1; i&lt;=300000; i++) s[i] = char(&#x27;a&#x27;+i%26);</span></span><br><span class="line">  <span class="comment">//s[300001] = 0;</span></span><br><span class="line">  n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>; d&lt;=n; d++) <span class="built_in">Add</span>(res, <span class="built_in">work</span>(d));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, ++kase, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pre</span>(N<span class="number">-5</span>);</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codechef Counting Spaghetti 数学</title>
      <link href="/2020/11/25/codechef-counting-spaghetti-shu-xue/"/>
      <url>/2020/11/25/codechef-counting-spaghetti-shu-xue/</url>
      
        <content type="html"><![CDATA[<p>现在有$L, L+1,…R-1,R$这R-L+1个数字，问你能够组成多少种不同的数字和<br>$L \leq 10^9, R \leq 10^9$</p><p>考虑用x个数字来组合<br>1个数字：$[L, R]内的所有数字</p><p>2个数字：$[L+L+1, R+R-1]$内的所有数字</p><p>3个数字：$[L+L+1+L+2, R+R-1-R-2]$内的所有数字</p><p>则对于x个数字有：$l_x &#x3D; \frac{x(2L+x-1)}{2}$, $r_x &#x3D; \frac{x(2R-x+1)}{2}$</p><p>因此只要求用1~R-L+1个数字构成的各个区间的并集的长度即可<br>考虑$l_x&gt;r_{x-1}$<br>则要满足$x^2 + (L-R-2)x + R + 1 &gt; 0$<br>当$(R-L+2)^2 - 4R - 4&lt;0$时，所有区间都不相交，又发现此时R-L+1在$O(\sqrt R​$)级别，所以暴力求出各个区间的长度相加即可<br>否则，求出两个根x1，x2，则在$[x1,x2]$这一段区间都是相交的，区间并的左端点为x1的左端点，右端点x2的右端点。<br>考虑$\frac{R-L+2 \pm \sqrt{(R-L+2)^2-4R-4}}{2}$<br>设R-L+2为a，4R-4为b，且满足$a \geq \sqrt b$<br>$a-\sqrt{a^2-b} &#x3D; a-\sqrt{(a+\sqrt b)(a - \sqrt b)} \leq a - \sqrt{(a-\sqrt b)^2} &#x3D; \sqrt b$<br>所以1~x1的长度在$O(\sqrt b)$级别，而x2~a的长度为$a-\frac{R-L+2 + \sqrt{(R-L+2)^2-4R-4}}{2} &#x3D; \frac{R-L+2 - \sqrt{(R-L+2)^2-4R-4}}{2}$​，也在$O(\sqrt b)$级别，所以只需要对两端不相交的部分暴力即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC 江西省大学生程序设计竞赛</title>
      <link href="/2020/11/20/2020icpc-jiang-xi-sheng-da-xue-sheng-cheng-xu-she-ji-jing-sai/"/>
      <url>/2020/11/20/2020icpc-jiang-xi-sheng-da-xue-sheng-cheng-xu-she-ji-jing-sai/</url>
      
        <content type="html"><![CDATA[<p>题目都不难，D题题面出锅</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>定义$F_j$​为j各位数字之和<br>求$)\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^i [gcd(i,j)&#x3D;&#x3D;1]F(j)$<br>莫比乌斯反演，知道$\mu * I &#x3D; \epsilon$，则<br>$\sum \limits_{d \mid gcd(i,j)} &#x3D; [gcd(i,j)&#x3D;&#x3D;1]$<br>$d\mid gcd(i,j)$等价于$d\mid i,d\mid j$<br>转换成枚举d，然后就可以$O(n\log n)$枚举倍数算了</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>签到</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>有n个区间，要求选择某些区间，定义选择出的区间的价值为min(选择的区间个数，区间交集的长度)，要求最大化该价值<br>$n \leq 3\times 10^5$<br>显然可以二分，$O(n\log n)$的check也很简单，但是会被卡t<br>考虑如何$O(n)$的check<br>看价值能不能达到v，就等价于选择v个区间，且这些区间的交集的长度$\geq v$<br>将所有区间按照左端点先排序<br>枚举交集的区间的左端点l，则右端点为l+v-1，只要左端点小于等于l的区间中存在至少v个右端点$\geq l+v-1$即可，尺取法</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>有n个数字，总长度不超过$10^6$，让你求这些数字的所有本质不同子串的价值（数字大小）和<br>我描述成本质不同子串之后，应该很容易想到exsam<br><del>几个月没写概念都忘完</del><br>只需要建出exsam的dag图，然后按照拓扑序dp即可，只需要知道以每个endpos集合（即图上的每个节点）结尾的所有子串的和，如u有个i的出边连向v，则就有$dp[u]<em>10+i</em>|u|$的贡献，$|u|$就表示u这个endpos集合的大小，就是len[u] - len[fa[u]]<br>交上去wa了，想到一个前导0的坑点，比如302中，02和2应该算同一个？这样应该也能做，只要把原点的0出边的状态能到达的点的endpos集合大小-1就行。<br>其实并不是<br>题面模998244353，数据是模1000000007，离谱</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>一个长度为n的序列c，求有多少个子序列满足每种数字出现偶数次<br>$n\leq 10^6,c_i\leq 20$<br>子序列考虑前缀和，对20种数字状压即可</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>让你构造一个最大的数，满足它的每个前缀都能被这个前缀的长度整除，构造的数字要求用火柴棒表示，且要求恰好使用n根<br>$n \leq 10^{100}$<br>稍微想想就能感觉到符合的数位数不会很大，事实上长度超过3就一定不行了，所以暴力dfs就完事了</p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>一个集合包含1-n n个数，要求你依次选择m个数的集合，要求集合间没有交集，集合可以空，求操作的方案数<br>转化一下，可以考虑第i个数归属哪个集合，显然有m+1种选择，没被选或者选到第j个集合。<br>所以答案就是$(m+1)^n$<br>python的pow自带快速幂</p><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>一个序列，要求支持修改一个数，询问以某个数为最小值的区间个数。<br>保证序列中没有重复数字<br>显然只要找到左右两边第一个小于你的数即可<br>记录区间最小值，线段树上贪心着走即可</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>规律题</p><h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>二维SG</p><h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><p>可以从起点出发带x个物品，走第y步路的消费是$x^y$，多次询问从s到t，你拥有m元钱，则在起点最多带多少个物品。<br>点数是100<br>先跑个floyd，则s到t的花费就是一个等比数列，二分一下公比即可，注意公比为1的情况</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>n皇后，但是可以在一条斜线<br>状压dp</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>输出string s+string t</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ccpc 绵阳</title>
      <link href="/2020/11/02/2020ccpc-mian-yang/"/>
      <url>/2020/11/02/2020ccpc-mian-yang/</url>
      
        <content type="html"><![CDATA[<h2 id="D：-Defuse-the-Bombs"><a href="#D：-Defuse-the-Bombs" class="headerlink" title="D： Defuse the Bombs"></a>D： Defuse the Bombs</h2><p>有n个计数器，初值为aia_iai​，每秒钟可以将一个计数器的值+1，然后所有的计数器的值-1。问最多几秒后所有计数器的最小值$&lt;0$<br>$n\leq 10^5, 0 \leq a_i \leq 10^9$</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>转化一下问题：每秒钟可以让一个计数器值+1，第i秒钟要求所有计数器的值$\geq i$，问第几秒后不满足。<br>假如第x秒钟满足条件，则要满足$sum_p+x \geq x*p$，其中$a_p$​为小于x的最大的p。<br>先枚举$a_i$​，找到第一个不满足的，那么答案就是$\frac{sum_i}{i-1}+1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  ll p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1ll</span>*i*a[i]-sum[i]&gt;a[i]) <span class="keyword">break</span>;</span><br><span class="line">    p = i;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; sum[p]/(p<span class="number">-1</span>)+<span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> kase=<span class="number">1</span>; kase&lt;=_; kase++) <span class="built_in">solve</span>(kase);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Knowledge-is-Power"><a href="#K-Knowledge-is-Power" class="headerlink" title="K Knowledge is Power"></a>K Knowledge is Power</h2><p>给定数x，要求将其分解成若干大于1的数，要求满足两两互质且和为x。最小化这些数的最大值和最小值的差值。<br>$5 \leq x \leq 10^9$</p><h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><p>x为奇数，显然$2\frac{x-1}{2}, \frac{x+1}{2}$​最优，为1<br>考虑x为偶数：<br>x&#x3D;6无解<br>x&#x3D;8，分成3和5即可（我一开始误判成无解）<br>通过打表得到答案只可能是2，3，4<br>x是3的倍数，显然可以分成y,y+1,y+2y, y+1, y+2y,y+1,y+2的形式，又由于y一定是奇数，所以合法，答案为2<br>x%3&#x3D;&#x3D;1x%3&#x3D;&#x3D;1x%3&#x3D;&#x3D;1，如果能分成互质的y,y+1,y+3y, y+1, y+3y,y+1,y+3则为3，否则为4<br>x%3&#x3D;&#x3D;2x%3&#x3D;&#x3D;2x%3&#x3D;&#x3D;2，如果能分成互质的y,y+2,y+3y, y+2, y+3y,y+2,y+3则为3，否则为4</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">6</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x&amp;<span class="number">1</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">0</span>) cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(__gcd(x/<span class="number">2</span><span class="number">-1</span>, x/<span class="number">2</span>+<span class="number">1</span>)==<span class="number">1</span>) cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> a = (x<span class="number">-5</span>)/<span class="number">3</span>, b = a+<span class="number">2</span>, c = a+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(a, b)==<span class="number">1</span> &amp;&amp; __gcd(a, c)==<span class="number">1</span> &amp;&amp; __gcd(b, c)==<span class="number">1</span>) ok = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> a = (x<span class="number">-4</span>)/<span class="number">3</span>, b = a+<span class="number">1</span>, c = a+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>( __gcd(a, b)==<span class="number">1</span> &amp;&amp; __gcd(a, c)==<span class="number">1</span> &amp;&amp; __gcd(b, c)==<span class="number">1</span>) ok = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(ok) cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=_; k++) <span class="built_in">solve</span>(k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-Joy-of-Handcraft"><a href="#J-Joy-of-Handcraft" class="headerlink" title="J Joy of Handcraft"></a>J Joy of Handcraft</h2><p>有n个灯泡，分别有周期$t_i$​，每两个周期中，前一个周期亮，后一个周期暗，有亮度$x_i$​。<br>问1-m每个时间内的最大亮度<br>n$n \leq 10^5, m \leq 10^5, t_i \leq 10^5, x_i \leq$</p><h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><p>周期相同的只要取亮度最大的那个，然后暴力枚举每种周期的灯泡亮的时间，复杂度是O(nlogn)O(nlogn)O(nlogn)，<br>注意到将亮度排序后，就是个区间覆盖问题了，线段树即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cov[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cov[p&lt;&lt;<span class="number">1</span>] = cov[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = cov[p];</span><br><span class="line">  cov[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">  &#123;</span><br><span class="line">    cov[p] = v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cov[p]) <span class="built_in">push</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">cover</span>(p&lt;&lt;<span class="number">1</span>, l, mid, x, y, v);</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">cover</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, x, y, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123; cout &lt;&lt; cov[p] &lt;&lt; <span class="string">&quot; \n&quot;</span>[l==m]; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span>(cov[p]) <span class="built_in">push</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">print</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">print</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">4</span>*m; i++) cov[i] = <span class="number">0</span>;</span><br><span class="line">  vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">lamb</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : lamb) cin &gt;&gt; it.first &gt;&gt; it.second;</span><br><span class="line">  <span class="built_in">sort</span>(<span class="built_in">begin</span>(lamb), <span class="built_in">end</span>(lamb));</span><br><span class="line">  vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; tmp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="type">int</span>)lamb.<span class="built_in">size</span>(); )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;(<span class="type">int</span>)lamb.<span class="built_in">size</span>() &amp;&amp; lamb[j].first==lamb[i].first) ++j;</span><br><span class="line">    tmp.<span class="built_in">push_back</span>(&#123;lamb[j<span class="number">-1</span>].second, lamb[j<span class="number">-1</span>].first&#125;);</span><br><span class="line">    i = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(<span class="built_in">begin</span>(tmp), <span class="built_in">end</span>(tmp));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : tmp)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=m; k+=<span class="number">2</span>*it.second) <span class="built_in">cover</span>(<span class="number">1</span>, <span class="number">1</span>, m, k, <span class="built_in">min</span>(m, k+it.second<span class="number">-1</span>), it.first);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=_; k++) <span class="built_in">solve</span>(k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L-Lottery"><a href="#L-Lottery" class="headerlink" title="L Lottery"></a>L Lottery</h2><p>有n种石头，第i种石头体积为$2^{a_i}$​，数量为$x_i$​，问能拼成的体积数量。<br>$n \leq 10^5, a_i, x_i \leq 10^9$</p><h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h3><p>按照体积从小到大考虑<br>设当前枚举到第i块石头，前$i-1$块石头(前mx的体积中)不能拼成的体积为ans，前2$2^{a_{i-1}}$​的体积中有delta个不能被拼成，之前所有石头能拼成的最大体积为$mx$。<br>$mx\geq 2^{a_i}$​：<br>那么对于$2^{a_{i-1}}$​到$2^{a_i}$​之间，每$2^{a_{i-1}}$​个就有delta个体积不能被拼成。<br>因此$\leq 2^{a_i}$​的体积中不能拼成的体积的数量就是$2^{a_i-a_{i-1}}\times delta$，前i块石头不能拼成的体积就要增加$delta<em>x_i$​个<br>$mx&lt;2^{a_i}$​：<br>那么$mx+1$到$2^{a_i}-1$之间的体积就无法拼成<br>前$2^{a_{i}}$​的体积中有$ans+2^{a_i}-mx-1$不能被拼成<br>前i块石头不能拼成的体积增加$delta</em>x_i$​个</p><p>由于有取模操作，不能直接判断$mx$和$2^{a_i}$​的大小关系，用一个map来存储mx的二进制表示即可，只要mx的二进制中最高位high$\geq a_i$​，就说明$mx \geq 2^{a_i}$​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; p[i].fi &gt;&gt; p[i].se;</span><br><span class="line">  map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; bit;</span><br><span class="line">  <span class="built_in">sort</span>(p+<span class="number">1</span>, p+n+<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> mx = <span class="number">0</span>, delta = <span class="number">0</span>, ans = <span class="number">0</span>, high = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="built_in">Pow</span>(<span class="number">2</span>, p[i].fi);</span><br><span class="line">    <span class="keyword">if</span>(high&gt;=p[i].fi)</span><br><span class="line">    &#123;</span><br><span class="line">      delta = <span class="number">1ll</span>*delta*<span class="built_in">Pow</span>(<span class="number">2</span>, p[i].fi-p[i<span class="number">-1</span>].fi)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//cout &lt;&lt; cur &lt;&lt; &#x27; &#x27; &lt;&lt; mx &lt;&lt; &#x27; &#x27; &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">      delta = ((cur-mx<span class="number">-1</span>+ans)%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; delta &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    ans = (ans + <span class="number">1ll</span>*delta*p[i].se)%mod;</span><br><span class="line">    mx = (mx + <span class="number">1ll</span>*cur*p[i].se)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">30</span>; j++)</span><br><span class="line">      <span class="keyword">if</span>((p[i].se&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> x = p[i].fi + j;</span><br><span class="line">        bit[x]++;</span><br><span class="line">        <span class="keyword">while</span>(bit[x]==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          bit[x] = <span class="number">0</span>;</span><br><span class="line">          ++x;</span><br><span class="line">          bit[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        high = <span class="built_in">max</span>(high, x);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  cout &lt;&lt; ((mx - ans + <span class="number">1</span>)%mod+mod)%mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=_; k++) <span class="built_in">solve</span>(k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Game-of-Cards"><a href="#G-Game-of-Cards" class="headerlink" title="G Game of Cards"></a>G Game of Cards</h2><p>有$c_0$​个0号牌，$c_1$​个1号牌，$c_2$​个2号牌，$c_3$​个3号牌，每次操作可以选取两张和不超过3的牌，然后将这两张牌换成一张它们的和的号的牌，不能操作者输。<br>$0\leq c_0,c_1,c_2, c_3\leq 10^9$</p><h3 id="做法-4"><a href="#做法-4" class="headerlink" title="做法"></a>做法</h3><p>简单分析一下：<br>3号牌只能和0号牌组合，且只会增加不会减少，影响到局面的就是3号牌有还是没有。<br>如果操作0号牌，每次必然会减少1，所以0号牌影响局面的是它的奇偶性。<br>然后只需要对1和2的数目以及3号牌是0还是1，0号牌是奇数还是偶数打个sg表即可。<br>发现只有0号牌时，需要特判。<br>此外3号牌没有影响。<br>0号牌有偶数个时，2号牌为0和非0时，1号牌模3各有一个规律<br>0号牌有奇数个时，2号牌为0和1和&gt;1时，1号牌模3各有一规律<br>if else一下即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">win</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Rabbit\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lose</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Horse\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a, b, c, d;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">  <span class="type">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!c)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b%<span class="number">3</span>==<span class="number">2</span>) ok = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> ok = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b%<span class="number">3</span>==<span class="number">0</span>) ok = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!c)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b%<span class="number">3</span>==<span class="number">2</span>) ok = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b%<span class="number">3</span>==<span class="number">0</span>) ok = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> ok = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b%<span class="number">3</span>==<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!b&amp;&amp;!c&amp;&amp;!d)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a&amp;<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> ok = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ok ? <span class="built_in">win</span>() : <span class="built_in">lose</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=_; k++) <span class="built_in">solve</span>(k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019ccpc 秦皇岛A. Angle Beats</title>
      <link href="/2020/10/09/2019ccpc-qin-huang-dao-a-angle-beats/"/>
      <url>/2020/10/09/2019ccpc-qin-huang-dao-a-angle-beats/</url>
      
        <content type="html"><![CDATA[<p>给定n个点，有q次询问，每次询问给出一定点，问从原来的n个点中选出两个和当前点构成直角三角形的方案数<br>$n\leq2000,q\leq2000$<br>思路很显然，第一种是询问点作为直角顶点，第二种是询问点不是直角顶点，分别统计即可<br>对于第一种，只要记录所有点和询问点的斜率，第二种只要预处理出初始的每个点和其它点的斜率<br>如果用atan2，精度会炸，这里用分数的形式来表示，如果斜率为$\dfrac{y}{x}$​,那就要查找$\dfrac{-x}{y}$的个数，提前将斜率预处理好并排序，然后查询只要upper_bound - lower_bound即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> db eps = <span class="number">1e-15</span>, pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Frac</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a%b); &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="built_in">Frac</span>() : <span class="built_in">a</span>(<span class="number">0</span>), <span class="built_in">b</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Frac</span>(<span class="type">int</span> x) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Frac</span>(<span class="type">int</span> x, <span class="type">int</span> y) &#123; a = x, b = y; <span class="built_in">norm</span>(); &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Frac f) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="number">1ll</span>*a*f.b &lt; <span class="number">1ll</span>*b*f.a; &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> == (Frac f) &#123; <span class="keyword">return</span> <span class="number">1ll</span>*a*f.b == <span class="number">1ll</span>*b*f.a; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">norm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(a), <span class="built_in">abs</span>(b));</span><br><span class="line">    a = a/g*<span class="built_in">sgn</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(!a) b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!b) a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> b = <span class="built_in">abs</span>(b/g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> (x&lt;-eps ? <span class="number">-1</span> : x&gt;eps); &#125;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">&#125;p[N];</span><br><span class="line">Frac seq[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(i&lt;x) seq[x][i] = <span class="built_in">Frac</span>(p[i].y-p[x].y, p[i].x-p[x].x);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;x) seq[x][i<span class="number">-1</span>] = <span class="built_in">Frac</span>(p[i].y-p[x].y, p[i].x-p[x].x);</span><br><span class="line">    <span class="built_in">sort</span>(seq[x]+<span class="number">1</span>, seq[x]+n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">  <span class="built_in">pre</span>();</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; p[<span class="number">0</span>].x &gt;&gt; p[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) seq[<span class="number">0</span>][i] = <span class="built_in">Frac</span>(p[i].y-p[<span class="number">0</span>].y, p[i].x-p[<span class="number">0</span>].x);</span><br><span class="line">    <span class="built_in">sort</span>(seq[<span class="number">0</span>]+<span class="number">1</span>, seq[<span class="number">0</span>]+n+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">Frac <span class="title">k</span><span class="params">(-p[<span class="number">0</span>].x+p[i].x, p[<span class="number">0</span>].y-p[i].y)</span></span>;</span><br><span class="line">      ans += <span class="built_in">upper_bound</span>(seq[i]+<span class="number">1</span>, seq[i]+n, k) - <span class="built_in">lower_bound</span>(seq[i]+<span class="number">1</span>, seq[i]+n, k);</span><br><span class="line">      ans2 += <span class="built_in">upper_bound</span>(seq[<span class="number">0</span>]+<span class="number">1</span>, seq[<span class="number">0</span>]+n+<span class="number">1</span>, k) - <span class="built_in">lower_bound</span>(seq[<span class="number">0</span>]+<span class="number">1</span>, seq[<span class="number">0</span>]+n+<span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans + ans2/<span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; q) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cf487E tourists 树剖+线段树维护圆方树</title>
      <link href="/2020/10/09/cf487e-tourists-shu-pou-xian-duan-shu-wei-hu-yuan-fang-shu/"/>
      <url>/2020/10/09/cf487e-tourists-shu-pou-xian-duan-shu-wei-hu-yuan-fang-shu/</url>
      
        <content type="html"><![CDATA[<p>给定无向图，每个点有点权，多次询问两点间所有简单路径上的点权的最小值，并要求支持修改点权</p><p>考虑建出圆方树，将方点的点权置为所有相邻圆点的点权的最小值，那答案就是两个点在圆方树上的路径上的点权最小值。但是如果一个圆点和多个方点相邻，在修改的时候复杂度就炸了。<br>此时的trick是让1为根，方点维护所有儿子的圆点的权值最小值，这样在修改时圆点只需要单点修改其父亲即可，而在查询时，如果lca是一个方点，再统计一下方点的父亲这个圆点的答案即可。<br>树剖，线段树支持单点修改，区间查询最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> low[N], dfn[N], stk[N], clk, top, cnt;</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N], T[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  low[u] = dfn[u] = ++clk;</span><br><span class="line">  stk[++top] = u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">      <span class="keyword">if</span>(low[v]&gt;=dfn[u])</span><br><span class="line">      &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x!=v; top--)</span><br><span class="line">        &#123;</span><br><span class="line">          x = stk[top];</span><br><span class="line">          T[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">          T[x].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        T[cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">        T[u].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mst[M];</span><br><span class="line"><span class="keyword">namespace</span> HLD</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sz[M], top[M], son[M], dep[M], fa[M], dfn[M], idfn[M], tot;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>; fa[u] = f;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;=n) mst[u].<span class="built_in">insert</span>(val[u]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : T[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(v!=f)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;n) mst[u].<span class="built_in">insert</span>(val[v]);</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[v]&gt;sz[son[u]]) son[u] = v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    top[u] = t;</span><br><span class="line">    dfn[u] = ++tot;</span><br><span class="line">    idfn[tot] = u;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : T[u])</span><br><span class="line">      <span class="keyword">if</span>(v!=son[u]&amp;&amp;v!=fa[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> HLD::fa;</span><br><span class="line"><span class="keyword">using</span> HLD::idfn;</span><br><span class="line"><span class="keyword">using</span> HLD::dep;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, mn;</span><br><span class="line">&#125;t[M&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; t[p].mn = <span class="built_in">min</span>(t[p&lt;&lt;<span class="number">1</span>].mn, t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mn); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].l = l, t[p].r = r;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mn = *mst[idfn[l]].<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mn = y;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>, x, y);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y);</span><br><span class="line">  <span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y) <span class="keyword">return</span> t[p].mn;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, ans = inf;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">askt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = inf;</span><br><span class="line">  <span class="keyword">while</span>(HLD::top[x]!=HLD::top[y])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[HLD::top[x]]&lt;dep[HLD::top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(<span class="number">1</span>, HLD::dfn[HLD::top[x]], HLD::dfn[x]));</span><br><span class="line">    x = fa[HLD::top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(<span class="number">1</span>, HLD::dfn[x], HLD::dfn[y]));</span><br><span class="line">  <span class="keyword">if</span>(x&gt;n) ans = <span class="built_in">min</span>(ans, val[fa[x]]);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; val[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(v); G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  cnt = n; <span class="built_in">tarjan</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  HLD::<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), HLD::<span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>*n);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> op; <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(fa[x])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> pre = *mst[fa[x]].<span class="built_in">begin</span>();</span><br><span class="line">        mst[fa[x]].<span class="built_in">erase</span>(mst[fa[x]].<span class="built_in">find</span>(val[x]));</span><br><span class="line">        mst[fa[x]].<span class="built_in">insert</span>(y);</span><br><span class="line">        <span class="type">int</span> cur = *mst[fa[x]].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(pre!=cur) <span class="built_in">upd</span>(<span class="number">1</span>, HLD::dfn[fa[x]], cur);</span><br><span class="line">      &#125;</span><br><span class="line">      val[x] = y;</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>, HLD::dfn[x], y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">askt</span>(x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Capture Stars 圆的反演</title>
      <link href="/2020/10/08/capture-stars-yuan-de-fan-yan/"/>
      <url>/2020/10/08/capture-stars-yuan-de-fan-yan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/7830/D">https://ac.nowcoder.com/acm/contest/7830/D</a><br>有一个大圆和一个小圆，两者内切于原点，然后再大圆内小圆外有若干个点，现在让你找一个圆使其和小圆外切，大圆内切，并且最大化该圆覆盖的点数<br>这种多个圆有相切关系的题，考虑圆的反演<br>反演：一个反演点O，一个反演半径R，在O的同侧有两个点P和P’，若满足|OP||OP’|&#x3D;R*R，则P和P’互为反演点<br>不经过反演点的圆的反演仍然是一个圆<br>经过反演点的圆的反演是一条直线<br>点反演还是点</p><p>再考虑本题，以小圆和大圆的内切点即原点为反演点，反演半径任意，这样就变成了两条直线，而要找的圆在反演后就是相切于这两条直线的圆，点反演后仍为点<br>对于每个点，仅当圆心的纵坐标处于一个区间内才能覆盖，全部求出后差分前缀和即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pdi = pair&lt;db, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> db eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> (x&lt;-eps ? <span class="number">-1</span> : x&gt;eps); &#125;</span><br><span class="line"><span class="function">db <span class="title">sqr</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">db R, r, invr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span></span><br><span class="line">&#123;</span><br><span class="line">  db x, y;</span><br><span class="line">  <span class="built_in">P</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">P</span>(db _x, db _y) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">  P <span class="keyword">operator</span> * (<span class="type">const</span> db k) &#123; <span class="keyword">return</span> <span class="built_in">P</span>(k*x, k*y); &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; R &gt;&gt; r;</span><br><span class="line">  invr = <span class="number">2</span>*R;</span><br><span class="line">  db xl = <span class="number">0.5</span>*<span class="built_in">sqr</span>(invr)/R, xr = <span class="number">0.5</span>*<span class="built_in">sqr</span>(invr)/r;</span><br><span class="line">  db O = (xl+xr)/<span class="number">2</span>, Or = (xr-xl)/<span class="number">2</span>;</span><br><span class="line">  vector&lt;pdi&gt; seg;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    db d = <span class="built_in">sqrt</span>(<span class="built_in">sqr</span>(p[i].x) + <span class="built_in">sqr</span>(p[i].y));</span><br><span class="line">    db dd = <span class="built_in">sqr</span>(invr)/d;</span><br><span class="line">    p[i] = p[i]*(dd/d);</span><br><span class="line">    db t = <span class="built_in">fabs</span>(O-p[i].x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(Or-t)&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    db delta = <span class="built_in">sqrt</span>(<span class="built_in">sqr</span>(Or)-<span class="built_in">sqr</span>(t));</span><br><span class="line">    seg.<span class="built_in">push_back</span>(&#123;p[i].y-delta, <span class="number">1</span>&#125;);</span><br><span class="line">    seg.<span class="built_in">push_back</span>(&#123;p[i].y+delta+eps, <span class="number">-1</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(<span class="built_in">begin</span>(seg), <span class="built_in">end</span>(seg));</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : seg)</span><br><span class="line">  &#123;</span><br><span class="line">    cur += it.second;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;ans) ans = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Naomi with Graph 最小割</title>
      <link href="/2020/10/08/naomi-with-graph-zui-xiao-ge/"/>
      <url>/2020/10/08/naomi-with-graph-zui-xiao-ge/</url>
      
        <content type="html"><![CDATA[<p>给定一张n个点m条边的无向图，每个点有权值$a_i$​，现在可以任意加边，要求最小化$\sum_{i&#x3D;1}^n(a_i-<br>dist_i)^2$，其中$dist_i$​表示1到i点的最短路<br>$n \leq 40,m \leq 1600$</p><p>任意加边并不代表每个点的的$dist_i$​都可以任意，仍然要满足一下条件<br>$dist_1 &#x3D; 0$<br>$dist_i \not &#x3D; 0, i \not&#x3D; 1$<br>$|dist_i-dist_j| \leq 1,(i,j) \in E$</p><p>考虑对每个点拆成n-1个点，S和第一个点相连，第i个点和第i+1个点相连，第n-1个点和T相连，边权即为$(a_i-j)^2$，由于$dist_1&#x3D;0$，所以直接让1拆出的第一个点和S不连边，最后再加上$a_i^2$​的贡献。再考虑第三个限制，如果i和j有边，就让i拆出的第x个点向j拆出的第x-1个点连边，j同理。这样如果割掉i点拆出的x和x+1之间的边，就表示$dist_i&#x3D;x$，并且此时对于和i有边的j，必须割掉x-1和x或者x和x+1或者x+1和x+2这三条边之一。所以这样建图再跑最小割即可。<br><img src="/../post-images/1602154040898.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小圆覆盖至少x个点</title>
      <link href="/2020/10/06/zui-xiao-yuan-fu-gai-zhi-shao-x-ge-dian/"/>
      <url>/2020/10/06/zui-xiao-yuan-fu-gai-zhi-shao-x-ge-dian/</url>
      
        <content type="html"><![CDATA[<p>先考虑一个问题，平面上有n个点，问用一个单位圆最多能覆盖几个点<br>可以转化成将所有点变成以该点为圆心的单位圆，被圆覆盖最多次的点就是答案<br>考虑枚举一个圆，其余圆和该圆如果有交，就是该圆上的一段圆弧，求出极角后就可以转化为一个区间覆盖最多次的问题，差分+前缀和即可。<br>该题可以二分最小圆的半径，然后用以上方法来check即可<br><a href="https://www.zhihu.com/question/266750532/answer/312982493">https://www.zhihu.com/question/266750532/answer/312982493</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pdi = pair&lt;db, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> db eps = <span class="number">1e-8</span>, pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> (x&lt;-eps ? <span class="number">-1</span> : x&gt;eps); &#125;</span><br><span class="line"><span class="function">db <span class="title">sqr</span><span class="params">(db x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="type">int</span> n, s;</span><br><span class="line">db R;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span></span><br><span class="line">&#123;</span><br><span class="line">  db x, y;</span><br><span class="line">  <span class="built_in">P</span>() &#123;&#125;</span><br><span class="line">  <span class="function">db <span class="title">dis</span><span class="params">(P p)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">sqr</span>(x-p.x) + <span class="built_in">sqr</span>(y-p.y)); &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">norm</span><span class="params">(db&amp; theta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">sgn</span>(theta)&lt;<span class="number">0</span>) theta += <span class="number">2</span>*pi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(db r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    vector&lt;pdi&gt; pre;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      db d = p[i].<span class="built_in">dis</span>(p[j]);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">sgn</span>(d)==<span class="number">0</span>) &#123; ++cnt; <span class="keyword">continue</span>; &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">sgn</span>(d<span class="number">-2</span>*r)&gt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      db p1 = <span class="built_in">atan2</span>(p[j].y-p[i].y, p[j].x-p[i].x);</span><br><span class="line">      db p2 = <span class="built_in">acos</span>(<span class="number">0.5</span>*d/r);</span><br><span class="line">      db l = p1 - p2, r = p1 + p2;</span><br><span class="line">      <span class="built_in">norm</span>(l), <span class="built_in">norm</span>(r);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">sgn</span>(r-l)&gt;=<span class="number">0</span>) pre.<span class="built_in">push_back</span>(&#123;l, <span class="number">1</span>&#125;), pre.<span class="built_in">push_back</span>(&#123;r+eps, <span class="number">-1</span>&#125;);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        pre.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;), pre.<span class="built_in">push_back</span>(&#123;r+eps, <span class="number">-1</span>&#125;);</span><br><span class="line">        pre.<span class="built_in">push_back</span>(&#123;l, <span class="number">1</span>&#125;), pre.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>*pi+eps, <span class="number">-1</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx = cnt, cur = cnt;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">begin</span>(pre), <span class="built_in">end</span>(pre));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="type">int</span>)pre.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      cur += pre[i].se;</span><br><span class="line">      <span class="keyword">if</span>(cur&gt;mx) mx = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mx&gt;=s) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  db l = <span class="number">0.0</span>, r = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      r = <span class="built_in">max</span>(r, p[i].<span class="built_in">dis</span>(p[j]));</span><br><span class="line">  db ans = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">  &#123;</span><br><span class="line">    db mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid, ans = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans + R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">  cin &gt;&gt; R;</span><br><span class="line">  <span class="keyword">if</span>(s&gt;n) cout &lt;&lt; <span class="string">&quot;The cake is a lie.\n&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">work</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">  <span class="keyword">while</span>(_--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020牛客国庆集训派对day1</title>
      <link href="/2020/10/01/2020-niu-ke-guo-qing-ji-xun-pai-dui-day1/"/>
      <url>/2020/10/01/2020-niu-ke-guo-qing-ji-xun-pai-dui-day1/</url>
      
        <content type="html"><![CDATA[<p>题目都不难，貌似是去年欧洲区域赛题</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>给定一个长度为n的字符串，问你最少在 <strong>后面</strong> 添加多少个字符，使其变成回文串<br>$n \leq 4 \times10^5$<br>注意是只能加在后面，所以马拉车一下就行，找一个最长的回文后缀，然后补齐前缀即可<br>（如果是任意添加，那答案就是正串和反串的LCS，只能$n^2$）</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>给定一个长度为n的数组a，定义$g(i, j) &#x3D;<br>gcd(a_i,\dots,a_j),m(i,j) &#x3D;<br>max(a_i,\dots,a_j)$，求$\sum_{i&#x3D;1}^n\sum_{j&#x3D;i}^n<br>g(i,j)m(i,j)$<br>$n \leq 2\times10^5$<br>很套路的题，gcd可以分成不同的log段<br>枚举右端点，利用单调栈和线段树动态维护后缀最值，然后二分gcd不同的段的左端点即可<br>一种更好的写法是利用路径压缩，可以去掉一个log<br>令$g_i$​表示i到当前右端点的gcd的值，$nxt_i$​表示i左边第一个g与$g_i$​不同的点，不断跳$nxt_i$​，当i和$nxt_i$​的gcd相同时，就合并$nxt_i<br>&#x3D; nxt_{nxt_i}$</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>给定一棵树，每次可以修改一个点的父亲，问最少几次操作变成一条链<br>答案就是所有大于2的点的度数-2的和<br>因为度数$\leq 2$可以不管，$&gt;2$，就必须把其它的点挪走</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>给定n个点，1条直线，参数r<br>让你在这条直线上选择一个点作为圆心，作一个半径为r的圆，覆盖最多的点，求点数<br>$n \leq 3 \times 10^5$<br>考虑每个点能被覆盖的都是直线上的一个区间，求出区间后，就相当于用一个长度为$2r$的区间覆盖最多的区间，因为区间的长度都是小于$2r$的，所以离散化之后差分前缀和取max即可<br>另一种做法是先按区间的左端点升序排序，枚举第i个区间作为最后一个被覆盖的区间，贪心的考虑肯定将圆心放在该区间的左端点上（即尽可能的靠左），此时覆盖的点的个数就是前面所有右端点$\geq$该左端点的区间个数，pbds即可</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>求$\sum\limits_{i&#x3D;n}^m \sum\limits_{d\mid i}$<br>$n\leq m \leq 10^{12}$<br>转成枚举因数d的贡献就是一个整除分块了</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>有n个数，让你找k个使得它们相与的结果最大<br>从高位往低位贪心即可，该位有超过k个1就取</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p>给出q个字符串sis_isi​，询问长度n的字符串中有多少串不包含这q个字符串<br>$\sum\limits_{i&#x3D;1}^q |s_i| \leq<br>100$，$n\leq10^9$<br>到最后才想到ac自动机，一开始一直在想容斥<br>对这q个串建出trie图，然后标记出不合法的位（每个串的末端，以及每个串可识别的后缀）<br>接下来就转成图上n步路径问题，对邻接矩阵作快速幂即可</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>给出两个字符串s和t，只包含字符AGCT，保证t可由s交换字符得到，问最少的交换次数<br>考虑置换，对于一个长度为x的循环，需要x-1次交换，所以只要贪心的最大化循环个数即可，即最小化每个循环的长度。由于只有这四种字符，所以只有可能是1234元环，从小到大搞就行</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p>给出一张无向图，多次询问只考虑给定的一个大小为s的点集时连通块的个数<br>询问的点集大小和不超过$10^5$<br>也很套路，考虑度数小的点，直接暴力枚举所有出边，如果在当前点集中就用并查集合并<br>再考虑度数大的点，对于度数大的点和度数小的点的边，我们在度数小的点中已经枚举了，所以只考虑度数大的点和度数大的点之间的边，设置阈值$n\sqrt<br>n$​，显然这样的点个数不超过2\sqrt<br>n​，直接预处理出这些点之间有没有边（用一个二维矩阵存储），再对于点集内所有度数大的点单独做一次二维for循环合并即可</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><p>给出一个数组，然后询问是否存在相应的大小关系的三元组(x1,x2,x3)(x_1, x_2, x_3)(x1​,x2​,x3​)<br>总共有13种，分别做即可</p><ul><li>三个相等111，看有没有一个数出现3次以上，map记录</li><li>$x_1&#x3D;x_2$​，枚举$x_2$​，如果前面有相等的$x_1$​，就看后面有没有大于和小于$x_2$​的，112，221</li><li>$x_2 &#x3D; x_3$​，上一种倒着做，122，211</li><li>$x_1&#x3D;x_3$​，对每种数，取最左出现和最右出现的，然后只要看两者间的最大值和最小值和这个数的关系，121，212</li><li>$x_1&lt;x_2&lt;x_3$​，枚举中间数，123</li><li>$x_1&gt;x_2&gt;x_3$​，同理，321</li><li>$x_1<x_2>x_3$​，枚举中间数，然后看左右两侧小于$x_2$​的最大的和最小的数的大小关系，132，231</li><li>$x_1&gt;x_2&lt;x_3$​，同理，213，312</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACL Beginner Contest F - Heights and Pairs</title>
      <link href="/2020/09/29/acl-beginner-contest-f-heights-and-pairs/"/>
      <url>/2020/09/29/acl-beginner-contest-f-heights-and-pairs/</url>
      
        <content type="html"><![CDATA[<p>有2n个人，身高分别为$h_i$​，求将他们两两配对，且每对人身高均不同的方案数(mod 998244353)<br>$n\leq 5\times 10^4,h_i \leq 10^5$</p><p>设恰好有i对人身高不同的方案数为$g_i$​，至少有i对人身高不同的方案数为$f_i$<br>恰好不好求，先求至少<br>$f_i &#x3D; \sum \limits_{j&#x3D;i}^n \binom{j}{i}g_j$<br>利用二项式反演<br>$g_i &#x3D; \sum \limits_{j&#x3D;i}^n(-1)^{j-i}\binom{j}{i}f_j$<br>答案即为$g_0$​<br>单独考虑每种身高，若身高为h的有x个人，则将他们配成身高相同的i组人的方案数是$\dfrac{\sum\limits_{j&#x3D;1}^i \binom{x-2*j+2}{2}}{i!}$<br>这样对每种身高就可以写出一个OGF，全部乘起来后$x^i$的系数就是i组人配对的方案数，再考虑剩余的$2n-2i$个人，任意配对的方案数为$\dfrac{(2n-2i)!}{(n-i)!2^{(n-i)}}$​，两项相乘就是$f_i$​，再用上述式子即可得到$g_0$​<br>其中n个OGF相乘利用分治NTT即可</p><p>在reverse一个空数组时会re，要注意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, h[N], cnt[N], d[N], sd[N];</span><br><span class="line"><span class="type">int</span> *f[N], buf[N&lt;&lt;<span class="number">5</span>], *<span class="built_in">np</span>(buf);</span><br><span class="line"><span class="type">int</span> fac[N], ifac[N], g[N];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> up, w[N], rev[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpw</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myassert</span><span class="params">(<span class="type">bool</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x) <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> poly</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) inv[i] = <span class="number">1ll</span>*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    up = <span class="number">1</span>; <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(up&lt;=n) up &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">    <span class="type">int</span> wn = <span class="built_in">fpw</span>(G, mod&gt;&gt;l); w[up&gt;&gt;<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>; i&lt;up; i++) w[i] = <span class="number">1ll</span>*w[i<span class="number">-1</span>]*wn%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) w[i] = w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> </span>&#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, n&lt;&lt;<span class="number">2</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(n)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> *b)</span> </span>&#123; <span class="keyword">while</span>(n--) *b++ = <span class="number">1ll</span>**a++*x%mod; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dot</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> n, <span class="type">int</span> *c)</span> </span>&#123; <span class="keyword">while</span>(n--) *c++ = <span class="number">1ll</span>**a++**b++%mod; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp[N];</span><br><span class="line">    <span class="type">int</span> u = __builtin_ctz(up/l), t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) tmp[i] = a[rev[i]&gt;&gt;u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i^l; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>, d=i&lt;&lt;<span class="number">1</span>; j^l; j+=d)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">          t = tmp[i|j|k]*w[i|k]%mod, tmp[i|j|k] = tmp[j|k]+mod-t, tmp[j|k] += t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) a[i] = tmp[i]%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">IDFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+l); <span class="built_in">DFT</span>(a, l);</span><br><span class="line">    <span class="built_in">mul</span>(a, l, mod-mod/l, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">conv</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> l)</span> </span>&#123; <span class="built_in">DFT</span>(a, l); <span class="built_in">DFT</span>(b, l); <span class="built_in">dot</span>(a, b, l, a); <span class="built_in">IDFT</span>(a, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> *b, <span class="type">int</span> m, <span class="type">int</span> *c)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> l, ta[N], tb[N];</span><br><span class="line">    <span class="keyword">if</span>(n+m==<span class="number">0</span>) <span class="comment">//此时l=1，IDFT会re！！</span></span><br><span class="line">    &#123;</span><br><span class="line">      c[<span class="number">0</span>] = <span class="number">1ll</span>*a[<span class="number">0</span>]*b[<span class="number">0</span>]%mod;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l = <span class="built_in">getlen</span>(n+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) ta[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=m; i++) tb[i] = b[i];</span><br><span class="line">    <span class="built_in">conv</span>(ta, tb, l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n+m; i++) c[i] = ta[i];</span><br><span class="line">    <span class="built_in">clear</span>(ta, l), <span class="built_in">clear</span>(tb, l);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fac[i] = <span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">  ifac[n] = <span class="built_in">fpw</span>(fac[n], mod<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) ifac[i] = <span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a&lt;b||b&lt;<span class="number">0</span>||a&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span>*fac[a]*ifac[b]%mod*ifac[a-b]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  f[p] = np, np += sd[r] - sd[l<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=d[l]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      f[p][i] = cur;</span><br><span class="line">      cur = <span class="number">1ll</span>*cur*<span class="built_in">comb</span>(cnt[l]<span class="number">-2</span>*i, <span class="number">2</span>)%mod*inv[i+<span class="number">1</span>]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">solve</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">solve</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  poly::<span class="built_in">mul</span>(f[p&lt;&lt;<span class="number">1</span>], sd[mid]-sd[l<span class="number">-1</span>], f[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>], sd[r]-sd[mid], f[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">init</span>(<span class="number">2</span>*n);</span><br><span class="line">  poly::<span class="built_in">init</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>*n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; h[i];</span><br><span class="line">    cnt[h[i]]++;</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, h[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=mx; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    d[i] = cnt[i]/<span class="number">2</span>;</span><br><span class="line">    sd[i] = sd[i<span class="number">-1</span>] + d[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve</span>(<span class="number">1</span>, <span class="number">1</span>, mx);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=sd[mx]; i++) g[i] = <span class="number">1ll</span>*f[<span class="number">1</span>][i]*fac[<span class="number">2</span>*n<span class="number">-2</span>*i]%mod*ifac[n-i]%mod*<span class="built_in">fpw</span>(<span class="built_in">fpw</span>(<span class="number">2</span>, n-i), mod<span class="number">-2</span>)%mod;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=sd[mx]; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ans = (ans - g[i] + mod)%mod;</span><br><span class="line">    <span class="keyword">else</span> ans = (ans + g[i])%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj2821 循环卷积 bluestein算法</title>
      <link href="/2020/09/25/poj2821-xun-huan-juan-ji-bluestein-suan-fa/"/>
      <url>/2020/09/25/poj2821-xun-huan-juan-ji-bluestein-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>已知多项式A*B&#x3D;C,其中*为循环卷积，给出B和C求A<br>对B和C进行任意长度的DFT（bluestein，狭义的CZT），然后点值相除再变换回去即可<br>$ij &#x3D; \binom{i+j}{2} - \binom{i}{2} - \binom{j}{2}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">19</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cp</span></span><br><span class="line">&#123;</span><br><span class="line">  db x, y;</span><br><span class="line">  <span class="built_in">cp</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">cp</span>(db _x, db _y): <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">  cp <span class="keyword">operator</span> + (cp &amp;oth) &#123; <span class="keyword">return</span> <span class="built_in">cp</span>(x+oth.x, y+oth.y); &#125;</span><br><span class="line">  cp <span class="keyword">operator</span> - (cp &amp;oth) &#123; <span class="keyword">return</span> <span class="built_in">cp</span>(x-oth.x, y-oth.y); &#125;</span><br><span class="line">  cp <span class="keyword">operator</span> * (cp &amp;oth) &#123; <span class="keyword">return</span> <span class="built_in">cp</span>(x*oth.x-y*oth.y, x*oth.y+y*oth.x); &#125;</span><br><span class="line">  cp <span class="keyword">operator</span> / (cp &amp;oth) &#123; <span class="keyword">return</span> <span class="built_in">cp</span>((x*oth.x+y*oth.y)/(oth.x*oth.x+oth.y*oth.y), (y*oth.x-x*oth.y)/(oth.x*oth.x+oth.y*oth.y)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> up, rev[N];</span><br><span class="line">cp w[N], pw[N];</span><br><span class="line"><span class="type">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  up = <span class="number">1</span>; <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(up&lt;=n) up &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;up; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">      w[i+j] = <span class="built_in">cp</span>(<span class="built_in">cos</span>(pi*j/i), <span class="built_in">sin</span>(pi*j/i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(cp *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> cp t;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i^l; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>, d=i&lt;&lt;<span class="number">1</span>; j^l; j+=d)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">        t = a[i|j|k]*w[i|k], a[i|j|k] = a[j|k]-t, a[j|k] = a[j|k]+t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IDFT</span><span class="params">(cp *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+l); <span class="built_in">DFT</span>(a, l);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) a[i].x /= l, a[i].y /= l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cp a[N], b[N], c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span>*x*(x<span class="number">-1</span>)/<span class="number">2</span>%n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bluestein</span><span class="params">(cp *a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> cp x[N], y[N];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) x[i].x = x[i].y = y[i].x = y[i].y = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) x[i] = pw[n-<span class="built_in">comb</span>(i)]*a[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++) y[i] = pw[<span class="built_in">comb</span>(i)];</span><br><span class="line">  <span class="built_in">reverse</span>(x, x+n);</span><br><span class="line">  <span class="built_in">DFT</span>(x, up); <span class="built_in">DFT</span>(y, up);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) x[i] = x[i]*y[i];</span><br><span class="line">  <span class="built_in">IDFT</span>(x, up);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&lt;=<span class="number">2</span>*n<span class="number">-2</span>; i++) a[i-n+<span class="number">1</span>] = x[i]*pw[n-<span class="built_in">comb</span>(i-n+<span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ibluestein</span><span class="params">(cp *a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+n); <span class="built_in">bluestein</span>(a, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) a[i].x /= n, a[i].y /= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(cp *a, cp * b, cp * c, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">bluestein</span>(a, n);</span><br><span class="line">  <span class="built_in">bluestein</span>(b, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) c[i] = a[i]/b[i];</span><br><span class="line">  <span class="built_in">Ibluestein</span>(c, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;b[i].x);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;c[i].x);</span><br><span class="line">  <span class="built_in">init</span>(<span class="number">3</span>*n<span class="number">-3</span>);</span><br><span class="line">  pw[<span class="number">0</span>] = <span class="built_in">cp</span>(<span class="number">1</span>, <span class="number">0</span>); pw[<span class="number">1</span>] = <span class="built_in">cp</span>(<span class="built_in">cos</span>(<span class="number">2</span>*pi/n), <span class="built_in">sin</span>(<span class="number">2</span>*pi/n));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) pw[i] = pw[i<span class="number">-1</span>]*pw[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">div</span>(c, b, a, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>, a[i].x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客 导一导 莱布尼茨求导公式</title>
      <link href="/2020/09/24/niu-ke-dao-yi-dao-lai-bu-ni-ci-qiu-dao-gong-shi/"/>
      <url>/2020/09/24/niu-ke-dao-yi-dao-lai-bu-ni-ci-qiu-dao-gong-shi/</url>
      
        <content type="html"><![CDATA[<p>求∑i&#x3D;1kaisinxxi(n)\sum\limits_{i&#x3D;1}^k a_i<br>\frac{sinx}{x^i}^{(n)}i&#x3D;1∑k​ai​xisinx​(n)<br>输出sinxxi和cosxxi\frac{sinx}{x^i} 和\frac{cosx}{x^i}xisinx​和xicosx​前的系数<br>n,k≤105n, k \leq 10^5n,k≤105</p><p>(uv)(n)&#x3D;∑k&#x3D;0n(nk)u(k)v(n−k)(uv)^{(n)} &#x3D; \sum\limits_{k&#x3D;0}^n \binom{n}{k}<br>u^{(k)}v^{(n-k)}(uv)(n)&#x3D;k&#x3D;0∑n​(kn​)u(k)v(n−k)<br>∑j&#x3D;0k(kj)sinx(k−j)∑i&#x3D;1k(aix−i)(j)\sum\limits_{j&#x3D;0}^k \binom{k}{j} sinx^{(k-j)}<br>\sum\limits_{i&#x3D;1}^k(a_ix^{-i})^{(j)}j&#x3D;0∑k​(jk​)sinx(k−j)i&#x3D;1∑k​(ai​x−i)(j)<br>发现是一个多项式乘法的形式，继续化简<br>∑j&#x3D;0k(kj)sinx(k−j)∑i&#x3D;1kai(−i)j‾x−i−j\sum\limits_{j&#x3D;0}^k \binom{k}{j}<br>sinx^{(k-j)}<br>\sum\limits_{i&#x3D;1}^ka_i(-i)^{\underline{j}}x^{-i-j}j&#x3D;0∑k​(jk​)sinx(k−j)i&#x3D;1∑k​ai​(−i)j​x−i−j<br>∑j&#x3D;0k(kj)sinx(k−j)x−j(−1)j∑i&#x3D;1kai(i+j−1)!(i−1)!x−i\sum\limits_{j&#x3D;0}^k<br>\binom{k}{j} sinx^{(k-j)}x^{-j}(-1)^j<br>\sum\limits_{i&#x3D;1}^ka_i\frac{(i+j-1)!}{(i-1)!}x^{-i}j&#x3D;0∑k​(jk​)sinx(k−j)x−j(−1)ji&#x3D;1∑k​ai​(i−1)!(i+j−1)!​x−i<br>把(i+j−1)!(i+j-1)!(i+j−1)!提出来，其余的就是两个多项式，NTT相乘后，最后再乘上(i+j−1)!(i+j-1)!(i+j−1)!的贡献即可</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 5;int n, k, fac[N], ifac[N], a[N], b[N], bb[N], c[N];const int mod = 998244353, G = 3;int up, w[N], rev[N];int fpw(int a, int b)&#123;    int ans = 1;    while(b)    &#123;        if(b&amp;1) ans = 1ll*ans*a%mod;        a = 1ll*a*a%mod;        b &gt;&gt;= 1;    &#125;    return ans;&#125;namespace poly&#123;    void init(int n)    &#123;        up = 1; int l = 0;        while(up&lt;=n) up &lt;&lt;= 1, l++;        for(int i=0; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1));        int wn = fpw(G, mod&gt;&gt;l); w[up&gt;&gt;1] = 1;        for(int i=(up&gt;&gt;1)+1; i&lt;up; i++) w[i] = 1ll*w[i-1]*wn%mod;        for(int i=(up&gt;&gt;1)-1; i&gt;=1; i--) w[i] = w[i&lt;&lt;1];    &#125;    void clear(int *a, int n) &#123; memset(a, 0, n&lt;&lt;2); &#125;    int getlen(int n) &#123; return 1&lt;&lt;(32-__builtin_clz(n)); &#125;    inline void mul(int *a, int n, int x, int *b) &#123; while(n--) *b++ = 1ll**a++*x%mod; &#125;    inline void dot(int *a, int *b, int n, int *c) &#123; while(n--) *c++ = 1ll**a++**b++%mod; &#125;    void DFT(int *a, int l)    &#123;        static unsigned long long tmp[N];        int u = __builtin_ctz(up/l), t;        for(int i=0; i&lt;l; i++) tmp[i] = a[rev[i]&gt;&gt;u];        for(int i=1; i^l; i&lt;&lt;=1)            for(int j=0, d=i&lt;&lt;1; j^l; j+=d)                for(int k=0; k&lt;i; k++)                    t = tmp[i|j|k]*w[i|k]%mod, tmp[i|j|k] = tmp[j|k]+mod-t, tmp[j|k] += t;        for(int i=0; i&lt;l; i++) a[i] = tmp[i]%mod;    &#125;    void IDFT(int *a, int l)    &#123;        reverse(a+1, a+l); DFT(a, l);        mul(a, l, mod-mod/l, a);    &#125;&#125;int comb(int n, int m)&#123;    if(n&lt;m||n&lt;0||m&lt;0) return 0;    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cin &gt;&gt; n &gt;&gt; k;    poly::init(n+k);    fac[0] = 1;    for(int i=1; i&lt;=n+k; i++) fac[i] = 1ll*fac[i-1]*i%mod;    ifac[n+k] = fpw(fac[n+k], mod-2);    for(int i=n+k-1; i&gt;=0; i--) ifac[i] = 1ll*ifac[i+1]*(i+1)%mod;    for(int i=1; i&lt;=k; i++)     &#123;        cin &gt;&gt; a[i];        a[i] = 1ll*a[i]*ifac[i-1]%mod;    &#125;    poly::DFT(a, up);    for(int i=0; i&lt;=n; i++)    &#123;        b[i] = comb(n, i);        if((n-i)%4&gt;1) b[i] = mod - b[i];        if(i&amp;1) b[i] = mod - b[i];    &#125;    for(int i=0; i&lt;=n; i+=2) bb[i] = b[i];    poly::DFT(bb, up);    for(int i=0; i&lt;up; i++) c[i] = 1ll*a[i]*bb[i]%mod;    poly::IDFT(c, up);    for(int i=1; i&lt;=n+k; i++) cout &lt;&lt; 1ll*c[i]*fac[i-1]%mod &lt;&lt; &quot; \n&quot;[i==n+k];    poly::clear(bb, up);    for(int i=1; i&lt;=n; i+=2) bb[i] = b[i];    poly::DFT(bb, up);    for(int i=0; i&lt;up; i++) c[i] = 1ll*a[i]*bb[i]%mod;    poly::IDFT(c, up);    for(int i=1; i&lt;=n+k; i++) cout &lt;&lt; 1ll*c[i]*fac[i-1]%mod &lt;&lt; &quot; \n&quot;[i==n+k];    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5394 【模板】下降幂多项式乘法</title>
      <link href="/2020/09/24/p5394-mo-ban-xia-jiang-mi-duo-xiang-shi-cheng-fa/"/>
      <url>/2020/09/24/p5394-mo-ban-xia-jiang-mi-duo-xiang-shi-cheng-fa/</url>
      
        <content type="html"><![CDATA[<p>下降幂多项式：Falling Factorial Polynomial(FFP)<br>形式f(x)&#x3D;∑i&#x3D;0naixi‾f(x) &#x3D; \sum \limits_{i&#x3D;0}^{n}<br>a_ix^{\underline{i}}f(x)&#x3D;i&#x3D;0∑n​ai​xi​<br>普通多项式与下降幂多项式是一一对应的（从高幂次向低幂次配系数即可）<br>现在给出两个下降幂多项式f，g，要求出这两个多项式乘法的结果（输出普通多项式的系数）<br>n≤105n \leq 10^5n≤105<br>在FFT下，普通多项式在单位根处的点值可以快速计算<br>而下降幂多项式在0…n0 \dots n0…n处的点值可以快速计算<br>考虑f(x)的EGF：∑i&#x3D;0∞f(i)i!xi&#x3D;∑i&#x3D;0∞∑j&#x3D;0najij‾i!xi&#x3D;∑j&#x3D;0naj∑i&#x3D;0∞1(i−j)!xi&#x3D;∑j&#x3D;0najxj∑i&#x3D;0∞xii!&#x3D;ex∑i&#x3D;0naixi\sum<br>\limits_{i&#x3D;0}^{\infty} \frac{f(i)}{i!}x^i &#x3D; \sum \limits_{i&#x3D;0}^{\infty}<br>\frac{\sum \limits_{j&#x3D;0}^{n} a_ji^{\underline{j}}}{i!}x^i &#x3D; \sum<br>\limits_{j&#x3D;0}^n a_j \sum\limits_{i&#x3D;0}^\infty \frac{1}{(i-j)!}x^i &#x3D;<br>\sum\limits_{j&#x3D;0}^n a_jx^j \sum\limits_{i&#x3D;0}^\infty \frac{x^i}{i!} &#x3D;<br>e^x\sum\limits_{i&#x3D;0}^n<br>a_ix^ii&#x3D;0∑∞​i!f(i)​xi&#x3D;i&#x3D;0∑∞​i!j&#x3D;0∑n​aj​ij​​xi&#x3D;j&#x3D;0∑n​aj​i&#x3D;0∑∞​(i−j)!1​xi&#x3D;j&#x3D;0∑n​aj​xji&#x3D;0∑∞​i!xi​&#x3D;exi&#x3D;0∑n​ai​xi<br>所以我们只要把下降幂多项式当成普通多项式，然后卷上一个exe^xex就可以快速计算出f(x)在0…n0\dots<br>n0…n处的取值（实质是f(x)x!\frac{f(x)}{x!}x!f(x)​）<br>那么将f和g分别卷上exe^xex然后对应点值相乘，再反变换回去（乘上e−x&#x3D;∑i&#x3D;0∞(−x)ii!e^{-x} &#x3D;<br>\sum\limits_{i&#x3D;0}^\infty \frac{(-x)^i}{i!}e−x&#x3D;i&#x3D;0∑∞​i!(−x)i​）即可<br>复杂度O(nlogn)O(nlogn)O(nlogn)</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 8e5 + 5;const int mod = 998244353, G = 3;int up, w[N], rev[N], fac[N], ifac[N];int fpw(int a, int b)&#123;    int ans = 1;    while(b)    &#123;        if(b&amp;1) ans = 1ll*ans*a%mod;        a = 1ll*a*a%mod;        b &gt;&gt;= 1;    &#125;    return ans;&#125;namespace poly&#123;    void init(int n)    &#123;        up = 1; int l = 0;        while(up&lt;=n) up &lt;&lt;= 1, l++;        for(int i=0; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1));        int wn = fpw(G, mod&gt;&gt;l); w[up&gt;&gt;1] = 1;        for(int i=(up&gt;&gt;1)+1; i&lt;up; i++) w[i] = 1ll*w[i-1]*wn%mod;        for(int i=(up&gt;&gt;1)-1; i&gt;=1; i--) w[i] = w[i&lt;&lt;1];    &#125;    void clear(int *a, int n) &#123; memset(a, 0, n&lt;&lt;2); &#125;    int getlen(int n) &#123; return 1&lt;&lt;(32-__builtin_clz(n)); &#125;    inline void mul(int *a, int n, int x, int *b) &#123; while(n--) *b++ = 1ll**a++*x%mod; &#125;    inline void dot(int *a, int *b, int n, int *c) &#123; while(n--) *c++ = 1ll**a++**b++%mod; &#125;    void DFT(int *a, int l)    &#123;        static unsigned long long tmp[N];        int u = __builtin_ctz(up/l), t;        for(int i=0; i&lt;l; i++) tmp[i] = a[rev[i]&gt;&gt;u];        for(int i=1; i^l; i&lt;&lt;=1)            for(int j=0, d=i&lt;&lt;1; j^l; j+=d)                for(int k=0; k&lt;i; k++)                    t = tmp[i|j|k]*w[i|k]%mod, tmp[i|j|k] = tmp[j|k]+mod-t, tmp[j|k] += t;        for(int i=0; i&lt;l; i++) a[i] = tmp[i]%mod;    &#125;    void IDFT(int *a, int l)    &#123;        reverse(a+1, a+l); DFT(a, l);        mul(a, l, mod-mod/l, a);    &#125;    inline void conv(int *a, int *b, int l) &#123; DFT(a, l); DFT(b, l); dot(a, b, l, a); IDFT(a, l); &#125;&#125;int n, m, a[N], b[N];void ffp(int *a, int n, int op)&#123;    static int tmp[N];    poly::clear(tmp, up);    if(op) for(int i=0; i&lt;=n; i++) tmp[i] = ifac[i];    else for(int i=0; i&lt;=n; i++) if(i&amp;1) tmp[i] = mod - ifac[i]; else tmp[i] = ifac[i];    poly::conv(a, tmp, up);&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cin &gt;&gt; n &gt;&gt; m;    int deg = n + m;    fac[0] = 1;    for(int i=1; i&lt;=deg; i++) fac[i] = 1ll*fac[i-1]*i%mod;    ifac[deg] = fpw(fac[deg], mod-2);    for(int i=deg-1; i&gt;=0; i--) ifac[i] = 1ll*ifac[i+1]*(i+1)%mod;    poly::init(deg&lt;&lt;1);    for(int i=0; i&lt;=n; i++) cin &gt;&gt; a[i];    for(int i=0; i&lt;=m; i++) cin &gt;&gt; b[i];    ffp(a, deg, 1); ffp(b, deg, 1);    for(int i=0; i&lt;up; i++) a[i] = 1ll*a[i]*b[i]%mod*fac[i]%mod;    ffp(a, deg, 0);    for(int i=0; i&lt;=deg; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; \n&quot;[i==deg];    return 0;&#125;</code></pre><p>那么这玩意除了做这种 <del>没啥用</del> 的模板题还能干啥呢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客挑战赛41 D买糖果 折半 多点求值</title>
      <link href="/2020/09/23/niu-ke-tiao-zhan-sai-41-d-mai-tang-guo-zhe-ban-duo-dian-qiu-zhi/"/>
      <url>/2020/09/23/niu-ke-tiao-zhan-sai-41-d-mai-tang-guo-zhe-ban-duo-dian-qiu-zhi/</url>
      
        <content type="html"><![CDATA[<p>给定n个数，求所有非空子集的和的乘积mod 998244353<br>$n \leq 32$</p><p>考虑折半L，R，很容易状压求出两部分内部各自的贡献，两部分共同的贡献可以用$\prod\limits_{i&#x3D;1}^{(1&lt;&lt;L)-1} \prod \limits_{j&#x3D;1}^{(1&lt;&lt;R)-1} (c_i + d_j)$<br>令$f(x) &#x3D; \prod \limits_{j&#x3D;1}^{(1&lt;&lt;R)-1}(x+d_j)$，显然可以用分治NTT求得该多项式，然后只要对每个$c_i$​求值后乘积即可，多点求值板子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>, G = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">17</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> up, w[N], rev[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpw</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%mod;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> poly</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) inv[i] = <span class="number">1ll</span>*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    up = <span class="number">1</span>; <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(up&lt;=n) up &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">    <span class="type">int</span> wn = <span class="built_in">fpw</span>(G, mod&gt;&gt;l); w[up&gt;&gt;<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>; i&lt;up; i++) w[i] = <span class="number">1ll</span>*w[i<span class="number">-1</span>]*wn%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(up&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) w[i] = w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> </span>&#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, n&lt;&lt;<span class="number">2</span>); &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(n)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> *b)</span> </span>&#123; <span class="keyword">while</span>(n--) *b++ = <span class="number">1ll</span>**a++*x%mod; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dot</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> n, <span class="type">int</span> *c)</span> </span>&#123; <span class="keyword">while</span>(n--) *c++ = <span class="number">1ll</span>**a++**b++%mod; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp[N];</span><br><span class="line">    <span class="type">int</span> u = __builtin_ctz(up/l), t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) tmp[i] = a[rev[i]&gt;&gt;u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i^l; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>, d=i&lt;&lt;<span class="number">1</span>; j^l; j+=d)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">          t = tmp[i|j|k]*w[i|k]%mod, tmp[i|j|k] = tmp[j|k]+mod-t, tmp[j|k] += t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) a[i] = tmp[i]%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">IDFT</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>, a+l); <span class="built_in">DFT</span>(a, l);</span><br><span class="line">    <span class="built_in">mul</span>(a, l, mod-mod/l, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">conv</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> l)</span> </span>&#123; <span class="built_in">DFT</span>(a, l); <span class="built_in">DFT</span>(b, l); <span class="built_in">dot</span>(a, b, l, a); <span class="built_in">IDFT</span>(a, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Inv</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c[N], l;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) &#123; b[<span class="number">0</span>] = <span class="built_in">fpw</span>(a[<span class="number">0</span>], mod<span class="number">-2</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">Inv</span>(a, b, n&gt;&gt;<span class="number">1</span>); l = <span class="built_in">getlen</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) c[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>; i&lt;l; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DFT</span>(c, l); <span class="built_in">DFT</span>(b, l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;l; i++) b[i] = (<span class="number">2ll</span><span class="number">-1ll</span>*c[i]*b[i]%mod+mod)%mod*b[i]%mod;</span><br><span class="line">    <span class="built_in">IDFT</span>(b, l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>; i&lt;l; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> *f[N], *g[N], buf[N&lt;&lt;<span class="number">5</span>], *<span class="built_in">np</span>(buf);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> *b, <span class="type">int</span> m, <span class="type">int</span> *c, <span class="type">int</span> deg, <span class="type">int</span> st)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> A[N], B[N], l;</span><br><span class="line">    l = <span class="built_in">getlen</span>(deg), <span class="built_in">copy</span>(a, a+n+<span class="number">1</span>, A), <span class="built_in">copy</span>(b, b+m+<span class="number">1</span>, B);</span><br><span class="line">    <span class="built_in">conv</span>(A, B, l); <span class="built_in">copy</span>(A+st, A+deg+<span class="number">1</span>, c);</span><br><span class="line">    <span class="built_in">clear</span>(A, l), <span class="built_in">clear</span>(B, l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eval_init</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    g[p] = np, np += r-l+<span class="number">2</span>, f[p] = np, np += r-l+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123; g[p][<span class="number">0</span>] = (mod-a[l])%mod, g[p][<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="type">int</span> lc = p&lt;&lt;<span class="number">1</span>, rc = lc|<span class="number">1</span>, mid = (l+r)&gt;&gt;<span class="number">1</span>, up1 = mid-l+<span class="number">1</span>, up2 = r-mid;</span><br><span class="line">    <span class="built_in">eval_init</span>(lc, l, mid, a); <span class="built_in">eval_init</span>(rc, mid+<span class="number">1</span>, r, a);</span><br><span class="line">    <span class="built_in">mul</span>(g[lc], up1, g[rc], up2, g[p], up1+up2, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eval_work</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123; a[l] = f[p][<span class="number">0</span>]; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="type">int</span> lc = p&lt;&lt;<span class="number">1</span>, rc = lc|<span class="number">1</span>, mid = (l+r)&gt;&gt;<span class="number">1</span>, up1 = mid-l+<span class="number">1</span>, up2 = r-mid;</span><br><span class="line">    <span class="built_in">mul</span>(f[p], r-l, g[rc], up2, f[lc], r-l, up2);</span><br><span class="line">    <span class="built_in">eval_work</span>(lc, l, mid, a);</span><br><span class="line">    <span class="built_in">mul</span>(f[p], r-l, g[lc], up1, f[rc], r-l, up1);</span><br><span class="line">    <span class="built_in">eval_work</span>(rc, mid+<span class="number">1</span>, r, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> *b, <span class="type">int</span> m, <span class="type">int</span> *c)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> invg[N], q[N];</span><br><span class="line">    <span class="built_in">eval_init</span>(<span class="number">1</span>, <span class="number">1</span>, m, b);</span><br><span class="line">    <span class="built_in">reverse</span>(g[<span class="number">1</span>], g[<span class="number">1</span>]+m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Inv</span>(g[<span class="number">1</span>], invg, m);</span><br><span class="line">    <span class="built_in">reverse</span>(invg, invg+m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">mul</span>(a, n, invg, m, q, n+m, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">copy</span>(q+n+<span class="number">1</span>, q+n+m+<span class="number">1</span>, f[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">eval_work</span>(<span class="number">1</span>, <span class="number">1</span>, m, c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) c[i] = (<span class="number">1ll</span>*c[i]*b[i]%mod+a[<span class="number">0</span>])%mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, a[<span class="number">35</span>];</span><br><span class="line"><span class="type">int</span> c[N], d[N], v[N];</span><br><span class="line"><span class="type">int</span> *f[N], pool[N&lt;&lt;<span class="number">5</span>], *<span class="built_in">ptr</span>(pool);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  f[p] = ptr, ptr += r-l+<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123; f[p][<span class="number">0</span>] = d[l], f[p][<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="type">int</span> lc = p&lt;&lt;<span class="number">1</span>, rc = lc|<span class="number">1</span>, mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">solve</span>(lc, l, mid); <span class="built_in">solve</span>(rc, mid+<span class="number">1</span>, r);</span><br><span class="line">  poly::<span class="built_in">mul</span>(f[lc], mid-l+<span class="number">1</span>, f[rc], r-mid, f[p], r-l+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="type">int</span> L = n/<span class="number">2</span>, R = n - L, ans = <span class="number">1</span>;</span><br><span class="line">  poly::<span class="built_in">init</span>((<span class="number">1</span>&lt;&lt;(R+<span class="number">1</span>))<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;(<span class="number">1</span>&lt;&lt;L); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;L; j++)</span><br><span class="line">        <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>) cur += a[j];</span><br><span class="line">    ans = <span class="number">1ll</span>*ans*cur%mod;</span><br><span class="line">    c[i] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;(<span class="number">1</span>&lt;&lt;R); i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;R; j++)</span><br><span class="line">        <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>) cur += a[L+j];</span><br><span class="line">    ans = <span class="number">1ll</span>*ans*cur%mod;</span><br><span class="line">    d[i] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve</span>(<span class="number">1</span>, <span class="number">1</span>, (<span class="number">1</span>&lt;&lt;R)<span class="number">-1</span>);</span><br><span class="line">  poly::<span class="built_in">eval</span>(f[<span class="number">1</span>], (<span class="number">1</span>&lt;&lt;R)<span class="number">-1</span>, c, (<span class="number">1</span>&lt;&lt;R)<span class="number">-1</span>, v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;(<span class="number">1</span>&lt;&lt;L); i++) ans = <span class="number">1ll</span>*ans*v[i]%mod;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>狄利克雷卷积相关</title>
      <link href="/2020/09/18/di-li-ke-lei-juan-ji-xiang-guan/"/>
      <url>/2020/09/18/di-li-ke-lei-juan-ji-xiang-guan/</url>
      
        <content type="html"><![CDATA[<p>狄利克雷卷积即乘法卷积<br>fn&#x3D;∑d∣ngdhndf_n &#x3D; \sum \limits_{d\mid n} g_dh_{\frac{n}{d}}fn​&#x3D;d∣n∑​gd​hdn​​<br>两个积性函数的狄利克雷卷积仍然积性</p><h4 id="Dirichlet-k-th-root"><a href="#Dirichlet-k-th-root" class="headerlink" title="Dirichlet k -th root"></a>Dirichlet k -th root</h4><p>给定f，令gk&#x3D;fg^k &#x3D; fgk&#x3D;f，求g<br>此处乘法为狄利克雷卷积<br>有结论fmod&#x3D;ϵf^{mod} &#x3D; \epsilonfmod&#x3D;ϵ，因而fmod+1&#x3D;ff^{mod+1} &#x3D;<br>ffmod+1&#x3D;f，尝试找一个x，使得x∗k&#x3D;p∗mod+1x<em>k &#x3D;<br>p</em>mod+1x∗k&#x3D;p∗mod+1，这样fxf^xfx即为答案。x&#x3D;inv(k)x&#x3D;inv(k)x&#x3D;inv(k)即可<br>由于狄利克雷卷积具有结合律，套一个快速幂</p><h4 id="P4714-「数学」约数个数和"><a href="#P4714-「数学」约数个数和" class="headerlink" title="P4714 「数学」约数个数和"></a>P4714 「数学」约数个数和</h4><p>求fn&#x3D;∑i1∣n∑i2∣i1⋯∑ik∣ik−11f_n &#x3D; \sum \limits_{i_1\mid n}\sum \limits_{i_2\mid<br>i_1} \dots \sum \limits_{i_k\mid i_{k-1}} 1fn​&#x3D;i1​∣n∑​i2​∣i1​∑​⋯ik​∣ik−1​∑​1<br>n≤1018,k≤1018n \leq 10^{18},k \leq 10^{18}n≤1018,k≤1018<br>上面这个求和形式可以转化成狄利克雷卷积的形式<br>令gi&#x3D;1g_i &#x3D; 1gi​&#x3D;1，则f&#x3D;ϵk∗gf &#x3D; \epsilon^k * gf&#x3D;ϵk∗g<br>然而这里数字太大，做不了<br>这是一个积性函数，所以对n质因数分解后考虑单个素因子的幂次的值（这里要pollard-rho）<br>对于fpxf_{p^x}fpx​，我们相当于枚举了所有满足x1+x2+⋯+xk≤xx_1+x_2+\dots + x_k \leq<br>xx1​+x2​+⋯+xk​≤x，其中xi≥0x_i \geq<br>0xi​≥0的x的组合，根据插板法其值为(x+kk)\binom{x+k}{k}(kx+k​)，由于幂次不会很大，可以转化成(x+kx)\binom{x+k}{x}(xx+k​)，暴力计算即可</p><h4 id="hdu5628-Clarke-and-math"><a href="#hdu5628-Clarke-and-math" class="headerlink" title="hdu5628 Clarke and math"></a>hdu5628 Clarke and math</h4><p>求fn&#x3D;∑i1∣n∑i2∣i1⋯∑ik∣ik−1gikf_n &#x3D; \sum \limits_{i_1\mid n}\sum \limits_{i_2\mid<br>i_1} \dots \sum \limits_{i_k\mid i_{k-1}}<br>g_{i_k}fn​&#x3D;i1​∣n∑​i2​∣i1​∑​⋯ik​∣ik−1​∑​gik​​<br>n≤105,k≤105n \leq 10^5, k\leq 10^5n≤105,k≤105<br>这题就是把上题的1换成了gikg_{i_k}gik​​<br>显然的做法就是狄利克雷卷积加快速幂<br>这边考虑仿照上一题的做法，令hih_ihi​表示gjg_jgj​转移给fijf_{ij}fij​的贡献，如果能算出hih_ihi​，那么O(nlogn)O(nlogn)O(nlogn)枚举倍数即可解决<br>这同样是个积性函数，考虑hpxh_{p^x}hpx​，相当于枚举了所有满足x1+x2+⋯+xk&#x3D;xx_1+x_2+\dots + x_k &#x3D;<br>xx1​+x2​+⋯+xk​&#x3D;x，其中xi≥0x_i \geq<br>0xi​≥0的x的组合，根据插板法值为(x+k−1x)\binom{x+k-1}{x}(xx+k−1​)<br>这里n很小，所以可以利用素数筛O(n)O(n)O(n)求得该积性函数h<br>所以总复杂度是O(nlogn)O(nlogn)O(nlogn)</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5, mod = 1e9 + 7, up = 2e5;int fac[N], ifac[N], f[N], g[N], h[N];int n, k, pr[N];bool vis[N];int fpw(int a, int b)&#123;    int ans = 1;    while(b)    &#123;        if(b&amp;1) ans = 1ll*ans*a%mod;        a = 1ll*a*a%mod;        b &gt;&gt;= 1;    &#125;    return ans;&#125;void init(int n)&#123;    fac[0] = 1;    for(int i=1; i&lt;=n; i++) fac[i] = 1ll*i*fac[i-1]%mod;    ifac[n] = fpw(fac[n], mod-2);    for(int i=n-1; i&gt;=0; i--) ifac[i] = 1ll*(i+1)*ifac[i+1]%mod;&#125;int comb(int a, int b)&#123;    if(a&lt;0||b&lt;0||a&lt;b) return 0;    return 1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;&#125;void get(int n)&#123;    h[1] = 1;    for(int i=2; i&lt;=n; i++)    &#123;        if(!vis[i]) h[i] = k, pr[++pr[0]] = i;        for(int j=1; j&lt;=pr[0]&amp;&amp;1ll*pr[j]*i&lt;=n; j++)        &#123;            vis[pr[j]*i] = 1;            if(i%pr[j]==0)             &#123;                int tmp = i/pr[j], cnt = 2;                while(tmp%pr[j]==0) ++cnt, tmp /= pr[j];                h[pr[j]*i] = 1ll*h[tmp]*comb(cnt+k-1, cnt)%mod;                 break;            &#125;            else h[pr[j]*i] = 1ll*h[i]*h[pr[j]]%mod;         &#125;    &#125;&#125;void solve()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, f+i), g[i] = 0;    get(n);    for(int i=1; i&lt;=n; i++)        for(int j=1; i*j&lt;=n; j++)            g[i*j] = (g[i*j] + 1ll*f[i]*h[j])%mod;    for(int i=1; i&lt;=n; i++) printf(&quot;%d%c&quot;, g[i], &quot; \n&quot;[i==n]);&#125;int main()&#123;    init(up);    int _; scanf(&quot;%d&quot;, &amp;_);    while(_--) solve();    return 0;&#125;</code></pre><ul><li><pre><code>*       *         * Dirichlet k -th root* P4714 「数学」约数个数和* hdu5628 Clarke and math</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC178</title>
      <link href="/2020/09/17/abc178/"/>
      <url>/2020/09/17/abc178/</url>
      
        <content type="html"><![CDATA[<p>比较水的一场</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>！运算符</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>四种边界取个max</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>简单容斥</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>问你有多少个序列满足所有元素都$\geq 3$并且和等于s<br>$s\leq 2000$<br>考虑枚举这个序列的长度为n<br>那么就要满足$x_1+\dots +x_n &#x3D; s - 2n$，其中$x_i$​为正整数，每个数$\geq 3$，那么我们给每个数减掉2就转化为正整数的要求，下面就是一个经典的组合数插板问题，答案是$\binom{s-2n-1}{n-1}$</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>给定n个点的坐标，求两点间的最大曼哈顿距离<br>很套路的题，保存(+x,+y),(+x,-y),(-x,+y),(-x,-y)四种情况的最值，枚举取max即可，容易发现虽然枚举中有不合法的情况，但一定不是最优解（因为这时候我们把绝对值取负了）</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>给定两个长度为n递增序列a和b，要求重排b，使得对于所有i，满足$a_i \neq b_i$​<br>$n \leq 2\times 10^5$<br>可以转化为一个网络流问题，对于每个$b_i$​，你可以放的位置就是a中所有$a_j \neq b_i$​的j，连边跑最大流即可，然而显然会爆<br>这种特殊的网络流，考虑贪心的解法<br>维护一个优先队列，对于每个$a_i$​，我们选择不等于$a_i$​的且可放置位置最少的那个$b_j$​，即在a中和它相等的元素最多。这样贪心即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDU95</title>
      <link href="/2020/09/15/edu95/"/>
      <url>/2020/09/15/edu95/</url>
      
        <content type="html"><![CDATA[<h2 id="D-Trash-Problem"><a href="#D-Trash-Problem" class="headerlink" title="D. Trash Problem"></a>D. Trash Problem</h2><p>有n堆物品排成一条线，可以将同一位置的<strong>所有</strong><br>物品同时移动到相邻的位置，q次操作，每次可以添加一堆物品或者删除一堆物品，并询问将所有物品移动成小于等于2堆的最小代价<br>$n \leq 10^5,q \leq 10^5$<br>第一反应应该是中位数，但要发现每次必须同时移动同一位置的所有物品，那么如果移成一堆，答案就是最大坐标$x_n$​-最小坐标$x_1$​，考虑移成两堆，只要枚举一个分割点i，然后前面的代价是$x_i-x_1$​，后面的代价是$x_n-x_{i+1}$​，所以最小代价就是最大坐标-最小坐标-<br>相邻坐标的最大差值。利用multiset动态维护即可<br>tips:可以用rbegin来指向最后一个元素，比–end方便点</p><h2 id="E-Expected-Damage"><a href="#E-Expected-Damage" class="headerlink" title="E. Expected Damage"></a>E. Expected Damage</h2><p>有n个怪物，第i个怪物的伤害为did_idi​，现在有一个盾牌，有属性a和b，当$a&gt;0$时，可以免疫$&lt;b$的伤害，而$&gt;&#x3D;b$的伤害会使$a-1$（不会受到伤害），而当$a&#x3D;0$时，会受到所有的伤害。<br>现在有m种盾牌，对于每种需要回答在n!n!n!种打怪方式下，受到的伤害的期望<br>$n \leq 2\times 10^5,m \leq 2\times 10^5$<br>考虑每种怪物的贡献，容易发现可以分成伤害$&lt;b$和$&gt;&#x3D;b$两类计算<br>最好的做法是从整体上考虑<br>定义ge为伤害$&gt;&#x3D;b$的怪物数量，le为$&lt;b$的怪物数量，将d排序后lowerbound即可<br>对于伤害$&gt;&#x3D;b$的ge个怪物，排在前a个是没有伤害的，因为会被盾牌挡掉，所以有贡献的概率就是$\frac{ge-a}{ge}，再乘上这些怪物的伤害和即可<br>对于伤害$&lt;b$的le个怪物，必须保证前面有至少a个伤害$&gt;&#x3D;b$的怪物，可以固定住ge个怪物的位置，那么现在有ge+1个空位，前a个是没有贡献的，所以有贡献的概率就是$\frac{ge+1-a}{ge+1}$​，再乘上一个前缀和即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, m, d[N], sum[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) inv[i] = <span class="number">1ll</span>*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; d[i];</span><br><span class="line">  <span class="built_in">sort</span>(d+<span class="number">1</span>, d+n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) sum[i] = (sum[i<span class="number">-1</span>] + d[i])%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> le = <span class="built_in">lower_bound</span>(d+<span class="number">1</span>, d+n+<span class="number">1</span>, b) - d - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ge = n - le;</span><br><span class="line">    <span class="type">int</span> x = (ge &lt; a ? <span class="number">0</span> : <span class="number">1ll</span>*(ge-a)*inv[ge]%mod*(sum[n]-sum[le])%mod);</span><br><span class="line">    <span class="type">int</span> y = (ge &lt; a ? <span class="number">0</span> : <span class="number">1ll</span>*(ge+<span class="number">1</span>-a)*inv[ge+<span class="number">1</span>]%mod*sum[le]%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((x+y)%mod+mod)%mod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Three-Occurrences"><a href="#G-Three-Occurrences" class="headerlink" title="G. Three Occurrences"></a>G. Three Occurrences</h2><p>给出一个数组a，定义一个区间是好的，当且仅当每个数恰好出现0次或者3次，询问好区间的个数<br>$n\leq 5\times 10^5, 1\leq a_i \leq n$<br>考虑固定左端点为i，那么$a_i$​出现0次和3次就是两个连续的区间，我们对$1-n$的每个数维护它的合法区间，如果是合法的就让这段区间的每个数都等于1，我们可以用一颗线段树来维护。从后往前枚举左端点，对于$a_i$​，我们先删除它之前的合法区间(两段区间-1)，然后再加上它当前的合法区间(两端区间+1)，只需要查询左端点-<br>n中大小等于n的值的个数即可(显然最大值$\leq n$，所以维护最大值以及最大值个数即可)<br>$O(n\log n)$<br>这题还有一种更加普适的哈希做法，而且复杂度是$O(n)$的，先咕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, mx, cnt, tag;</span><br><span class="line">  <span class="built_in">seg</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">seg</span>(<span class="type">int</span> _l, <span class="type">int</span> _r) : <span class="built_in">l</span>(_l), <span class="built_in">r</span>(_r), <span class="built_in">mx</span>(<span class="number">0</span>), <span class="built_in">cnt</span>(<span class="number">0</span>), <span class="built_in">tag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].mx = <span class="built_in">max</span>(t[p&lt;&lt;<span class="number">1</span>].mx, t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx);</span><br><span class="line">  t[p].cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].mx==t[p&lt;&lt;<span class="number">1</span>].mx) t[p].cnt += t[p&lt;&lt;<span class="number">1</span>].cnt;</span><br><span class="line">  <span class="keyword">if</span>(t[p].mx==t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx) t[p].cnt += t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setv</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].mx += v;</span><br><span class="line">  t[p].tag += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setv</span>(p&lt;&lt;<span class="number">1</span>, t[p].tag); <span class="built_in">setv</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, t[p].tag);</span><br><span class="line">  t[p].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p] = <span class="built_in">seg</span>(l, r);</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mx = n, t[p].cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setv</span>(p, v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">push</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>, x, y, v);</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y, v);</span><br><span class="line">  <span class="built_in">pull</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chk</span><span class="params">(pii &amp;a, pii b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.fi==b.fi) a.se += b.se;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(a.fi&lt;b.fi) a = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y) <span class="keyword">return</span> &#123;t[p].mx, t[p].cnt&#125;;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">push</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; pii ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">chk</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">chk</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="type">int64_t</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) p[i].<span class="built_in">push_back</span>(n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> sz = p[a[i]].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(sz&gt;=<span class="number">4</span>) <span class="built_in">upd</span>(<span class="number">1</span>, p[a[i]][sz<span class="number">-3</span>], p[a[i]][sz<span class="number">-4</span>]<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> suf = p[a[i]][sz<span class="number">-1</span>];</span><br><span class="line">    p[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    ++sz;</span><br><span class="line">    <span class="keyword">if</span>(sz&gt;=<span class="number">4</span>) <span class="built_in">upd</span>(<span class="number">1</span>, p[a[i]][sz<span class="number">-3</span>], p[a[i]][sz<span class="number">-4</span>]<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>, i, suf<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> cur = <span class="built_in">ask</span>(<span class="number">1</span>, i, n);</span><br><span class="line">    <span class="keyword">if</span>(cur.fi==n) ans += cur.se;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6800 【模板】Chirp-Z Transform</title>
      <link href="/2020/09/13/p6800-mo-ban-chirp-z-transform/"/>
      <url>/2020/09/13/p6800-mo-ban-chirp-z-transform/</url>
      
        <content type="html"><![CDATA[<p>给出一个n项多项式P，要求出在c0,c1,…,cm−1c^0,c^1,…,c^{m-1}c0,c1,…,cm−1处多项式的值<br>n≤106,m≤106n\leq 10^6,m\leq 10^6n≤106,m≤106</p><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><p>直接多点求值会t<br>P(cm)&#x3D;∑i&#x3D;0n−1aicmiP(c^m) &#x3D; \sum \limits_{i&#x3D;0}^{n-1}<br>a_ic^{mi}P(cm)&#x3D;i&#x3D;0∑n−1​ai​cmi<br>考虑把mimimi换一下<br>mi&#x3D;(m+i2)−(m2)−(i2)mi &#x3D; \binom{m+i}{2} - \binom{m}{2} -<br>\binom{i}{2}mi&#x3D;(2m+i​)−(2m​)−(2i​)<br>P(cm)&#x3D;c−(m2)∑i&#x3D;0n−1(aic−(i2))(c(m+i2))P(c^m) &#x3D; c^{-\binom{m}{2}}<br>\sum\limits_{i&#x3D;0}^{n-1}(a_ic^{-\binom{i}{2}})(c^{\binom{m+i}{2}})P(cm)&#x3D;c−(2m​)i&#x3D;0∑n−1​(ai​c−(2i​))(c(2m+i​))<br>减法卷积，把前一个翻转后NTT即可<br>注意指数上的取模要用扩展欧拉定理<br>如果把c换成ωn1\omega_n^1ωn1​即complex(cos(2π&#x2F;n),sin(2π&#x2F;n))complex(cos(2\pi&#x2F;n),sin(2\pi&#x2F;n))complex(cos(2π&#x2F;n),sin(2π&#x2F;n))，就是bluestein算法了，可以解决任意长度的卷积，就是常数很大，因为一次DFT就相当于一次多项式乘法，即三次DFT<br>小优化：由于我们只需要得到n到n+m项的值，所以n次多项式和n+m次多项式我们只需要求到n+m即可，而不用求到2*n+m</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e6 + 5;const int mod = 998244353, G = 3;int n, c, m, a[N], b[N];int up, w[N], rev[N];int fpw(int a, int b)&#123;    int ans = 1;    while(b)    &#123;        if(b&amp;1) ans = 1ll*ans*a%mod;        a = 1ll*a*a%mod;        b &gt;&gt;= 1;    &#125;    return ans;&#125;void init(int n)&#123;    up = 1; int l = 0;    while(up&lt;=n) up &lt;&lt;= 1, l++;    for(int i=0; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1));    int wn = fpw(G, mod&gt;&gt;l); w[up&gt;&gt;1] = 1;    for(int i=(up&gt;&gt;1)+1; i&lt;up; i++) w[i] = 1ll*w[i-1]*wn%mod;    for(int i=(up&gt;&gt;1)-1; i&gt;=1; i--) w[i] = w[i&lt;&lt;1];&#125;int getlen(int n) &#123; return 1&lt;&lt;(32-__builtin_clz(n)); &#125;inline void mul(int *a, int n, int x, int *b) &#123; while(n--) *b++ = 1ll**a++*x%mod; &#125;inline void dot(int *a, int *b, int n, int *c) &#123; while(n--) *c++ = 1ll**a++**b++%mod; &#125;void DFT(int *a, int l)&#123;    static unsigned long long tmp[N];    int u = __builtin_ctz(up/l), t;    for(int i=0; i&lt;l; i++) tmp[i] = a[rev[i]&gt;&gt;u];    for(int i=1; i^l; i&lt;&lt;=1)        for(int j=0, d=i&lt;&lt;1; j^l; j+=d)            for(int k=0; k&lt;i; k++)                t = tmp[i|j|k]*w[i|k]%mod, tmp[i|j|k] = tmp[j|k]+mod-t, tmp[j|k] += t;    for(int i=0; i&lt;l; i++) a[i] = tmp[i]%mod;&#125;void IDFT(int *a, int l)&#123;    reverse(a+1, a+l); DFT(a, l);    mul(a, l, mod-mod/l, a);&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;c, &amp;m);    --n, --m;    for(int i=0; i&lt;=n; i++)     &#123;        scanf(&quot;%d&quot;, a+i);        a[i] = 1ll*a[i]*fpw(c, (mod-1)-1ll*i*(i-1)/2%(mod-1))%mod;    &#125;    for(int i=0; i&lt;=n+m; i++) b[i] = fpw(c, 1ll*i*(i-1)/2%(mod-1));    init(2*n+m);    reverse(a, a+n+1);    int l = getlen(2*n+m);    DFT(a, l); DFT(b, l); dot(a, b, l, a); IDFT(a, l);    for(int i=n; i&lt;=n+m; i++) printf(&quot;%d%c&quot;, 1ll*a[i]*fpw(c, (mod-1)-1ll*(i-n)*(i-n-1)/2%(mod-1))%mod, &quot; \n&quot;[i==n+m]);    return 0;&#125;</code></pre><ul><li><pre><code>*       *         * 做法</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G、Pikachu 问题转化+换根dp</title>
      <link href="/2020/09/03/gpikachu-wen-ti-zhuan-hua-huan-gen-dp/"/>
      <url>/2020/09/03/gpikachu-wen-ti-zhuan-hua-huan-gen-dp/</url>
      
        <content type="html"><![CDATA[<p>给定一棵n个点的树，定义一张完全图，$w(u, v) &#x3D; dis(u, v)$，问你各对节点间的最大流的和<br>$n \leq 10^5$<br>最大流不好想，转化成最小割，那么s到t的最小割就是将完全图分成两个不连通的完全图，其中一个包含s，另一个包含t，然后要最大化这两个完全图内部的边权和。容易发现当其中一个点为孤立点，另一个为n-1个点的完全图是最优，相当于割去孤立点与其他n-1个点间的所有边。所以s与t间的最大流等于min(s与其他所有点在树上的距离和，t与其他所有点在树上的距离和)。<br>我们可以通过换根dp求出每个节点与其他所有点在树上的距离和，然后从大到小排序后，每个的贡献就是(rank-1)次，粗略估算可以发现答案需要用__int128存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, sz[N];</span><br><span class="line">vector&lt;pii&gt; G[N];</span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sz[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    sz[u] += sz[v];</span><br><span class="line">    dp[u][<span class="number">0</span>] += dp[v][<span class="number">0</span>] + w*sz[v];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    dp[v][<span class="number">1</span>] = dp[u][<span class="number">0</span>] - dp[v][<span class="number">0</span>] - w*sz[v] + w*(sz[u] - sz[v]) + dp[u][<span class="number">1</span>] + w*(n - sz[u]);</span><br><span class="line">    <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> buf[<span class="number">70</span>], tp;</span><br><span class="line">  tp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(!x) buf[tp = <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    buf[++tp] = x%<span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=tp; i&gt;=<span class="number">1</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> kase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) G[i].<span class="built_in">clear</span>(), dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    G[u].<span class="built_in">emplace_back</span>(v, w); G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="function">vector&lt;ll&gt; <span class="title">alldis</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) alldis[i<span class="number">-1</span>] = dp[i][<span class="number">0</span>] + dp[i][<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">sort</span>(<span class="built_in">begin</span>(alldis), <span class="built_in">end</span>(alldis)); <span class="built_in">reverse</span>(<span class="built_in">begin</span>(alldis), <span class="built_in">end</span>(alldis));</span><br><span class="line">  __int128 ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) ans += (__int128)i*alldis[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, kase); <span class="built_in">print</span>(ans); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> kase=<span class="number">1</span>; kase&lt;=_; ++kase) <span class="built_in">solve</span>(kase);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kinetic Tournament</title>
      <link href="/2020/09/03/kinetic-tournament/"/>
      <url>/2020/09/03/kinetic-tournament/</url>
      
        <content type="html"><![CDATA[<p>又是一个凸壳问题<br>现在有n条直线，第i条的斜率为$k_i$​，截距为$b_i$​，当前x坐标的值为$x_i$​，要求支持以下操作<br>1.修改第i条直线的斜率、截距<br>2.让$[l, r]$范围内所有直线的x坐标的值增加delta<br>3.询问$[l, r]$范围内所有直线的y坐标的最大值<br><a href="https://codeforces.com/blog/entry/82094">https://codeforces.com/blog/entry/82094</a><br>第二个操作必须是增加，不能减少<br>其实就是用普通的线段树来做，如果不带修改，就是一棵胜者树(tournament)，自底向上进行pushup操作，p结点存储的是子树内所有直线中y坐标最大的那条，第一个操作和第三个操作就是普通的线段树了。<br>对于第二个操作，我们在每个结点额外维护一个叫wait的变量，表示 <strong>如果子树内胜者发生变化，最少要让整个子树的x坐标增加wait</strong><br>，这个东西可以pushup来维护，而区间增加delta，用一个lazytag即可。但是当且仅当当前区间的wait值大于这个增量delta时我们才直接整个子树修改，否则由于胜者会发生变化，所以我们继续递归下去（类似于segment beats，也是用摊还分析( <del>不会</del> )），复杂度大概是$\lt O(nlog^3n) \ or \approx O(nlog^2n)$<br>那么问题来了，这玩意有啥用<br>第一个操作可以当成插入和删除直线，第二个操作相当于修改询问的值，如果询问非增我们可以离线下来，第三个操作就是区间凸壳询问，而且斜率是否单调无关紧要。<br>如果用一般的CHT，要实现区间查询，还要在外面套一个fenwicktree 或者是<br>segtree，复杂度上并没有优势，此外这个东西还能支持删除操作，似乎有点用。<br>考虑一个树上的斜率优化，斜率单调我们可以用可回退的队列来维护凸壳，但是有了这个我们直接无脑树剖，管他斜率单不单调。<br>以上纯属猜想，未经实践。。</p><h2 id="cf1178-G-The-Awesomest-Vertex"><a href="#cf1178-G-The-Awesomest-Vertex" class="headerlink" title="cf1178 G. The Awesomest Vertex"></a>cf1178 G. The Awesomest Vertex</h2><p>这个问题相当于上面的支持2和3操作的版本，同时是子树问题（dfs序即可）<br>这边要维护的是$|b_ix + a_ib_i|$的最大值，由于带绝对值，要同时维护最大值和最小值，我们考虑维护$-b_ix - a_ib_$​的最大值即可。似乎要建两棵线段树，不过这边用一个技巧。我们开一个2*n的线段树，把这两棵树合起来，一颗放在$2i-1$的位置，一颗放在$2i$的位置，然后就可以当成一棵来操作了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll inf = LLONG_MAX;</span><br><span class="line"><span class="type">int</span> n, q, a[N], b[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> in[N], out[N], num[N], id;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  in[u] = ++id;</span><br><span class="line">  num[id] = u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    a[v] += a[u]; b[v] += b[u];</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  out[u] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">  ll k, b, x;</span><br><span class="line">  <span class="function">ll <span class="title">eval</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> k*x + b; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Line&amp; oth)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ll x1 = <span class="built_in">eval</span>(), x2 = oth.<span class="built_in">eval</span>();</span><br><span class="line">    <span class="keyword">if</span>(x1!=x2) <span class="keyword">return</span> x1 &gt; x2;</span><br><span class="line">    <span class="keyword">return</span> k &gt; oth.k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">isect</span><span class="params">(<span class="type">const</span> Line&amp; oth)</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">eval</span>()-oth.<span class="built_in">eval</span>())/(oth.k-k) + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  Line L;</span><br><span class="line">  ll wait, tag;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setv</span><span class="params">(<span class="type">int</span> p, ll add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].L.x += add;</span><br><span class="line">  t[p].tag += add;</span><br><span class="line">  t[p].wait -= add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> l1 = t[p&lt;&lt;<span class="number">1</span>].L, l2 = t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].L;</span><br><span class="line">  <span class="keyword">if</span>(!l1.<span class="built_in">cmp</span>(l2)) <span class="built_in">swap</span>(l1, l2);</span><br><span class="line">  t[p].L = l1;</span><br><span class="line">  t[p].wait = <span class="built_in">min</span>(t[p&lt;&lt;<span class="number">1</span>].wait, t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].wait);</span><br><span class="line">  <span class="keyword">if</span>(l1.k&lt;l2.k) t[p].wait = <span class="built_in">min</span>(t[p].wait, l1.<span class="built_in">isect</span>(l2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setv</span>(p&lt;&lt;<span class="number">1</span>, t[p].tag), <span class="built_in">setv</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, t[p].tag);</span><br><span class="line">  t[p].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].l = l, t[p].r = r, t[p].wait = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x = num[(l+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(l&amp;<span class="number">1</span>) t[p].L = &#123;b[x], <span class="number">1ll</span>*a[x]*b[x], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span> t[p].L = &#123;-b[x], <span class="number">-1ll</span>*a[x]*b[x], <span class="number">0</span>&#125;;</span><br><span class="line">    t[p].wait = inf;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y, ll add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y &amp;&amp; t[p].wait&gt;add)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setv</span>(p, add);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>, x, y, add);</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y, add);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y) <span class="keyword">return</span> t[p].L.<span class="built_in">eval</span>();</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">qry</span>(p&lt;&lt;<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">qry</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> fa; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;fa);</span><br><span class="line">    G[fa].<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b+i);</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>*n);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;v);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ll x; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>, in[v]*<span class="number">2</span><span class="number">-1</span>, out[v]*<span class="number">2</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">qry</span>(<span class="number">1</span>, in[v]*<span class="number">2</span><span class="number">-1</span>, out[v]*<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cache friendly</title>
      <link href="/2020/09/02/cache-friendly/"/>
      <url>/2020/09/02/cache-friendly/</url>
      
        <content type="html"><![CDATA[<p>尽量减少cache miss<br>保证时空局部性，尽量连续地访存，使用局部变量<br>使用指针访问可以加快速度（仅限于卡常）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *st = a + <span class="number">1</span>, *ed = a + n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(st!=ed) <span class="built_in">work</span>(*(st++));</span><br></pre></td></tr></table></figure><ul><li>对树进行树链剖分后，子树是一个连续的区间，树上的路径也可以被划分成log段连续区间。<br>然后利用数据结构对这些连续区间进行操作即可。<br>但是有些时候数据结构这块不好写，或者常数很大，比如说需要$O(n\sqrt n \log<br>n)$来维护$10^5$个节点的操作，这时候我们可以直接对所有连续段for循环暴力$O(n^2)$维护，然后注意访问的连续性，这样cache的miss率是log级别的，通过pragma等预编译命令加速会有不错的效果</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast,no-stack-protector&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target(<span class="string">&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>该方法可以用于树上dp，如果是子树dp的话直接利用dfs序即可<br>如果是到根的树链上dp，那就先树剖，然后对每个点把到根的路径化成log个连续段，然后暴力<br>我们用一个局部变量存储需要更新的dp[u]，然后用来更新的dp[v]就是连续访存的，可以达到一定的加速效果，用指针可以略微加速</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updt</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll cur = LLONG_MAX, a = dep[u], b = p[u];</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    ll *p=tmpdep+dfn[top[x]]<span class="number">-1</span>, *q = dp+dfn[top[x]]<span class="number">-1</span>, *ped = tmpdep + dfn[x];</span><br><span class="line">    <span class="keyword">while</span>(p!=ped) <span class="built_in">chk</span>(cur, *(++q)+(a-*(++p)*b));</span><br><span class="line">    x = fa[<span class="number">0</span>][top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  ll *p=tmpdep+dfn[x]<span class="number">-1</span>, *ped = tmpdep+dfn[y], *q = dp+dfn[x] - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p!=ped) <span class="built_in">chk</span>(cur, *(++q)+(a-*(++p)*b));</span><br><span class="line">  dp[dfn[u]] = cur + q[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试$10^5$次的数据级别2.5s能出结果，这在一些时限比较宽松，正解复杂度要多个log或者根号的情况下可能可以骗过去，而$2\times 10^5$就是10s左右才能出结果了。</p><ul><li>点分治的时候我们要处理跨越重心的各部分的贡献，这需要双指针或者一些数据结构来维护，同样的我们把它们映射到连续的数组段上，在进行暴力也会有一定加速</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4072 [SDOI2016]征途 推式子 斜率优化dp</title>
      <link href="/2020/09/02/p4072-sdoi2016zheng-tu-tui-shi-zi-xie-lu-you-hua-dp/"/>
      <url>/2020/09/02/p4072-sdoi2016zheng-tu-tui-shi-zi-xie-lu-you-hua-dp/</url>
      
        <content type="html"><![CDATA[<p>给定n段路的长度，每天可以走连续的几段路，要求你走m天，并最小化每天走的路程长度的方差$\times m^2$的大小<br>$n \leq 3000,m \leq 3000$</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>方差：$\frac{1}{m}\sum (x_i - \bar{x})^2m$ &#x3D; $\frac{1}{m}(\sum x_i^2 + \sum \bar{x}^2 - 2\sum x_i\bar{x}) &#x3D; \sum x_i$<br>$\frac{1}{m}(\sum (x_i - \bar{x})^2) &#x3D; m(\sum x_i^2 - \bar{x}\sum x_i)$ &#x3D; $m\sum x_i^2 - (\sum x_i)^2$<br>容易发现后一项是定值，所以只需要最小化$\sum x_i^2$​即可<br>$dp_{i,j}$​表示前i段路走了j天的最小方差<br>$dp_{i,j} &#x3D; \min \limits_{k&lt;i} \{dp_{k,j-1} + (sum_i-sum_k)^2\}$<br>每次询问$sum_i$​处y的最小值，然后插入一条斜率为$-2sum_i$​，截距为$sum_i^2 + dp_{i,j-1}$​的直线。斜率单调递减，询问单调递增，双端队列维护下凸壳即可<br>通过斜率优化就可以$n^2$通过本题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, d[N];</span><br><span class="line">ll sum[N], dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">  ll k, b;</span><br><span class="line">  <span class="function">ll <span class="title">eval</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> k*x + b; &#125;</span><br><span class="line">  <span class="function">db <span class="title">insect</span><span class="params">(Line oth)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">db</span>(b-oth.b)/(oth.k-k); &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="type">int</span> ql, qr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, d+i), sum[i] = sum[i<span class="number">-1</span>] + d[i], dp[i][<span class="number">0</span>] = sum[i]*sum[i];</span><br><span class="line">  <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">  ll ans = dp[n][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">2</span>; c&lt;=m; c++, p^=<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    q[ql=qr=<span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span>(ql&lt;qr &amp;&amp; q[ql].<span class="built_in">insect</span>(q[ql+<span class="number">1</span>])&lt;=sum[i]) ++ql;</span><br><span class="line">      dp[i][p] = q[ql].<span class="built_in">eval</span>(sum[i]) + sum[i]*sum[i];</span><br><span class="line">      Line cur = &#123;<span class="number">-2</span>*sum[i], sum[i]*sum[i]+dp[i][p^<span class="number">1</span>]&#125;;</span><br><span class="line">      <span class="keyword">while</span>(ql&lt;qr &amp;&amp; cur.<span class="built_in">insect</span>(q[qr])&lt;=cur.<span class="built_in">insect</span>(q[qr<span class="number">-1</span>])) --qr;</span><br><span class="line">      q[++qr] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, dp[n][p]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, m*ans-sum[n]*sum[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4655 [CEOI2017]Building Bridges 斜率优化</title>
      <link href="/2020/09/02/p4655-ceoi2017building-bridges-xie-lu-you-hua/"/>
      <url>/2020/09/02/p4655-ceoi2017building-bridges-xie-lu-you-hua/</url>
      
        <content type="html"><![CDATA[<p>有n根柱子，第i根柱子的高度为hih_ihi​，被拆除的代价为wiw_iwi​，在j和i两根柱子间架桥的费用为(hi−hj)2+∑k&#x3D;j+1i−1wk(h_i-<br>h_j)^2 + \sum \limits_{k&#x3D;j+1}^{i-1} w_k(hi​−hj​)2+k&#x3D;j+1∑i−1​wk​，问连接1和n的最小代价</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>dpi&#x3D;min⁡j&lt;i{dpj+(hi−hj)2+si−1−sj}dp_i &#x3D; \min \limits_{j&lt;i} \{dp_j + (h_i-<br>h_j)^2 + s_{i-1} - s_j\}dpi​&#x3D;j&lt;imin​{dpj​+(hi​−hj​)2+si−1​−sj​} 此处s为w的前缀和<br>显然可以化为斜率优化的形式<br>每次询问hih_ihi​处y的最小值，然后插入一条斜率为−2hi-2h_i−2hi​，截距为hi2−si+dpih_i^2-s_i+dp_ihi2​−si​+dpi​的直线。<br>由于这里的hih_ihi​不具备单调性，所以不能用队列来维护。可以用平衡树、李超树或者cdq分治解决</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 1e5 + 5;int n, h[N];ll w[N], dp[N];bool Cmp;struct Line &#123;    mutable ll k, b, p;    bool operator &lt; (const Line&amp; oth) const &#123; return Cmp ? p &lt; oth.p : k &lt; oth.k; &#125;&#125;;struct ConvecHull : multiset&lt;Line&gt; &#123;    static const ll inf = LLONG_MAX;    ll div(ll a, ll b)     &#123;         if(!b) return a&gt;0 ? inf : -inf;        return a / b - ((a ^ b) &lt; 0 &amp;&amp; a % b);     &#125;    bool isect(iterator x, iterator y)     &#123;        if (y == end()) &#123; x-&gt;p = inf; return false; &#125;        if (x-&gt;k == y-&gt;k) x-&gt;p = x-&gt;b &gt; y-&gt;b ? inf : -inf;        else x-&gt;p = div((y-&gt;b - x-&gt;b), (x-&gt;k - y-&gt;k));        return x-&gt;p &gt;= y-&gt;p;    &#125;    void add(ll k, ll b)     &#123;        auto z = insert(&#123;k, b, 0&#125;), y = z++, x = y;        while (isect(y, z)) z = erase(z);        if (x != begin() &amp;&amp; isect(--x, y)) isect(x, y = erase(y));        while ((y = x) != begin() &amp;&amp; (--x)-&gt;p &gt;= y-&gt;p) isect(x, erase(y));    &#125;    ll qry(ll x)     &#123;        Cmp = 1; auto l = *lower_bound(&#123;0, 0, x&#125;); Cmp = 0;        return l.k * x + l.b;    &#125;&#125;ch;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, h+i);    for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;, w+i), w[i] += w[i-1];    ch.add(2*h[1], -1ll*h[1]*h[1]+w[1]);    for(int i=2; i&lt;=n; i++)    &#123;        dp[i] = -ch.qry(h[i]) + w[i-1] + 1ll*h[i]*h[i];        ch.add(2*h[i], -1ll*h[i]*h[i]+w[i]-dp[i]);    &#125;    printf(&quot;%lld\n&quot;, dp[n]);    return 0;&#125;</code></pre><ul><li><pre><code>*       * 做法</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforces1396C</title>
      <link href="/2020/08/31/codeforces1396c/"/>
      <url>/2020/08/31/codeforces1396c/</url>
      
        <content type="html"><![CDATA[<p>有n个关卡，每关有aia_iai​个小怪(1hp)和1个boss(2hp)，在第i关可以转移到i-1和i+1关，需要花费d，有三种武器</p><ul><li>花费r1，让一只怪物-1hp</li><li>花费r2，让所有怪物-1hp</li><li>花费r3，秒杀一只怪物</li></ul><p>其中第一和第三种武器必须在没有小怪的情况下才能攻击boss，并且如果没有秒掉boss（还剩1滴血），则会被强制转移到相邻的关卡（花费d），问你杀死所有怪物的最小花费<br>n≤106,1≤r1≤r2≤r3≤109n \leq 10^6,1\leq r1 \leq r2 \leq r3 \leq<br>10^9n≤106,1≤r1≤r2≤r3≤109</p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>在某一关中我们要么用r3直接秒掉boss避免强制转移(先用r1清小怪)，要么就先让boss少一滴血(用r1清小怪再点一下boss或者一下r2)转移走，之后再回来用一下r1点死boss。<br>所以每关其实只有两种选择，一是用r1杀掉小怪后用r3秒掉boss(cost1 &#x3D;<br>a[i]*r1+r3)，二是用r2或者(a[i]<em>r1+r1)让boss剩1hp然后强制转移走回来后再花r1杀死boss(cost2&#x3D;min(a[i]<em>r1+r1,r2))，然后就可以dp了<br>dpi,0dp_{i,0}dpi,0​表示第i关已经解决的最小费用，dpi,1dp_{i,1}dpi,1​表示第i关的boss还剩1hp然后还没强制跳转的最小费用<br>dp0,0&#x3D;min(dpi−1,0+d+min(cost1,2∗d+cost2+r1),dpi−1,1+3∗d+r1+min(cost1,cost2+r1))dp_{0,0}&#x3D;min(dp_{i-1,0}+d+min(cost1,2</em>d+cost2+r1),dp_{i-1,1}+3</em>d+r1+min(cost1,cost2+r1))dp0,0​&#x3D;min(dpi−1,0​+d+min(cost1,2∗d+cost2+r1),dpi−1,1​+3∗d+r1+min(cost1,cost2+r1))<br>如果上一关已经消灭(dpi−1,0dp_{i-1,0}dpi−1,0​)，这一关要么就cost1，要么就cost2然后来回跳两个d，再一个r1补死<br>如果上一关还有1hp，那么这关消灭后再回去补死上一关再回来<br>dpi,1&#x3D;dpi−1,0+d+cost2dp_{i,1} &#x3D; dp_{i-1,0}+d+cost2dpi,1​&#x3D;dpi−1,0​+d+cost2<br>还有一种特殊情况就是在倒数第二关强制转移到最后一关，然后消灭最后一关再转移到倒数第二关补死之后结束。</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 1e6 + 5;int n, a[N];ll r1, r2, r3, d, dp[N][2];int main()&#123;    scanf(&quot;%d%lld%lld%lld%lld&quot;, &amp;n, &amp;r1, &amp;r2, &amp;r3, &amp;d);    for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, a+i);    memset(dp, 0x3f, sizeof(dp));    dp[0][0] = -d;    for(int i=1; i&lt;=n; i++)    &#123;        ll c1 = min(a[i]*r1+r1, r2), c2 = a[i]*r1 + r3;        dp[i][0] = min(dp[i-1][0]+d+min(c2, 2*d+c1+r1), dp[i-1][1]+3*d+r1+min(r1+c1, c2));        dp[i][1] = dp[i-1][0]+d+c1;     &#125;    ll ans = min(dp[n][0], dp[n-2][0]+d+a[n]*r1+r3+r1+2*d+min(a[n-1]*r1+r1, r2));    printf(&quot;%lld\n&quot;, ans);    return 0;&#125;</code></pre><ul><li><pre><code>*       *         * 解法</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸包</title>
      <link href="/2020/08/30/convex-hull-trick/"/>
      <url>/2020/08/30/convex-hull-trick/</url>
      
        <content type="html"><![CDATA[<h2 id="计算几何中的凸包"><a href="#计算几何中的凸包" class="headerlink" title="计算几何中的凸包"></a>计算几何中的凸包</h2><p>给定n个点求凸包<br>利用andrew算法（比graham好写一点而且常数小）<br>将所有点按照x为第一关键字，y为第二关键字排序<br>然后从前往后用栈维护出下凸壳，再从后往前用栈维护出上凸壳即可<br>考虑当前栈中的最后两个点p，q，现在加入一个点o，那么只要看q-p和o-p这两条直线的左右关系即可，用叉积判断<br>多边形用vector存储，凸包分为严格凸包和非严格凸包（一般都是建成严格的），区别就是如果叉积等于0的时候不再pop，那么就是非严格的，可能会存在多点共线的情况<br>另外要注意多边形点数少于3的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Polygon <span class="title">ConvexHull</span><span class="params">(Polygon&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = s.<span class="built_in">size</span>(), sz = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">  <span class="function">Polygon <span class="title">res</span><span class="params">(<span class="number">2</span>*n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(sz&gt;<span class="number">0</span> &amp;&amp; <span class="built_in">crossop</span>(res[sz<span class="number">-1</span>], res[sz], s[i])&lt;=<span class="number">0</span>) --sz;</span><br><span class="line">    res[++sz] = s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> pre = sz;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(sz&gt;pre &amp;&amp; <span class="built_in">crossop</span>(res[sz<span class="number">-1</span>], res[sz], s[i])&lt;=<span class="number">0</span>) --sz;</span><br><span class="line">    res[++sz] = s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="built_in">resize</span>(sz);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多边形面积(相邻点叉积求和，逆时针为正，顺时针为负)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">db <span class="title">getarea</span><span class="params">(Polygon&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  db ans = <span class="number">0</span>; <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) ans += (s[i]^s[(i+<span class="number">1</span>)%n]);</span><br><span class="line">  <span class="keyword">return</span> ans/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凸包周长(相邻点距离求和即可)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">db <span class="title">getcir</span><span class="params">(Polygon&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">db ans = <span class="number">0</span>; <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) ans += s[i].<span class="built_in">dis</span>(s[(i+<span class="number">1</span>)%n]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凸包直径(旋转卡壳，对于每条边(i,i+1)，找到距离这条边最远的点j，容易发现具有单调性，可以用双指针实现)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">db <span class="title">ConvexDiameter</span><span class="params">(Polygon&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">0</span>].<span class="built_in">dis</span>(s[<span class="number">1</span>]);</span><br><span class="line">  <span class="type">int</span> j = <span class="number">2</span>; db ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cross</span>(s[i], s[i+<span class="number">1</span>], s[j])&lt;<span class="built_in">cross</span>(s[i], s[i+<span class="number">1</span>], s[(j+<span class="number">1</span>)%n])) j = (j+<span class="number">1</span>)%n;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(s[i].<span class="built_in">dis</span>(s[j]), s[i+<span class="number">1</span>].<span class="built_in">dis</span>(s[j])));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凸包的闵可夫斯基和还是凸包(定义就是一个凸包中的点按照原点和另一个凸包中的点形成的向量移动后形成的图形)<br>闵可夫斯基和后的凸包的边是由原来的两个凸包上的边构成的，所以归并排序一下即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Polygon <span class="title">Minkowski</span><span class="params">(Polygon&amp; a, Polygon&amp; b)</span> <span class="comment">//可能有三点共线，可以再求一次凸包</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Polygon c;</span><br><span class="line">  <span class="type">int</span> n = a.<span class="built_in">size</span>(), m = b.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;n||j&lt;m; )</span><br><span class="line">  &#123;</span><br><span class="line">    c.<span class="built_in">push_back</span>(a[i%n]+b[j%m]);</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=n) ++j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=m) ++i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sgn</span>((a[(i+<span class="number">1</span>)%n]-a[i])^(b[(j+<span class="number">1</span>)%m]-b[j]))&gt;=<span class="number">0</span>) ++i;</span><br><span class="line">    <span class="keyword">else</span> ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划中的凸包"><a href="#动态规划中的凸包" class="headerlink" title="动态规划中的凸包"></a>动态规划中的凸包</h2><p>一般用于斜率优化，考虑一个dp转移式$f_i &#x3D; \max \limits_{k&lt;i} \{ f_k + a_ib_k\}$<br>可以把后面的东西看成$b_ka_i + f_k$​，即$kx+b$的直线形式，然后我们就是要对每个$a_i$​找到之前所有直线中在该点处的最大值(别人的斜率优化可能是按照斜率的，不过我觉得这样子更直观一点，也不需要移项，如果了解李超树，很容易发现这完全可以用李超树来做)<br>当然用李超树来做似乎有点大材小用，容易发现答案一定是在所有直线形成的上凸壳上，而且每条直线会有一个贡献范围</p><ul><li><p>如果插入的直线斜率单调($b_k$​)，且询问点也单调($a_i$​)<br>这时候我们只需要用双端队列来维护上凸壳即可，在队尾不断插入直线并且维护凸壳，在队首及时排掉已经结束贡献了的点，对于当前询问的最优点就是队首</p></li><li><p>如果插入的直线斜率单调($b_k$​)，但询问点不单调($a_i$​)<br>斜率单调，所以我们仍然可以线性地维护上凸壳，但是我们不能pop_front来维护最优点，因为最优点没有单调性了，所以我们需要在凸壳上二分，找到最优决策点</p></li><li><p>如果插入的直线斜率不单调($b_k$​)，且询问点也不单调($a_i$​)<br>一种方法就是李超树了，另一种方法是用平衡树来维护，以下给出一份set实现的代码（很好用，如果插入的是直线就用这个，如果是线段的话就只能李超树了）<br>k和b分别是斜率和截距，p类似于最优决策点（不用管）<br>div函数是一个下取整函数，负数的时候的取整和正数会有区别<br>isect是求两条直线的交点，然后进行判断（类似于李超树中的判断）<br>使用的时候只需要add(k,b)来添加一条直线，qry(x)来询问在x点处的最大值<br>当然如果要求最小值，只需要add(-k,-b)，然后-qry(x)就是答案了</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Cmp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">mutable</span> ll k, b, p;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Line&amp; oth) <span class="type">const</span> &#123; <span class="keyword">return</span> Cmp ? p &lt; oth.p : k &lt; oth.k; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConvecHull</span> : multiset&lt;Line&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ll inf = LLONG_MAX;</span><br><span class="line">  <span class="function">ll <span class="title">div</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a&gt;<span class="number">0</span> ? inf : -inf;</span><br><span class="line">    <span class="keyword">return</span> a / b - ((a ^ b) &lt; <span class="number">0</span> &amp;&amp; a % b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isect</span><span class="params">(iterator x, iterator y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="built_in">end</span>()) &#123; x-&gt;p = inf; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;k == y-&gt;k) x-&gt;p = x-&gt;b &gt; y-&gt;b ? inf : -inf;</span><br><span class="line">    <span class="keyword">else</span> x-&gt;p = <span class="built_in">div</span>((y-&gt;b - x-&gt;b), (x-&gt;k - y-&gt;k));</span><br><span class="line">    <span class="keyword">return</span> x-&gt;p &gt;= y-&gt;p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll k, ll b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">insert</span>(&#123;k, b, <span class="number">0</span>&#125;), y = z++, x = y;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isect</span>(y, z)) z = <span class="built_in">erase</span>(z);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="built_in">begin</span>() &amp;&amp; <span class="built_in">isect</span>(--x, y)) <span class="built_in">isect</span>(x, y = <span class="built_in">erase</span>(y));</span><br><span class="line">    <span class="keyword">while</span> ((y = x) != <span class="built_in">begin</span>() &amp;&amp; (--x)-&gt;p &gt;= y-&gt;p) <span class="built_in">isect</span>(x, <span class="built_in">erase</span>(y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">qry</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Cmp = <span class="number">1</span>; <span class="keyword">auto</span> l = *<span class="built_in">lower_bound</span>(&#123;<span class="number">0</span>, <span class="number">0</span>, x&#125;); Cmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l.k * x + l.b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何删除一条直线"><a href="#如何删除一条直线" class="headerlink" title="如何删除一条直线"></a>如何删除一条直线</h3><p>删除操作不好做（类似并查集），我们可以离线后把每条直线的存活时间塞到线段树上的log个节点上（即线段树分治），对每个节点维护一个凸壳，然后对于一个询问就是线段树上包含该点的节点的凸壳上的最大值的最大值<br>给出所有直线再建凸壳，可以利用andrew来实现（排序后，从前往后用栈维护），询问最值一次二分即可（没必要三分）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gym101482G 距离转化 三分 思维</title>
      <link href="/2020/08/29/gym101482g-ju-chi-zhuan-hua-san-fen-si-wei/"/>
      <url>/2020/08/29/gym101482g-ju-chi-zhuan-hua-san-fen-si-wei/</url>
      
        <content type="html"><![CDATA[<p>给定二维平面上n个点的坐标，让你找一个点，最小化所有点到这个点的曼哈顿距离之和，并且要求每个点到该点的曼哈顿距离不能超过d<br>$n \leq 100000,d \leq 2\times 10^9$</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>如果没有d的限制，答案就是这n个点x坐标的中位数和y坐标的中位数。<br>加上d的限制后，对于每个点都有一个菱形的限制区域，所以最后的可行域就是这n个点限制的菱形区域的并，菱形不好处理，我们转化成切比雪夫距离后就变成了正方形，维护L，R，D，U，那么两个正方形的并就是max(L)，min(R)，max(D)，min(U)。曼哈顿距离中x、y两维是独立的，而每一维又是一个凹函数，所以在可行域范围内三分套三分即可。<br>给定一个点的坐标，计算n个点到这个点的曼哈顿距离和可以通过二分$O(\log n)$解决。<br>(x,y) -&gt; (x+y,x-y) 原坐标系的曼哈顿距离-&gt;新坐标系的切比雪夫距离<br>(x,y) -&gt; ((x+y)&#x2F;2,(x-y)&#x2F;2) 原坐标系的切比雪夫距离-&gt;新坐标系的曼哈顿距离<br>我们维护的LRDU是在切比雪夫坐标系中，而三分的范围是在曼哈顿坐标中的，所以x的三分范围应该是[(L+D)&#x2F;2,(R+U)&#x2F;2]，确定了x后，$L\leq<br>x+y \leq R,D\leq x-y \leq U$，那么y的三分范围就是[max(L-x,x-U),min(R-x,x-D)]了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, x[N], y[N], d;</span><br><span class="line">ll U, D, L, R, prex[N], prey[N];</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">upper_bound</span>(x+<span class="number">1</span>, x+n+<span class="number">1</span>, a) - x - <span class="number">1</span>, q = <span class="built_in">upper_bound</span>(y+<span class="number">1</span>, y+n+<span class="number">1</span>, b) - y - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> a*p - prex[p] + b*q - prey[q] - (n-p)*a + (prex[n] - prex[p]) - (n-q)*b + (prey[n] - prey[q]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll l = <span class="built_in">max</span>(x-U, L-x), r = <span class="built_in">min</span>(x-D, R-x), ans = LINF;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    ll mid = (<span class="number">2</span>*l+r)/<span class="number">3</span>, mmid = (<span class="number">2</span>*r+l+<span class="number">2</span>)/<span class="number">3</span>;</span><br><span class="line">    ll fmid = <span class="built_in">f</span>(x, mid), fmmid = <span class="built_in">f</span>(x, mmid);</span><br><span class="line">    <span class="keyword">if</span>(fmid&lt;=fmmid)</span><br><span class="line">    &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, fmid);</span><br><span class="line">      r = mmid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, fmmid);</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, x+i, y+i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">    U = LINF, D = -LINF, L = -LINF, R = LINF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      ll cx = x[i] + y[i], cy = x[i] - y[i];</span><br><span class="line">      U = <span class="built_in">min</span>(U, cy+d);</span><br><span class="line">      D = <span class="built_in">max</span>(D, cy-d);</span><br><span class="line">      L = <span class="built_in">max</span>(L, cx-d);</span><br><span class="line">      R = <span class="built_in">min</span>(R, cx+d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(D&gt;U||L&gt;R)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x+<span class="number">1</span>, x+n+<span class="number">1</span>); <span class="built_in">sort</span>(y+<span class="number">1</span>, y+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) prex[i] = prex[i<span class="number">-1</span>] + x[i], prey[i] = prey[i<span class="number">-1</span>] + y[i];</span><br><span class="line">    ll l = (L+D)/<span class="number">2</span>, r = (R+U)/<span class="number">2</span>, ans = LINF;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">      ll mid = (<span class="number">2</span>*l+r)/<span class="number">3</span>, mmid = (<span class="number">2</span>*r+l+<span class="number">2</span>)/<span class="number">3</span>;</span><br><span class="line">      ll fmid = <span class="built_in">cal</span>(mid), fmmid = <span class="built_in">cal</span>(mmid);</span><br><span class="line">      <span class="keyword">if</span>(fmid&lt;=fmmid)</span><br><span class="line">      &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, fmid);</span><br><span class="line">        r = mmid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, fmmid);</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>min_25筛</title>
      <link href="/2020/08/28/min_25-shai/"/>
      <url>/2020/08/28/min_25-shai/</url>
      
        <content type="html"><![CDATA[<p>当f(i)f(i)f(i)是一个积性函数，且f(p)f(p)f(p)是一个关于p的低阶多项式，f(pk)f(p^k)f(pk)是一个容易计算的式子，那么就可以利用该亚线性筛，快速算出∑i&#x3D;1nf(i)\sum_{i&#x3D;1}^n<br>f(i)∑i&#x3D;1n​f(i)，n≤1011n \leq 10^{11}n≤1011</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>利用另一个函数g(n,j)g(n,j)g(n,j)，快速计算出f在质数处的前缀和</p><p>g(n,j)&#x3D;∑i&#x3D;1n[i is prime∣∣minp&gt;pj]ikg(n, j) &#x3D; \sum \limits_{i&#x3D;1}^n [i \ is <br>prime || minp &gt; p_j] i^k g(n,j)&#x3D;i&#x3D;1∑n​[i is prime∣∣minp&gt;pj​]ik</p><p>表示≤n\leq n≤n中的所有质数以及最小质因子 <strong>大于</strong><br>第j小质数pjp_jpj​的所有数的k次方和，因为f(p)是一个关于p的多项式，这样我们把这个多项式拆成单项式，再取不同的k，而当pjp_jpj​等于最后一个小于等于n\sqrt<br>nn​的质因子时，g(n,j)g(n, j)g(n,j)就表示小于等于n的所有质数的k次方和了。<br>一个数的最小质因子一定是≤n\leq \sqrt n≤n​的<br>考虑从g(n,j−1)g(n, j-1)g(n,j−1)转移到g(n,j)g(n, j)g(n,j)时，只需要去掉最小质因子&#x3D;pjp_jpj​的所有合数即可</p><p>g(n,j)&#x3D;g(n,j−1)−pjk(g(npj,j−1)−g(pj−1,j−1))g(n, j) &#x3D; g(n, j-1) -<br>p_j^k(g(\frac{n}{p_j}, j-1) - g(p_{j-1}, j-1))<br>g(n,j)&#x3D;g(n,j−1)−pjk​(g(pj​n​,j−1)−g(pj−1​,j−1))</p><p>其中g(pj−1,j−1)g(p_{j-1}, j-1)g(pj−1​,j−1)表示前j-1个质数的k次方和，可以在线性筛的时候预处理出来<br>在转移的时候我们只需要用到⌊nx⌋\lfloor \dfrac{n}{x} \rfloor⌊xn​⌋处的取值，而这种值的个数是O(n)O(\sqrt<br>n)O(n​)级别的，可以利用一个id1数组和一个id2数组映射一下，对于≤n\leq \sqrt n≤n​的数，存在id1里，对于其他数存在id2中</p><pre><code>ll w[M], g1[M], g2[M];int id1[M], id2[M];auto id = [&amp;](ll x) &#123; return x&lt;=B ? id1[x] : id2[n/x]; &#125;;void solve(ll _n)&#123;    int sz = 0;    n = _n, B = sqrt(n) + 1;    getprime(B);    for(ll l=1, r, v; l&lt;=n; l=r+1)    &#123;        v = n/l, r = n/v;        w[++sz] = v; g1[sz] = prex1(v); g2[sz] = prex2(v);        if(v&lt;=B) id1[v] = sz; else id2[r] = sz;    &#125;    for(int i=1; i&lt;=pc; i++)    &#123;        for(int j=1; j&lt;=sz&amp;&amp;1ll*pr[i]*pr[i]&lt;=w[j]; j++)        &#123;            int t = id(w[j]/pr[i]);            g1[j] = ((g1[j] - (g1[t] - sp1[i-1])*x1(pr[i]))%mod + mod)%mod;            g2[j] = ((g2[j] - (g2[t] - sp2[i-1])*x2(pr[i]))%mod + mod)%mod;        &#125;    &#125;&#125;</code></pre><p>通过这一步我们就可以求f在质数处的前缀和了，如果要快速统计质数个数，答案就是gid(n)g_{id(n)}gid(n)​</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>同样的，设S(n,k)S(n,k)S(n,k)表示求所有质因子大于pkp_kpk​的数(大于pkp_kpk​的质数也算)的函数f之和，答案就是S(n,0)S(n,0)S(n,0)</p><p>S(n,x)&#x3D;g(n)−spx+∑pke≤n&amp;&amp;k&gt;xf(pke)S(npke+[e≠1])S(n,x) &#x3D; g(n) - sp_x + \sum<br>\limits_{p_k^e \leq n &amp;&amp; k&gt;x} f(p_k^e)S(\frac{n}{p_k^e} + [e \neq 1])<br>S(n,x)&#x3D;g(n)−spx​+pke​≤n&amp;&amp;k&gt;x∑​f(pke​)S(pke​n​+[e​&#x3D;1])</p><p>其中g(n)−spxg(n)-sp_xg(n)−spx​表示大于pkp_kpk​的质数的函数f之和，这在第一步中已经预处理出来，再枚举合数中最小质因子的大小以及幂次，递归处理即可，注意我们在所有计算中都是不统计1处的答案的，所以当e&gt;1e&gt;1e&gt;1时，要额外算上f(pke)f(p_k^e)f(pke​)处的值</p><pre><code>ll go(ll x, int k)&#123;    if(pr[k]&gt;=x) return 0;    int t = id(x); ll ans = (f(g1[t]-sp1[k], g2[t]-sp2[k])%mod + mod)%mod;     for(int i=k+1; i&lt;=pc&amp;&amp;1ll*pr[i]*pr[i]&lt;=x; i++)        for(ll pp=pr[i], e=1; pp&lt;=x; e++, pp=pp*pr[i])            ans = (ans + fp(pp%mod)*(go(x/pp, i)+(e!=1)))%mod;    return (ans+mod)%mod;&#125;</code></pre><p>最后的答案就是go(n, 0)+f(1)了</p><ul><li><pre><code>*       * 第一步</code></pre><ul><li>第二步</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gym102501H Pseudo-Random Number Generator 循环节</title>
      <link href="/2020/08/27/gym102501h-pseudo-random-number-generator-xun-huan-jie/"/>
      <url>/2020/08/27/gym102501h-pseudo-random-number-generator-xun-huan-jie/</url>
      
        <content type="html"><![CDATA[<p>给定一个数列的递推方式，求其前n项中偶数的个数<br>$M&#x3D;1ull&lt;&lt;40$<br>$s0&#x3D;0x600DCAFE$<br>$s_{n+1} &#x3D; (s_n + (s_n &gt;&gt; 20) + 12345)%M$<br>$n \lt 2^{63}$</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>因为要模M，所以猜想有循环节<br>找循环节的方式是用链表的判环算法（快慢指针）<br>快慢指针同时位于起点，然后快指针一次走两步，慢指针一次走一步，若两者相遇说明有环，此时让一个指针从起点开始，一个指针从相遇点开始，一次各走一步，当两者相遇，该点就是入环点<br>以下代码返回入环点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ull <span class="title">findloop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ull fst = <span class="number">0x600DCAFE</span>, slw = <span class="number">0x600DCAFE</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    slw = <span class="built_in">nxt</span>(slw);</span><br><span class="line">    fst = <span class="built_in">nxt</span>(<span class="built_in">nxt</span>(fst));</span><br><span class="line">    <span class="keyword">if</span>(fst==slw) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  slw = <span class="number">0x600DCAFE</span>;</span><br><span class="line">  <span class="keyword">while</span>(slw!=fst) slw = <span class="built_in">nxt</span>(slw), fst = <span class="built_in">nxt</span>(fst);</span><br><span class="line">  <span class="keyword">return</span> slw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道入环点后，让一个指针在起点走至该点的步数就是循环节开始的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ull x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ull s = <span class="number">0x600DCAFE</span>; ll len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(s!=x) len++, s = <span class="built_in">nxt</span>(s);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让一个指针从入环点下一个开始再走至入环点的步数+1就是循环节的长度（环长）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">g</span><span class="params">(ull x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ull s = <span class="built_in">nxt</span>(x); ll len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(s!=x) len++, s = <span class="built_in">nxt</span>(s);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果是st &#x3D; 350125310, loop &#x3D; 182129209<br>这样还是过不了，我们可以利用分段打表，将前st项每隔1e6个数记录一下前缀答案，循环节也每隔1e6个数记录一下前缀答案，此外还要记录一下该点对应处的数列的取值。<br>这样对于整块我们可以直接得到答案，而后面不完整的块再暴力一下即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p5488 差分与前缀和</title>
      <link href="/2020/08/25/p5488-chai-fen-yu-qian-zhui-he-2/"/>
      <url>/2020/08/25/p5488-chai-fen-yu-qian-zhui-he-2/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>快速求一个数列a的k阶差分或者k阶前缀和<br>n≤105,k≤102333,mod&#x3D;1004535809n \leq 10^5,k\leq<br>10^{2333},mod&#x3D;1004535809n≤105,k≤102333,mod&#x3D;1004535809</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>将数列a看成OGF:F(x)&#x3D;∑i&#x3D;0∞aixiF(x) &#x3D; \sum \limits_{i&#x3D;0}^{\infty}<br>a_ix^iF(x)&#x3D;i&#x3D;0∑∞​ai​xi<br>作一次前缀和相当于乘以∑i&#x3D;0∞xi&#x3D;11−x\sum \limits_{i&#x3D;0}^{\infty} x^i &#x3D;<br>\dfrac{1}{1-x}i&#x3D;0∑∞​xi&#x3D;1−x1​<br>作一次差分相当于乘以(1−x)(1-x)(1−x)<br>利用二项式定理：<br>1(1−x)k&#x3D;(1−x)−k&#x3D;∑i&#x3D;0∞(−k)i‾i!(−x)i&#x3D;∑i&#x3D;0∞(k+i−1)i‾i!xi\dfrac{1}{(1-x)^k} &#x3D;<br>(1-x)^{-k} &#x3D; \sum \limits_{i&#x3D;0}^{\infty} \dfrac{(-k)^{\underline{i}}}{i!}<br>(-x)^i &#x3D; \sum \limits_{i&#x3D;0}^{\infty} \dfrac{(k+i-1)^{\underline{i}}}{i!}<br>x^i(1−x)k1​&#x3D;(1−x)−k&#x3D;i&#x3D;0∑∞​i!(−k)i​​(−x)i&#x3D;i&#x3D;0∑∞​i!(k+i−1)i​​xi<br>线性递推出前n项的系数，然后和a作一次卷积即可</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 5, mod = 1004535809, gen = 3;int n, k, t, a[N], b[N], inv[N];int up, l, rev[N];void read(int &amp;k)&#123;    char c = getchar();    while(c&gt;&#39;9&#39;||c&lt;&#39;0&#39;) c = getchar();    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;) k = (1ll*k*10 + c - 48)%mod, c = getchar();&#125;int powmod(int a, int b)&#123;    int ans = 1;    while(b)    &#123;        if(b&amp;1) ans = 1ll*ans*a%mod;        a = 1ll*a*a%mod;        b &gt;&gt;= 1;    &#125;    return ans;&#125;inline void init(int n) &#123;    up = 1, l = 0;    while(up&lt;=n) up &lt;&lt;= 1, l++;    for(int i=0; i&lt;up; i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1));&#125;void NTT(int *a, int op)&#123;    for(int i=0; i&lt;up; i++) if(i&lt;rev[i]) swap(a[i], a[rev[i]]);    for(int i=1; i&lt;up; i&lt;&lt;=1)    &#123;        int gn = powmod(gen, (mod-1)/(i&lt;&lt;1));         if(op==-1) gn = powmod(gn, mod-2);        for(int j=0; j&lt;up; j+=(i&lt;&lt;1))        for(int k=0,g=1; k&lt;i; k++,g=1ll*g*gn%mod)        &#123;            int x = a[j+k], y = 1ll*g*a[j+k+i]%mod;            a[j+k] = (x+y)%mod, a[j+k+i] = (x-y+mod)%mod;        &#125;    &#125;    if(op==-1)     &#123;        int invup = powmod(up, mod-2);        for(int i=0; i&lt;up; i++) a[i] = 1ll*a[i]*invup%mod;    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    inv[0] = inv[1] = 1;    for(int i=2; i&lt;=n; i++) inv[i] = 1ll*(mod-mod/i)*inv[mod%i]%mod;    read(k);    scanf(&quot;%d&quot;, &amp;t);    for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;a[i]);    b[0] = 1;    if(t) for(int i=1; i&lt;=n; i++) b[i] = (-1ll*b[i-1]*(k-i+1)%mod*inv[i]%mod+mod)%mod;    else for(int i=1; i&lt;=n; i++) b[i] = 1ll*b[i-1]*(k+i-1)%mod*inv[i]%mod;    init(2*n-1);    NTT(a, 1); NTT(b, 1);    for(int i=0; i&lt;up; i++) a[i] = 1ll*a[i]*b[i]%mod;    NTT(a, -1);    for(int i=0; i&lt;n; i++) printf(&quot;%d%c&quot;, a[i], &quot; \n&quot;[i==n-1]);    return 0;&#125;</code></pre><ul><li><pre><code>*       * 题意</code></pre><ul><li>做法</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨氏矩阵(杨表）</title>
      <link href="/2020/08/25/yang-shi-ju-zhen-yang-biao/"/>
      <url>/2020/08/25/yang-shi-ju-zhen-yang-biao/</url>
      
        <content type="html"><![CDATA[<h4 id="杨图"><a href="#杨图" class="headerlink" title="杨图"></a>杨图</h4><p>对于n的一个划分λ&#x3D;(λ1≥λ2…)⊢n\lambda&#x3D;(\lambda_1 \geq \lambda_2 \ldots) \vdash<br>nλ&#x3D;(λ1​≥λ2​…)⊢n，杨图第i行有λi\lambda_iλi​个方块</p><h4 id="标准杨表"><a href="#标准杨表" class="headerlink" title="标准杨表"></a>标准杨表</h4><p>将1-n这n个数填入一个杨图λ\lambdaλ的每一个方块中，使得从上到下，从左到右数字都递增</p><h4 id="近似杨表"><a href="#近似杨表" class="headerlink" title="近似杨表"></a>近似杨表</h4><p>将n个不同的数字填入杨图中<br>存在一种插入算法RSK，从第一行开始，每次替换当前行第一个大于自己的数（如果有相同数字就替换第一个大于等于自己的数），并将替换的数去插入下一行，若找不到这样一个数，则将该数插入到该行末尾并结束</p><h4 id="钩子定理"><a href="#钩子定理" class="headerlink" title="钩子定理"></a>钩子定理</h4><p>hi,jh_{i,j}hi,j​定义为(i,j)这个格子下面的格子数+右边的格子数+1<br>对于λ⊢n\lambda \vdash nλ⊢n，有fλ&#x3D;n!∏hi,jf^\lambda &#x3D; \dfrac{n!}{\prod<br>h_{i,j}}fλ&#x3D;∏hi,j​n!​<br>fλf^\lambdafλ表示λ\lambdaλ对应的杨图的填法</p><h4 id="Robinson–Schensted-correspondence"><a href="#Robinson–Schensted-correspondence" class="headerlink" title="Robinson–Schensted correspondence"></a>Robinson–Schensted correspondence</h4><p>一个1到n个数的排列和一对相同形状的标准杨表一一对应<br>∑λ⊢n(fλ)2&#x3D;n!\sum \limits_{\lambda \vdash n} (f^\lambda)^2 &#x3D; n!λ⊢n∑​(fλ)2&#x3D;n!</p><h4 id="n个元素的杨氏矩阵的个数"><a href="#n个元素的杨氏矩阵的个数" class="headerlink" title="n个元素的杨氏矩阵的个数"></a>n个元素的杨氏矩阵的个数</h4><p>fn&#x3D;fn−1+(n−1)fn−2f_n &#x3D; f_{n-1} + (n-1)f_{n-2}fn​&#x3D;fn−1​+(n−1)fn−2​</p><h4 id="杨表与LIS"><a href="#杨表与LIS" class="headerlink" title="杨表与LIS"></a>杨表与LIS</h4><p>将一个排列按序用RSK算法插入到杨表中，则杨表第一行的长度等于其LIS长度（构建的杨表从上到下，从左到右递增）<br>将杨表的比较方式取反(&lt;变≥\geq≥,&gt;变≤\leq≤)，所得杨表的形状为原杨表的转置(仅形状而言)<br>杨表第一列的长度等于最长不上升子序列长度(考虑转置)<br>杨表前k列的长度和等于LIS≤k\leq k≤k的k-LIS的长度(利用Dilworth定理，等价于划分出k个不相交的最长不上升子序列)</p><h4 id="P3774-CTSC2017-最长上升子序列"><a href="#P3774-CTSC2017-最长上升子序列" class="headerlink" title="P3774 [CTSC2017]最长上升子序列"></a>P3774 [CTSC2017]最长上升子序列</h4><p>给定一个长为n的序列a，q次询问a的某个前缀的最长k-LIS的长度<br>n≤50000,q≤200000n\leq 50000, q \leq 200000n≤50000,q≤200000<br>对于每个询问的答案就是将a的这个前缀依次插入杨表后，前k列长度的和<br>考虑离线询问后动态维护前k列长度和<br>每次插入的复杂度是O(nlogn)O(nlogn)O(nlogn)的<br>我们可以只维护杨表的前n\sqrt nn​行，然后反转比较方式，再维护这个杨表的转置的前n\sqrt nn​行(等价于维护了原杨表的前n\sqrt<br>nn​列，当这一列的长度超过n\sqrt nn​时，表明这个元素在原杨表中没有维护到，所以在这里维护即可)，显然每个元素的行或列的下标至少有一个≤n\leq<br>\sqrt n≤n​，所以这样是正确的<br>复杂度为O(nnlogn)O(n\sqrt n logn)O(nn​logn)</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4 + 5, M = 255;int n, qq, blo, a[N], c[N], ans[4*N];vector&lt;int&gt; YT[M], YT2[M];struct qry&#123;    int m, k, idx;    bool operator &lt; (const qry&amp; oth) &#123; return m &lt; oth.m; &#125;&#125;q[4*N];void upd(int x, int v)&#123;    for(int i=x; i&lt;=n; i+=(i&amp;-i)) c[i] += v;&#125;int ask(int x)&#123;    int ans = 0;    for(int i=x; i&gt;0; i-=(i&amp;-i)) ans += c[i];    return ans;&#125;void add(int v)&#123;    for(int i=1, x=v; i&lt;blo; i++)    &#123;        if(YT[i].empty() || YT[i].back()&lt;x)         &#123;            YT[i].push_back(x);            upd(YT[i].size(), 1);            break;        &#125;        swap(YT[i][lower_bound(YT[i].begin(), YT[i].end(), x)-YT[i].begin()], x);    &#125;&#125;void add2(int v)&#123;    for(int i=1, x=v; i&lt;blo; i++)    &#123;        if(YT2[i].empty() || YT2[i].back()&gt;=x)         &#123;            YT2[i].push_back(x);            if((int)YT2[i].size()&gt;=blo) upd(i, 1);            break;        &#125;        swap(YT2[i][upper_bound(YT2[i].begin(), YT2[i].end(), x, greater&lt;int&gt;())-YT2[i].begin()], x);    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;qq);    blo = sqrt(n) + 1;    for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, a+i);    for(int i=1; i&lt;=qq; i++) scanf(&quot;%d%d&quot;, &amp;q[i].m, &amp;q[i].k), q[i].idx = i;    sort(q+1, q+qq+1);    int pre = 1;    for(int i=1; i&lt;=qq; )    &#123;        int j = i;        while(pre&lt;=q[i].m) add(a[pre]), add2(a[pre]), pre++;        while(j&lt;=qq &amp;&amp; q[j].m==q[i].m)        &#123;            ans[q[j].idx] = ask(q[j].k);            j++;        &#125;        i = j;    &#125;    for(int i=1; i&lt;=qq; i++) printf(&quot;%d\n&quot;, ans[i]);    return 0;&#125;</code></pre><h4 id="P4484-BJWC2018-最长上升子序列"><a href="#P4484-BJWC2018-最长上升子序列" class="headerlink" title="P4484 [BJWC2018]最长上升子序列"></a>P4484 [BJWC2018]最长上升子序列</h4><p>求长度为n的随机排列的LIS的长度的期望<br>n≤28n \leq 28n≤28<br><del>暴力跑前几个然后oeis</del><br>我们只需要枚举n的所有整数划分λ\lambdaλ，然后利用钩子公式计算出相应的fλf^\lambdafλ，那么所有排列的LIS长度的和是∑λ⊢n(fλ)2λ1\sum<br>\limits_{\lambda \vdash n} (f^\lambda)^2 \lambda_1λ⊢n∑​(fλ)2λ1​，再除以排列数n!n!n!即可<br>n的整数划分个数p(n)≈14n3exp(π2n3)p(n) \approx \frac{1}{4n\sqrt 3}exp(\pi<br>\sqrt{\frac{2n}{3}})p(n)≈4n3​1​exp(π32n​​)<br>复杂度O(p(n))O(p(n))O(p(n))，大概能跑n≤63\leq 63≤63</p><pre><code>#include &lt;bits/stdc++.h&gt;using ll = long long;using namespace std;const int mod = 998244353, N = 30;int n;ll inv[N], ans;int a[N];int powmod(int a, int b)&#123;    int ans = 1;    while(b)    &#123;        if(b&amp;1) ans = 1ll*ans*a%mod;        a = 1ll*a*a%mod;        b &gt;&gt;= 1;    &#125;    return ans;&#125;void dfs(int x, int y)&#123;    if(!x)    &#123;        ll cur = 1;        for(int i=2; i&lt;=n; i++) cur = cur*i%mod;        for(int i=1; i&lt;y; i++)            for(int j=1; j&lt;=a[i]; j++)            &#123;                int R = a[i] - j, D = 0;                for(int k=i; k&lt;y; k++)                    if(a[k]&gt;=j) D++;                cur = cur*inv[R+D]%mod;            &#125;        ans = (ans + cur*cur%mod*a[1]%mod)%mod;        return;    &#125;    for(int i=1; i&lt;=x; i++)    &#123;        if(y!=1 &amp;&amp; i&gt;a[y-1]) continue;        a[y] = i;        dfs(x-i, y+1);    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for(int i=1; i&lt;=n; i++) inv[i] = powmod(i, mod-2);    dfs(n, 1);    for(int i=1; i&lt;=n; i++) ans = ans*inv[i]%mod;    printf(&quot;%lld\n&quot;, ans);    return 0;&#125;</code></pre><h4 id="求不相交的LIS"><a href="#求不相交的LIS" class="headerlink" title="求不相交的LIS"></a>求不相交的LIS</h4><p>考虑dpi,jdp_{i,j}dpi,j​表示第一个LIS的最后一个元素的值为i，第二个LIS的最后一个元素的值为j，朴素转移的复杂度是O(n3)O(n^3)O(n3)，利用树状数组可以优化到O(n2logn)O(n^2logn)O(n2logn)<br>此外也可以用费用流<br>如果询问的是不相交LIS的长度，只要维护出杨表的前两行即可，然后答案就是前两行的长度和<br>O(2nlogn)O(2nlogn)O(2nlogn)，对于k不相交LIS，可以做到O(knlogn)O(knlogn)O(knlogn)<br>hdu5406</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5;int n;pair&lt;int, int&gt; p[N];struct YT&#123;    vector&lt;int&gt; t[3];    YT() &#123; for(int i=1; i&lt;=2; i++) t[i].clear(); &#125;    void add(int v)    &#123;        for(int i=1, x=v; i&lt;=2; i++)        &#123;            if(t[i].empty() || t[i].back()&lt;=x)             &#123;                t[i].push_back(x);                break;            &#125;            swap(t[i][upper_bound(t[i].begin(), t[i].end(), x)-t[i].begin()], x);        &#125;    &#125; &#125;;void solve()&#123;    scanf(&quot;%d&quot;, &amp;n);    for(int i=1; i&lt;=n; i++) scanf(&quot;%d%d&quot;, &amp;p[i].first, &amp;p[i].second);    sort(p+1, p+n+1, [](pair&lt;int, int&gt; x, pair&lt;int, int&gt; y) &#123;        if(x.first==y.first) return x.second &lt; y.second;        return x.first &gt; y.first;    &#125;);    YT T;    for(int i=1; i&lt;=n; i++) T.add(p[i].second);    printf(&quot;%d\n&quot;, int(T.t[1].size() + T.t[2].size())); &#125;int main()&#123;    int _; scanf(&quot;%d&quot;, &amp;_);    while(_--) solve();    return 0;&#125;</code></pre><ul><li><pre><code>*       *         * 杨图* 标准杨表* 近似杨表* 钩子定理* Robinson–Schensted correspondence* n个元素的杨氏矩阵的个数* 杨表与LIS* P3774 [CTSC2017]最长上升子序列* P4484 [BJWC2018]最长上升子序列* 求不相交的LIS</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环矩阵</title>
      <link href="/2020/08/25/xun-huan-ju-zhen/"/>
      <url>/2020/08/25/xun-huan-ju-zhen/</url>
      
        <content type="html"><![CDATA[<p>矩阵的第i行是其上一行循环右移的结果</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>循环矩阵的线性运算及乘积仍是循环矩阵<br>循环矩阵的逆矩阵以及转置矩阵仍是循环矩阵<br>循环矩阵乘法满足交换律</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>由于两个循环矩阵的乘法的结果仍然是一个循环矩阵，所以可以$O(n^2)$求得结果的第一行，这样就可以得到其他各行的结果，将矩阵乘法的复杂度下降了一级<br>若下标从0开始：$c[1][(i+j)%n] +&#x3D; a[1][i] * b[1][j]$<br>若下标从1开始：$c[1][(i+j-2)%n+1] +&#x3D; a[1][i] * b[1][j]$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cirmat</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mat[N];</span><br><span class="line">    <span class="built_in">cirmat</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">cirmat</span>(<span class="type">int</span> _) : <span class="built_in">n</span>(_) &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="built_in">cirmat</span>() &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123; mat[<span class="number">0</span>] = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">cirmat <span class="keyword">operator</span> * (cirmat a, cirmat b)</span><br><span class="line">&#123;</span><br><span class="line">  cirmat res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      (res.mat[(i+j<span class="number">-2</span>)%n+<span class="number">1</span>] += <span class="number">1ll</span>*a.mat[i]*b.mat[j]%mod) %= mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">cirmat <span class="keyword">operator</span> ^ (cirmat a, ll x)</span><br><span class="line">&#123;</span><br><span class="line">  cirmat res; res.<span class="built_in">one</span>();</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;<span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bzoj2510-弱题"><a href="#bzoj2510-弱题" class="headerlink" title="bzoj2510 弱题"></a>bzoj2510 弱题</h2><p>有m个带标号球，标号范围为1-n，每次操作等概率选择一个球，使得该球的标号加1（如果是n，就变成1）<br>问k次操作后，各个标号球的个数的期望<br>$n \leq 1000,m \leq 10^9,k \leq INT\_MAX$<br>转移矩阵是一个循环矩阵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cirmat</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> mat[N];</span><br><span class="line">  <span class="built_in">cirmat</span>() &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123; mat[<span class="number">0</span>] = <span class="number">1.0</span>; &#125;</span><br><span class="line">&#125;a, b;</span><br><span class="line">cirmat <span class="keyword">operator</span> * (cirmat a, cirmat b)</span><br><span class="line">&#123;</span><br><span class="line">  cirmat res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">      res.mat[(i+j)%n] += a.mat[i]*b.mat[j];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">cirmat <span class="keyword">operator</span> ^ (cirmat a, <span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">  cirmat res; res.<span class="built_in">one</span>();</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;<span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a.mat[i]);</span><br><span class="line">  b.mat[<span class="number">0</span>] = <span class="number">1.0</span> - <span class="number">1.0</span>/m, b.mat[<span class="number">1</span>] = <span class="number">1.0</span>/m;</span><br><span class="line">  b = b ^ k;</span><br><span class="line">  a = a * b;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, a.mat[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客14532-没有名字"><a href="#牛客14532-没有名字" class="headerlink" title="牛客14532 没有名字"></a>牛客14532 没有名字</h2><p>转移是一个循环矩阵</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using ll = long long;using namespace std;const int mod = 1e9 + 7, N = 205;int n, k;ll m;struct cirmat&#123;  int mat[N];  cirmat() &#123; memset(mat, 0, sizeof(mat)); &#125;  void one() &#123; mat[1] = 1; &#125;&#125;a, b;cirmat operator * (cirmat a, cirmat b)&#123;  cirmat res;  for(int i=1; i&lt;=n; i++)    for(int j=1; j&lt;=n; j++)      (res.mat[(i+j-2)%n+1] += 1ll*a.mat[i]*b.mat[j]%mod) %= mod;  return res;&#125;cirmat operator ^ (cirmat a, ll x)&#123;  cirmat res; res.one();  while(x)  &#123;    if(x&amp;1) res = res * a;    a = a * a;    x &gt;&gt;= 1;  &#125;  return res;&#125;void solve()&#123;  scanf(&quot;%d%lld%d&quot;, &amp;n, &amp;m, &amp;k);  for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, &amp;a.mat[i]);  for(int i=1; i&lt;=n; i++)  &#123;    int dis = min(i-1, n+1-i);    if(i==1 || dis&gt;=k) b.mat[i] = 0;    else b.mat[i] = k - dis;  &#125;  b = b ^ m;  a = a * b;  for(int i=1; i&lt;=n; i++) printf(&quot;%d%c&quot;, a.mat[i], &quot; \n&quot;[i==n]);&#125;int main()&#123;  int _; scanf(&quot;%d&quot;, &amp;_);  while(_--) solve();  return 0;&#125;另外，利用FFT还可以将循环矩阵乘法优化到$O(n\log n)$，还不会，先咕</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小割相关</title>
      <link href="/2020/08/16/zui-xiao-ge-xiang-guan/"/>
      <url>/2020/08/16/zui-xiao-ge-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="最小割的方案"><a href="#最小割的方案" class="headerlink" title="最小割的方案"></a>最小割的方案</h2><p>跑一遍最大流，记录从s出发能到达的点集S，不能到达的点集为T，则跨越S和T的满流边（残留网络中容量&#x3D;0）是最小割中的边</p><h2 id="可行边与必须边"><a href="#可行边与必须边" class="headerlink" title="可行边与必须边"></a>可行边与必须边</h2><p>可行边：属于所有可能的最小割集的并集中的边<br>必须边：属于所有可能的最小割集的交集中的边<br>跑一遍最大流，然后对残余网络（容量大于0的边）跑一遍tarjan<br>如果该边还有容量，不属于最小割集，所以既不是可行边也不是必须边<br>如果某条边连接的两个点分属于两个scc，则为可行边<br>如果某条边连接的两个点一个与S同在一个scc，一个与T同在一个scc，则为必须边</p><h2 id="求边数最少的最小割"><a href="#求边数最少的最小割" class="headerlink" title="求边数最少的最小割"></a>求边数最少的最小割</h2><p>设原图总边数&#x3D;M<br>让原图的每一条边的权值w变成$(M+1)w+1$<br>再跑最大流即可</p><h2 id="每条边有两个权值，在最小化第一个权值的割后，找一个第二个权值字典序最小的割"><a href="#每条边有两个权值，在最小化第一个权值的割后，找一个第二个权值字典序最小的割" class="headerlink" title="每条边有两个权值，在最小化第一个权值的割后，找一个第二个权值字典序最小的割"></a>每条边有两个权值，在最小化第一个权值的割后，找一个第二个权值字典序最小的割</h2><p>先随便求一个最小割，将这些边按照第二个权值排序，判断该边是否是可行边，如果是就选择，割掉一条边需要利用退流操作，具体做法是对于边(u,v)，让u向S跑一遍最大流，再让T向v跑一遍最大流，最后让(u,v)这条边及其反边的残余流量置0，即w&#x3D;0</p><h2 id="最小割树"><a href="#最小割树" class="headerlink" title="最小割树"></a>最小割树</h2><p>求任意两点间的最小割<br>本质只有$O(n)$种，建出最小割树后，u，v两点的最小割等于路径上的最小边权<br>建树方法：跑n次最大流<br>每次随机取两个点，求它们的最小割，将图分为两部分，在这两个集合间连一条边权为最小割的边，然后分治处理两个集合。这样最后会得到一棵树。则两个点之间的最小割大小为其树上唯一路径的最小值。<br>每次网络流的流量要复原，所以用变量fw记录每条边已经流过的流量，变量w记录容量保持不变，当fw&#x3D;w时说明该边满流，复原只需要清零fw即可<br>求路径最小值没必要倍增，因为点数不会很大，直接建出树，以每个点为根bfs一次即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">505</span>, M = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt, head[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> next, to, w, fw;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[++cnt] = &#123;head[u], v, w, <span class="number">0</span>&#125;;</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n, m, s, t;</span><br><span class="line">  <span class="type">int</span> dep[N], cur[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    cnt = <span class="number">1</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> cap)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(u, v, cap);</span><br><span class="line">    <span class="built_in">add</span>(v, u, cap);</span><br><span class="line">    m += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s); dep[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dep[v]&amp;&amp;e[i].fw&lt;e[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">          dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> used = flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">      cur[u] = i;</span><br><span class="line">      <span class="type">int</span> v = e[i].to;</span><br><span class="line">      <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="built_in">dfs</span>(v,<span class="built_in">min</span>(flow,e[i].w-e[i].fw));</span><br><span class="line">        e[i].fw += low; e[i^<span class="number">1</span>].fw -= low;</span><br><span class="line">        flow -= low;</span><br><span class="line">        <span class="keyword">if</span>(!flow) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used - flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">go</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxflow = <span class="number">0</span>; s = x, t = y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=cnt; i++) e[i].fw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) maxflow += <span class="built_in">dfs</span>(s,INF);</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;MF;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GHT</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pt[N], col[N], tmpt[N], cnt, cut[N][N];</span><br><span class="line">  vector&lt;pii&gt; G[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    col[u] = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next)</span><br><span class="line">      <span class="keyword">if</span>(e[i].fw&lt;e[i].w &amp;&amp; col[e[i].to]!=cnt)</span><br><span class="line">        <span class="built_in">dfs</span>(e[i].to);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = pt[l], y = pt[l+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> cutw = MF.<span class="built_in">go</span>(x, y);</span><br><span class="line">    ++cnt; <span class="built_in">dfs</span>(x); <span class="type">int</span> p = l, q = r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++)</span><br><span class="line">      <span class="keyword">if</span>(col[pt[i]]==cnt) tmpt[p++] = pt[i];</span><br><span class="line">      <span class="keyword">else</span> tmpt[q--] = pt[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) pt[i] = tmpt[i];</span><br><span class="line">    G[x].<span class="built_in">pb</span>(&#123;y, cutw&#125;); G[y].<span class="built_in">pb</span>(&#123;x, cutw&#125;);</span><br><span class="line">    <span class="built_in">build</span>(l, p<span class="number">-1</span>); <span class="built_in">build</span>(q+<span class="number">1</span>, r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> *dis)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) dis[i] = <span class="number">-1</span>;</span><br><span class="line">    dis[s] = INF;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">sz</span>(q))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">        <span class="keyword">if</span>(~dis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v] = <span class="built_in">min</span>(dis[u], w);</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  MF.<span class="built_in">init</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    MF.<span class="built_in">addedge</span>(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">iota</span>(T.pt+<span class="number">1</span>, T.pt+n+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  T.<span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) T.<span class="built_in">bfs</span>(i, T.cut[i]);</span><br><span class="line">  <span class="type">int</span> q; cin &gt;&gt; q;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    cout &lt;&lt; T.cut[u][v] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数拆分</title>
      <link href="/2020/08/15/zheng-shu-chai-fen/"/>
      <url>/2020/08/15/zheng-shu-chai-fen/</url>
      
        <content type="html"><![CDATA[<h3 id="不能相等"><a href="#不能相等" class="headerlink" title="不能相等"></a>不能相等</h3><p>将正整数n划分成不能相等的若干个正整数的和的方案数<br>由于不能相等，所以划分成的数字个数不超过n\sqrt nn​<br>设fi,jf_{i,j}fi,j​表示将i划分成j个不同数字的和的方案数<br>fi,j&#x3D;fi−j,j+fi−j,j−1f_{i,j} &#x3D; f_{i-j,j} + f_{i-j,j-1}fi,j​&#x3D;fi−j,j​+fi−j,j−1​<br>O(nn)O(n\sqrt n)O(nn​)</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4 + 5, B = 350, mod = 1e9 + 7;int n, f[N][B];inline int add(int x, int y) &#123; return (x+y&gt;=mod) ? x+y-mod : x+y; &#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    f[0][0] = 1;    for(int i=1; i&lt;=n; i++)        for(int j=1; j&lt;=i &amp;&amp; j&lt;B; j++)            f[i][j] = add(f[i-j][j], f[i-j][j-1]);    int ans = 0;    for(int j=1; j&lt;B; j++) ans = add(ans, f[n][j]);    printf(&quot;%d\n&quot;, ans);    return 0;&#125;</code></pre><h3 id="能相等"><a href="#能相等" class="headerlink" title="能相等"></a>能相等</h3><p>将正整数n划分成若干正整数的和的方案数<br>设定阈值B&#x3D;nB&#x3D;\sqrt nB&#x3D;n​<br>对于&lt;B的部分，直接做完全背包<br>对于&gt;&#x3D;B的部分，选择的数字个数不超过B<br>设fi,jf_{i,j}fi,j​表示将i划分成j个不同数字的和的方案数<br>fi,j&#x3D;fi−B,j−1+fi−j,jf_{i,j} &#x3D; f_{i-B,j-1} + f_{i-j,j}fi,j​&#x3D;fi−B,j−1​+fi−j,j​<br>O(nn)O(n\sqrt n)O(nn​) 但只能解决单次询问</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4 + 5, B = 350, mod = 1e9 + 7;int n, f0[N], f1[N], f[N][B];inline int Mul(int a, int b) &#123; return 1ll*a*b%mod; &#125;inline void add(int &amp;a, int b) &#123; a+=b; if(a&gt;=mod) a-=mod; &#125;inline int Add(int a, int b) &#123; return (a+b&gt;=mod) ? a+b-mod : a+b; &#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    f0[0] = f1[0] = 1;    for(int j=1; j&lt;B &amp;&amp; j&lt;=n; j++)        for(int i=j; i&lt;=n; i++)            f0[i] = Add(f0[i], f0[i-j]);    f[0][0] = 1;    for(int i=B; i&lt;=n; i++)        for(int j=1; j&lt;=B; j++)        &#123;            f[i][j] = Add(f[i-B][j-1], f[i-j][j]);            f1[i] = Add(f1[i], f[i][j]);        &#125;    int ans = 0;    for(int i=0; i&lt;=n; i++) add(ans, Mul(f0[i], f1[n-i]));    printf(&quot;%d\n&quot;, ans);    return 0;&#125;</code></pre><p>五边形数n(3n−1)2\frac{n(3n-1)}{2}2n(3n−1)​<br>欧拉函数<br>ϕ(n)&#x3D;∏i&#x3D;1∞(1−xi)&#x3D;∏i&#x3D;−∞∞(−1)ixi(3i−1)2\phi(n) &#x3D; \prod \limits_{i&#x3D;1}^{\infty}<br>(1-x^i) &#x3D; \prod<br>\limits_{i&#x3D;-\infty}^{\infty}(-1)^ix^{\frac{i(3i-1)}{2}}ϕ(n)&#x3D;i&#x3D;1∏∞​(1−xi)&#x3D;i&#x3D;−∞∏∞​(−1)ix2i(3i−1)​<br>即展开后只留下幂次为广义五边形数的项<br>考虑整数拆分的生成函数<br>F(x)&#x3D;∑i&#x3D;1∞P(i)xi&#x3D;∏i&#x3D;1∞(1+xi+x2i…)&#x3D;∏i&#x3D;1∞11−xiF(x) &#x3D; \sum<br>\limits_{i&#x3D;1}^{\infty} P(i)x^i &#x3D;\prod \limits_{i&#x3D;1}^{\infty}(1+x^i+x^{2i}…)<br>&#x3D; \prod<br>\limits_{i&#x3D;1}^{\infty}\frac{1}{1-x^i}F(x)&#x3D;i&#x3D;1∑∞​P(i)xi&#x3D;i&#x3D;1∏∞​(1+xi+x2i…)&#x3D;i&#x3D;1∏∞​1−xi1​<br>即F(x)ϕ(x)&#x3D;1F(x)\phi(x)&#x3D;1F(x)ϕ(x)&#x3D;1<br>可以得到P(n)−P(n−1)−P(n−2)+P(n−5)+P(n−7)−…&#x3D;0P(n)-P(n-1)-P(n-2)+P(n-5)+P(n-7)-…&#x3D;0P(n)−P(n−1)−P(n−2)+P(n−5)+P(n−7)−…&#x3D;0<br>容易发现P(n)可由n−i(3∗i−1)2n-\dfrac{i(3<em>i-1)}{2}n−2i(3∗i−1)​以及n−i(3∗i+1)2n-\dfrac{i(3</em>i+1)}{2}n−2i(3∗i+1)​更新得到<br>由于五边形数是n2n^2n2级别增长的，所以可以O(nn)O(n\sqrt n)O(nn​)递推得到P(1)…P(n)P(1)\dots<br>P(n)P(1)…P(n)</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4 + 5, B = 350, mod = 1e9 + 7;int n, m, i, j, f[B], g[N];int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for(f[1]=1,f[2]=2,f[3]=5,f[4]=7,i=5; f[i-1]&lt;n; i++) f[i] = 3 + 2*f[i-2] - f[i-4];    for(g[0]=i=1; i&lt;=n; i++)        for(j=1; f[j]&lt;=i; j++)            if((j+1)&gt;&gt;1&amp;1) g[i] = (g[i] + g[i-f[j]])%mod;            else g[i] = (g[i]-g[i-f[j]]+mod)%mod;    printf(&quot;%d\n&quot;, (g[n]&lt;0) ? g[n]+mod : g[n]);    return 0;&#125;</code></pre><p>沈阳的I题是询问n个点深度不超过2的树的个数，显然是个n-1的整数拆分，然而n≤5×105n \leq 5\times10^5n≤5×105</p><ol><li><p>O(nn)O(n\sqrt n)O(nn​)<br>取模优化，g数组开成longlong，这样对于gig_igi​只要在最后取一次模即可，因为最多根号次加法所以不会爆longlong<br>cachemiss优化，gig_igi​用变量x代替，这样可以一定程度上减少cache的miss<br>循环优化，大力循环展开<br>然后就能过了</p></li><li><p>O(nlogn)O(nlogn)O(nlogn)<br>更快也更简单，只需要对ϕ\phiϕ求个逆即可</p></li></ol><ul><li><pre><code>*       * 不能相等</code></pre><ul><li>能相等</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平面图</title>
      <link href="/2020/08/13/ping-mian-tu/"/>
      <url>/2020/08/13/ping-mian-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>画在平面上，任意两条边除顶点外无交点<br>包围一个面的边的条数称为该面的次数</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>欧拉公式：<br>n - m + r &#x3D; 2<br>点数-边数+面数&#x3D;2<br>点数$n \geq 3$的平面图的边数$m \leq 3n-6$ (边数是线性的)</p><h2 id="对偶图"><a href="#对偶图" class="headerlink" title="对偶图"></a>对偶图</h2><p>每个面为一个顶点，对于平面图上的每条边（一定只与两个面相连），用边连接这两个面对应的顶点<br>平面图最小割&#x3D;对偶图最短路<br>（对偶图的边权相当于割掉平面图一条边的代价，所以维护对偶图的连通性，等价于维护平面图的非连通性）<br>G的面数等于G的点数， G与G的边数相同(每个面为一个点，每条边也对应了一条边)</p><h2 id="P4001-ICPC-Beijing-2006-狼抓兔子"><a href="#P4001-ICPC-Beijing-2006-狼抓兔子" class="headerlink" title="P4001 [ICPC-Beijing 2006]狼抓兔子"></a>P4001 [ICPC-Beijing 2006]狼抓兔子</h2><p>求网格图的最小割<br>网格图显然是平面图，转成对偶图后跑最短路即可<br><del>然后对偶图难建还比网络流慢</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line">vector&lt;pii&gt; G[<span class="number">2</span>*N*N];</span><br><span class="line">ll dis[<span class="number">2</span>*N*N];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">2</span>*N*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, (T+<span class="number">1</span>)*<span class="built_in">sizeof</span>(ll));</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, (T+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  priority_queue&lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt;&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>, s));</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">top</span>().se; q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)</span><br><span class="line">      &#123;</span><br><span class="line">        dis[v] = dis[u] + w;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">mp</span>(dis[v], v));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  S = <span class="number">0</span>, T = (<span class="number">2</span>*n<span class="number">-2</span>)*(m<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">auto</span> id = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>||y==m) <span class="keyword">return</span> S;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>*n<span class="number">-1</span>||y==<span class="number">0</span>) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*(m<span class="number">-1</span>) + y;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = <span class="built_in">id</span>(<span class="number">2</span>*i<span class="number">-2</span>, j), v = <span class="built_in">id</span>(<span class="number">2</span>*i<span class="number">-1</span>, j), w; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">      G[u].<span class="built_in">emplace_back</span>(v, w); G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = <span class="built_in">id</span>(<span class="number">2</span>*i<span class="number">-1</span>, j<span class="number">-1</span>), v = <span class="built_in">id</span>(<span class="number">2</span>*i, j), w; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">      G[u].<span class="built_in">emplace_back</span>(v, w); G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = <span class="built_in">id</span>(<span class="number">2</span>*i<span class="number">-1</span>, j), v = <span class="built_in">id</span>(<span class="number">2</span>*i, j), w; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">      G[u].<span class="built_in">emplace_back</span>(v, w); G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">Dijkstra</span>(S);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dis[T]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客多校2-Interval"><a href="#牛客多校2-Interval" class="headerlink" title="牛客多校2 Interval"></a>牛客多校2 Interval</h2><p>初始有一个区间$[1,n]$<br>对于一个区间$<a href="l%3Cr">l,r</a>$，可以变换成$[l+1,r]$,$[l,r-1]$,$[l−1,r]$,$[l,r+1]$<br>现在给定m种方式，可以花费一定的代价限制某种变换，问最少花费多少代价使得区间$[1,n]$无法变换成长度为1的区间<br>$n \leq 500$</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>考虑网络流最小割建图，对每个区间建一个点，每种变换连边流量为INF，如果某种变换被限制，则连边流量为cost，表示割掉这条边的代价。<br>点数是$n^2n$,边数也是$n^2$的<br>发现这是一个平面图，所以转成对偶图跑最短路就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pil = pair&lt;<span class="type">int</span>,ll&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T, idx[N][N], tot;</span><br><span class="line">ll dis[N*N];</span><br><span class="line"><span class="type">bool</span> vis[N*N];</span><br><span class="line">vector&lt;pil&gt; G[N*N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  G[u].<span class="built_in">emplace_back</span>(v, w);</span><br><span class="line">  G[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, (tot+<span class="number">1</span>)*<span class="built_in">sizeof</span>(ll));</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, (tot+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  priority_queue&lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt;&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">0</span>, s));</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">top</span>().se; q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> v = it.fi; ll w = it.se;</span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)</span><br><span class="line">      &#123;</span><br><span class="line">        dis[v] = dis[u] + w;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">mp</span>(dis[v], v));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">      idx[i][j] = ++tot;</span><br><span class="line">  S = <span class="number">0</span>; T = ++tot;</span><br><span class="line">  <span class="keyword">auto</span> id = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> S;</span><br><span class="line">    <span class="keyword">if</span>(y==n) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">return</span> idx[x][y];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">addedge</span>(<span class="built_in">id</span>(i<span class="number">-1</span>, j), <span class="built_in">id</span>(i, j), LINF);</span><br><span class="line">      <span class="built_in">addedge</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i, j+<span class="number">1</span>), LINF);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">addedge</span>(<span class="built_in">id</span>(i, i), <span class="built_in">id</span>(i<span class="number">-1</span>, i<span class="number">-1</span>), LINF);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, c;</span><br><span class="line">    <span class="type">char</span> dir;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; dir &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(dir==<span class="string">&#x27;L&#x27;</span>) <span class="built_in">addedge</span>(<span class="built_in">id</span>(l, r<span class="number">-1</span>), <span class="built_in">id</span>(l, r), c);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">addedge</span>(<span class="built_in">id</span>(l<span class="number">-1</span>, r<span class="number">-1</span>), <span class="built_in">id</span>(l, r<span class="number">-1</span>), c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Dijkstra</span>(S);</span><br><span class="line">  cout &lt;&lt; (dis[T]&gt;=LINF ? <span class="number">-1</span> : dis[T]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性规划 单纯型算法</title>
      <link href="/2020/08/11/xian-xing-gui-hua-dan-chun-xing-suan-fa/"/>
      <url>/2020/08/11/xian-xing-gui-hua-dan-chun-xing-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>n个变量x1,…,xnx_1,…,x_nx1​,…,xn​，m个线性约束，形如∑i&#x3D;1naijxi≤bj\sum \limits_{i&#x3D;1}^n<br>a_{ij}x_i \leq b_ji&#x3D;1∑n​aij​xi​≤bj​,要求确定这n个变量的值，max⁡z&#x3D;∑i&#x3D;1ncixi\max z &#x3D;<br>\sum\limits_{i&#x3D;1}^n c_ix_imaxz&#x3D;i&#x3D;1∑n​ci​xi​<br>单纯型可以被卡到指数级，但一般情况下速度较快，相比于MCMF，代码更短，而且更直观<br>以下用矩阵形式表达（规定小写为列向量，大写为矩阵）</p><h3 id="标准形式"><a href="#标准形式" class="headerlink" title="标准形式"></a>标准形式</h3><p>最大化cTxc^TxcTx，满足约束Ax≤b,xi≥0Ax\leq b,x_i \geq 0Ax≤b,xi​≥0</p><h3 id="松弛形式"><a href="#松弛形式" class="headerlink" title="松弛形式"></a>松弛形式</h3><p>最大化cTxc^TxcTx，满足约束Ax&#x3D;b,xi≥0Ax&#x3D;b,x_i \geq 0Ax&#x3D;b,xi​≥0<br>只要对每个标准形式的约束条件增加一个变量xn+i≥0x_{n+i} \geq 0xn+i​≥0即可</p><h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><p>最小化bTxb^TxbTx，满足约束ATx≤c,xi≥0A^Tx \leq c,x_i \geq 0ATx≤c,xi​≥0<br>目标函数的系数c与约束条件右边的系数b交换，并将约束系数矩阵转置，最大化与最小化互换，改变不等式号</p><p>a00&#x3D;−z,a0i&#x3D;ci,ai0&#x3D;bia_{00}&#x3D;-z,a_{0i}&#x3D;c_i,a_{i0}&#x3D;b_ia00​&#x3D;−z,a0i​&#x3D;ci​,ai0​&#x3D;bi​<br>m行n列，表示n个变量，m个约束，单纯型使用的是松弛形式，只不过没有显示表示出来<br>当约束系数aija_{ij}aij​为0，1，-1（全幺模矩阵）时用以下代码</p><pre><code>int n, m;int a[N][M], q[M];const int INF = 0x3f3f3f3f;void cal(int l, int e)&#123;    a[l][e] = 1; int p = 0;    for(int j=0; j&lt;=n; j++) if(a[l][j]) q[++p] = j;    for(int i=0, t=0; i&lt;=m; i++)        if(i!=l &amp;&amp; (t=a[i][e]))        &#123;            a[i][e] = 0;            for(int j=1; j&lt;=p; j++) a[i][q[j]] -= t*a[l][q[j]];        &#125;&#125;int work()&#123;    while(true)    &#123;        int l = 0, e = 0, mn = INF;        for(int j=1; j&lt;=n; j++)             if(a[0][j]&gt;0) &#123; e = j; break; &#125;        if(!e) break;        for(int i=1; i&lt;=m; i++)            if(a[i][e]&gt;0 &amp;&amp; a[i][0]&lt;mn) mn = a[i][0], l = i;        assert(l);        cal(l, e);    &#125;    return -a[0][0];&#125;</code></pre><p>一般情况下，原问题或者对偶问题中至少有一个零解是可行解，所以不需要init，否则需要先通过init找到一组初始解，再进行simplex优化</p><pre><code>const double eps = 1e-8, INF = 1e15;int n, m, type, id[M*2], q[M];double a[N][M], ans[M];void pivot(int l, int e)&#123;    swap(id[l+n], id[e]);    double t = a[l][e]; a[l][e] = 1.0; int p = 0;    for(int j=0; j&lt;=n; j++) a[l][j] /= t;    for(int j=0; j&lt;=n; j++) if(fabs(a[l][j])&gt;eps) q[++p] = j;    for(int i=0; i&lt;=m; i++)        if(i!=l &amp;&amp; fabs(a[i][e])&gt;eps)        &#123;            double t = a[i][e]; a[i][e] = 0.0;            for(int j=1; j&lt;=p; j++) a[i][q[j]] -= t*a[l][q[j]];        &#125;&#125;bool init()&#123;    while(true)    &#123;        int l = 0, e = 0;        for(int i=1; i&lt;=m; i++)            if(a[i][0]&lt;-eps &amp;&amp; (!l || (rand()&amp;1))) l = i;        if(!l) break;        for(int j=1; j&lt;=n; j++)            if(a[l][j]&lt;-eps &amp;&amp; (!e || (rand()&amp;1))) e = j;        if(!e) return puts(&quot;Infeasible&quot;), false; //无解        pivot(l, e);    &#125;    return true;&#125;bool simplex()&#123;    while(true)    &#123;        int l = 0, e = 0; double w = eps;        for(int j=1; j&lt;=n; j++) //选择最大的那个（更快找到最优解），或者选择第一个大于0的（可以防止死循环）            if(a[0][j]&gt;w) w = a[0][j], e = j;        if(!e) break;        w = INF;        for(int i=1; i&lt;=m; i++)            if(a[i][e]&gt;eps &amp;&amp; a[i][0]/a[i][e]&lt;w)                w = a[i][0]/a[i][e], l = i;        if(!l) return puts(&quot;Unbounded&quot;), false;//解无界        pivot(l, e);    &#125;     return true;&#125;void solve()&#123;    iota(id+1, id+n+1, 1);    if(init() &amp;&amp; simplex())    &#123;        printf(&quot;%.8f\n&quot;, -a[0][0]);        for(int i=1; i&lt;=m; i++) ans[id[n+i]] = a[i][0];        if(type) for(int i=1; i&lt;=n; i++) printf(&quot;%.8f &quot;, ans[i]);     &#125;&#125;</code></pre><p>线性规划转费用流：<br>列出标准形式，添加松弛变量转化为松弛型<br>每个式子与前一个式子相减，如果每个变量只出现两次，且系数一正一负，就可以转化为费用流<br>对于每个等式新建一个点，如果等式中右边常数b为正数，从源点s向该点连边（b,0），否则该点向汇点连边（-b,0）。对每个变量（包括添加的用来松弛的变量）从它系数为正的等式代表的点向它系数为负的等式代表的点连边（INF，c），c为目标函数中的系数</p><ul><li><pre><code>*       * 标准形式</code></pre><ul><li>松弛形式</li><li>对偶问题</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分散层叠算法(Fractional Cascading)</title>
      <link href="/2020/08/07/fen-san-ceng-die-suan-fa-fractional-cascading/"/>
      <url>/2020/08/07/fen-san-ceng-die-suan-fa-fractional-cascading/</url>
      
        <content type="html"><![CDATA[<p>给定k个长度为n有序数组L，要求<strong>在线</strong>q次回答每个数组中$\geq x$的最小的数<br>$k\leq 100,n\leq 10^4, q\leq 3\times 10^5$<br>离线的话可以整体二分<br>在线用该算法时间复杂度为$O(k+\log n)$，空间复杂度为$O(n)$<br>用一个$k\times n$的二维数组M，M[i]的每一位记录三个信息，｛键值，在L[i]中后继的位置，在M[i+1]中后继的位置｝<br>考虑从后往前构造，M[k]&#x3D;L[k]<br>由于是有序的，利用归并$O(n)$合并L[i]和M[i+1]，注意对于M[i+1]只合并偶数位置（节省空间）<br>对于查询，先利用一次二分在M[1]中找到后继的位置，此时该位的第二个信息就表示了在L[1]数组中的答案，而该位的第三个信息表示了在M[2]中后继的位置，注意由于是间隔插入，所以需要和该位置的前一个位置取优。这样只需要一次二分，然后各数组间利用保存的信息（指针）可以$O(1)$转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k, q, d;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;q, &amp;d);</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">L</span>(k, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L[i][j]);</span><br><span class="line">  vector&lt;vector&lt;pair&lt;<span class="type">int</span>,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;&gt; <span class="built_in">M</span>(k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    M[k<span class="number">-1</span>].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(L[k<span class="number">-1</span>][i], <span class="built_in">mp</span>(i, <span class="number">0</span>)));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;n &amp;&amp; b&lt;<span class="built_in">sz</span>(M[i+<span class="number">1</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(L[i][a]&lt;=M[i+<span class="number">1</span>][b].first) M[i].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(L[i][a], <span class="built_in">mp</span>(a, b))), a++;</span><br><span class="line">      <span class="keyword">else</span> M[i].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(M[i+<span class="number">1</span>][b].first, <span class="built_in">mp</span>(a, b))), b += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;n) M[i].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(L[i][a], <span class="built_in">mp</span>(a, b))), a++;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;<span class="built_in">sz</span>(M[i+<span class="number">1</span>])) M[i].<span class="built_in">push_back</span>(<span class="built_in">mp</span>(M[i+<span class="number">1</span>][b].first, <span class="built_in">mp</span>(a, b))), b += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> lstans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> _=<span class="number">1</span>; _&lt;=q; _++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    x ^= lstans;</span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">lower_bound</span>(M[<span class="number">0</span>].<span class="built_in">begin</span>(), M[<span class="number">0</span>].<span class="built_in">end</span>(), <span class="built_in">mp</span>(x, <span class="built_in">mp</span>(<span class="number">0</span>, <span class="number">0</span>))) - M[<span class="number">0</span>].<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> curans = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx&lt;k &amp;&amp; p&lt;<span class="built_in">sz</span>(M[idx]))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(M[idx][p].second.first&lt;n) curans ^= L[idx][M[idx][p].second.first];</span><br><span class="line">      <span class="keyword">if</span>(idx&lt;k<span class="number">-1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> nxtp = M[idx][p].second.second;</span><br><span class="line">        <span class="keyword">if</span>(nxtp<span class="number">-1</span>&lt;<span class="built_in">sz</span>(M[idx+<span class="number">1</span>]) &amp;&amp; M[idx+<span class="number">1</span>][nxtp<span class="number">-1</span>].first&gt;=x) --nxtp;</span><br><span class="line">        p = nxtp;</span><br><span class="line">      &#125;</span><br><span class="line">      ++idx;</span><br><span class="line">    &#125;</span><br><span class="line">    lstans = curans;</span><br><span class="line">    <span class="keyword">if</span>(_%d==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, curans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kosaraju求强连通分量</title>
      <link href="/2020/08/07/kosaraju-qiu-qiang-lian-tong-fen-liang/"/>
      <url>/2020/08/07/kosaraju-qiu-qiang-lian-tong-fen-liang/</url>
      
        <content type="html"><![CDATA[<p>反图的强连通分量和原图相同<br>按照反图的逆后序方向遍历原图即可<br>逆后序方向：先遍历与该点相连的节点，最后将该点入栈，栈的反序为逆后序<br>利用bitset可以优化到$O(n^2&#x2F;32)$，适合稠密图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Kosaraju</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ord[N], tp, num[N], scc;</span><br><span class="line">  bitset&lt;N&gt; tag, G[N], rG[N], t;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) G[i].<span class="built_in">reset</span>(), rG[i].<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    tag[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((t=rG[u]&amp;tag).<span class="built_in">any</span>())</span><br><span class="line">      <span class="built_in">dfs</span>(t._Find_first());</span><br><span class="line">    ord[++tp] = u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    num[u] = scc;</span><br><span class="line">    tag[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((t=G[u]&amp;tag).<span class="built_in">any</span>())</span><br><span class="line">      <span class="built_in">dfs2</span>(t._Find_first());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">gao</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    tp = scc = <span class="number">0</span>;</span><br><span class="line">    tag.<span class="built_in">set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(tag[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">    tag.<span class="built_in">set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">      <span class="keyword">if</span>(tag[ord[i]])</span><br><span class="line">      &#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        <span class="built_in">dfs2</span>(ord[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅行 有向图两点可达性</title>
      <link href="/2020/08/06/lu-xing-you-xiang-tu-liang-dian-ke-da-xing/"/>
      <url>/2020/08/06/lu-xing-you-xiang-tu-liang-dian-ke-da-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一张随机生成的有向图，多次询问x点能否到达y点<br>$n \leq 10^5,m \leq n + 5000,q \leq 3\times$</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>跑一遍tarjan缩点成DAG<br>设置根号个标记点，然后暴力跑出这些标记点能够到达的点，用bitset记录<br>对于每个询问从x暴力dfs，遇到标记点则返回<br>标记点选择度数最大的根号个<br>复杂度：O(能过)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">405</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N], DAG[N];</span><br><span class="line">vector&lt;pii&gt; edges;</span><br><span class="line"><span class="type">int</span> n, m, _;</span><br><span class="line"><span class="type">int</span> dfn[N], num[N], low[N], id, tot, sta[N], top, deg[N], idx[N];</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line"><span class="type">int</span> vis[N], spe[N];</span><br><span class="line">bitset&lt;N&gt; bit[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  in[u] = <span class="number">1</span>;</span><br><span class="line">  low[u] = dfn[u] = ++id;</span><br><span class="line">  sta[++top] = u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(in[v]) low[u] = <span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(low[u]==dfn[u])</span><br><span class="line">  &#123;</span><br><span class="line">    tot++;</span><br><span class="line">    <span class="keyword">while</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> tmp = sta[top--];</span><br><span class="line">      in[tmp] = <span class="number">0</span>;</span><br><span class="line">      num[tmp] = tot;</span><br><span class="line">      <span class="keyword">if</span>(tmp==u) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(spe[u]) &#123; bit[t] |= bit[spe[u]]; <span class="keyword">return</span>; &#125;</span><br><span class="line">  vis[u] = t;</span><br><span class="line">  bit[t].<span class="built_in">set</span>(u);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : DAG[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[v]==t) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : edges)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = num[it.fi], v = num[it.se];</span><br><span class="line">    <span class="keyword">if</span>(u!=v) DAG[u].<span class="built_in">pb</span>(v), deg[u]++, deg[v]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> lim = (<span class="type">int</span>)<span class="built_in">sqrt</span>(tot) + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">iota</span>(idx+<span class="number">1</span>, idx+tot+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">sort</span>(idx+<span class="number">1</span>, idx+tot+<span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> deg[x] &gt; deg[y];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lim; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(idx[i], i);</span><br><span class="line">    spe[idx[i]] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(spe[s]) <span class="keyword">return</span> bit[spe[s]].<span class="built_in">test</span>(t);</span><br><span class="line">  vis[s] = tt;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> ss : DAG[s])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[ss]==tt) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs2</span>(ss, t, tt)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> u, v;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">  ++u, ++v;</span><br><span class="line">  <span class="keyword">if</span>(num[u]==num[v]) <span class="built_in">puts</span>(<span class="string">&quot;Good&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">puts</span>((<span class="built_in">dfs2</span>(num[u], num[v], t) ? <span class="string">&quot;Good&quot;</span> : <span class="string">&quot;Bad&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    ++u, ++v;</span><br><span class="line">    G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">    edges.<span class="built_in">emplace_back</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">prework</span>();</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=_; i++) <span class="built_in">solve</span>(<span class="number">400</span>+i);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括号序列问题</title>
      <link href="/2020/07/30/gua-hao-xu-lie-wen-ti/"/>
      <url>/2020/07/30/gua-hao-xu-lie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="前置结论"><a href="#前置结论" class="headerlink" title="前置结论"></a>前置结论</h3><p>定义左括号’(‘为+1，右括号’)’为-1，作前缀和得到一个序列p<br>当且仅当pn&#x3D;0∧∀i pi&gt;&#x3D;0p_n &#x3D; 0 \wedge \forall i \ p_i &gt;&#x3D;0pn​&#x3D;0∧∀i pi​&gt;&#x3D;0时，该括号序列合法</p><p>取mn&#x3D;min⁡i&#x3D;1npimn &#x3D; \min_{i&#x3D;1}^n<br>p_imn&#x3D;mini&#x3D;1n​pi​，则该括号序列的最长合法括号子序列的长度为n−pn+2mnn - p_n + 2mnn−pn​+2mn<br>考虑位置pos，其中ppos&#x3D;mnp_{pos}&#x3D;mnppos​&#x3D;mn，则在1…pos1…pos1…pos中，有-mn个右括号失配，在pos+1…npos+1…npos+1…n中有pn−mnp_n-<br>mnpn​−mn个左括号失配</p><p>一个长度为n，右括号个数为m，对应的序列p的最小值为t的括号序列的个数有(nn−m−t)−(nn−m−t+1)\binom{n}{n-m-t} -<br>\binom{n}{n-m-t+1}(n−m−tn​)−(n−m−t+1n​)<br>先考虑对应的序列p的最小值不小于t的方案数：<br>利用计算卡特兰数的方法，所有-<br>不合法。所有即为(nm)\binom{n}{m}(mn​)。不合法的即序列p的最小值是&lt;&#x3D;t-1的，考虑位置pos，其中ppos&#x3D;t−1p_{pos}&#x3D;t-1ppos​&#x3D;t−1，则在1…pos1…pos1…pos中左括号比右括号少−(t−1)-(t-1)−(t−1)个，pos+1…npos+1…npos+1…n中左括号比右括号多n−2m−(t−1)n-2m-(t-1)n−2m−(t−1)，将1…pos1…pos1…pos的左右括号翻转，则1…n1…n1…n中左括号比右括号多n−2m−2(t−1)n-2m-2(t-1)n−2m−2(t−1)个，容易发现不合法的括号序列与左括号比右括号多n−2m−2(t−1)n-2m-2(t-1)n−2m−2(t−1)个的括号序列一一对应，所以不合法即为(nn−m−t+1)\binom{n}{n-m-t+1}(n−m−t+1n​)<br>那么对应的序列p的最小值不小于t+1的方案数为(nm)−(nn−m−t)\binom{n}{m} -<br>\binom{n}{n-m-t}(mn​)−(n−m−tn​)<br>则对应的序列p的最小值为t的方案数为(nn−m−t)−(nn−m−t+1)\binom{n}{n-m-t} -<br>\binom{n}{n-m-t+1}(n−m−tn​)−(n−m−t+1n​)</p><p>一个括号序列循环移位后合法的方案数：</p><ul><li>若左括号数不等于右括号数，显然无解</li><li>ans &#x3D; p中最小值出现的次数，若ppos&#x3D;mnp_{pos} &#x3D; mnppos​&#x3D;mn，则将1…pos1…pos1…pos移到后面，pos+1…npos+1…npos+1…n移到前面则合法</li></ul><h3 id="洛谷p6689-序列"><a href="#洛谷p6689-序列" class="headerlink" title="洛谷p6689 序列"></a>洛谷p6689 序列</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>一个长度为n，初始全为’(‘的括号序列，给定参数k，每次随机在[1,n]选择一个位置然后翻转该位置的括号，当翻转了一个’(‘，就让k-1，重复直至k&#x3D;0。询问最后生成的括号序列的最长合法子序列的期望长度<br>n,k&lt;&#x3D;5×103n, k&lt;&#x3D;5\times 10^3n,k&lt;&#x3D;5×103</p><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><p>知道一个括号序列的左右括号的个数以及其对应的序列p的最小值就可以得到该括号序列的最长合法子序列的长度。<br>先求出长度为n的括号序列中有m个右括号的概率，再枚举序列p的最小值即可解决，这是两个独立的问题。<br>首先概率dp：fijf_{ij}fij​表示当前参数为i，已经有j个右括号的概率<br>fij&#x3D;n−j+1n∑k&#x3D;j−1nfik∏l&#x3D;jklnf_{ij} &#x3D; \dfrac{n-j+1}{n}\sum_{k&#x3D;j-1}^{n} f_{ik}<br>\prod_{l&#x3D;j}^{k}\dfrac{l}{n}fij​&#x3D;nn−j+1​∑k&#x3D;j−1n​fik​∏l&#x3D;jk​nl​<br>fijf_{ij}fij​可以由j−1…nj-1…nj−1…n个右括号的情况转移过来，相当于先连续将x个右括号变成左括号，然后再将1个左括号变成右括号<br>f0m(nm)\dfrac{f_{0m}}{\binom{n}{m}}(mn​)f0m​​就等于生成一个有m个右括号的括号序列的概率<br>最后枚举这个括号序列的最小值，然后依据上面的公式计算即可</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353, N = 5e3 + 5;inline void mul(int &amp;a, int b) &#123; a = 1ll*a*b%mod; &#125;inline int Mul(int a, int b) &#123; return 1ll*a*b%mod; &#125;inline void add(int &amp;a, int b) &#123; a+=b; if(a&gt;=mod) a-=mod; &#125;inline int Add(int a, int b) &#123; a+=b; if(a&gt;=mod) return a-mod; return a; &#125;inline void sub(int &amp;a, int b) &#123; a-=b; if(a&lt;0) a+=mod; &#125;inline int Sub(int a, int b) &#123; a-=b; if(a&lt;0) return a+mod; return a; &#125;int n, k, f[N][N], fac[N], inv[N];int powmod(int a, int b)&#123;    int ans = 1;    while(b)    &#123;        if(b&amp;1) mul(ans, a);        mul(a, a);        b &gt;&gt;= 1;    &#125;    return ans;&#125;void init(int n)&#123;    fac[0] = 1;    for(int i=1;i&lt;=n;i++) fac[i] = 1ll*fac[i-1]*i%mod;    inv[n] = powmod(fac[n], mod-2);    for(int i=n-1;i&gt;=0;i--) inv[i] = 1ll*inv[i+1]*(i+1)%mod;&#125;int comb(int a, int b)&#123;    if(a&lt;b||b&lt;0||a&lt;0) return 0;    return 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    int invn = powmod(n, mod-2);    f[0][0] = 1;    init(n);    for(int i=1; i&lt;=k; i++)    &#123;        int sum = f[i-1][n];        for(int j=n; j&gt;=1; j--)        &#123;            mul(sum, Mul(j, invn));            add(sum, f[i-1][j-1]);            f[i][j] = Mul(Mul(invn, (n-j+1)), sum);        &#125;    &#125;    for(int i=1; i&lt;=n; i++) mul(f[k][i], powmod(comb(n, i), mod-2));    int ans = 0;    auto cal = [](int x, int y, int z)-&gt;int //长度为x的括号序列，有y个右括号，对应序列p的最小值为z的方案数    &#123;        return Sub(comb(x, x-y-z), comb(x, x-y-z+1));    &#125;;    for(int i=1; i&lt;=n; i++) //枚举右括号个数        for(int j=2; j&lt;=n&amp;&amp;min(i, n-i)&gt;=j/2; j+=2) //枚举最长合法子序列的长度为j，则此时p序列的mn=(j-2i)/2            add(ans, Mul(Mul(j, f[k][i]), cal(n, i, (j-2*i)/2)));     printf(&quot;%d\n&quot;, ans);    return 0;&#125;</code></pre><h3 id="D2-The-World-Is-Just-a-Programming-Task-Hard-Version"><a href="#D2-The-World-Is-Just-a-Programming-Task-Hard-Version" class="headerlink" title="D2. The World Is Just a Programming Task (Hard Version)"></a>D2. The World Is Just a Programming Task (Hard Version)</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定一个括号序列，要求交换其中两个位置的括号，使得该括号序列循环移位后合法的方案数最多<br>n&lt;&#x3D;3×105n&lt;&#x3D;3\times 10^5n&lt;&#x3D;3×105</p><h4 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h4><p>由上面结论可得，就是要最大化该括号序列对应的p序列的最小值的个数<br>显然交换两个相同的括号是没有意义的<br>当交换一个左括号和一个右括号时，相当于对这段区间的p序列-2<br>当交换一个右括号和一个左括号时，相当于对这段区间的p序列+2<br>显然区间+2只会使最小值个数减少<br>下面考虑区间-2：<br>如果操作的区间中包含了原来最小值的某个位置，显然答案不会更优<br>所以设pos1,…,posxpos_1,…,pos_xpos1​,…,posx​为p序列最小值所处的位置，那么操作的区间只可能是(pos1,pos2)…(pos_1,pos_2)…(pos1​,pos2​)…，也可能是(posx,pos1)(pos_x,pos_1)(posx​,pos1​)，准确来说是对[pos1,posx][pos_1,pos_x][pos1​,posx​]+2，相当于是对(posx,n]，[1,pos1)−2(pos_x,n]，[1,pos_1)-2(posx​,n]，[1,pos1​)−2<br>最优的情况只有两种：</p><ul><li><p>让最小值变成mn-1，只要统计出以上区间中等于mn+1的最多个数即可（显然操作区间越大越好，即[posi,posi+1][pos_i, pos_{i+1}][posi​,posi+1​]）</p></li><li><p>让最小值仍为mn，需要统计出以上区间中连续的且 <strong>不包含mn+1</strong> 的然后mn+2值最多的个数，还要再加上原本等于mn的个数（在以上每个操作区间中作尺取法即可，遇见mn+1就让计数器清空，否则不断往右移动）<br>以上两者取优即可</p><p>#include &lt;bits&#x2F;stdc++.h&gt;<br>#define mp make_pair<br>#define pb push_back<br>#define sz(x) (int)x.size()<br>#define all(x) begin(x), end(x)<br>#define fi first<br>#define se second<br>#define debug(x) cerr &lt;&lt; #x &lt;&lt; “ “ &lt;&lt; x &lt;&lt; ‘\n’<br>using namespace std;<br>using ll &#x3D; long long;<br>using pii &#x3D; pair&lt;int,int&gt;;<br>using pli &#x3D; pair&lt;ll,int&gt;;<br>const int INF &#x3D; 0x3f3f3f3f, N &#x3D; 3e5 + 5;<br>const ll LINF &#x3D; 1e18 + 5;<br>constexpr int mod &#x3D; 1e9 + 7;<br>int n, p[N];<br>char s[N];<br>int main()<br>{<br>ios::sync_with_stdio(false);<br>cin.tie(nullptr);<br>cin &gt;&gt; n &gt;&gt; (s+1);<br>for(int i&#x3D;1; i&lt;&#x3D;n; i++) p[i] &#x3D; (p[i-1] + (s[i]&#x3D;&#x3D;’(‘ ? 1 : -1));<br>if(p[n]) { cout &lt;&lt; 0 &lt;&lt; ‘\n’ &lt;&lt; 1 &lt;&lt; ‘ ‘ &lt;&lt; 1 &lt;&lt; ‘\n’; return 0; }<br>int mn &#x3D; *min_element(p+1, p+n+1);<br>vector<int> vec;<br>for(int i&#x3D;1; i&lt;&#x3D;n; i++) if(p[i]&#x3D;&#x3D;mn) vec.pb(i);<br>int ans &#x3D; sz(vec);<br>pii pos &#x3D; {1, 1};<br>for(int i&#x3D;0; i&lt;sz(vec)-1; i++)<br>{<br>    int j &#x3D; vec[i] + 1, k &#x3D; vec[i+1] - 1;<br>    if(j&gt;k) continue;<br>    int one &#x3D; 0, two &#x3D; 0, tmp &#x3D; 0, st &#x3D; 0;<br>    pii pp &#x3D; {0, 0};<br>    for(int _&#x3D;j; _&lt;&#x3D;k; _++)<br>    {<br>        if(p[_]&#x3D;&#x3D;mn+1)<br>        {<br>            ++one;<br>            tmp &#x3D; st &#x3D; 0;<br>        }<br>        if(p[_]&#x3D;&#x3D;mn+2)<br>        {<br>            ++tmp;<br>            if(!st) st &#x3D; _;<br>        }<br>        if(tmp&gt;two)<br>        {<br>            two &#x3D; tmp;<br>            pp &#x3D; {st, _%n+1};<br>        }<br>    }<br>    if(one&gt;ans) ans &#x3D; one, pos &#x3D; {j, k%n+1};<br>    if(two+sz(vec)&gt;ans) ans &#x3D; two+sz(vec), pos &#x3D; pp;<br>}<br>int one &#x3D; 0, two &#x3D; 0, tmp &#x3D; 0, st &#x3D; 0;<br>pii pp &#x3D; {0, 0};<br>for(int <em>&#x3D;vec.back()%n+1; <em>!&#x3D;vec.front(); <em>&#x3D;</em>%n+1)<br>{<br>    if(p[</em>]&#x3D;&#x3D;mn+1)<br>    {<br>        ++one;<br>        tmp &#x3D; st &#x3D; 0;<br>    }<br>    if(p[</em>]&#x3D;&#x3D;mn+2)<br>    {<br>        ++tmp;<br>        if(!st) st &#x3D; _;<br>    }<br>    if(tmp&gt;two)<br>    {<br>        two &#x3D; tmp;<br>        pp &#x3D; {st, _%n+1};<br>    }<br>}<br>if(one&gt;ans) ans &#x3D; one, pos &#x3D; {vec.back()%n+1, vec.front()};<br>if(two+sz(vec)&gt;ans) ans &#x3D; two+sz(vec), pos &#x3D; pp;<br>cout &lt;&lt; ans &lt;&lt; ‘\n’;<br>cout &lt;&lt; pos.fi &lt;&lt; ‘ ‘ &lt;&lt; pos.se &lt;&lt; ‘\n’;<br>return 0;<br>}</p></li><li><pre><code>*       * 前置结论</code></pre><ul><li>洛谷p6689 序列<ul><li>题意</li><li>做法</li></ul></li><li>D2. The World Is Just a Programming Task (Hard Version)<ul><li>题意</li><li>做法</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷7月月赛</title>
      <link href="/2020/07/27/luo-gu-7-yue-yue-sai/"/>
      <url>/2020/07/27/luo-gu-7-yue-yue-sai/</url>
      
        <content type="html"><![CDATA[<h2 id="P6685-可持久化动态仙人掌的直径问题"><a href="#P6685-可持久化动态仙人掌的直径问题" class="headerlink" title="P6685 可持久化动态仙人掌的直径问题"></a>P6685 可持久化动态仙人掌的直径问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定n, m，求满足$x^m &lt;&#x3D; n$的正整数x个数，$n&lt;&#x3D;10^9, m&lt;&#x3D;10^9$</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><ul><li>m&#x3D;1, ans &#x3D; n</li><li>m&gt;&#x3D;2时显然答案很小， <del>所以随便怎么搞就行</del> ，如果二分的话注意下界从2开始(因为这个t了好几发👀)</li></ul><h2 id="P6686-混凝土数学"><a href="#P6686-混凝土数学" class="headerlink" title="P6686 混凝土数学"></a>P6686 混凝土数学</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定n根木棍的长度$a_i$​，求选择三根构成等腰三角形的方案数(无序对)</p><h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><p>显然排序后枚举腰长x然后二分$&lt;2x$的数的个数即可</p><h2 id="P6687-论如何玩转-Excel-表格"><a href="#P6687-论如何玩转-Excel-表格" class="headerlink" title="P6687 论如何玩转 Excel 表格"></a>P6687 论如何玩转 Excel 表格</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>$2 \times n的网格，不重复的填入$1 \sim 2n$，现在有一种操作，每次可以选择$2 \times 2$的正方形区域然后旋转$180^\circ$，问从给定网格到目标网格的最少操作次数，或输出无解<br>$n&lt;&#x3D;10^6$</p><p>$$<br>[1234]\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix} \quad [13​24​]</p><p>[4321]\begin{bmatrix} 4 &amp; 3 \\ 2 &amp; 1 \end{bmatrix} \quad [42​31​]<br>$$</p><h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><p>容易发现对同一个正方形区域操作两次等于不操作，操作一次相当于交换相邻两列，并且两行元素交换。<br>所以不管怎么操作每列的两个元素是固定的，最多上下位置交换一下。<br>考虑当前网格中第i列的两个元素在目标网格中第j列(如果两个元素在不同列，显然无解)，如果j-i为奇数则位置应该颠倒，偶数则位置应该相同。这样扫一遍就可以判定有没有解。<br>可以发现最后就是要让第i列转移到第$p_i$​列，考虑一个排列，每次只能交换相邻两个元素，问使其有序最少需要的操作次数。答案为逆序对个数。<br>设f为一个置换，$f(p) &#x3D; 1,2,3,…,n$，则答案为$f^{-1}$的逆序对数，树状数组即可</p><h2 id="P6688-可重集"><a href="#P6688-可重集" class="headerlink" title="P6688 可重集"></a>P6688 可重集</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定数组$a_i$​，支持单点修改，并多次询问区间[l1:r1]与区间[l2:r2]是否本质相同。其中本质相同只对这两个区间排序后，对应元素的差值均为整数k。$n&lt;&#x3D;10^6n$</p><h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h3><p>先说一下P3792 由乃与大母神原型和偶像崇拜<br>这题，支持单点修改，并多次询问区间[l:r]在重排后是否是值域连续的。这两道题的特点都是一眼不可做，而解法是数据结构+哈希，所以不能保证一定正确。维护出区间最小值，区间最大值，区间和，区间平方和，然后判断即可<br>从这题的思路容易想到通过维护区间和很容易得到这个差值k，然后再维护平方和？很不幸被出题人卡成了0pts。三次方？没啥用。。<br>考虑设置一个数magic，然后维护$\sum magic^{a_i}$​，然后只要看$\sum_{i&#x3D;l1}^{r1}magic^{a_i} * magic^k&#x3D;&#x3D;\sum_{i&#x3D;l2}^{r2}magic^{a_i}$<br>由于很大要取模，magic和mod随便设就能过。。当然应该能卡<br>上面的方法是把加法利用幂次转成乘法，另一种做法是利用sin。<br>$sin(x+y) &#x3D; sinxcosy + cosxsiny$<br>$cos(x+y) &#x3D; cosxcosy − sinxsiny$<br>维护一下$\sum sinx$和\sum cosx$，同样先利用区间和搞出k，然后用上面的公式判断即可，注意double比较用eps<br>具体怎么维护可以看p6327，区间修改+区间sin和。本题是单点修改+区间sin和<br>由于n是$10^6$级别，而且是单点修+区间查，所以树状数组即可<br>当然以上只是部分可以通过的解法，仅仅是为了拓展一下思路（转成幂次，转成sin）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> magic = <span class="number">1919810</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a = <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) a-=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) <span class="keyword">return</span> a-mod; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a-=b; <span class="keyword">if</span>(a&lt;<span class="number">0</span>) a+=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a-=b; <span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> a+mod; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="keyword">namespace</span> IO</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">  <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,MAXSIZE,stdin),p1==p2) ? EOF : *p1++); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">gc</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) t = t*<span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">    t *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">out</span><span class="params">(T p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sta[<span class="number">70</span>], tp;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span>) &#123; p = -p; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">while</span>(p) sta[++tp] = p%<span class="number">10</span>, p/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(sta[tp--]+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="type">int</span> n, q, a[N], pw[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) <span class="built_in">add</span>(c[i], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) <span class="built_in">sub</span>(c[i], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) <span class="built_in">add</span>(ans, c[i]);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v, <span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) sum[i] += v*op;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) ans += sum[i];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(b&lt;N) <span class="keyword">return</span> pw[b];</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans*a%mod;</span><br><span class="line">    a = a*a%mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(q);</span><br><span class="line">  pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N; i++) pw[i] = <span class="built_in">Mul</span>(pw[i<span class="number">-1</span>], magic);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">ins</span>(i, pw[a[i]]);</span><br><span class="line">    <span class="built_in">upd</span>(i, a[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op; <span class="built_in">read</span>(op);</span><br><span class="line">    <span class="keyword">if</span>(!op)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x, y;</span><br><span class="line">      <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">      <span class="built_in">del</span>(x, pw[a[x]]);</span><br><span class="line">      <span class="built_in">upd</span>(x, a[x], <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">ins</span>(x, pw[a[x]=y]);</span><br><span class="line">      <span class="built_in">upd</span>(x, a[x], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">      <span class="built_in">read</span>(l1), <span class="built_in">read</span>(r1), <span class="built_in">read</span>(l2), <span class="built_in">read</span>(r2);</span><br><span class="line">      <span class="type">int</span> x = <span class="built_in">Sub</span>(<span class="built_in">ask</span>(r1), <span class="built_in">ask</span>(l1<span class="number">-1</span>)), y = <span class="built_in">Sub</span>(<span class="built_in">ask</span>(r2), <span class="built_in">ask</span>(l2<span class="number">-1</span>));</span><br><span class="line">      ll s1 = <span class="built_in">ask2</span>(r1) - <span class="built_in">ask2</span>(l1<span class="number">-1</span>), s2 = <span class="built_in">ask2</span>(r2) - <span class="built_in">ask2</span>(l2<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">if</span>((s2-s1)%(r1-l1+<span class="number">1</span>)) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ll k = (s2-s1)/(r1-l1+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>) k = -k, <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(x*<span class="built_in">powmod</span>(magic, k)%mod==y) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">namespace</span> IO</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">  <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,MAXSIZE,stdin),p1==p2) ? EOF : *p1++); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">gc</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) t = t*<span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">    t *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">out</span><span class="params">(T p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sta[<span class="number">70</span>], tp;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span>) &#123; p = -p; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">while</span>(p) sta[++tp] = p%<span class="number">10</span>, p/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(tp) <span class="built_in">putchar</span>(sta[tp--]+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="type">int</span> n, q, a[N];</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="type">double</span> snx[N], csx[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="keyword">return</span> (x&lt;-eps ? <span class="number">-1</span> : x&gt;eps); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v, <span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> snv = <span class="built_in">sin</span>(v), csv = <span class="built_in">cos</span>(v);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i))</span><br><span class="line">  &#123;</span><br><span class="line">    sum[i] += v*op;</span><br><span class="line">    snx[i] += snv*op;</span><br><span class="line">    csx[i] += csv*op;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) ans += sum[i];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="keyword">operator</span> - (pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; a, pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; b) &#123; <span class="keyword">return</span> <span class="built_in">mp</span>(a.fi-b.fi, a.se-b.se); &#125;</span><br><span class="line"><span class="function">pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="title">ask2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> sn = <span class="number">0.0</span>, cs = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) sn += snx[i], cs += csx[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mp</span>(sn, cs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n); <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">upd</span>(i, a[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="built_in">read</span>(op);</span><br><span class="line">    <span class="keyword">if</span>(op)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">      <span class="built_in">read</span>(l1); <span class="built_in">read</span>(r1); <span class="built_in">read</span>(l2); <span class="built_in">read</span>(r2);</span><br><span class="line">      ll x = <span class="built_in">ask</span>(r1) - <span class="built_in">ask</span>(l1<span class="number">-1</span>);</span><br><span class="line">      ll y = <span class="built_in">ask</span>(r2) - <span class="built_in">ask</span>(l2<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">if</span>((y-x)%(r1-l1+<span class="number">1</span>)) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ll k = (y-x)/(r1-l1+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">ask2</span>(r1) - <span class="built_in">ask2</span>(l1<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> q = <span class="built_in">ask2</span>(r2) - <span class="built_in">ask2</span>(l2<span class="number">-1</span>);</span><br><span class="line">        <span class="type">double</span> snk = <span class="built_in">sin</span>(k), csk = <span class="built_in">cos</span>(k);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(q.fi-p.fi*csk-p.se*snk) || <span class="built_in">sgn</span>(q.se-p.se*csk+p.fi*snk)) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x, y;</span><br><span class="line">      <span class="built_in">read</span>(x); <span class="built_in">read</span>(y);</span><br><span class="line">      <span class="built_in">upd</span>(x, a[x], <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">upd</span>(x, a[x]=y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shift-and/or 字符串匹配算法</title>
      <link href="/2020/07/22/shift-andor-zi-fu-chuan-pi-pei-suan-fa/"/>
      <url>/2020/07/22/shift-andor-zi-fu-chuan-pi-pei-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="shift-and"><a href="#shift-and" class="headerlink" title="shift-and"></a>shift-and</h2><p>在串s中查找串t<br>规定串s的长度为n，串t的长度为m，字符串下标从0开始<br>bitset<m> B[26];<br>预处理字符集中每个字母在串t中的出现的位置，各用一个bitset表示。B[s[i]-‘a’]表示的是s串中i位置与t串中哪些位置可以匹配<br>bitset<m> D;<br>在s中枚举位置i，D[j]&#x3D;1仅当串t的前缀t[0…j]是串s的后缀s[i-j…i]<br>当D[m-1]&#x3D;1时表示一次匹配<br>当枚举位置i+1，就要更新D<br>D &#x3D; (D&lt;&lt;1|1)&amp;B[s[i+1]-‘a’];<br>复杂度O(nm32)O(\frac{nm}{32})O(32nm​)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shift_and</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">strlen</span>(s), m = <span class="built_in">strlen</span>(t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    B[s[i]-<span class="string">&#x27;A&#x27;</span>].<span class="built_in">set</span>(i);</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    D &lt;&lt;= <span class="number">1</span>; D.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line">    D &amp;= B[t[i]-<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(D[n<span class="number">-1</span>]) cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shift-or"><a href="#shift-or" class="headerlink" title="shift-or"></a>shift-or</h2><p>与shiftand的B和D含义都相反，B&#x3D;0表示存在，D&#x3D;0表示匹配，所以初始时B和D全为1，每次转移D &#x3D; (D&lt;&lt;1|B[s[i]-‘a’])</p><p>在普通的字符串匹配中这两者的作用显然没有kmp强，复杂度劣势<br>但是在可选字符匹配中很有用<br>规定每个位置可以与多个字符相匹配，此时只要让这些字符的B的那个位置都置1即可</p><ul><li>hdu 5972 输出的时候令s[n+1]&#x3D;0,然后puts(s[i-n+1])，再还原s[n+1]。如果先记录匹配位置最后双重for会T</li><li>hdu 5716</li><li>牛客多校2G题<br>给定长度为n的数组a和长度为m的数组b，询问数组a中每一位都严格大于数组b的子段个数<br>可以把这个问题当成一个可选字符匹配问题，对于每个a[i]可以与所有&lt;&#x3D;a[i]的b[j]相匹配。<br>考虑预处理出bitset<M> B[N]，表示a的每一位可以与b的哪些位相匹配，然后跑一遍shift-and即可。<br>这样会MLE，随着a的增大，能够匹配的位置不断增加，所以本质不同的bitset只有m个，开成bitset<M> B[M]即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1.5e5</span> + <span class="number">5</span>, M = <span class="number">4e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, idx[N];</span><br><span class="line">pii a[N], b[M];</span><br><span class="line">bitset&lt;M&gt; B[M], D;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].fi), a[i].se = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i].fi), b[i].se = i;</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>); <span class="built_in">sort</span>(b+<span class="number">1</span>, b+m+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    B[i] = B[i<span class="number">-1</span>], B[i].<span class="built_in">set</span>(b[i].se);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=m &amp;&amp; a[i].fi&gt;=b[j].fi) ++j;</span><br><span class="line">    idx[a[i].se] = j<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    D &lt;&lt;= <span class="number">1</span>; D.<span class="built_in">set</span>(<span class="number">1</span>);</span><br><span class="line">    D &amp;= B[idx[i]];</span><br><span class="line">    <span class="keyword">if</span>(D[m]) ++ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑预处理bitset<N> B[i]表示b数组中第i位可以与a数组中哪些位相匹配。然后用一个全1的bitset<N><br>D，当D[i]&#x3D;1时表示a数组中以i下标起始的长度为m的子段可以与b数组相匹配。只要枚举b数组中的所有位置让D &amp;&#x3D;<br>(B[i]&gt;&gt;(i-1))即可，如果B[i][j]&#x3D;0，那么D[j-i+1]起始的子段就不可能与b数组相匹配，因为a[j]!&#x3D;b[i]。<br>以上方法也可以用于字符串匹配。<br>在牛客多校这题中，利用该方法可以仅开一个bitset<N><br>B，因为在这里b数组下标的枚举顺序是任意的，所以我们可以对b排序后再枚举，然后利用尺取实现B的滚动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1.5e5</span> + <span class="number">5</span>, M = <span class="number">4e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, idx[N];</span><br><span class="line">pii a[N], b[M];</span><br><span class="line">bitset&lt;N&gt; B, D;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].fi), a[i].se = i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i].fi), b[i].se = i;</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>); <span class="built_in">sort</span>(b+<span class="number">1</span>, b+m+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n-m+<span class="number">1</span>; i++) D.<span class="built_in">set</span>(i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=m, j=n; i; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; a[j].fi&gt;=b[i].fi) B.<span class="built_in">set</span>(a[j--].se);</span><br><span class="line">    D &amp;= (B&gt;&gt;(b[i].se<span class="number">-1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)D.<span class="built_in">count</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀自动机和广义后缀自动机的一些疑问</title>
      <link href="/2020/07/17/hou-zhui-zi-dong-ji-he-guang-yi-hou-zhui-zi-dong-ji-de-yi-xie-yi-wen/"/>
      <url>/2020/07/17/hou-zhui-zi-dong-ji-he-guang-yi-hou-zhui-zi-dong-ji-de-yi-xie-yi-wen/</url>
      
        <content type="html"><![CDATA[<p>感觉sam，特别是parent树上的复杂度很玄学？！</p><ul><li><p>暴力跳parent树的复杂度是多少？<br>第一种情况是建广义sam，然后每个串暴力跳parent标记，复杂度似乎是$n\sqrt n$​（维护多串的根号trick）<br>第二种是sam上直接无脑暴力跳到某个长度范围内，一般情况是要写倍增的，但是我在2019徐州L、p4094上直接暴力跳也都过了，而且比倍增快（常数小）。。如果是aaaaa…的话parent树是链，应该能卡，所以还是要写倍增吧</p></li><li><p>trie上建广义sam<br>正解是bfs的做法，但是需要显示的建出trie，如果不建会错，我认为是重边的影响（不确定）。<br>如果直接dfs，复杂度会取决于trie上$\sum dep(leaf)$（15国家论文），感觉可以卡成$n^2$，然而我在2019徐州L、2019wfG上直接dfs建就过了，由于不用建trie，时间和空间上都挺优秀，目前还不知道是数据问题还是什么。p3346由于叶子只有20个，所以dfs肯定是对的。</p></li><li><p>广义sam能不能基数排序<br>突然意识到广义sam基数排序后的结果与拓扑序可能有出入，不过我好几道exsam用基数排序得到的拓扑序去做也过了。。很迷<br>还是老老实实把parent树建出来吧。</p></li><li><p>注意：线段树合并求endpos集合的时候，一定要新开点，否则可能会影响子树的信息。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kmp学习笔记</title>
      <link href="/2020/07/14/kmp-xue-xi-bi-ji/"/>
      <url>/2020/07/14/kmp-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>给定主串t和模式串s，求出s在t中的所有匹配位置<br>求出一个串的所有前缀的最大border(next数组)</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>前缀pre(s, l)：s长度为l的前缀(s[1…l])<br>后缀suf(s, l)：s长度为l的后缀(s[|s|-l+1…|s|])<br>周期period：s[i]&#x3D;s[i+p]，∀i∈1…∣s∣−ps[i] &#x3D; s[i+p]，\forall i \in<br>1…|s|-ps[i]&#x3D;s[i+p]，∀i∈1…∣s∣−p，则p是s的周期<br>border: pre(s,l)&#x3D;suf(s,l)pre(s, l) &#x3D; suf(s, l)pre(s,l)&#x3D;suf(s,l)，则pre(s,<br>l)是s的border</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>若s有长为x的border，则|s|-x为s的一个周期。证明可以分成border相交和不相交两种情况<br>最小周期&#x3D;串长-最大border<br>border具有传递性，串s的所有border可以用nxt[∣s∣]，nxt[nxt[∣s∣]]…nxt[|s|]，nxt[nxt[|s|]]…nxt[∣s∣]，nxt[nxt[∣s∣]]…表示<br><strong>Weak Periodicity Lemma</strong><br>p和q是s的周期，p+q&lt;&#x3D;|s|，则gcd(p, q)也是s的周期<br><strong>Periodicity Lemma</strong><br>p和q是s的周期，p+q-gcd(p, q)&lt;&#x3D;|s|，则gcd(p, q)也是s的周期<br>(牛客多校1的签到是给出两个无限串各自的周期，要求比较这两个串的字典序大小，只需要比较前p+q-gcd(p,q)或者前p+q个字符，如果都相同，说明p和q都是各自的周期，两个串相等)</p><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>nxt数组的求法可以当作是s串自己和自己匹配的过程。<br>规定nxt[0]&#x3D;−1nxt[0] &#x3D; -1nxt[0]&#x3D;−1，s串从0开始，nxt[i]表示s[0…i-1]的最大border<br>考虑当前已经求出了nxt[0…i]，且nxt[i]&#x3D;jnxt[0…i]，且nxt[i]&#x3D;jnxt[0…i]，且nxt[i]&#x3D;j，说明s[i-j…i-1]&#x3D;s[0…j-1]</p><ul><li><p>s[i]&#x3D;&#x3D;s[j]，nxt[++i]&#x3D;++js[i]&#x3D;&#x3D;s[j]，nxt[++i] &#x3D; ++js[i]&#x3D;&#x3D;s[j]，nxt[++i]&#x3D;++j</p></li><li><p>s[i]!&#x3D;s[j]s[i]!&#x3D;s[j]s[i]!&#x3D;s[j]，此时我们需要不断往前跳nxt，直到找到一个border的后一个字符等于s[j]，然后转为第一种情况</p><p>void kmp_pre(char s[], int n, int nxt[])<br>{<br>int i &#x3D; 0, j &#x3D; nxt[0] &#x3D; -1;<br>while(i&lt;n)<br>{<br>    while(j!&#x3D;-1&amp;&amp;s[i]!&#x3D;s[j]) j &#x3D; nxt[j];<br>    nxt[++i] &#x3D; ++j;<br>}<br>}</p></li></ul><p>字符串匹配的过程和求next数组的过程类似（模式串都是s，只不过主串变了）。<br>规定s串为模式串，t为主串，下标均从0开始。<br>先求出s串的next数组<br>考虑当前t串匹配到i-1，s串匹配到j-1，说明t[i−j…i−1]&#x3D;s[0…j−1]t[i-j…i-1]&#x3D;s[0…j-1]t[i−j…i−1]&#x3D;s[0…j−1]</p><ul><li><p>t[i]&#x3D;s[j]t[i]&#x3D;s[j]t[i]&#x3D;s[j]，++i，++j。如果j&gt;|s|，说明找到一个匹配，记录下位置，让j&#x3D;nxt[j]</p></li><li><p>t[i]!&#x3D;s[j]t[i]!&#x3D;s[j]t[i]!&#x3D;s[j]，j不断跳nxt直到找到一个border的后一个字符等于t[i]为止，然后转化为第一种情况</p><p>int kmp_work(char s[], int n, char t[], int m)<br>{<br>int i &#x3D; 0, j &#x3D; 0, ans &#x3D; 0;<br>kmp_pre(s, n, nxt);<br>while(i&lt;m)<br>{<br>    while(j!&#x3D;-1&amp;&amp;t[i]!&#x3D;s[j]) j &#x3D; nxt[j];<br>    i++; j++;<br>    if(j&gt;&#x3D;n)<br>    {<br>        ans++;<br>        match[i-n] &#x3D; 1;<br>        j &#x3D; nxt[j];<br>    }<br>}<br>return ans;<br>}</p></li></ul><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul><li><p>p3375<br>求出所有匹配位置+nxt数组</p></li><li><p>p5829<br>引入一种失配树（和ac自动机的fail树类似）：按照next数组进行建树，next[i]作为i的父亲。<br>显然每个点有且仅有一个父节点。<br>容易发现每个点的所有祖先就是它的所有border，跳nxt的过程相当于不断往父亲走<br>本题多次询问一个串s的某两个前缀的最大公共border。建出失配树后很直观的可以发现答案就是两个节点的LCA代表的前缀</p></li><li><p>p3435<br>求每个前缀的最大周期。<br>求最大周期相当于求最小border。放在失配树上就相当于找到每个点祖先中离根最近的那个。树上dp一下即可。也可以路径压缩。</p></li><li><p>poj2185<br>一个n*m字符矩阵，求一个最小的子矩阵，使其重复多次后所得矩阵包含原矩阵。<br>行列分开做一遍kmp，求出各自的最大border。<br>按行做的时候，每一行的字符当作一个字符（hash一下，直接暴力也行）</p></li><li><p>p2375<br>对s的所有前缀，求出长度不超过一半的border数量<br>放到失配树上，倍增一下（border长度单减）（无脑+暴力）O(nlogn)O(nlogn)O(nlogn)<br>O(n)O(n)O(n)做法：<br>考虑在求解nxt数组的时候，再增加一个k指针，该指针和j指针一样，但是需要额外满足长度的限制，如果不满足继续跳nxt。i点的答案就是k点的答案的nxt前缀和（同时dp递推即可）</p><p>void solve()<br>{<br>cin &gt;&gt; s;<br>int n &#x3D; strlen(s);<br>int i &#x3D; 0, j &#x3D; nxt[0] &#x3D; -1, k &#x3D; -1;<br>ll ans &#x3D; 1;<br>while(i&lt;n)<br>{<br>    while(<del>j &amp;&amp; s[i]!&#x3D;s[j]) j &#x3D; nxt[j];<br>    while(</del>k &amp;&amp; s[i]!&#x3D;s[k]) k &#x3D; nxt[k];<br>    nxt[++i] &#x3D; ++j;<br>    ++k;<br>    dp[i] &#x3D; dp[nxt[i]] + 1;<br>    while(2<em>k&gt;i) k &#x3D; nxt[k];<br>    ans &#x3D; ans</em>(dp[k]+1)%mod; &#x2F;&#x2F;求的是每个点答案+1的连乘积<br>}<br>cout &lt;&lt; ans &lt;&lt; ‘\n’;<br>}</p></li><li><p>p3426<br>对于字符串s，求一个最短的字符串t，其 <strong>可重叠</strong> 地重复数次后等于s<br>显然t是s的一个border<br>如果当前等价于s[1…i]，相当于t是pre(s,<br>i)的一个border。所以这个t是s的某些前缀的border，而且这些前缀的位置的差值要&lt;&#x3D;这个串t的长度。<br>在失配树上考虑，答案是0到n这条链上的某个点x(s的某个border)，并且该点子树内所有点的位置的最大差值&lt;&#x3D;x(x是其子树内的所有点的某个border)，如果最大差值&gt;x，那么这两个前缀间就不能通过x拼接而成。<br>失配树上从0走到n，不断删去非子树内的点，用set或双向链表维护maxgap即可<br>考虑dp[i]：s[1…i]的答案<br>dp[i]要么等于i，要么等于dp[nxt[i]]<br>等于dp[nxt[i]]的条件是nxt[i]…i-1间∃j dp[j]&#x3D;dp[nxt[i]]∧i−j&lt;&#x3D;dp[nxt[i]]\exists j <br>dp[j] &#x3D; dp[nxt[i]] \land i-j&lt;&#x3D;dp[nxt[i]]∃j dp[j]&#x3D;dp[nxt[i]]∧i−j&lt;&#x3D;dp[nxt[i]]</p><p>for(int i&#x3D;1; i&lt;&#x3D;n; i++)<br>{<br>dp[i] &#x3D; i;<br>if(p[dp[nxt[i]]] &amp;&amp; i-p[dp[nxt[i]]]&lt;&#x3D;dp[nxt[i]])<br>    dp[i] &#x3D; dp[nxt[i]];<br>p[dp[i]] &#x3D; i;<br>}</p></li><li><p>p3193<br>给定一个长为m的字符串t，问能构造出多少个长为n的字符串s，使得t不是s的子串。<br>m&lt;&#x3D;20,n&lt;&#x3D;109m&lt;&#x3D;20, n&lt;&#x3D;10^9m&lt;&#x3D;20,n&lt;&#x3D;109<br>f[i][j]：s串构造到i，t串匹配到j的方案数f[i][j]：s串构造到i，t串匹配到j的方案数f[i][j]：s串构造到i，t串匹配到j的方案数<br>先预处理出t串当前匹配到i，加一个字符后匹配到j的方案数g[i][j]，这个用kmp即可<br>转移：f[i][j]&#x3D;∑k&#x3D;0m−1f[i−1][k]∗g[k][j]f[i][j] &#x3D; \sum_{k&#x3D;0}^{m-1} f[i-1][k] *<br>g[k][j]f[i][j]&#x3D;∑k&#x3D;0m−1​f[i−1][k]∗g[k][j]<br>显然可以矩阵快速幂优化</p></li></ul><p>[f[i][0]⋯f[i][m−1]]&#x3D;[f[i−1][0]⋯f[i−1][m−1]][g[0][0]⋯g[0][m−1]⋮⋱⋮g[m−1][0]⋯g[m−1][m−1]]\begin{bmatrix}<br>f[i][0] &amp; \cdots &amp; f[i][m-1] \end{bmatrix} &#x3D; \begin{bmatrix} f[i-1][0] &amp;<br>\cdots &amp; f[i-1][m-1] \end{bmatrix} \begin{bmatrix} g[0][0] &amp; \cdots &amp;<br>g[0][m-1] \\ \vdots &amp; \ddots &amp; \vdots \\ g[m-1][0] &amp; \cdots &amp; g[m-1][m-1]<br>\\ \end{bmatrix}<br>[f[i][0]​⋯​f[i][m−1]​]&#x3D;[f[i−1][0]​⋯​f[i−1][m−1]​]⎣⎢⎡​g[0][0]⋮g[m−1][0]​⋯⋱⋯​g[0][m−1]⋮g[m−1][m−1]​⎦⎥⎤​</p><p>其中f[0][0]&#x3D;1<br>最后答案即为gng^ngn的第一行的和</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 25;const ll LINF = 1e18 + 5;int n, m, mod;int g[N][N], nxt[N];char s[N];struct matrix&#123;    int n, m;    int mat[N][N];    matrix() &#123;&#125;    matrix(int a, int b) : n(a), m(b) &#123; memset(mat, 0, sizeof(mat)); &#125;    void one()    &#123;        for(int i=1; i&lt;=n; i++)            for(int j=1; j&lt;=m; j++)                mat[i][j] = (i==j);    &#125;&#125;;matrix operator * (matrix a, matrix b) &#123;    matrix res(a.n, b.m);    for(int i=1; i&lt;=a.n; i++)        for(int j=1; j&lt;=b.m; j++)            for(int k=1; k&lt;=a.m; k++)                res.mat[i][j] = (res.mat[i][j]+a.mat[i][k]*b.mat[k][j])%mod;    return res;&#125;matrix operator ^ (matrix a, ll x) &#123;    matrix res(a.n, a.m); res.one();    while(x)    &#123;        if(x&amp;1) res = res * a;        a = a * a;        x &gt;&gt;= 1;    &#125;    return res;&#125;void get_nxt()&#123;    int i = 0, j = nxt[0] = -1;    while(i&lt;m)    &#123;        while(~j &amp;&amp; s[i]!=s[j]) j = nxt[j];        nxt[++i] = ++j;    &#125;&#125;void init_g()&#123;    for(int i=-1; i&lt;m-1; i++)        for(int k=0; k&lt;10; k++)        &#123;            int j = i + 1;            while(~j &amp;&amp; s[j]-&#39;0&#39;!=k) j = nxt[j];            g[i+1][j+1]++;        &#125;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;    cin &gt;&gt; s;    get_nxt();    init_g();    matrix f(m, m);    for(int i=1; i&lt;=m; i++)        for(int j=1; j&lt;=m; j++)            f.mat[i][j] = g[i-1][j-1];    f = f ^ n;    int ans = 0;    for(int i=1; i&lt;=m; i++) ans = (ans + f.mat[1][i])%mod;    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre><ul><li><pre><code>*       * 应用</code></pre><ul><li>定义</li><li>性质</li><li>求法</li><li>习题</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D-Array 构造</title>
      <link href="/2020/06/18/d-array-gou-zao/"/>
      <url>/2020/06/18/d-array-gou-zao/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个数x和y，要求用最少的n个数，使得他们的异或和&#x3D;x，求和&#x3D;y</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>这道题在cf上有类似的</p><ul><li>x&#x3D;y&#x3D;0 输出0</li><li>x&#x3D;y!&#x3D;0 输出1</li><li>x&gt;y 输出-1</li><li>(y-x)&amp;1 输出-1</li><li>如果可以用(y+x)&#x2F;2 和(y-x)&#x2F;2，就输出2</li><li>否则输出3 x, (y-x)&#x2F;2, (y-x)&#x2F;2<br>顺便记一下python多组输入(竟然跑了6s多。。)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="keyword">if</span> x==y:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">0</span>) <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">else</span> <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> x&gt;y:</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> (y-x)&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> ((y+x)//<span class="number">2</span>) ^ ((y-x)//<span class="number">2</span>) == x:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛65</title>
      <link href="/2020/06/18/niu-ke-lian-xi-sai-65/"/>
      <url>/2020/06/18/niu-ke-lian-xi-sai-65/</url>
      
        <content type="html"><![CDATA[<h2 id="C-二维动点"><a href="#C-二维动点" class="headerlink" title="C 二维动点"></a>C 二维动点</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>平面上有n个点，每次可以选择一个与当前不重合的点，然后移动到两者<strong>直线</strong>上的任意一点，多次询问从原点到(x, y)最少的移动次数</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>大力分类讨论：</p><ul><li>(0, 0）是没有用的，如果出现需要去掉</li><li>如果平面上所有点到原点的连线是相同的，且询问点不在该连线上，输出-1</li><li>如果询问点与原点连成的直线上存在平面上的n个点中的至少一个，输出1，可以利用pair来存斜率，注意归约化处理</li><li>如果点数&gt;&#x3D;3，输出2，只要有两条直线相交，就可以先移到交点，再移过去</li><li>当只有2个点时，考虑一种特殊情况（样例已经提示），原点+这2个点+询问点构成平行四边形，此时需要3次，先随便移到某个点处，再按上一条的做法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, q, x[N], y[N];</span><br><span class="line">map&lt;pii, <span class="type">int</span>&gt; cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"><span class="function">pii <span class="title">cal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = c - a, y = d - b;</span><br><span class="line">  <span class="built_in">assert</span>(x || y);</span><br><span class="line">  <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> f = <span class="built_in">sgn</span>(x)*<span class="built_in">sgn</span>(y);</span><br><span class="line">  <span class="type">int</span> t = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(x), <span class="built_in">abs</span>(y));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mp</span>(f*x/t, y/t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="type">int</span> m = n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    <span class="keyword">if</span>(!x[i]&amp;&amp;!y[i])</span><br><span class="line">    &#123;</span><br><span class="line">      m--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[<span class="built_in">cal</span>(<span class="number">0</span>, <span class="number">0</span>, x[i], y[i])]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(!a&amp;&amp;!b) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt.<span class="built_in">count</span>(<span class="built_in">cal</span>(<span class="number">0</span>, <span class="number">0</span>, a, b))) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sz</span>(cnt)&lt;=<span class="number">1</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m&gt;=<span class="number">3</span>) cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">cal</span>(<span class="number">0</span>, <span class="number">0</span>, x[<span class="number">1</span>], y[<span class="number">1</span>])==<span class="built_in">cal</span>(x[<span class="number">2</span>], y[<span class="number">2</span>], a, b) &amp;&amp; <span class="built_in">cal</span>(<span class="number">0</span>, <span class="number">0</span>, x[<span class="number">2</span>], y[<span class="number">2</span>])==<span class="built_in">cal</span>(x[<span class="number">1</span>], y[<span class="number">1</span>], a, b)) cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-最小公倍数"><a href="#D-最小公倍数" class="headerlink" title="D 最小公倍数"></a>D 最小公倍数</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个数n，要求拆分成k个数，定义拆分后的价值为该序列的所有子序列的lcm的<strong>种类数</strong> ，注意空序列的lcm&#x3D;1</p><h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><p>因为答案要取模，所以感觉没法比较大小，所以在做题的时候以为是个构造。。。然后其实就是dp<br>考虑数$p_1*p_2$​，显然没有拆成$p_1, p_2$​两个数优，因为它们的贡献是一样的，但是后者更小。<br>所以最后一定是拆成若干个素数的幂次。<br>考虑进行背包dp，因为各个素数的贡献其实是一样的，所以一定是从小往大选，前100多个素数的和就超过$10^5$了，如果当前这个素数选了k个，即选择了$p_1,<br>p_2 … p_k$​，假设之前有x个不同的种类，那现在就有(k+1)*x个不同的种类。<br>下面的问题是由于要取模，没法比较最后的大小了（毒瘤），一种方法是用double来存价值，并记录转移路径，最后在回溯的时候用longlong，并且取模，另一种是用<code>Pair&lt;double, long long&gt;</code>，前者利用log函数将乘法转为加法，后者存答案，即取模后的值，由于pair已经封装好了，所以直接取max即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, prime[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">pair&lt;<span class="type">double</span>,ll&gt; dp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getprime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=x; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) prime[++prime[<span class="number">0</span>]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=prime[<span class="number">0</span>]&amp;&amp;<span class="number">1ll</span>*prime[j]*i&lt;=x; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      vis[prime[j]*i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="built_in">getprime</span>(n);</span><br><span class="line">  <span class="type">int</span> cur = <span class="number">0</span>, tot = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(tot&lt;=prime[<span class="number">0</span>]&amp;&amp;cur+prime[tot]&lt;=n) cur += prime[tot++];</span><br><span class="line">  dp[<span class="number">0</span>].se = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;tot; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=n; j&gt;=prime[i]; j--)</span><br><span class="line">    &#123;</span><br><span class="line">      ll t = prime[i], s = t;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; s&lt;=j; s += (t*=prime[i]), k++)</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], <span class="built_in">mp</span>(dp[j-s].fi+<span class="built_in">log2</span>(k+<span class="number">1</span>), dp[j-s].se*(k+<span class="number">1</span>)%mod));</span><br><span class="line">    &#125;</span><br><span class="line">  pair&lt;<span class="type">double</span>, ll&gt; ans = &#123;<span class="number">0.0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">  cout &lt;&lt; ans.se &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-游走配对"><a href="#E-游走配对" class="headerlink" title="E 游走配对"></a>E 游走配对</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>无向图上，有q个蓝点，q个红点，要求将蓝点和红点进行配对，每次配对产生的费用是他们路径上经过的所有点权的和，此外一个点如果被经过了k次，那么它的点权是$a_i + (k-1)*b_i$​，问最小的配对费用</p><h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><p>数据量较小，MCMF。<br>由于是点权，我们拆成入点和出点，点权放在入点到出点的边上，并且拆除q条边，每条边流量为1，费用为第i次经过产生的费用，再将源点与q个蓝点的入点相连，q个红点的出点与汇相连，原图的m条边，则将u的出点和v的入点相连，v的出点和u的入点相连，然后跑最小费用最大流<br>算是网络流基础题了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>, M = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, q, m, x[N], y[N];</span><br><span class="line"><span class="type">int</span> cnt, head[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> next, to, w, f;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[++cnt] = &#123;head[u],v,w,f&#125;;</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MCMF</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n, m, s, t;</span><br><span class="line">  <span class="type">int</span> flow, cost;</span><br><span class="line">  <span class="type">bool</span> inq[N];</span><br><span class="line">  <span class="type">int</span> d[N], p[N], a[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n = n, <span class="keyword">this</span>-&gt;s = s, <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">    cnt = <span class="number">1</span>, m = <span class="number">0</span>, flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> cap,<span class="type">int</span> cost)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(u,v,cap,cost);</span><br><span class="line">    <span class="built_in">add</span>(v,u,<span class="number">0</span>,-cost);</span><br><span class="line">    m += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(inq,<span class="number">0</span>,(n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>, a[s] = INF;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      inq[u] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(u==t) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(e[i].w&amp;&amp;d[v]&gt;d[u]+e[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">          d[v] = d[u] + e[i].f;</span><br><span class="line">          p[v] = i;</span><br><span class="line">          a[v] = <span class="built_in">min</span>(a[u],e[i].w);</span><br><span class="line">          <span class="keyword">if</span>(!inq[v])</span><br><span class="line">          &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">            inq[v] = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[t] != INF;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      flow += a[t];</span><br><span class="line">      cost += a[t] * d[t];</span><br><span class="line">      <span class="type">int</span> u = t;</span><br><span class="line">      <span class="keyword">while</span>(u!=s)</span><br><span class="line">      &#123;</span><br><span class="line">        e[p[u]].w -= a[t];</span><br><span class="line">        e[p[u]^<span class="number">1</span>].w += a[t];</span><br><span class="line">        u = e[p[u]^<span class="number">1</span>].to;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;MM;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">  MM.<span class="built_in">init</span>(<span class="number">2</span>*n+<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=q; j++)</span><br><span class="line">      MM.<span class="built_in">addedge</span>(i, n+i, <span class="number">1</span>, (j<span class="number">-1</span>)*b+a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> c, d;</span><br><span class="line">    cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    MM.<span class="built_in">addedge</span>(c+n, d, q, <span class="number">0</span>);</span><br><span class="line">    MM.<span class="built_in">addedge</span>(d+n, c, q, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) cin &gt;&gt; x[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) cin &gt;&gt; y[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    MM.<span class="built_in">addedge</span>(MM.s, x[i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    MM.<span class="built_in">addedge</span>(y[i]+n, MM.t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  MM.<span class="built_in">go</span>();</span><br><span class="line">  cout &lt;&lt; MM.cost &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforces1361</title>
      <link href="/2020/06/06/codeforces1361/"/>
      <url>/2020/06/06/codeforces1361/</url>
      
        <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>给定一张无向图，每个点有一个权值，如果访问u点，产生的价值是与u相连的所有点的点权的mex，给定价值序列，让你求访问顺序</p><p>显然只要按照权值从小到大访问，然后模拟一遍看是否合法即可。<br><del>我TM在排序里用了等于号，一直re，人快没了</del> sort的比较函数必须是偏序的</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>每个物品的权值为pkip^{k_i}pki​，给定ppp和kik_iki​，问将物品分成两堆，使权值和的差最小，问最小值。</p><p>可以看成一个p进制的数，每次将当前最高位丢入第一堆，然后用后面的数不断补给第二堆，直到与第一堆相等，然后重复即可。记录两堆相差的p的幂次即可，细节较多<br>感觉最近写题的正确率有点低，总是犯些奇奇怪怪的错误，导致调的时候也很烦</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>用n个线段，每个线段的端点有权值a和b，要求将它们串成一个环，定义两条线段连接点处的权值为highbit(ab)highbit(a^b)highbit(ab)，环的价值为所有连接点处价值的最小值，问环的价值最大是多少</p><p>显然二分价值（由于只有20，直接从大到小枚举即可，考虑如何check。如果价值为x，说明连接点处两点权值的低x位是相同的，所以按照a&amp;((1&lt;&lt;k)-1)<br>– b&amp;((1&lt;&lt;k)-1)建图，看是否存在欧拉回路即可<br>我貌似不会欧拉回路怎么记录。。。<br>随便从一点出发找出欧拉路径，看其长度是否为n，再看 <strong>首尾连接点处的权值是否满足要求</strong><br>，注意在找路径前要先利用度数进行判断，否则找的路径会出问题（我也不知道为什么）<br>对于欧拉图（存在欧拉回路），所有点度数一定都是偶数，且为连通图（可以不判断，因为如果找到的欧拉路径&lt;n就说明不连通）</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = (1&lt;&lt;20) + 5;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7;int n, a[N], b[N], cur[N], in[N], out[N];vector&lt;int&gt; path;vector&lt;pii&gt; G[N];bool vis[N];void dfs(int u, int pre) //找欧拉路径的板子&#123;    while(cur[u]&lt;sz(G[u]))    &#123;        int v = G[u][cur[u]].fi, id = G[u][cur[u]].se;        ++cur[u];        if(!vis[id])         &#123;            vis[id] = vis[id^1] = 1; //每条边正向和反向选其1，所以走了一个后，另一个也要标记            dfs(v, id);        &#125;    &#125;    if(pre!=-1) path.pb(pre);&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cin &gt;&gt; n;    for(int i=1; i&lt;=n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];    for(int k=20; k&gt;=0; k--)    &#123;        int c = (1&lt;&lt;k) - 1;        for(int i=0; i&lt;=c; i++) G[i].clear(), cur[i] = 0, in[i] = 0;        for(int i=2; i&lt;=2*n+1; i++) vis[i] = 0;        for(int i=1; i&lt;=n; i++)        &#123;            G[a[i]&amp;c].emplace_back(b[i]&amp;c, 2*i);            G[b[i]&amp;c].emplace_back(a[i]&amp;c, 2*i+1);            in[a[i]&amp;c]++, in[b[i]&amp;c]++;        &#125;        bool ok = 1;        for(int i=0; i&lt;=c&amp;&amp;ok; i++)            if(in[i]&amp;1) ok = 0;        if(!ok) continue;        path.clear();        dfs(a[1]&amp;c, -1);        if(sz(path)&lt;n) continue;        if(path[0]%2&amp;&amp;(a[(path[0]-1)/2]&amp;c)!=(a[1]&amp;c)) continue;        if(path[0]%2==0&amp;&amp;(b[path[0]/2]&amp;c)!=(a[1]&amp;c)) continue;        cout &lt;&lt; k &lt;&lt; &#39;\n&#39;;        for(int x : path)        &#123;            if(x&amp;1) cout &lt;&lt; x-2 &lt;&lt; &#39; &#39; &lt;&lt; x-1 &lt;&lt; &#39; &#39;;            else cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; x-1 &lt;&lt; &#39; &#39;;        &#125;        cout &lt;&lt; &#39;\n&#39;;        break;    &#125;    return 0;&#125;</code></pre><ul><li><pre><code>*       * A</code></pre><ul><li>B</li><li>C</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lyndon 分解</title>
      <link href="/2020/06/03/lyndon-fen-jie/"/>
      <url>/2020/06/03/lyndon-fen-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Lyndon串：s是s所有后缀中字典序最小的（s是其所有循坏位移中最小的一个）<br>Lyndon分解：Lyndon 分解是将字符串 s 分解成 $s&#x3D;s_1s_2 \dots s_n$​,使得每个$s_i$​都是Lyndon串，且$s_i&gt;&#x3D;s_{i+1}$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>Lyndon分解唯一，且每个字符串都存在Lyndon分解。</p><h3 id="Duval-算法"><a href="#Duval-算法" class="headerlink" title="Duval 算法"></a>Duval 算法</h3><p>O(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> j = i, k = i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(k&lt;=n&amp;&amp;s[j]&lt;=s[k])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[j]&lt;s[k]) j = i;</span><br><span class="line">    <span class="keyword">else</span> j++;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">  &#123;</span><br><span class="line">    ans ^= i+k-j<span class="number">-1</span>;  <span class="comment">//[i:i+k-j-1]是某个分解的s_i</span></span><br><span class="line">    i += k-j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最小表示法只要对s+s进行Lyndon分解并找到最后一个分解的串的起点取长度n即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stern-Brocot 树与 Farey 序列</title>
      <link href="/2020/06/03/stern-brocot-shu-yu-farey-xu-lie/"/>
      <url>/2020/06/03/stern-brocot-shu-yu-farey-xu-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="Stern-Brocot-树"><a href="#Stern-Brocot-树" class="headerlink" title="Stern-Brocot 树"></a>Stern-Brocot 树</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>从两个最简单的分数开始： $\dfrac 01 \quad \dfrac 10$<br>每次在相邻的两个分数$\dfrac {a}{b} \quad \dfrac{c}{d}$​中间插入一个分数$\dfrac{a+c}{b+d}$​即可</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li><p>每一层的序列中，分数单调递增，即$\dfrac {a}{b} &lt; \dfrac{a+c}{b+d} &lt; \dfrac{c}{d}$<br>这是一棵平衡树，中序遍历是有序的（建树、查找）</p></li><li><p>每个分数都是最简分数</p></li><li><p>可以表示出<strong>所有</strong>的最简分数，每个分数唯一</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">1</span>, <span class="type">int</span> c = <span class="number">1</span>, <span class="type">int</span> d = <span class="number">0</span>, <span class="type">int</span> level = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = a + c, y = b + d;</span><br><span class="line">  <span class="comment">// ... output the current fraction x/y</span></span><br><span class="line">  <span class="comment">// at the current level in the tree</span></span><br><span class="line">  <span class="built_in">build</span>(a, b, x, y, level + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">build</span>(x, y, c, d, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Farey序列"><a href="#Farey序列" class="headerlink" title="Farey序列"></a>Farey序列</h2><p>Fi：把分母小于等于i的所有最简真分数按大小顺序排列形成的序列。<br>可以通过SB树的方法类似构造<br>长度：<br>$L_i &#x3D; L_{i-1} + \phi(i)$<br>$L_i &#x3D; 1 + \sum_{j&#x3D;1}^n \phi(j)$<br>分母每增大1，可以多phi(i)个最简真分数，即与i互质</p><p>求$f(x) &#x3D; \dfrac{k}{x}$ 与 $g(x) &#x3D; x^{\frac12}f(x)&#x3D;x$​的交点的横坐标的最接近的分数，要求分母小于$10^5$<br>让$k&#x3D;k^2$，相当于找到最接近$k^\frac13$​的分数<br>令初始分数为a &#x3D; x-1, b &#x3D; 1, c &#x3D; x, d &#x3D; 1<br>然后在SB树上不断迭代靠近即可（类似二分的过程）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll x, k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    k = k*k;</span><br><span class="line">    <span class="keyword">while</span>(x*x*x&lt;k) x++;</span><br><span class="line">    <span class="keyword">if</span>(x*x*x==k) <span class="built_in">printf</span>(<span class="string">&quot;%lld/1\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ll a = x<span class="number">-1</span>, b = <span class="number">1</span>, c = x, d = <span class="number">1</span>, p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">      <span class="type">long</span> <span class="type">double</span> delta = <span class="built_in">min</span>(x*x*x-k, k-(x<span class="number">-1</span>)*(x<span class="number">-1</span>)*(x<span class="number">-1</span>));</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ll x = a + c, y = b + d;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;<span class="number">100000</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">double</span> tmp = (<span class="type">long</span> <span class="type">double</span>)x*x*x/(y*y*y);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(tmp-k)&lt;delta)</span><br><span class="line">        &#123;</span><br><span class="line">          delta = <span class="built_in">fabs</span>(tmp-k);</span><br><span class="line">          p = x, q = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;k) c = x, d = y;</span><br><span class="line">        <span class="keyword">else</span> a = x, b = y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YsOI2020 幼儿园 思维</title>
      <link href="/2020/06/02/ysoi2020you-er-yuan-si-wei/"/>
      <url>/2020/06/02/ysoi2020you-er-yuan-si-wei/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定有向图，n个点m条边，每条边有权值i，且恰好是1-m的一个排列，多次询问从x点只走$[l,<br>r]$的边，且边权严格单调下降能否到达1号点，强制在线</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>限制了边权的范围$[l, r]$，我们可以先考虑$[1,<br>r]$的时候怎么做，考虑dp[u]表示u号点与1连通需要的最小边权，从小到大枚举每一条边，如果该点与1相连，则dp[u]&#x3D;w，否则如果dp[v]有值，则dp[u]&#x3D;i，然后只要看dp[u]是不是小于r即可<br>加入下界限制后，将dp[u]转化为与1连通时需要经过的最小边权 <strong>最大</strong><br>是多少，如果该点与1相连，则dp[u]&#x3D;i，否则dp[u]&#x3D;max(dp[u],dp[v])，随着从小到大枚举边权dp，dp[u]是不断变大的，考虑按照枚举顺序建立主席树，每次单点更新u点的值，询问只要查询rt[r]版本的主席树中x点的值是否&gt;&#x3D;l即可。<br>相当于每个点处有很多单调递增的二维点（x坐标为边权，y坐标为dp），我们对每个点用vector存这些点，那么只要看x&lt;&#x3D;r的最后一个点的y是否&gt;&#x3D;l。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>严格单调下降的限制只要通过从小到大的顺序dp即可解决，对于既有上界又有下界的限制，考虑枚举上界，然后最大化下界即可</p><p>主席树写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, w, dp[N];</span><br><span class="line">pii edges[N];</span><br><span class="line"><span class="keyword">namespace</span> PSegTree</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ls(x) t[x].l</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rs(x) t[x].r</span></span><br><span class="line">  <span class="type">int</span> rt[N], tot;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, mx;</span><br><span class="line">  &#125;t[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t[++tot] = t[p];</span><br><span class="line">    p = tot;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">newnode</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">      t[p].mx = <span class="built_in">max</span>(t[p].mx, v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(<span class="built_in">ls</span>(p), l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">upd</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r, x, v);</span><br><span class="line">    t[p].mx = <span class="built_in">max</span>(t[<span class="built_in">ls</span>(p)].mx, t[<span class="built_in">rs</span>(p)].mx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> t[p].mx;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">ls</span>(p), l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PSegTree;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;w);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;edges[i].fi, &amp;edges[i].se);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = edges[i].fi, v = edges[i].se;</span><br><span class="line">    <span class="keyword">if</span>(v==<span class="number">1</span>) dp[u] = i;</span><br><span class="line">    <span class="keyword">else</span> dp[u] = <span class="built_in">max</span>(dp[u], dp[v]);</span><br><span class="line">    rt[i] = rt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">upd</span>(rt[i], <span class="number">1</span>, m, u, dp[u]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x, l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">if</span>(w) x ^= L, l ^= L, r ^= L;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>||<span class="built_in">ask</span>(rt[r], <span class="number">1</span>, m, x)&gt;=l) ++L, <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF893F Subtree Minimum Query 主席树trick</title>
      <link href="/2020/06/02/cf893f-subtree-minimum-query-zhu-xi-shu-trick/"/>
      <url>/2020/06/02/cf893f-subtree-minimum-query-zhu-xi-shu-trick/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一棵有点权的树，每次询问点u子树中距离u&lt;&#x3D;k的点的点权的最小值，要求在线回答</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>询问子树，考虑dfs序，即询问[in[u]：out[u]][in[u]：out[u]][in[u]：out[u]]<br>[dep[u]：dep[u]+k][dep[u]：dep[u]+k][dep[u]：dep[u]+k] 中的min{a}<br>二维偏序，发现每个dfs序对应了一个点，按照深度建主席树，每个版本的主席树维护的是[1,dep[u]][1,dep[u]][1,dep[u]]这个深度前缀中dfs序区间的最小值，按照bfs深度顺序更新。<br>询问的时候只要ask dep[u]+k版本的主席树中[in[u], out[u]]区间的最小值即可</p><p>一些不一定对的思考：<br>线段树可以高效维护一段区间的信息，而主席树可以维护各个版本的线段树，每个版本维护的是它及其之前的所有版本的前缀信息，所以主席树可以维护二维的信息，通过转变维度，巧妙的利用某一维来建树可以解决很多问题。该题中最小值不可减，所以只能询问前缀，而不能询问rt[l]-rt[r]，但是在该dfs序中的点dep[u]都是符合条件的，所以没有问题。再说带修的主席树，由于主席树维护的是每个版本的前缀信息，所以在修改的时候需要修改后面每个版本的信息，所以考虑在外层套一个树状数组，此时树状数组中每棵主席树维护的不再是前缀信息了，不需要继承前一个版本(rt[i]&#x3D;rt[i-1])，每次的查询和询问操作都只与log棵主席树相关</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 1e5 + 5;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7;int n, r, a[N], in[N], out[N], dfn, dep[N];int m, p, q, mxdep;vector&lt;int&gt; G[N];namespace PSegTree &#123;    #define ls(x) t[x].l    #define rs(x) t[x].r    int rt[N], tot;    struct node    &#123;        int l, r, mn;    &#125;t[N&lt;&lt;5];    inline void newnode(int &amp;p)    &#123;        t[++tot] = t[p];        p = tot;     &#125;    void upd(int &amp;p, int l, int r, int x, int v)    &#123;        newnode(p);        if(l==r)         &#123;            t[p].mn = min(t[p].mn, v);            return;        &#125;        int mid = (l+r) &gt;&gt; 1;        if(x&lt;=mid) upd(ls(p), l, mid, x, v);        else upd(rs(p), mid+1, r, x, v);        t[p].mn = min(t[ls(p)].mn, t[rs(p)].mn);    &#125;    int ask(int p, int l, int r, int ql, int qr)     &#123;        if(l&gt;=ql&amp;&amp;r&lt;=qr) return t[p].mn;        int ans = INF, mid = (l+r)&gt;&gt;1;        if(ql&lt;=mid) ans = min(ans, ask(ls(p), l, mid, ql, qr));        if(qr&gt;mid) ans = min(ans, ask(rs(p), mid+1, r, ql, qr));        return ans;    &#125;    #undef ls    #undef rs&#125;using namespace PSegTree;void dfs(int u, int fa)&#123;    in[u] = ++dfn;    dep[u] = dep[fa] + 1;    mxdep = max(mxdep, dep[u]);    for(int v : G[u])    &#123;        if(v==fa) continue;        dfs(v, u);    &#125;    out[u] = dfn;&#125;void bfs()&#123;    queue&lt;int&gt; q;    q.push(r);    int curd = 0;    rt[0] = 0;    t[0].mn = INF;    while(sz(q))    &#123;        int u = q.front(); q.pop();        if(dep[u]&gt;curd)        &#123;            rt[dep[u]] = rt[curd];            curd = dep[u];        &#125;        upd(rt[dep[u]], 1, n, in[u], a[u]);        //cout &lt;&lt; u &lt;&lt; &#39; &#39; &lt;&lt; in[u] &lt;&lt; &#39; &#39; &lt;&lt; a[u] &lt;&lt; &#39;\n&#39;;        for(int v : G[u])            if(dep[v]==dep[u]+1) q.push(v);    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;r);    for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, a+i);    for(int i=1; i&lt;n; i++)    &#123;        int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        G[x].pb(y); G[y].pb(x);    &#125;    dfs(r, 0);    bfs();    scanf(&quot;%d&quot;, &amp;m);    int lstans = 0;    while(m--)    &#123;        scanf(&quot;%d%d&quot;, &amp;p, &amp;q);        p = (p+lstans)%n + 1;        q = (q+lstans)%n;        //debug(p); debug(q);        printf(&quot;%d\n&quot;, lstans=ask(rt[min(mxdep, dep[p]+q)], 1, n, in[p], out[p]));    &#125;    return 0;&#125;</code></pre><ul><li><pre><code>*       * 题意</code></pre><ul><li>做法</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6583 回首过去 数论+整除分块</title>
      <link href="/2020/06/02/p6583-hui-shou-guo-qu-shu-lun-zheng-chu-fen-kuai/"/>
      <url>/2020/06/02/p6583-hui-shou-guo-qu-shu-lun-zheng-chu-fen-kuai/</url>
      
        <content type="html"><![CDATA[<p>给定n&lt;&#x3D;1012n&lt;&#x3D;10^{12}n&lt;&#x3D;1012<br>询问∑x&#x3D;1n∑y&#x3D;1n[xy是有限小数]\sum_{x&#x3D;1}^n \sum_{y&#x3D;1}^n \left[ \dfrac{x}{y} 是有限小数<br>\right]∑x&#x3D;1n​∑y&#x3D;1n​[yx​是有限小数]</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>当真分数xy\dfrac {x}{y}yx​中分母y为2p5q2^p5^q2p5q的形式时才为有限小数<br>即可以表示成d∗gcd(x,y)2p5qgcd(x,y)\dfrac {d*gcd(x, y)}{2^p5^qgcd(x,<br>y)}2p5qgcd(x,y)d∗gcd(x,y)​<br>考虑枚举分母y，则可行的x的个数为⌊nζ(y)⌋\left \lfloor \dfrac {n}{\zeta(y)} \right<br>\rfloor⌊ζ(y)n​⌋，ζ(y)\zeta(y)ζ(y)表示小于等于y的最大的不含2和5的因子的整数，相当于是gcd（x, y）<br>这样是O(n)的，考虑改变枚举顺序<br>枚举ζ(y)\zeta(y)ζ(y)，那么答案就是∑k&#x3D;1n[2∤k][5∤k]⌊nk⌋g(⌊nk⌋)\sum_{k&#x3D;1}^n [2 \nmid k][5<br>\nmid k] \left \lfloor \dfrac {n}{k} \right \rfloor g(\left \lfloor \dfrac<br>{n}{k} \right \rfloor)∑k&#x3D;1n​[2∤k][5∤k]⌊kn​⌋g(⌊kn​⌋)<br>显然可以整除分块，其中g(i)代表小于等于i的且能表示成2p5q2^p5^q2p5q的数的个数（相当于是贡献次数）。<br>然后可以通过容斥计算出区间内不被2和5整除的数的个数。</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 2e5 + 5;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7;ll n;ll f(ll x)&#123;    return x - x/2 - x/5 + x/10;&#125;ll g(ll x)&#123;    ll ans = 0;    for(ll i=1; i&lt;=x; i*=2)    &#123;        for(ll j=1; j&lt;=x; j*=5)        &#123;            if(i*j&gt;x) break;            ans++;        &#125;    &#125;    return ans;&#125;int main()&#123;    scanf(&quot;%lld&quot;, &amp;n);    ll ans = 0;    for(ll l=1,r; l&lt;=n; l=r+1)    &#123;        r = min(n, n/(n/l));        ans += (f(r) - f(l-1))*(n/l)*g(n/l);    &#125;    printf(&quot;%lld\n&quot;, ans);    return 0;&#125;</code></pre><ul><li><pre><code>*       * 做法</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019ICPC 徐州</title>
      <link href="/2020/05/31/2019icpc-xu-zhou/"/>
      <url>/2020/05/31/2019icpc-xu-zhou/</url>
      
        <content type="html"><![CDATA[<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>暴力打表即可，不过在我电脑上跑的挺慢的。。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>素数密度是不断变小的</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>利用连续整数异或和的trick即可，只要小范围枚举左右两端点，中间一大段大概率可以是0</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>求出$\frac{Y!} {\prod {a_i}}$​是X的多少次方的倍数<br>利用pollardrho求解X的所有素因子，然后求出各个阶乘中各素因子幂次的数量，乘法+，除法-，最后每个素因子取个min，注意负数和正数上下取整的问题</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>单点修改，区间询问该段区间最小的不能被表示的数<br>洛谷p4587+修改<br>先考虑不带修改的情况，对[l,r]内的数从小到大考虑，假设当前能够表示出[1,cur]的范围，如果询问[1,cur+1]的值等于cur，说明剩余的值都是大于等于cur+2的，此时cur+1是无法被表示出来的，所以break，容易发现该操作中cur的增长速度是fibnacci级别的，利用主席树完成二维数点问题。<br>至于修改，在外层套一个树状数组即可，复杂度$O(n log^3 n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>, up = <span class="number">2e5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, q, a[N];</span><br><span class="line"><span class="keyword">namespace</span> PSegTree</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ls(x) t[x].l</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rs(x) t[x].r</span></span><br><span class="line">  <span class="type">int</span> rt[N], tot;</span><br><span class="line">  <span class="type">int</span> lrt[N], rrt[N], lc, rc;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum;</span><br><span class="line">  &#125;t[N*<span class="number">128</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = ++tot;</span><br><span class="line">    t[p].sum += x*v;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">insert</span>(<span class="built_in">ls</span>(p), l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(<span class="built_in">rs</span>(p), mid+<span class="number">1</span>, r, x, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">      ll ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) ans -= t[lrt[i]].sum;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) ans += t[rrt[i]].sum;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) lrt[i] = <span class="built_in">ls</span>(lrt[i]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) rrt[i] = <span class="built_in">ls</span>(rrt[i]);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ask</span>(l, mid, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ll ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) ans -= t[<span class="built_in">ls</span>(lrt[i])].sum;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) ans += t[<span class="built_in">ls</span>(rrt[i])].sum;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=lc; i++) lrt[i] = <span class="built_in">rs</span>(lrt[i]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=rc; i++) rrt[i] = <span class="built_in">rs</span>(rrt[i]);</span><br><span class="line">      <span class="keyword">return</span> ans + <span class="built_in">ask</span>(mid+<span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PSegTree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=(i&amp;-i)) <span class="built_in">insert</span>(rt[i], <span class="number">1</span>, up, a[x], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  lc = rc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) lrt[++lc] = rt[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=r; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) rrt[++rc] = rt[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="number">1</span>, up, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">upd</span>(i, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">upd</span>(x, <span class="number">-1</span>);</span><br><span class="line">      a[x] = y;</span><br><span class="line">      <span class="built_in">upd</span>(x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ll cur = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ll sum = <span class="built_in">query</span>(x, y, <span class="built_in">min</span>((ll)up, cur+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(sum==cur) <span class="keyword">break</span>;</span><br><span class="line">        cur = sum;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, cur+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“科林明伦杯”哈尔滨理工大学第十届程序设计竞赛</title>
      <link href="/2020/05/31/ke-lin-ming-lun-bei-ha-er-bin-li-gong-da-xue-di-shi-jie-cheng-xu-she-ji-jing-sai/"/>
      <url>/2020/05/31/ke-lin-ming-lun-bei-ha-er-bin-li-gong-da-xue-di-shi-jie-cheng-xu-she-ji-jing-sai/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>给定一棵树，定义点对（s, t）间距离为<strong>路径上边权和+s和t的点权和</strong><br>dp记录每个点子树中到该点的最大和次大距离即可<br>比赛的时候用树直径两次dfs的方法wa了，应该是有问题</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>给定n个数，每次可以选择一段区间，使区间-1，问最少几次操作可以使所有数变为1<br>区间操作利用差分就可以转化成两次单点操作，再贪心考虑就很简单了</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>小学数学</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>条件概率，$P(A|B) &#x3D; \frac {P(AB)} {P(B)}$<br>P(AB):至少m枚硬币是反面，且恰好k枚硬币是正面同时发生，由于正面固定，所以反面为n-k，当$n-k&lt;m$时概率为0,否则为$C(n,k)&#x2F;(2^n)$<br>P(B):从m到n枚举反面硬币个数，$\sum_{i&#x3D;m}^{n} C(n,i)&#x2F;(2^n)$<br>代入公式即可</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>简单贪心，从小到大去战胜，并且每次用刚好大于的那个</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>显然是个fibonacci，数据范围有点坑，我开了ull还是wa，改成py就过了<br>😡😤</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p>显然最大流</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>每增加一条边，最多可以与之前的所有直线都产生一个交点<br>蜜汁数据范围，又要大数，不过py不香吗</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p>给定n个数，定义n个数组，第i个数组为删去$a_i$​后形成的，问这n个数组字典序从大到小的排列顺序<br>考虑相邻两个数$a_i, a_{i+1}$</p><ul><li>$a_i &lt; a_{i+1}$​ i比后面所有的都要劣</li><li>$a_i &gt; a_{i+1}$ i比后面所有的都要优</li><li>$a_i &#x3D; a_{i+1}$​ i比i+1优<br>考虑将相同的一起考虑，然后用两个栈来模拟即可</li></ul><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><p>问一个串中最长的与前缀相同的非前缀串的长度<br>比赛的时候无脑二分+kmp<br>next[i]表示s[0:i]这个前缀与后缀相同的最长长度（前缀最长border），所以所有next取个max即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>厦门大学“网宿杯“17届程序设计竞赛决赛</title>
      <link href="/2020/05/31/sha-men-da-xue-wang-su-bei-17-jie-cheng-xu-she-ji-jing-sai-jue-sai/"/>
      <url>/2020/05/31/sha-men-da-xue-wang-su-bei-17-jie-cheng-xu-she-ji-jing-sai-jue-sai/</url>
      
        <content type="html"><![CDATA[<h2 id="ABC签到"><a href="#ABC签到" class="headerlink" title="ABC签到"></a>ABC签到</h2><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>对小数据写个爆搜后很容易发现规律</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>利用扩展欧拉定理，$n*{a^n} \equiv n % p*{a^{n % (p-1)}}$<br>令$j &#x3D; n%(p-1)$, $i &#x3D; n%p$, $j-i&#x3D;k$<br>我们枚举a的幂次j（从0到p-2），利用逆元算出i的值<br>满足条件的$n &#x3D; t(p-1)*p + kp + i，t为整数，算出[1,x]范围内符合条件的t的个数即可</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>有向图，每条边权值为kx+b,问x在[0,H]范围内最短路最长是多少，容易发现从1到n的路径合并后还是一个kx+b，对于某一天，就相当于众多直线在该天的值中取min，可以发现这是一个上凸包，求最大值三分即可</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>对一个数做gcd的下降速度是很快的，每次至少减半，所以用线段树合理剪枝就能过，复杂度不会证。<br>剪枝方法：</p><ul><li>区间最大值&#x3D;1，说明该段区间所有值都是1，直接return</li><li>区间最大值&#x3D;最小值&#x3D;x，return</li></ul><p>只做第一个剪枝，很容易被所有数相等然后每次操作也等于该数的数据卡掉，加上第二个剪枝，就过了，是否正确不知</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p>在森林中每次可以取走<strong>若干</strong>个根，初始是一棵1为根的树，不能操作者输<br>比赛的时候看错题了，我以为每次只能取一个根<br>首先叶子是必胜态，再考虑一个节点的所有儿子，如果都是必败态，那你就是必胜态。如果存在某个儿子是必胜态，你就是必败态，因为你取走该节点后，对手只要把所有是必胜态的节点的根取走，那你面对的所有节点都是必败态的了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p5903 树上k级祖先</title>
      <link href="/2020/05/30/p5903-shu-shang-k-ji-zu-xian/"/>
      <url>/2020/05/30/p5903-shu-shang-k-ji-zu-xian/</url>
      
        <content type="html"><![CDATA[<p>使用倍增每次可以在logn的时间内解决，而使用长链剖分，可以在O(nlogn)预处理后，O(1)回答询问，虽然在实践中相差无几，也不太可能要求O(1),但是长剖的这种做法以及预处理的方法还是很巧妙的</p><ul><li>预处理出倍增数组，长链的长度以及链顶节点，再预处理出每个数字的最高二级制位hb[i]，如果当前节点为链顶节点，预处理出其向上(跳fa)和向下(跳son)len[u]-1个节点</li><li>处理询问时，先利用倍增数组跳到(1&lt;&lt;hb[i])的祖先处，此时k’ &#x3D; k-(1&lt;&lt;hb[i]) &lt; (1&lt;&lt;hb[i])</li><li>当前所在的长链的长度一定是大于k’的，所以考虑跳到链顶，而后根据剩余的k选择向上还是向下跳，此时利用预处理出的up，dwn数组即可实现O(1)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define mp make_pair</span><br><span class="line">#define pb push_back</span><br><span class="line">#define sz(x) (int)x.size()</span><br><span class="line">#define all(x) begin(x), end(x)</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#x27;\n&#x27;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll = long long;</span><br><span class="line">using pii = pair&lt;int,int&gt;;</span><br><span class="line">using pli = pair&lt;ll,int&gt;;</span><br><span class="line">const int INF = 0x3f3f3f3f, N = 5e5 + 5;</span><br><span class="line">const ll LINF = 1e18 + 5;</span><br><span class="line">constexpr int mod = 1e9 + 7;</span><br><span class="line">int n, q, hb[N], fa[N][22], rt;</span><br><span class="line">int len[N], dep[N], top[N], son[N];</span><br><span class="line">unsigned int s;</span><br><span class="line">vector&lt;int&gt; G[N], up[N], dwn[N];</span><br><span class="line">inline unsigned int get(unsigned int x)</span><br><span class="line">&#123;</span><br><span class="line">  x ^= x &lt;&lt; 13;</span><br><span class="line">  x ^= x &gt;&gt; 17;</span><br><span class="line">  x ^= x &lt;&lt; 5;</span><br><span class="line">  return s = x;</span><br><span class="line">&#125;</span><br><span class="line">void dfs1(int u)</span><br><span class="line">&#123;</span><br><span class="line">  dep[u] = dep[fa[u][0]] + 1;</span><br><span class="line">  for(int v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    if(v==fa[u][0]) continue;</span><br><span class="line">    for(int i=0; fa[v][i]; i++) fa[v][i+1] = fa[fa[v][i]][i];</span><br><span class="line">    dfs1(v);</span><br><span class="line">    if(len[v]&gt;len[son[u]]) son[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  len[u] = len[son[u]] + 1;</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int u, int t)</span><br><span class="line">&#123;</span><br><span class="line">  top[u] = t;</span><br><span class="line">  if(u==t)</span><br><span class="line">  &#123;</span><br><span class="line">    for(int i=0, j=u; i&lt;len[u]; i++)</span><br><span class="line">      up[u].pb(j), j = fa[j][0];</span><br><span class="line">    for(int i=0, j=u; i&lt;len[u]; i++)</span><br><span class="line">      dwn[u].pb(j), j = son[j];</span><br><span class="line">  &#125;</span><br><span class="line">  if(son[u]) dfs2(son[u], t);</span><br><span class="line">  for(int v : G[u])</span><br><span class="line">    if(v!=son[u])</span><br><span class="line">      dfs2(v, v);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">int ask(int x, int k)</span><br><span class="line">&#123;</span><br><span class="line">  if(!k) return x;</span><br><span class="line">  x = fa[x][hb[k]], k -= (1&lt;&lt;hb[k]);</span><br><span class="line">  k -= dep[x] - dep[top[x]], x = top[x];</span><br><span class="line">  return k&gt;=0 ? up[x][k] : dwn[x][-k];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  ios::sync_with_stdio(false);</span><br><span class="line">  cin.tie(nullptr);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;</span><br><span class="line">  hb[0] = -1;</span><br><span class="line">  for(int i=1; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; fa[i][0];</span><br><span class="line">    if(!fa[i][0]) rt = i;</span><br><span class="line">    else G[fa[i][0]].pb(i);</span><br><span class="line">    hb[i] = hb[i&gt;&gt;1] + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs1(rt); dfs2(rt, rt);</span><br><span class="line">  int ans = 0;</span><br><span class="line">  ll res = 0;</span><br><span class="line">  for(int i=1; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    int x = (get(s)^ans)%n + 1;</span><br><span class="line">    int k = (get(s)^ans)%dep[x];</span><br><span class="line">    res ^= 1ll*i*(ans=ask(x, k));</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; res &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小V和gcd树 带修主席树+树剖trick</title>
      <link href="/2020/05/26/xiao-v-he-gcd-shu-dai-xiu-zhu-xi-shu-shu-pou-trick/"/>
      <url>/2020/05/26/xiao-v-he-gcd-shu-dai-xiu-zhu-xi-shu-shu-pou-trick/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一颗无根树，点有点权$a_i$​，边有边权$\gcd(a_i, a_j)$),要求支持两种操作：</p><ul><li>修改一个点的点权，相应边权也会更改</li><li>询问u-&gt;v路径上边权&lt;&#x3D;k的数量</li></ul><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>因为修改某个点的点权，同时会修改其所有出边，直观的想法是考虑bfs树，然后转化为区间修改，但是每个儿子的修改是不同的，区间每个数对x取gcd（做不了）<br>下面就需要一种树剖的trick，每次修改的时候，我们只修改父亲和重儿子的信息，而在询问的时候，对于一整条重链，可以保证信息是正确的，而每次跳到链顶，再修改一下该点（轻儿子）与父亲的信息即可，这样就转化为简单的单点修改了。<br>考虑本题，可以将边权下放到深度大的点上，套用上述做法即可，而区间询问&lt;&#x3D;k的数量就用带修主席树维护。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>modify:<br>upd: u-&gt;fa[u] son[u]-&gt;u<br>query<br>ask: u-&gt;top[u] upd: top[u]-&gt;fa[top[u]]<br>u &#x3D; fa[top[u]]<br>ask: u-&gt;v(是重链)<br>注意本题是把边权下放到了点权，所以u这个点的值应该去掉，所以询问的是dfn[u]+1-&gt;dfn[v]</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 2e4 + 5, M = 1e6 + 5, up = 1e6;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7;int n, q, a[N], b[N];vector&lt;int&gt; G[N];int sz[N], top[N], son[N], dep[N], fa[N], dfn[N], idfn[N], tot;void dfs1(int u, int f)&#123;  dep[u] = dep[f] + 1; fa[u] = f;  sz[u] = 1;  for(int v : G[u])  &#123;    if(v!=f)    &#123;      dfs1(v, u);      sz[u] += sz[v];      if(sz[v]&gt;sz[son[u]]) son[u] = v;    &#125;  &#125;&#125;void dfs2(int u, int t)&#123;  top[u] = t;  dfn[u] = ++tot;  idfn[tot] = u;  if(!son[u]) return;  dfs2(son[u], t);  for(int v : G[u])    if(v!=son[u]&amp;&amp;v!=fa[u]) dfs2(v, v);&#125;namespace PSegTree&#123;  #define ls(x) t[x].l  #define rs(x) t[x].r  int rt[N], tot;  int lrt[N], rrt[N], lc, rc;  struct node  &#123;    int l, r, cnt;  &#125;t[M*32];  void insert(int &amp;p, int l, int r, int x, int v)  &#123;    if(!p) p = ++tot;    t[p].cnt += v;    if(l==r) return;    int mid = (l+r) &gt;&gt; 1;    if(x&lt;=mid) insert(ls(p), l, mid, x, v);    else insert(rs(p), mid+1, r, x, v);  &#125;  int ask(int l, int r, int k)  &#123;    if(l==r)    &#123;      if(l&gt;k) return 0;      int cnt = 0;      for(int i=1; i&lt;=lc; i++) cnt -= t[lrt[i]].cnt;      for(int i=1; i&lt;=rc; i++) cnt += t[rrt[i]].cnt;      return cnt;    &#125;    int mid = (l+r) &gt;&gt; 1;    if(k&lt;=mid)    &#123;      for(int i=1; i&lt;=lc; i++) lrt[i] = ls(lrt[i]);      for(int i=1; i&lt;=rc; i++) rrt[i] = ls(rrt[i]);      return ask(l, mid, k);    &#125;    else    &#123;      int lcnt = 0;      for(int i=1; i&lt;=lc; i++) lcnt -= t[ls(lrt[i])].cnt;      for(int i=1; i&lt;=rc; i++) lcnt += t[ls(rrt[i])].cnt;      for(int i=1; i&lt;=lc; i++) lrt[i] = rs(lrt[i]);      for(int i=1; i&lt;=rc; i++) rrt[i] = rs(rrt[i]);      return lcnt + ask(mid+1, r, k);    &#125;  &#125;  #undef ls  #undef rs&#125;using namespace PSegTree;void upd(int x, int val, int v)&#123;  for(int i=x; i&lt;=n; i+=(i&amp;-i)) insert(rt[i], 1, up, val, v);&#125;int query(int l, int r, int k)&#123;  lc = 0, rc = 0;  for(int i=l-1; i&gt;0; i-=(i&amp;-i)) lrt[++lc] = rt[i];  for(int i=r; i&gt;0; i-=(i&amp;-i)) rrt[++rc] = rt[i];  return ask(1, up, k);&#125;int queryt(int x, int y, int k)&#123;  int ans = 0;  while(top[x]!=top[y])  &#123;    if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);    int tmp = top[x];    if(fa[tmp]&amp;&amp;b[tmp]!=__gcd(a[tmp], a[fa[tmp]]))    &#123;      upd(dfn[tmp], b[tmp], -1);      upd(dfn[tmp], b[tmp]=__gcd(a[tmp], a[fa[tmp]]), 1);    &#125;    ans += query(dfn[top[x]], dfn[x], k);    x = fa[top[x]];  &#125;  if(dep[x]&gt;dep[y]) swap(x,y);  if(x!=y) ans += query(dfn[x]+1, dfn[y], k);  return ans;&#125;int main()&#123;  scanf(&quot;%d%d&quot;, &amp;n, &amp;q);  for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, a+i);  for(int i=1; i&lt;n; i++)  &#123;    int u, v;    scanf(&quot;%d%d&quot;, &amp;u, &amp;v);    G[u].pb(v); G[v].pb(u);  &#125;  dfs1(1, 0); dfs2(1, 1);  for(int u=2; u&lt;=n; u++)    upd(dfn[u], b[u]=__gcd(a[u], a[fa[u]]), 1);  for(int i=1; i&lt;=q; i++)  &#123;    int op;    scanf(&quot;%d&quot;, &amp;op);    if(op==1)    &#123;      int u, x;      scanf(&quot;%d%d&quot;, &amp;u, &amp;x);      if(fa[u])      &#123;        upd(dfn[u], b[u], -1);        upd(dfn[u], b[u]=__gcd(x, a[fa[u]]), 1);      &#125;      if(son[u])      &#123;        upd(dfn[son[u]], b[son[u]], -1);        upd(dfn[son[u]], b[son[u]]=__gcd(x, a[son[u]]), 1);      &#125;      a[u] = x;    &#125;    else    &#123;      int u, v, k;      scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;k);      printf(&quot;%d\n&quot;, queryt(u, v, k));    &#125;  &#125;  return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小球与盒子</title>
      <link href="/2020/05/25/xiao-qiu-yu-he-zi/"/>
      <url>/2020/05/25/xiao-qiu-yu-he-zi/</url>
      
        <content type="html"><![CDATA[<p>n个球放进k个盒子，根据球是否相同、盒子是否相同、盒子是否可以为空，可以总结出8个模型。<br>前置芝士：组合数、斯特林数、快速幂、贝尔数、整数拆分等</p><h2 id="球不同，盒子相同（不同），不能空盒"><a href="#球不同，盒子相同（不同），不能空盒" class="headerlink" title="球不同，盒子相同（不同），不能空盒"></a>球不同，盒子相同（不同），不能空盒</h2><p>盒子相同时为第二类斯特林数，不同时再乘以$k!$即可<br>可以nk递推，可以容斥</p><h2 id="球不同，盒子不同，可以空盒"><a href="#球不同，盒子不同，可以空盒" class="headerlink" title="球不同，盒子不同，可以空盒"></a>球不同，盒子不同，可以空盒</h2><p>每个球有k种方法 $k^n$</p><h2 id="球不同，盒子相同，可以空盒"><a href="#球不同，盒子相同，可以空盒" class="headerlink" title="球不同，盒子相同，可以空盒"></a>球不同，盒子相同，可以空盒</h2><p>枚举空盒的数量，答案为第二类斯特林数一行求和<br>也相当与是贝尔数</p><h2 id="球相同，盒子不同，不能空盒"><a href="#球相同，盒子不同，不能空盒" class="headerlink" title="球相同，盒子不同，不能空盒"></a>球相同，盒子不同，不能空盒</h2><p>$x_1+x_2+\dots+x_n &#x3D; k$的正整数解个数<br>C(n-1, k-1)</p><h2 id="球相同，盒子不同，可以空盒"><a href="#球相同，盒子不同，可以空盒" class="headerlink" title="球相同，盒子不同，可以空盒"></a>球相同，盒子不同，可以空盒</h2><p>$x_1+x_2+\dots+x_n &#x3D; k$的非负整数解个数<br>C(n+k-1, k-1)</p><h2 id="球相同，盒子相同，不能空盒"><a href="#球相同，盒子相同，不能空盒" class="headerlink" title="球相同，盒子相同，不能空盒"></a>球相同，盒子相同，不能空盒</h2><p>整数n拆分成k份&#x3D;用最大数为k拆分n<br>D(n-k, k) 将n-k用$\le k$的数拆分</p><h2 id="球相同，盒子相同，可以空盒"><a href="#球相同，盒子相同，可以空盒" class="headerlink" title="球相同，盒子相同，可以空盒"></a>球相同，盒子相同，可以空盒</h2><p>D(n, k) &#x3D; D(n, k-1) + D(n-k, k)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树维护前缀最值问题</title>
      <link href="/2020/05/23/xian-duan-shu-wei-hu-qian-zhui-zui-zhi-wen-ti/"/>
      <url>/2020/05/23/xian-duan-shu-wei-hu-qian-zhui-zui-zhi-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="楼房重建"><a href="#楼房重建" class="headerlink" title="楼房重建"></a>楼房重建</h1><p>有n栋房屋,问从1号楼往后看,最多能看到几栋楼,要求支持单点修改<br>例:(1,3,2,5,4)(1, 3, 2, 5, 4)(1,3,2,5,4) 答案为3:(1,3,5)3:(1, 3, 5)3:(1,3,5)<br>答案就是从1开始的严格前缀最大值的长度,考虑线段树维护,但是在pushup的时候,如果简单的将左右子树的答案相加,是不对的,因为左边的楼房高度会影响到右边.<br>不妨考虑递归的进行pushup(也是某种启发,因为pushup一般都是O(1)合并的,但logn合并未尝不可?)<br>线段树每个节点维护mx,lenmx,lenmx,len分别表示区间最大值(用于剪枝), <strong>只考虑</strong> 该区间时的答案<br>添加函数merge(v, p) 表示线段树上编号p节点管辖的区间在左边最大值为v的影响下产生的答案<br>以下考虑几种情况:</p><ul><li>t[p]t[p]t[p]的最大值是小于v 此时没有贡献, return 0return ,0return0即可</li><li>p是叶子节点return t[p].mx&gt;vreturn , t[p].mx&gt;vreturnt[p].mx&gt;v返回该节点代表的值与v的大小关系即可</li><li>考虑左右儿子为ls, rs 若t[ls].mx&lt;&#x3D;vt[ls].mx&lt;&#x3D;vt[ls].mx&lt;&#x3D;v此时左区间无贡献,递归右区间即可,return merge(v,rs)return ,merge(v, rs)returnmerge(v,rs).否则递归左区间,那么右区间的贡献是t[p].len−t[ls].lent[p].len-t[ls].lent[p].len−t[ls].len(注意不是t[rs].len)<br>在pushup的时候,维护好mx,并让t[p].len &#x3D; t[ls].len + merge(t[ls].mx, rs)即可</li></ul><h1 id="最简单的一道题"><a href="#最简单的一道题" class="headerlink" title="最简单的一道题"></a>最简单的一道题</h1><p>西邮新生赛的一题,没人过<br>我看到的时候就发现是跟楼房重建一样的trick,然而 <del>调bug调了半天,wa了无数发</del><br>给定n个数,询问从第x个数往后的非严格前缀最小值的长度,要求支持区间加<br>做法跟上题类似,注意在merge里面也要加上pushdown,在每次要访问一个点的左右儿子的时候,就应该下放该点的lazytag<br>上一题的询问都是从1开始的,所以答案就是t[1].len,但本题是从x开始的,我的做法是把[x,n][x,n][x,n]在线段树上的区间提取出来,然后从左往右合并,区间数是log段,合并也是log的,复杂度是O(n(logn)2)n(logn)<br>^ 2)n(logn)2))</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 2e5 + 5;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7;int a[N];int n, m, pos[N];vector&lt;int&gt; vec;namespace SegTree&#123;    #define ls (p&lt;&lt;1)    #define rs (p&lt;&lt;1|1)    struct seg    &#123;        int l, r, len;        ll mn, tag;    &#125;t[N&lt;&lt;2];    void setval(int p, ll v)    &#123;        t[p].mn += v;        t[p].tag += v;    &#125;    void pushdown(int p)    &#123;        setval(ls, t[p].tag); setval(rs, t[p].tag);        t[p].tag = 0;    &#125;    int merge(int v, int p) //重点    &#123;        int l = t[p].l, r = t[p].r;        if(t[p].mn&gt;v) return 0;        if(l==r) return t[p].mn&lt;=v;        if(t[p].tag) pushdown(p);        if(t[ls].mn&gt;v) return merge(v, rs);        else return merge(v, ls) + t[p].len - t[ls].len;    &#125;    void pushup(int p)    &#123;        t[p].mn = min(t[ls].mn, t[rs].mn);        t[p].len = t[ls].len + merge(t[ls].mn, rs);    &#125;    void build(int p, int l, int r)    &#123;        t[p].l = l, t[p].r = r;        if(l==r)         &#123;            t[p].mn = a[l];            t[p].len = 1;            pos[l] = p;            return;        &#125;        int mid = (l+r)&gt;&gt;1;        build(ls, l, mid); build(rs, mid+1, r);        pushup(p);    &#125;    void upd(int p, int x, int y, int v)    &#123;        int l = t[p].l, r = t[p].r;        if(l&gt;=x &amp;&amp; r&lt;=y)         &#123;            setval(p, v);            return;        &#125;        if(t[p].tag) pushdown(p);        int mid = (l+r)&gt;&gt;1;        if(x&lt;=mid) upd(ls, x, y, v);        if(y&gt;mid) upd(rs, x, y, v);        pushup(p);    &#125;    void ask(int p, int x, int y)    &#123;        int l = t[p].l, r = t[p].r;        if(l&gt;=x &amp;&amp; r&lt;=y)         &#123;            vec.pb(p);            return;        &#125;        if(t[p].tag) pushdown(p);        int mid = (l+r)&gt;&gt;1;        if(x&lt;=mid) ask(ls, x, y);        if(y&gt;mid) ask(rs, x, y);    &#125;    #undef ls    #undef rs&#125;using namespace SegTree;char op[2];int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, a+i);    build(1, 1, n);    for(int i=1; i&lt;=m; i++)    &#123;        scanf(&quot;%s&quot;, op);        if(op[0]==&#39;c&#39;)        &#123;            int l, r, k;            scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);            upd(1, l, r, k);        &#125;        else        &#123;            int x;            scanf(&quot;%d&quot;, &amp;x);            vec.clear();            ask(1, x, n);            int ans = t[vec[0]].len;            ll mn = t[vec[0]].mn;            for(int i=1; i&lt;sz(vec); i++)            &#123;                ans += merge(mn, vec[i]);                mn = min(mn, t[vec[i]].mn);            &#125;            printf(&quot;%d\n&quot;, ans-1);        &#125;    &#125;    return 0;&#125;</code></pre><p>copy自小粉兔:</p><blockquote><p>但是，我们注意到一个很关键的性质：<br> 当v小于左子树的最大值时，右子树对当前节点的贡献，是通过减法计算的<br> 也就是说这个信息要满足一定程度上的可减性<br> 但是有很多信息是不满足可减性的，比如 max,min、按位与、按位或等<br> 为了能让这种线段树适应更一般的情况，我们修改维护的信息的意义：<br> 仍然维护这个区间中的最大值。  </p><p>此时并不是维护区间的答案，而是仅考虑该区间的影响后，却又只统计右子树的答案仅考虑该区间的影响后，却又只统计右子树的答案仅考虑该区间的影响后，却又只统计右子树的答案。<br> 也就是说令当前节点对应的区间为 [l,r]，区间中点为 mid，则：<br> 维护的答案是，只考虑 [l,r] 时，在区间 [mid+1,r] 中的答案。</p></blockquote><p>线段树每个节点仍然维护mx[i], len[i],但对于叶节点len[i]无意义,再考虑merge(v, p)函数</p><pre><code>void pushup(int p)&#123;  t[p].mx = max(t[ls].mx, t[rs].mx);  t[p].len = merge(t[ls].mx, rs);&#125;int merge(int v, int p) &#123;  int l = t[p].l, r = t[p].r;  if(t[p].mx&lt;=v) return 0;  if(l==r) return t[p].mn&gt;v;  if(t[ls].mx&lt;=v) return merge(v, rs);  else return merge(v, ls) + t[p].len; //避免了区间维护信息不可减的问题&#125;</code></pre><ul><li>楼房重建</li><li>最简单的一道题</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boruvka生成树算法</title>
      <link href="/2020/05/22/boruvka-sheng-cheng-shu-suan-fa/"/>
      <url>/2020/05/22/boruvka-sheng-cheng-shu-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>核心:每次从所有当前的连通块向其他连通块扩展出最小边,直至剩下一个连通块<br>每进行一次操作,连通块数量减半 $O(m\log n)$ 取决于计算最小边的代价</p><h1 id="codechef-spanning-tree"><a href="#codechef-spanning-tree" class="headerlink" title="codechef spanning tree"></a>codechef spanning tree</h1><p>交互题,每次可以给出两个点集A,B进行询问,会返回两个集合间的最小边,要求询问的$\sum |A|&lt;&#x3D;1e4, \sum |A|+|B|&lt;&#x3D;2e6,n&lt;&#x3D;1e3$,最后输出该图的最小生成树的权值和<br>按照上述算法询问即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, fa[N], idx[N], mncost;</span><br><span class="line">pii mn[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; scc[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">  <span class="keyword">if</span>(u!=v)</span><br><span class="line">  &#123;</span><br><span class="line">    fa[u] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">ask</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">sz</span>(a) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n-<span class="built_in">sz</span>(a) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> x : a)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(!vis[i]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="type">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mp</span>(v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fa[i] = i;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(fa[i]==i) idx[i] = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      scc[idx[<span class="built_in">find</span>(i)]].<span class="built_in">pb</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++) mn[i] = &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> cur = <span class="built_in">ask</span>(scc[i]);</span><br><span class="line">      <span class="keyword">if</span>(mn[i].fi==<span class="number">-1</span>) mn[i] = &#123;cur.se, cur.fi&#125;;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(cur.se&lt;mn[i].fi) mn[i] = &#123;cur.se, cur.fi&#125;;</span><br><span class="line">      scc[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(fa[i]==i &amp;&amp; <span class="built_in">merge</span>(i, mn[idx[i]].se))</span><br><span class="line">        mncost += mn[idx[i]].fi;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mncost &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="cf888G-xormst"><a href="#cf888G-xormst" class="headerlink" title="cf888G xormst"></a>cf888G xormst</h1><p>一张完全图,点数2e5,每个点有点权$a_i$​,边$(i,j)$的权值为$a_i xor a_j$​,求该图的mst<br>思考如何求出当前集合与其他集合的最小边权:<br>建出01trie,每次把该集合的点权删除,然后逐个询问与该点权xor后的最小值取小,最后再插入还原即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize (<span class="string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target(<span class="string">&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="type">int</span> fa[N], idx[N], cnt, mnto[N], mnval[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; scc[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">  <span class="keyword">if</span>(u!=v)</span><br><span class="line">  &#123;</span><br><span class="line">    fa[u] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot, nxt[N*<span class="number">29</span>][<span class="number">2</span>], sz[N*<span class="number">29</span>][<span class="number">2</span>], id[N*<span class="number">29</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v, <span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">29</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> k = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!nxt[now][k]) nxt[now][k] = ++tot;</span><br><span class="line">    sz[now][k] += v;</span><br><span class="line">    now = nxt[now][k];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(v==<span class="number">1</span>) id[now] = idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">29</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> k = (x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sz[now][k]) now = nxt[now][k];</span><br><span class="line">    <span class="keyword">else</span> now = nxt[now][k^<span class="number">1</span>], ans |= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;ans, id[now]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> startTime = (<span class="type">double</span>)<span class="built_in">clock</span>();</span><br><span class="line">  <span class="comment">//mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="comment">//n = 2e5;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    fa[i] = i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    <span class="comment">//a[i] = abs(rnd()%(1&lt;&lt;30));</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">  n = <span class="built_in">unique</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>) - a - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">upd</span>(a[i], <span class="number">1</span>, i);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(fa[i]==i)</span><br><span class="line">      &#123;</span><br><span class="line">        idx[i] = ++cnt;</span><br><span class="line">        mnto[cnt] = mnval[cnt] = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//debug(cnt);</span></span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      scc[idx[<span class="built_in">find</span>(i)]].<span class="built_in">pb</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : scc[i]) <span class="built_in">upd</span>(a[x], <span class="number">-1</span>, x);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : scc[i])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = <span class="built_in">ask</span>(a[x]);</span><br><span class="line">        <span class="keyword">if</span>(mnto[i]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          mnval[i] = cur.fi;</span><br><span class="line">          mnto[i] = cur.se;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur.fi&lt;mnval[i])</span><br><span class="line">        &#123;</span><br><span class="line">          mnval[i] = cur.fi;</span><br><span class="line">          mnto[i] = cur.se;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : scc[i]) <span class="built_in">upd</span>(a[x], <span class="number">1</span>, x);</span><br><span class="line">      scc[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">if</span>(fa[i]==i &amp;&amp; <span class="built_in">merge</span>(i, mnto[idx[i]]))</span><br><span class="line">        ans += mnval[idx[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  cerr &lt;&lt; ((<span class="type">double</span>)<span class="built_in">clock</span>() - startTime) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环鸽的数列</title>
      <link href="/2020/05/19/huan-ge-de-shu-lie/"/>
      <url>/2020/05/19/huan-ge-de-shu-lie/</url>
      
        <content type="html"><![CDATA[<p>区间加广义斐波那契数列<br>大概有三种做法<br>1.用特征方程求出通项,跑出根号的二次剩余后代入,变成区间加等比数列,线段树维护即可<br>2.矩阵<br>3.利用性质</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">9</span>, a = <span class="number">276601605</span>, b = <span class="number">691504013</span>, c = <span class="number">308495997</span>;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> n, m, x[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a = <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*a*b%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) a-=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a+=b; <span class="keyword">if</span>(a&gt;=mod) <span class="keyword">return</span> a-mod; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span> </span>&#123; a-=b; <span class="keyword">if</span>(a&lt;<span class="number">0</span>) a+=mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a-=b; <span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> a+mod; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">powmod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="built_in">Mul</span>(ans, a);</span><br><span class="line">    a = <span class="built_in">Mul</span>(a, a);</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line">  <span class="type">int</span> inv, pw[N];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, sum, tag;</span><br><span class="line">  &#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) pw[i] = <span class="built_in">Mul</span>(pw[i<span class="number">-1</span>], q)%mod;</span><br><span class="line">    inv = <span class="built_in">powmod</span>(q<span class="number">-1</span>, mod<span class="number">-2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setval</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(t[p].sum, <span class="built_in">Mul</span>(<span class="built_in">Mul</span>(v, <span class="built_in">Sub</span>(pw[t[p].r-t[p].l+<span class="number">1</span>], <span class="number">1</span>)), inv));</span><br><span class="line">    <span class="built_in">add</span>(t[p].tag, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t[p].sum = <span class="built_in">Add</span>(t[ls].sum, t[rs].sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">setval</span>(ls, t[p].tag); <span class="built_in">setval</span>(rs, <span class="built_in">Mul</span>(t[p].tag, pw[t[rs].l-t[ls].l]));</span><br><span class="line">    t[p].tag = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid); <span class="built_in">build</span>(rs, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">setval</span>(p, pw[l-x+<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(ls, x, y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">upd</span>(rs, x, y);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">    <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(ls, x, y));</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(rs, x, y));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;T1, T2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, x+i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) sum[i] = <span class="built_in">Add</span>(sum[i<span class="number">-1</span>], x[i]);</span><br><span class="line">  T1.<span class="built_in">init</span>(b); T2.<span class="built_in">init</span>(c);</span><br><span class="line">  T1.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n); T2.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      T1.<span class="built_in">upd</span>(<span class="number">1</span>, l, r);</span><br><span class="line">      T2.<span class="built_in">upd</span>(<span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> ans = <span class="built_in">Mul</span>(<span class="built_in">Sub</span>(T1.<span class="built_in">ask</span>(<span class="number">1</span>, l, r), T2.<span class="built_in">ask</span>(<span class="number">1</span>, l, r)), a);</span><br><span class="line">      <span class="built_in">add</span>(ans, <span class="built_in">Sub</span>(sum[r], sum[l<span class="number">-1</span>]));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>525 美团杯2020 平行四边形</title>
      <link href="/2020/05/18/525-mei-tuan-bei-2020-ping-xing-si-bian-xing/"/>
      <url>/2020/05/18/525-mei-tuan-bei-2020-ping-xing-si-bian-xing/</url>
      
        <content type="html"><![CDATA[<p>给定n*n的棋盘,要求放置n个棋子,满足:</p><ul><li>x和y都是一个1-n的排列</li><li>任意四个棋子不构成平行四边形<br>其中n+1是一个质数</li></ul><p>考虑n+1的原根g,则$g,g^2,g^3…g^n%(n+1)$各不相同<br>$(1,g)…(n,g^n%(n+1))$即为答案<br>无证明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">powmod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = <span class="number">1ll</span>*ans*a%m;</span><br><span class="line">    a = <span class="number">1ll</span>*a*a%m;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;=x; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ans -= ans / i;</span><br><span class="line">      <span class="keyword">while</span>(x%i==<span class="number">0</span>) x /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;<span class="number">1</span>) ans -= ans / x;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="type">int</span> c = <span class="built_in">phi</span>(n+<span class="number">1</span>), g = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(++g)</span><br><span class="line">  &#123;</span><br><span class="line">    ok = (<span class="built_in">powmod</span>(g, c, n+<span class="number">1</span>)==<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> tmpc = c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;=tmpc&amp;&amp;ok; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(tmpc%i==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span>(tmpc%i==<span class="number">0</span>) tmpc /= i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">powmod</span>(g, c/i, n+<span class="number">1</span>)==<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmpc&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">powmod</span>(g, c/tmpc, n+<span class="number">1</span>)==<span class="number">1</span>) ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ok) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = g;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, ans);</span><br><span class="line">    ans = ans*g%(n+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客挑战赛40</title>
      <link href="/2020/05/16/niu-ke-tiao-zhan-sai-40/"/>
      <url>/2020/05/16/niu-ke-tiao-zhan-sai-40/</url>
      
        <content type="html"><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>给定1e6个随机生成的数,多次询问,给定y,问是否存在一个数x满足x^y在二进制下1的个数&lt;&#x3D;3</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>因为最多只有3个二进制位不同,考虑将二进制每16位分成4组,满足条件的x与y一定在某一组中的16位完全相同,所以查找该组中的数,又由于数字随机,每次查找的次数期望为$4*(2^{20} &#x2F; 2^{16})$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5236 【模板】静态仙人掌</title>
      <link href="/2020/05/15/p5236-mo-ban-jing-tai-xian-ren-zhang/"/>
      <url>/2020/05/15/p5236-mo-ban-jing-tai-xian-ren-zhang/</url>
      
        <content type="html"><![CDATA[<p>每条边最多在一个简单环上的图<br>每个环都是一个点双(方点),可以很方便的用圆方树来维护</p><p>求仙人掌图上两点间的最短路<br>注意仙人掌上的圆方树的建法:<br>每个简单环新建一个方点,环上每个点与方点连边,权值为到起点的最短距离,如果u是割点,向v连边权值为原图的边权(两个圆点连边)</p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>先建出圆方树<br>考虑u和v在树上的LCA:p</p><ul><li>p为圆点,则答案就是树上两点的距离</li><li>p为方点,找出p的两个儿子a(u的祖先),b(v的祖先),a和b处在一个环上,答案是dis(a,b)+dis(a,u)+dis(b,v),注意dis(a,b)要取min</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], clk, cnt, s[N], sum[N];</span><br><span class="line">vector&lt;pii&gt; G[N], T[N];</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> LOG = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">20</span>], dep[N], dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=LOG; i++)</span><br><span class="line">    fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : T[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    dis[v] = dis[u] + w;</span><br><span class="line">    dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">    fa[v][<span class="number">0</span>] = u;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(dep[fa[y][i]]&gt;=dep[x]) y = fa[y][i];</span><br><span class="line">  <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">  <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findcir</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ++cnt;</span><br><span class="line">  <span class="type">int</span> x = v, pre = w, pw = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x!=fa[u][<span class="number">0</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    sum[x] = pre;</span><br><span class="line">    pre += s[x];</span><br><span class="line">    x = fa[x][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  sum[cnt] = sum[u];</span><br><span class="line">  sum[u] = <span class="number">0</span>;</span><br><span class="line">  x = v;</span><br><span class="line">  <span class="keyword">while</span>(x!=fa[u][<span class="number">0</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    pw = <span class="built_in">min</span>(sum[x], sum[cnt]-sum[x]);</span><br><span class="line">    T[cnt].<span class="built_in">pb</span>(&#123;x, pw&#125;);</span><br><span class="line">    T[x].<span class="built_in">pb</span>(&#123;cnt, pw&#125;);</span><br><span class="line">    x = fa[x][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dfn[u] = low[u] = ++clk;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">    &#123;</span><br><span class="line">      fa[v][<span class="number">0</span>] = u;</span><br><span class="line">      s[v] = w;</span><br><span class="line">      <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    <span class="keyword">if</span>(low[v]&gt;dfn[u])</span><br><span class="line">    &#123;</span><br><span class="line">      T[u].<span class="built_in">pb</span>(&#123;v, w&#125;);</span><br><span class="line">      T[v].<span class="built_in">pb</span>(&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = it.fi, w = it.se;</span><br><span class="line">    <span class="keyword">if</span>(fa[v][<span class="number">0</span>]==u||dfn[v]&lt;=dfn[u]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">findcir</span>(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> t = x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(dep[fa[fa[t][i]][<span class="number">0</span>]]&gt;=dep[y]) t = fa[t][i];</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">  cnt = n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    G[u].<span class="built_in">pb</span>(&#123;v, w&#125;); G[v].<span class="built_in">pb</span>(&#123;u, w&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="type">int</span> z = <span class="built_in">LCA</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span>(z&lt;=n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[u]+dis[v]<span class="number">-2</span>*dis[z]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x = <span class="built_in">find</span>(u, z), y = <span class="built_in">find</span>(v, z);</span><br><span class="line">      <span class="keyword">if</span>(sum[x]&gt;sum[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">      <span class="type">int</span> ans = dis[u]-dis[x]+dis[v]-dis[y]+<span class="built_in">min</span>(sum[y]-sum[x], sum[x]+sum[z]-sum[y]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5495 Dirichlet 前缀和</title>
      <link href="/2020/05/15/p5495-dirichlet-qian-zhui-he/"/>
      <url>/2020/05/15/p5495-dirichlet-qian-zhui-he/</url>
      
        <content type="html"><![CDATA[<p>$b_k &#x3D; \sum_{i \mid k} a_i$<br>求数组b<br>考虑下标i和j,对其质因数分解,当且仅当i的所有质因数的幂次&lt;&#x3D;j的,i才是j的因数,可以有贡献<br>发现这个实际上就是一个关于质因子分解后的指数的高维前缀和，使用类似FMT的方法就可以了<br>复杂度$O(n\log \log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=prime[<span class="number">0</span>]; i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; <span class="number">1ll</span>*j*prime[i]&lt;=n; j++)</span><br><span class="line">    b[j*prime[i]] += b[j];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圆方树</title>
      <link href="/2020/05/15/yuan-fang-shu/"/>
      <url>/2020/05/15/yuan-fang-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>点双联通分量:不存在割点&#x2F;任意两点间有至少两条点不重复路径<br>特殊:两个点一条边<br>每条边属于一个点双,每个割点可以属于多个点双<br>圆方树中原图的每个点对应一个圆点,一个点双对应一个方点<br>对于每一个点双连通分量，它对应的方点向这个点双连通分量中的每个圆点连边<br>每个点双形成一个“菊花图”，多个“菊花图”通过原图中的割点连接在一起(因为点双的分隔点是割点)</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>圆点只和方点相连,方点只和圆点相连<br>度数大于1的圆点是原图的割点<br>圆方树是无根树,无论取哪个点为根开始dfs见树,形态都一样</p><h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>注意两倍空间<br>建完树栈中可能还有点,注意多组数据清空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[N], T[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  low[u] = dfn[u] = ++clk;</span><br><span class="line">  stk[++top] = u;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">      <span class="keyword">if</span>(low[v]&gt;=dfn[u])</span><br><span class="line">      &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x!=v; top--)</span><br><span class="line">        &#123;</span><br><span class="line">          x = stk[top];</span><br><span class="line">          T[cnt].<span class="built_in">pb</span>(x);</span><br><span class="line">          T[x].<span class="built_in">pb</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        T[cnt].<span class="built_in">pb</span>(u);</span><br><span class="line">        T[u].<span class="built_in">pb</span>(cnt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4169 [Violet]天使玩偶/SJY摆棋子 kdtree</title>
      <link href="/2020/05/14/p4169-violettian-shi-wan-ou-sjy-bai-qi-zi-kdtree/"/>
      <url>/2020/05/14/p4169-violettian-shi-wan-ou-sjy-bai-qi-zi-kdtree/</url>
      
        <content type="html"><![CDATA[<p>要求维护二维平面,支持插点,询问点集中两点的最小曼哈顿距离</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>kdtree维护<br>不断循环按照其中一维构建二叉树<br>每个点维护子树中的最大最小坐标(最大矩形),然后大力剪枝<br>本题有插入操作,所以可能会退化为链,需要定期重构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,MAXSIZE,stdin),p1==p2) ? EOF : *p1++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">gc</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) t = t*<span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">  t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m, rt, ans;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> alpha = <span class="number">0.75</span>;</span><br><span class="line"><span class="type">int</span> D, pool[N], top, tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x[k];</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> point &amp;oth) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x[D] &lt; oth.x[D];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;a[N], cur;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mx[k], mn[k];</span><br><span class="line">  <span class="type">int</span> l, r, sz;</span><br><span class="line">  point tp;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(top) <span class="keyword">return</span> pool[top--];</span><br><span class="line">  <span class="keyword">return</span> ++tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mn[i] = t[p].mx[i] = t[p].tp.x[i];</span><br><span class="line">    <span class="keyword">if</span>(l) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[l].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[l].mx[i]);</span><br><span class="line">    <span class="keyword">if</span>(r) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[r].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[r].mx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  t[p].sz = t[l].sz + t[r].sz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">newnode</span>(), mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  D = d;</span><br><span class="line">  <span class="built_in">nth_element</span>(a+l, a+mid, a+r+<span class="number">1</span>);</span><br><span class="line">  t[p].tp = a[mid];</span><br><span class="line">  t[p].l = <span class="built_in">build</span>(l, mid<span class="number">-1</span>, (d+<span class="number">1</span>)%k);</span><br><span class="line">  t[p].r = <span class="built_in">build</span>(mid+<span class="number">1</span>, r, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t[p].l) <span class="built_in">rebuild</span>(t[p].l, num);</span><br><span class="line">  a[num+t[t[p].l].sz+<span class="number">1</span>] = t[p].tp, pool[++top] = p;</span><br><span class="line">  <span class="keyword">if</span>(t[p].r) <span class="built_in">rebuild</span>(t[p].r, num+t[t[p].l].sz+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(alpha*t[p].sz&lt;t[t[p].l].sz||alpha*t[p].sz&lt;t[t[p].r].sz)</span><br><span class="line">    <span class="built_in">rebuild</span>(p, <span class="number">0</span>), p = <span class="built_in">build</span>(<span class="number">1</span>, t[p].sz, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p)</span><br><span class="line">  &#123;</span><br><span class="line">    p = <span class="built_in">newnode</span>();</span><br><span class="line">    t[p].tp = cur;</span><br><span class="line">    t[p].l = t[p].r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cur.x[d]&gt;t[p].tp.x[d]) <span class="built_in">insert</span>(t[p].r, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">insert</span>(t[p].l, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="built_in">pushup</span>(p); <span class="built_in">test</span>(p, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.x[i]&lt;t[p].mn[i]) ans += (t[p].mn[i]-cur.x[i]);</span><br><span class="line">    <span class="keyword">if</span>(cur.x[i]&gt;t[p].mx[i]) ans += (cur.x[i]-t[p].mx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(point a, point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    ans += <span class="built_in">abs</span>(a.x[i]-b.x[i]);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ans = <span class="built_in">min</span>(ans, <span class="built_in">dis</span>(t[p].tp, cur));</span><br><span class="line">  <span class="type">int</span> dl = INF, dr = INF;</span><br><span class="line">  <span class="keyword">if</span>(t[p].l) dl = <span class="built_in">getdis</span>(t[p].l);</span><br><span class="line">  <span class="keyword">if</span>(t[p].r) dr = <span class="built_in">getdis</span>(t[p].r);</span><br><span class="line">  <span class="keyword">if</span>(dl&lt;dr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dl&lt;ans) <span class="built_in">ask</span>(t[p].l);</span><br><span class="line">    <span class="keyword">if</span>(dr&lt;ans) <span class="built_in">ask</span>(t[p].r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dr&lt;ans) <span class="built_in">ask</span>(t[p].r);</span><br><span class="line">    <span class="keyword">if</span>(dl&lt;ans) <span class="built_in">ask</span>(t[p].l);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n); <span class="built_in">read</span>(m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">read</span>(a[i].x[<span class="number">0</span>]), <span class="built_in">read</span>(a[i].x[<span class="number">1</span>]);</span><br><span class="line">  rt = <span class="built_in">build</span>(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="built_in">read</span>(op); <span class="built_in">read</span>(cur.x[<span class="number">0</span>]); <span class="built_in">read</span>(cur.x[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">insert</span>(rt, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ans = INF;</span><br><span class="line">      <span class="built_in">ask</span>(rt);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4211 LCA 离线+树剖</title>
      <link href="/2020/05/14/p4211-lca-chi-xian-shu-pou/"/>
      <url>/2020/05/14/p4211-lca-chi-xian-shu-pou/</url>
      
        <content type="html"><![CDATA[<p>给定一棵1为根的树, 多次查询$\sum_{i&#x3D;l}^{r} dep[LCA(i,z)]$</p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>只需把l-r的每个点到根的路径+1,然后查询z到根的路径的和即可<br>考虑离线差分询问并按右端点排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">201314</span>;</span><br><span class="line"><span class="type">int</span> n, m, ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qry</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r, coef, z, id;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> qry &amp;oth) &#123;</span><br><span class="line">    <span class="keyword">return</span> r &lt; oth.r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u += v;</span><br><span class="line">  <span class="keyword">if</span>(u&gt;=mod) u -= mod;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> sz[N], top[N], son[N], dep[N], fa[N], dfn[N], idfn[N], tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, sum, tag;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setval</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">add</span>(t[p].sum, v*(t[p].r-t[p].l+<span class="number">1</span>));</span><br><span class="line">  <span class="built_in">add</span>(t[p].tag, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].sum = t[p&lt;&lt;<span class="number">1</span>].sum;</span><br><span class="line">  <span class="built_in">add</span>(t[p].sum, t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setval</span>(p&lt;&lt;<span class="number">1</span>, t[p].tag); <span class="built_in">setval</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, t[p].tag);</span><br><span class="line">  t[p].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t[p].l = l, t[p].r = r;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>, l, mid); <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setval</span>(p, v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>, x, y, v);</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">upd</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y, v);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=x &amp;&amp; r&lt;=y) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">if</span>(y&gt;mid) <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, x, y));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dep[u] = dep[f] + <span class="number">1</span>; fa[u] = f;</span><br><span class="line">  sz[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">    sz[u] += sz[v];</span><br><span class="line">    <span class="keyword">if</span>(sz[v]&gt;sz[son[u]]) son[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  top[u] = t;</span><br><span class="line">  dfn[u] = ++tot;</span><br><span class="line">  idfn[tot] = u;</span><br><span class="line">  <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[u], t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">    <span class="keyword">if</span>(v!=son[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>, dfn[top[x]], dfn[x], v);</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="built_in">upd</span>(<span class="number">1</span>, dfn[x], dfn[y], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">askt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]));</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="built_in">add</span>(ans, <span class="built_in">ask</span>(<span class="number">1</span>, dfn[x], dfn[y]));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">    G[u+<span class="number">1</span>].<span class="built_in">pb</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> l, r, z; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;z);</span><br><span class="line">    q[++tot] = &#123;l, <span class="number">-1</span>, z+<span class="number">1</span>, i&#125;;</span><br><span class="line">    q[++tot] = &#123;r+<span class="number">1</span>, <span class="number">1</span>, z+<span class="number">1</span>, i&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(q+<span class="number">1</span>, q+tot+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">upd</span>(<span class="number">1</span>, dfn[<span class="number">1</span>], dfn[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> pre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=tot; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(pre&lt;=q[i].r)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">updt</span>(<span class="number">1</span>, pre, <span class="number">1</span>);</span><br><span class="line">      ++pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(ans[q[i].id], q[i].coef*<span class="built_in">askt</span>(<span class="number">1</span>, q[i].z));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (ans[i]+mod)%mod);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6514 [QkOI#R1] Quark and Strings</title>
      <link href="/2020/05/14/p6514-qkoir1-quark-and-strings/"/>
      <url>/2020/05/14/p6514-qkoir1-quark-and-strings/</url>
      
        <content type="html"><![CDATA[<p>要求维护n个字符串,每次在区间[l,r]加一个字符,或询问区间[l,r]的字符串的最长公共子序列的长度</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>本质就是每次插入一条[l,r]的线段,或询问左端点&lt;&#x3D;l&amp;&amp;右端点&gt;&#x3D;r的线段的个数,转化后就是一个二维数点的模型,cdq分治,树套树,kdt都可以解决</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> alpha = <span class="number">0.75</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,MAXSIZE,stdin),p1==p2) ? EOF : *p1++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">gc</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) t = t*<span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">  t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> D, pool[N], top, tot, rt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x[k];</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> point &amp;oth) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x[D] &lt; oth.x[D];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;a[N], cur;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mx[k], mn[k];</span><br><span class="line">  <span class="type">int</span> l, r, sz;</span><br><span class="line">  point tp;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(top) <span class="keyword">return</span> pool[top--];</span><br><span class="line">  <span class="keyword">return</span> ++tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mn[i] = t[p].mx[i] = t[p].tp.x[i];</span><br><span class="line">    <span class="keyword">if</span>(l) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[l].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[l].mx[i]);</span><br><span class="line">    <span class="keyword">if</span>(r) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[r].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[r].mx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  t[p].sz = t[l].sz + t[r].sz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">newnode</span>(), mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  D = d;</span><br><span class="line">  <span class="built_in">nth_element</span>(a+l, a+mid, a+r+<span class="number">1</span>);</span><br><span class="line">  t[p].tp = a[mid];</span><br><span class="line">  t[p].l = <span class="built_in">build</span>(l, mid<span class="number">-1</span>, d^<span class="number">1</span>);</span><br><span class="line">  t[p].r = <span class="built_in">build</span>(mid+<span class="number">1</span>, r, d^<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t[p].l) <span class="built_in">rebuild</span>(t[p].l, num);</span><br><span class="line">  a[num+t[t[p].l].sz+<span class="number">1</span>] = t[p].tp, pool[++top] = p;</span><br><span class="line">  <span class="keyword">if</span>(t[p].r) <span class="built_in">rebuild</span>(t[p].r, num+t[t[p].l].sz+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(alpha*t[p].sz&lt;t[t[p].l].sz||alpha*t[p].sz&lt;t[t[p].r].sz)</span><br><span class="line">  <span class="built_in">rebuild</span>(p, <span class="number">0</span>), p = <span class="built_in">build</span>(<span class="number">1</span>, t[p].sz, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p)</span><br><span class="line">  &#123;</span><br><span class="line">    p = <span class="built_in">newnode</span>();</span><br><span class="line">    t[p].tp = cur;</span><br><span class="line">    t[p].l = t[p].r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cur.x[d]&gt;t[p].tp.x[d]) <span class="built_in">insert</span>(t[p].r, d^<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">insert</span>(t[p].l, d^<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">pushup</span>(p); <span class="built_in">test</span>(p, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].mx[<span class="number">0</span>]&lt;=cur.x[<span class="number">0</span>]&amp;&amp;t[p].mn[<span class="number">1</span>]&gt;=cur.x[<span class="number">1</span>]) <span class="keyword">return</span> t[p].sz;</span><br><span class="line">  <span class="keyword">if</span>(t[p].mn[<span class="number">0</span>]&gt;cur.x[<span class="number">0</span>]||t[p].mx[<span class="number">1</span>]&lt;cur.x[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(t[p].tp.x[<span class="number">0</span>]&lt;=cur.x[<span class="number">0</span>]&amp;&amp;t[p].tp.x[<span class="number">1</span>]&gt;=cur.x[<span class="number">1</span>]) ++ans;</span><br><span class="line">  ans += <span class="built_in">ask</span>(t[p].l) + <span class="built_in">ask</span>(t[p].r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n, q;</span><br><span class="line">  <span class="built_in">read</span>(n); <span class="built_in">read</span>(q);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="built_in">read</span>(op); <span class="built_in">read</span>(cur.x[<span class="number">0</span>]); <span class="built_in">read</span>(cur.x[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">insert</span>(rt, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(rt));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4148 简单题 kdtree</title>
      <link href="/2020/05/14/p4148-jian-dan-ti-kdtree/"/>
      <url>/2020/05/14/p4148-jian-dan-ti-kdtree/</url>
      
        <content type="html"><![CDATA[<p>维护矩形,支持加点,询问矩形和,强制在线</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>不强制在线可以cdq,强制在线就只能kdtree了<br>每个节点维护最大矩形,以及子树内所有点权值的和<br>对于询问,如果当前节点的最大矩形在询问矩形内部,直接返回sum,如果不相交,返回0,否则继续递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXSIZE = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,MAXSIZE,stdin),p1==p2) ? EOF : *p1++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  t = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>||c&lt;<span class="string">&#x27;0&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">gc</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) t = t*<span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">gc</span>();</span><br><span class="line">  t *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> alph = <span class="number">0.75</span>;</span><br><span class="line"><span class="type">int</span> rt, pool[N], top, tot, D;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x[k], w;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (point &amp;oth) &#123;</span><br><span class="line">    <span class="keyword">return</span> x[D] &lt; oth.x[D];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;a[N], cur;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> l, r, mx[k], mn[k], sum, sz;</span><br><span class="line">  point tp;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(top) <span class="keyword">return</span> pool[top--];</span><br><span class="line">  <span class="keyword">return</span> ++tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = t[p].l, r = t[p].r;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    t[p].mn[i] = t[p].mx[i] = t[p].tp.x[i];</span><br><span class="line">    <span class="keyword">if</span>(l) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[l].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[l].mx[i]);</span><br><span class="line">    <span class="keyword">if</span>(r) t[p].mn[i] = <span class="built_in">min</span>(t[p].mn[i], t[r].mn[i]), t[p].mx[i] = <span class="built_in">max</span>(t[p].mx[i], t[r].mx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  t[p].sz = t[l].sz + t[r].sz + <span class="number">1</span>;</span><br><span class="line">  t[p].sum = t[l].sum + t[r].sum + t[p].tp.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">newnode</span>(), mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  D = d;</span><br><span class="line">  <span class="built_in">nth_element</span>(a+l, a+mid, a+r+<span class="number">1</span>);</span><br><span class="line">  t[p].tp = a[mid];</span><br><span class="line">  t[p].l = <span class="built_in">build</span>(l, mid<span class="number">-1</span>, (d+<span class="number">1</span>)%k);</span><br><span class="line">  t[p].r = <span class="built_in">build</span>(mid+<span class="number">1</span>, r, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="built_in">pushup</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t[p].l) <span class="built_in">rebuild</span>(t[p].l, num);</span><br><span class="line">  a[num+t[t[p].l].sz+<span class="number">1</span>] = t[p].tp, pool[++top] = p;</span><br><span class="line">  <span class="keyword">if</span>(t[p].r) <span class="built_in">rebuild</span>(t[p].r, num+t[t[p].l].sz+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(alph*t[p].sz&lt;t[t[p].l].sz||alph*t[p].sz&lt;t[t[p].r].sz)</span><br><span class="line">    <span class="built_in">rebuild</span>(p, <span class="number">0</span>), p = <span class="built_in">build</span>(<span class="number">1</span>, t[p].sz, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> X1, <span class="type">int</span> Y1, <span class="type">int</span> X2, <span class="type">int</span> Y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> X1&gt;=x1&amp;&amp;Y1&gt;=y1&amp;&amp;X2&lt;=x2&amp;&amp;Y2&lt;=y2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">out</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> X1, <span class="type">int</span> Y1, <span class="type">int</span> X2, <span class="type">int</span> Y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> X2&lt;x1||X1&gt;x2||Y1&gt;y2||Y2&lt;y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">in</span>(x1, y1, x2, y2, t[p].mn[<span class="number">0</span>], t[p].mn[<span class="number">1</span>], t[p].mx[<span class="number">0</span>], t[p].mx[<span class="number">1</span>])) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">out</span>(x1, y1, x2, y2, t[p].mn[<span class="number">0</span>], t[p].mn[<span class="number">1</span>], t[p].mx[<span class="number">0</span>], t[p].mx[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">in</span>(x1, y1, x2, y2, t[p].tp.x[<span class="number">0</span>], t[p].tp.x[<span class="number">1</span>], t[p].tp.x[<span class="number">0</span>], t[p].tp.x[<span class="number">1</span>])) ans += t[p].tp.w;</span><br><span class="line">  ans += <span class="built_in">ask</span>(t[p].l, x1, y1, x2, y2) + <span class="built_in">ask</span>(t[p].r, x1, y1, x2, y2);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p)</span><br><span class="line">  &#123;</span><br><span class="line">    p = <span class="built_in">newnode</span>();</span><br><span class="line">    t[p].tp = cur;</span><br><span class="line">    t[p].l = t[p].r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(cur.x[d]&gt;t[p].tp.x[d]) <span class="built_in">insert</span>(t[p].r, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">insert</span>(t[p].l, (d+<span class="number">1</span>)%k);</span><br><span class="line">  <span class="built_in">pushup</span>(p); <span class="built_in">test</span>(p, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="type">int</span> lstans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="built_in">read</span>(op);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">read</span>(cur.x[<span class="number">0</span>]), <span class="built_in">read</span>(cur.x[<span class="number">1</span>]), <span class="built_in">read</span>(cur.w);</span><br><span class="line">      cur.x[<span class="number">0</span>] ^= lstans, cur.x[<span class="number">1</span>] ^= lstans, cur.w ^= lstans;</span><br><span class="line">      <span class="built_in">insert</span>(rt, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> a, b, c, d;</span><br><span class="line">      <span class="built_in">read</span>(a), <span class="built_in">read</span>(b), <span class="built_in">read</span>(c), <span class="built_in">read</span>(d);</span><br><span class="line">      a ^= lstans, b ^= lstans, c ^= lstans, d ^= lstans;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lstans=<span class="built_in">ask</span>(rt, a, b, c, d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces1349</title>
      <link href="/2020/05/13/codeforces1349/"/>
      <url>/2020/05/13/codeforces1349/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定n个数$a_i$​,求$gcd{(lcm(a_i,a_j))}$</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>考虑gcd和lcm的本质,gcd就是所有数个质因子幂次取min,而lcm是取max<br>所以答案就是各质因子幂次的次大值( <del>不会维护</del> )<br>考虑a[i]对答案的贡献,就是$lcm(a_i, sufgcd_{i+1})$<br>sufgcd为后缀gcd<br>最后各个数贡献取gcd即可</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定n个数$a_i$​,每次操作可以选定一个连续子段,并把所有数变为中位数(第$\lfloor \frac{n+1}{2}\rfloor$大的数),问能否通过若干次操作使整个数列所有数都是k</p><h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><p>1.如果没有k,无解<br>2.n&#x3D;1,看是不是k<br>3.如果有一段连续的k(&gt;&#x3D;2),则一定有解,因为每次都可以至少向左右延拓一步.<br>考虑到两个&gt;&#x3D;k的数可以把一个&lt;k的数变成&gt;&#x3D;k.而一个&#x3D;k数可以把一个&gt;k的数变成k<br>只要**存在两个&gt;&#x3D;k的数的位置差&lt;2**则一定有解(首先变成3个&gt;&#x3D;k的数,然后不断延拓即可)</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>一个黑白格,在每一秒,若一个格子与上下左右的格子颜色不同,它的颜色不改变,否则改变.问某个格子t秒后的颜色</p><h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><p>如果该格子与四周某格子颜色相同,那么它就一直会改变,否则它会保持不变x秒后,再一直改变,x为距离该格子最近的一直改变的格子的曼哈顿距离,多源bfs预处理即可.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p5107 矩阵快速幂+倍增+卡常</title>
      <link href="/2020/05/13/p5107-ju-zhen-kuai-su-mi-bei-zeng-qia-chang/"/>
      <url>/2020/05/13/p5107-ju-zhen-kuai-su-mi-bei-zeng-qia-chang/</url>
      
        <content type="html"><![CDATA[<p>带行和列的矩阵模板<br>记得初始化行列,注意左乘还是右乘<br>注意到询问很多,所以先预处理好倍增矩阵,(倍数不一定要是2,如果预处理复杂度比较低,可以增大倍数b)<br>增大倍数,预处理复杂度提升,但询问复杂度降低,可以考虑制衡两者<br>询问可以按从小到大的顺序排序,可以减少一些运算<br>可以把矩阵乘法的for进行循环展开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">55</span>, M = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, m, q, qry[M], idx[M], res[M];</span><br><span class="line">ll inv[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  ll mat[N][N];</span><br><span class="line">  <span class="built_in">matrix</span>() &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="built_in">matrix</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">n</span>(a), <span class="built_in">m</span>(b) &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">one</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">        mat[i][j] = (i==j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;b[<span class="number">32</span>];</span><br><span class="line">matrix <span class="keyword">operator</span> * (matrix a, matrix b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">matrix <span class="title">res</span><span class="params">(a.n, b.m)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=a.n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=b.m; j++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=a.m; k++)</span><br><span class="line">        res.mat[i][j] = (res.mat[i][j]+a.mat[i][k]*b.mat[k][j]%mod)%mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">matrix <span class="keyword">operator</span> ^ (matrix a, ll x)</span><br><span class="line">&#123;</span><br><span class="line">  matrix res; res.<span class="built_in">one</span>();</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;<span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">  <span class="function">matrix <span class="title">a</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a.mat[i][<span class="number">1</span>]);</span><br><span class="line">  b[<span class="number">0</span>].n = b[<span class="number">0</span>].m = n;</span><br><span class="line">  b[<span class="number">0</span>].<span class="built_in">one</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    b[<span class="number">0</span>].mat[v][u]++;</span><br><span class="line">  &#125;</span><br><span class="line">  inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) inv[i] = (mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) d += b[<span class="number">0</span>].mat[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) b[<span class="number">0</span>].mat[i][j] = b[<span class="number">0</span>].mat[i][j]*inv[d]%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">31</span>; i++) b[i] = b[i<span class="number">-1</span>]*b[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, qry+i);</span><br><span class="line">  <span class="built_in">iota</span>(idx+<span class="number">1</span>, idx+q+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">sort</span>(idx+<span class="number">1</span>, idx+q+<span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> qry[x] &lt; qry[y];</span><br><span class="line">  &#125;);</span><br><span class="line">  matrix ans = a;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> tmp = qry[idx[i]] - qry[idx[i<span class="number">-1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">31</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">      <span class="keyword">if</span>((tmp&gt;&gt;j)&amp;<span class="number">1</span>) ans = b[j]*ans;</span><br><span class="line">    ll Res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) Res ^= ans.mat[i][<span class="number">1</span>];</span><br><span class="line">    res[idx[i]] = Res%mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四维偏序 cdq套cdq</title>
      <link href="/2020/05/13/si-wei-pian-xu-cdq-tao-cdq/"/>
      <url>/2020/05/13/si-wei-pian-xu-cdq-tao-cdq/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>求解&lt;&#x3D;a&amp;&amp;&lt;&#x3D;b&amp;&amp;&lt;&#x3D;c&amp;&amp;&lt;&#x3D;d的四元组数量</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>1.有四元组相同需要先合并(unique)<br>2.对第一维排序<br>3.cdq1,<strong>先把左半部分标记为LEFT,右半部分标记为RIGHT</strong>,然后对第二维按序归并<br>4.cdq2,对第三维按序归并,第四维用数据结构(如bit)维护,<strong>只对左边标记为LEFT的进行修改,对右边标记为RIGHT的进行查询</strong><br>注:有时也可以直接sort,多一个log<br>cdq1中的归并数组最好和cdq2不同,否则在cdq2结束后记得还原为cdq1中的顺序<br>排序一定要彻底,否则会wa</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>hdu5126<br>立方体加点,立方体数点<br>把加点看作修改操作,数点利用容斥拆成8个询问.<br>修改和查询按照时间有序,是一个四维偏序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> q, c[N], tot, ans[N], id[N];</span><br><span class="line"><span class="type">bool</span> isq[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=tot; i+=(i&amp;-i)) c[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) ans += c[i];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">item</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x, y, z, t, coef;</span><br><span class="line">  <span class="type">bool</span> tag;</span><br><span class="line">&#125;p[N], tmp[N], tmp2[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(item a, item b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.x==b.x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y==b.y) <span class="keyword">return</span> a.z==b.z ? a.t &lt; b.t : a.z &lt; b.z;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">CDQ2</span>(l, mid); <span class="built_in">CDQ2</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="type">int</span> i = l, j = mid+<span class="number">1</span>, k = l;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp[i].z&lt;=tmp[j].z)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!tmp[i].tag&amp;&amp;!tmp[i].coef) <span class="built_in">upd</span>(tmp[i].t, <span class="number">1</span>);</span><br><span class="line">      tmp2[k++] = tmp[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(tmp[j].tag&amp;&amp;tmp[j].coef) ans[tmp[j].t] += <span class="built_in">ask</span>(tmp[j].t<span class="number">-1</span>)*tmp[j].coef;</span><br><span class="line">      tmp2[k++] = tmp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!tmp[i].tag&amp;&amp;!tmp[i].coef) <span class="built_in">upd</span>(tmp[i].t, <span class="number">1</span>);</span><br><span class="line">    tmp2[k++] = tmp[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp[j].tag&amp;&amp;tmp[j].coef) ans[tmp[j].t] += <span class="built_in">ask</span>(tmp[j].t<span class="number">-1</span>)*tmp[j].coef;</span><br><span class="line">    tmp2[k++] = tmp[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=mid; i++) <span class="keyword">if</span>(!tmp[i].tag&amp;&amp;!tmp[i].coef) <span class="built_in">upd</span>(tmp[i].t, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) tmp[i] = tmp2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">CDQ1</span>(l, mid); <span class="built_in">CDQ1</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=mid; i++) p[i].tag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>; i&lt;=r; i++) p[i].tag = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> i = l, j = mid+<span class="number">1</span>, k = l;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i].y&lt;=p[j].y) tmp[k++] = p[i++];</span><br><span class="line">    <span class="keyword">else</span> tmp[k++] = p[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=mid) tmp[k++] = p[i++];</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=r) tmp[k++] = p[j++];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) p[i] = tmp[i];</span><br><span class="line">  <span class="built_in">CDQ2</span>(l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">  tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">    ans[i] = isq[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">      p[++tot] = &#123;x, y, z, i, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> x1, y1, z1, x2, y2, z2;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;z1, &amp;x2, &amp;y2, &amp;z2);</span><br><span class="line">      isq[i] = <span class="number">1</span>;</span><br><span class="line">      p[++tot] = &#123;x2, y2, z2, i, <span class="number">1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x1<span class="number">-1</span>, y2, z2, i, <span class="number">-1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x2, y1<span class="number">-1</span>, z2, i, <span class="number">-1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x2, y2, z1<span class="number">-1</span>, i, <span class="number">-1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x1<span class="number">-1</span>, y1<span class="number">-1</span>, z2, i, <span class="number">1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x2, y1<span class="number">-1</span>, z1<span class="number">-1</span>, i, <span class="number">1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x1<span class="number">-1</span>, y2, z1<span class="number">-1</span>, i, <span class="number">1</span>&#125;;</span><br><span class="line">      p[++tot] = &#123;x1<span class="number">-1</span>, y1<span class="number">-1</span>, z1<span class="number">-1</span>, i, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(p+<span class="number">1</span>, p+tot+<span class="number">1</span>, cmp);</span><br><span class="line">  <span class="built_in">CDQ1</span>(<span class="number">1</span>, tot);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">    <span class="keyword">if</span>(isq[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p5621<br>四维LIS<br>树状数组维护第四维的dp前缀max,第四维要离散化,同时相同的四元组要合并<br><strong>注意</strong><br>此题要先cdq左半部分,然后统计左对右的答案,再cdq右半部分.<br>而上一题是先cdq左右,最后再统计答案(其实也可以按本题的流程,但本题不可以这样,因为本质是一个dp,必须从左到右,而统计没这个要求).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> id[N], lsh[N];</span><br><span class="line">ll c[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=m; i+=(i&amp;-i)) c[i] = <span class="built_in">max</span>(c[i], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=m; i+=(i&amp;-i)) c[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=(i&amp;-i)) ans = <span class="built_in">max</span>(ans, c[i]);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">item</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a, b, c, d, id;</span><br><span class="line">  <span class="type">bool</span> t;</span><br><span class="line">  ll mx, val;</span><br><span class="line">&#125;p[N], tmp[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(item x, item y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x.a==y.a)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x.b==y.b) <span class="keyword">return</span> x.c==y.c ? x.d &lt; y.d : x.c &lt; y.c;</span><br><span class="line">    <span class="keyword">return</span> x.b &lt; y.b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(item x, item y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.b==y.b&amp;&amp;x.c==y.c&amp;&amp;x.d==y.d) <span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">  <span class="keyword">if</span>(x.b==y.b) <span class="keyword">return</span> x.c==y.c ? x.d &lt; y.d : x.c &lt; y.c;</span><br><span class="line">  <span class="keyword">return</span> x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp3</span><span class="params">(item x, item y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.c==y.c&amp;&amp;x.d==y.d) <span class="keyword">return</span> x.a==y.a ? x.b &lt; y.b : x.a &lt; y.a;</span><br><span class="line">  <span class="keyword">return</span> x.c==y.c ? x.d &lt; y.d : x.c &lt; y.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">CDQ2</span>(l, mid);</span><br><span class="line">  <span class="built_in">sort</span>(p+l, p+mid+<span class="number">1</span>, cmp3);</span><br><span class="line">  <span class="built_in">sort</span>(p+mid+<span class="number">1</span>, p+r+<span class="number">1</span>, cmp3);</span><br><span class="line">  <span class="type">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; p[i].c&lt;=p[j].c)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!p[i].t) <span class="built_in">upd</span>(p[i].d, p[i].mx);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p[j].t) p[j].mx = <span class="built_in">max</span>(p[j].mx, <span class="built_in">ask</span>(p[j].d)+p[j].val);</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=mid; i++) <span class="keyword">if</span>(!p[i].t) <span class="built_in">clear</span>(p[i].d);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) tmp[id[p[i].id]] = p[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) p[i] = tmp[i];</span><br><span class="line">  <span class="built_in">CDQ2</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">CDQ1</span>(l, mid);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=mid; i++) p[i].t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>; i&lt;=r; i++) p[i].t = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">sort</span>(p+l, p+r+<span class="number">1</span>, cmp2);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) id[p[i].id] = i;</span><br><span class="line">  <span class="built_in">CDQ2</span>(l, r);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) tmp[p[i].id] = p[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) p[i] = tmp[i];</span><br><span class="line">  <span class="built_in">CDQ1</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;p[i].a, &amp;p[i].b, &amp;p[i].c, &amp;p[i].d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;p[i].val);</span><br><span class="line">    lsh[i] = p[i].d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(lsh+<span class="number">1</span>, lsh+n+<span class="number">1</span>);</span><br><span class="line">  m = <span class="built_in">unique</span>(lsh+<span class="number">1</span>, lsh+n+<span class="number">1</span>) - lsh - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    p[i].d = <span class="built_in">lower_bound</span>(lsh+<span class="number">1</span>, lsh+m+<span class="number">1</span>, p[i].d) - lsh;</span><br><span class="line">  <span class="type">int</span> tot = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">sort</span>(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmp1);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i].a!=p[i<span class="number">-1</span>].a||p[i].b!=p[i<span class="number">-1</span>].b||p[i].c!=p[i<span class="number">-1</span>].c||p[i].d!=p[i<span class="number">-1</span>].d) p[++tot] = p[i];</span><br><span class="line">    <span class="keyword">else</span> p[tot].val += <span class="built_in">max</span>(p[i].val, <span class="number">0ll</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  n = tot;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p[i].id = i;</span><br><span class="line">    p[i].mx = p[i].val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CDQ1</span>(<span class="number">1</span>, n);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) ans = <span class="built_in">max</span>(ans, p[i].mx);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chef and Bitwise Product 贪心+位运算</title>
      <link href="/2020/05/11/chef-and-bitwise-product-tan-xin-wei-yun-suan/"/>
      <url>/2020/05/11/chef-and-bitwise-product-tan-xin-wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<p>给两个数x,y($x, y &lt;&#x3D; 10^{12}$),要求找到一个数z,最大化(x&amp;z)*(y&amp;z)同时最小化z,且$L\leq z\leq R$,L和R由题目给出($L, R \leq 10^{12}$)</p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>先不考虑上下界限制,那么z全取1肯定最优,再加入上界限制,然而并不是取R最优,比如<br>x &#x3D; 7, y &#x3D; 12, l &#x3D; 0, r &#x3D; 8, 此时z&#x3D;7<br>可以想到一种贪心的做法,让R的某一位1变成0,然后让R的低位全变1,然后交一发会发现0分<br>其实这个时候已经可以最大化(x&amp;z)*(y&amp;z),下面要最小化z,可以发现如果x和y的某一位同时为0,此时z的该位为1也没用.所以只要在保证&gt;&#x3D;下界的情况下通过该条件最小化z即可.另外好像要特判一下下界为最优解的情况.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">15</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll x, y, l, r;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;l, &amp;r);</span><br><span class="line">  ll ans = (x&amp;r)*(y&amp;r), z = r;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">40</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> b = (r&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">      ll c = (r&gt;&gt;(i+<span class="number">1</span>)&lt;&lt;(i+<span class="number">1</span>)) + (<span class="number">1ll</span>&lt;&lt;i) - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">40</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> aa = (x&gt;&gt;i)&amp;<span class="number">1</span>, bb = (y&gt;&gt;i)&amp;<span class="number">1</span>, cc = (c&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!aa &amp;&amp; !bb &amp;&amp; cc)</span><br><span class="line">          <span class="keyword">if</span>((c^(<span class="number">1ll</span>&lt;&lt;i))&gt;=l) c ^= (<span class="number">1ll</span>&lt;&lt;i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(c&lt;l) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>((x&amp;c)*(y&amp;c)&gt;ans || (((x&amp;c)*(y&amp;c))==ans&amp;&amp;c&lt;z)) ans = (x&amp;c)*(y&amp;c), z = c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!ans) z = l;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Land 双栈trick</title>
      <link href="/2020/05/11/binary-land-shuang-zhan-trick/"/>
      <url>/2020/05/11/binary-land-shuang-zhan-trick/</url>
      
        <content type="html"><![CDATA[<p>要求动态维护一个01矩阵,支持:<br>1.从顶部删除一行<br>2.从尾部添加一行<br>3.询问当前顶部某列到尾部某列的合法路径数<br>其中合法路径数定义为,每次只能从[i,j]−&gt;[i,j−1]or[i,j]or[i,j+1],且要求两点同为0或1<br>矩阵列数&#x3D;20,操作数&#x3D;3e5</p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>显然路径数可以通过简单dp求得,从尾部添加一行也很简单,可以O(col)求得,但是删除操作很麻烦,必须全部重算.<br>此时就有一个trick了,当要求的是双端队列操作,但是只有添加可以快速做,那就可以用两个对顶栈来操作.开口向上的为s1,开口向下的为s2<br>尾部添加就让s2的栈指针++,并且O(col)更新<br>顶部删除就让s1的栈指针–,注意如果s1的栈指针为0,就把s2的所有值搬到s1,此时就相当于给s1添加,s2删除.<br>列数很少,我们直接保存所有可能的$n^2$个答案,然后每次修改也都是$n^2$的.<br>询问的话, $n^2$处理下对顶处部分答案的合并即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">3e5</span> + <span class="number">5</span>, M = <span class="number">25</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, q, sta[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2</span>][N][M][M];</span><br><span class="line">string p[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = sta[idx];</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        dp[idx][x][i][j] = (i==j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        dp[idx][x][i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">-1</span>; k&lt;=j+<span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(k&lt;<span class="number">1</span>||k&gt;n||p[idx][x<span class="number">-1</span>][k<span class="number">-1</span>]!=p[idx][x][j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">          dp[idx][x][i][j] += dp[idx][x<span class="number">-1</span>][i][k];</span><br><span class="line">          <span class="keyword">if</span>(dp[idx][x][i][j]&gt;=mod) dp[idx][x][i][j] -= mod;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    string op;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; p[<span class="number">1</span>][++sta[<span class="number">1</span>]];</span><br><span class="line">      <span class="built_in">upd</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(sta[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span>(sta[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">          p[<span class="number">0</span>][++sta[<span class="number">0</span>]] = p[<span class="number">1</span>][sta[<span class="number">1</span>]--];</span><br><span class="line">          <span class="built_in">upd</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sta[<span class="number">0</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> a, b;</span><br><span class="line">      cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">      <span class="keyword">if</span>(sta[<span class="number">0</span>]==<span class="number">0</span>) cout &lt;&lt; dp[<span class="number">1</span>][sta[<span class="number">1</span>]][a][b] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(sta[<span class="number">1</span>]==<span class="number">0</span>) cout &lt;&lt; dp[<span class="number">0</span>][sta[<span class="number">0</span>]][b][a] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>; j&lt;=i+<span class="number">1</span>; j++)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">1</span>||j&gt;n||p[<span class="number">0</span>][<span class="number">1</span>][i<span class="number">-1</span>]!=p[<span class="number">1</span>][<span class="number">1</span>][j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            ans += <span class="number">1ll</span>*dp[<span class="number">0</span>][sta[<span class="number">0</span>]][i][a]*dp[<span class="number">1</span>][sta[<span class="number">1</span>]][j][b]%mod;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;=mod) ans -= mod;</span><br><span class="line">          &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buying a New String AC自动机</title>
      <link href="/2020/05/11/buying-a-new-string-ac-zi-dong-ji/"/>
      <url>/2020/05/11/buying-a-new-string-ac-zi-dong-ji/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串A,B,<br>再给出n个字符串sis_isi​,每个sis_isi​有价值bib_ibi​,让你从A中取一个子串(可空),再从B中取一个子串(可空),拼接成串C,定义C的价值为∑cnti(C)⋅bi\sum<br>cnt_i(C)⋅b_i∑cnti​(C)⋅bi​ .cnticnt_icnti​表示sis_isi​在C中作为子串出现的次数.要求输出最大的价值.<br><strong>Constraints</strong><br>1≤T≤101≤T≤101≤T≤10<br>1≤∣A∣,∣B∣≤1031≤|A|,|B|≤10^31≤∣A∣,∣B∣≤103<br>1≤N≤1041≤N≤10^41≤N≤104<br>1≤∣Si∣≤261≤|S_i|≤261≤∣Si​∣≤26 for each valid i<br>1≤bi≤1051≤b_i≤10^51≤bi​≤105 for each valid i<br>A,B,S1,S2,…,SNA,B,S_1,S_2,…,S_NA,B,S1​,S2​,…,SN​ contain only lowercase<br>English letters<br>S1,S2,…,SNS_1,S_2,…,S_NS1​,S2​,…,SN​ are pairwise distinct<br>the sum of |A| over all test cases does not exceed 2⋅1032⋅10^32⋅103<br>the sum of |B| over all test cases does not exceed 2⋅1032⋅10^32⋅103<br>the sum of N over all test cases does not exceed 2⋅1042⋅10^42⋅104</p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>简单的贪心可以发现,肯定是取A的某个前缀和B的某个后缀拼接.此题的关键是∣Si∣|S_i|∣Si​∣很小,如果大了我不知道还能不能做了.利用这点我们可以先预处理出A的每个前缀的价值和B的每个后缀的价值,这个用ac自动机处理,然后枚举前缀i和后缀j拼接,此时C中没有算的影响就是拼接处前后26个字母的价值,可以从后缀的起点开始在ac自动机上走25步,每次暴力跳fail统计下答案,最后取个max.<br>这样还是会t,复杂度是O(∣A∣2∗262)O(|A|^2 * 26^2 )O(∣A∣2∗262)<br>大概6e9,每次跳fail是O(26)的,那就再建个fail树,预处理下把这个O(26)去掉就过了.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 3e5 + 5;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7;char a[N], b[N], rb[N];char s[N][30], rs[N][30];int n, val[N];ll pre[N], suf[N];struct ACA&#123;    int nxt[N][26], fail[N], len[N], cnt, end[N];    ll tmp[N][30];    vector &lt;int&gt; to[N];    void clear()    &#123;        for(int i=0; i&lt;=cnt; i++)        &#123;            fail[i] = end[i] = len[i] = 0;            to[i].clear();            for(int j=0; j&lt;26; j++)                nxt[i][j] = tmp[i][j+1] = 0;        &#125;         cnt = 0;    &#125;    void insert(char *s, int v, int n)    &#123;        int p = 0;        for(int i=0; i&lt;n; i++)        &#123;            int k = s[i] - &#39;a&#39;;            if(!nxt[p][k]) nxt[p][k] = ++cnt;            p = nxt[p][k];        &#125;        end[p] = v; len[p] = n;    &#125;    void build()     &#123;        queue &lt;int&gt; q;        for(int i=0;i&lt;26;i++) if(nxt[0][i]) q.push(nxt[0][i]);        while(!q.empty())        &#123;            int k = q.front(); q.pop();            for(int i=0;i&lt;26;i++)            &#123;                if(nxt[k][i])                &#123;                    fail[nxt[k][i]] = nxt[fail[k]][i];                     q.push(nxt[k][i]);                &#125;                else nxt[k][i] = nxt[fail[k]][i];            &#125;        &#125;    &#125;    void go(char *s, ll *v, int n)    &#123;        int p = 0;        for(int i=0; i&lt;n; i++)        &#123;            p = nxt[p][s[i]-&#39;a&#39;];            for(int j=p; j; j=fail[j])                v[i] += end[j];        &#125;    &#125;    void dfs(int u)    &#123;        for(int i=len[u]; i&gt;0; i--) tmp[u][i] += end[u];        for(int v : to[u])         &#123;            for(int i=26; i&gt;0; i--) tmp[v][i] += tmp[u][i];            dfs(v);        &#125;    &#125;&#125;ac, ac2;void solve()&#123;    scanf(&quot;%s%s&quot;, a, b);    scanf(&quot;%d&quot;, &amp;n);    int x = strlen(a), y = strlen(b);    for(int i=0; i&lt;y; i++) rb[i] = b[y-i-1];    ac.clear(); ac2.clear();    for(int i=1; i&lt;=n; i++)    &#123;        scanf(&quot;%s%d&quot;, s[i], val+i);        int t = strlen(s[i]);        ac.insert(s[i], val[i], t);        for(int j=0; j&lt;t; j++) rs[i][j] = s[i][t-j-1];        ac2.insert(rs[i], val[i], t);    &#125;    ac.build(); ac2.build();    for(int i=0; i&lt;x; i++) pre[i] = 0;    for(int i=0; i&lt;y; i++) suf[i] = 0;    ac.go(a, pre, x); ac2.go(rb, suf, y);    ll ans = 0;    int p = 0;    for(int i=1; i&lt;x; i++) pre[i] += pre[i-1];     for(int i=1; i&lt;y; i++) suf[i] += suf[i-1];    for(int i=1; i&lt;=ac.cnt; i++) ac.to[ac.fail[i]].pb(i);    ac.dfs(0);    for(int i=0; i&lt;x; i++)    &#123;        p = ac.nxt[p][a[i]-&#39;a&#39;];        for(int j=0; j&lt;y; j++)        &#123;            ll cur = pre[i] + suf[y-j-1];            int pp = p;            for(int k=0; k&lt;25&amp;&amp;j+k&lt;y; k++)            &#123;                pp = ac.nxt[pp][b[j+k]-&#39;a&#39;];                cur += ac.tmp[pp][k+2];            &#125;            if(cur&gt;ans) ans = cur;        &#125;    &#125;    printf(&quot;%lld\n&quot;, ans);&#125;int main()&#123;    int T; scanf(&quot;%d&quot;, &amp;T);    while(T--) solve();    return 0;&#125;</code></pre><ul><li>做法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Not a real world problem 最小割+方案</title>
      <link href="/2020/05/11/not-a-real-problem-zui-xiao-ge-fang-an/"/>
      <url>/2020/05/11/not-a-real-problem-zui-xiao-ge-fang-an/</url>
      
        <content type="html"><![CDATA[<p>有h*w的网格,每个点有权值h[i][j], 有n个粒子,告诉你每个点的坐标(x,y),权值的绝对值<br>∣p[i]∣\left| p[i]<br>\right|∣p[i]∣,定义价值为∑p[i]∗h[x[i]][y[i]]+∑p[i]∗p<a href="%E5%A6%82%E6%9E%9Ci%E7%82%B9%E5%92%8Cj%E7%82%B9%E7%9B%B8%E9%82%BB">j</a>\sum{p[i]*h[x[i]][y[i]]}</p><ul><li>\sum{p[i]*p[j]}(如果i点和j点相邻)∑p[i]∗h[x[i]][y[i]]+∑p[i]∗p<a href="%E5%A6%82%E6%9E%9Ci%E7%82%B9%E5%92%8Cj%E7%82%B9%E7%9B%B8%E9%82%BB">j</a><br>问如何分配p的正负号可以最大化价值,并输出方案</li></ul><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>这种分配到两个集合,然后定义一下价值并最大化的可以考虑转化为最小割,s代表+号,t代表-号,那么对于每个粒子i:s-&gt;i,权值为p[i]∗h[x[i]][y[i]]p[i]*h[x[i]][y[i]]p[i]∗h[x[i]][y[i]](表示如果割掉,则p为负号,会<br><strong>损失</strong><br>这么多),同理i-&gt;t,权值为−p[i]∗h[x[i]][y[i]]-p[i]*h[x[i]][y[i]]−p[i]∗h[x[i]][y[i]],注意不能有负权,所以全加一个偏移量offset.<br>再考虑相邻点,如果符号相同有一种收获x,符号不同有一种收获y.其实只要从i向j连边x-y,从j向i也连边x-y.可以默认两者符号相同收获x,那么如果割掉i与j间的边,说明两者分别属于s和t,损失x-y.<br>建完图最大流,输出方案只要从源点走权值&gt;0的边,所有经过的点就是属于s的(即符号为正)</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, maxn = 1e3 + 5;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7;int h, w, n, p[maxn], a[maxn][maxn], x[maxn], y[maxn], state[maxn];const int N = 1e4 + 5, M = 2e5 + 5; int cnt, head[N];bool vis[N];struct node&#123;    int next, to, w;&#125;e[M&lt;&lt;1];inline void add(int u,int v,int w)&#123;    e[++cnt].next = head[u];    e[cnt].to = v;    e[cnt].w = w;    head[u] = cnt;&#125;struct Dinic&#123;    int n, m, s, t;     int dep[N], cur[N];    void init(int n,int s,int t)    &#123;        this-&gt;s = s, this-&gt;t = t, this-&gt;n = n;        cnt = 1, m = 0;        memset(head,0,(n+1)*sizeof(int));        memset(vis,0,(n+1)*sizeof(bool));    &#125;    void addedge(int u,int v,int cap)     &#123;        add(u,v,cap);         add(v,u,0);        m += 2;    &#125;    bool bfs()    &#123;        memset(dep,0,(n+1)*sizeof(int));        memcpy(cur,head,(n+1)*sizeof(int));        queue &lt;int&gt; q;        q.push(s); dep[s] = 1;        while(!q.empty())        &#123;            int u = q.front(); q.pop();            for(int i=head[u];i;i=e[i].next)            &#123;                int v = e[i].to;                if(!dep[v]&amp;&amp;e[i].w&gt;0)                &#123;                    dep[v] = dep[u] + 1;                    q.push(v);                &#125;            &#125;        &#125;        return dep[t];    &#125;    int dfs(int u,int flow)    &#123;        if(u==t||!flow) return flow;        int used = flow;        for(int i=cur[u];i;i=e[i].next)        &#123;            cur[u] = i;            int v = e[i].to;            if(dep[v]==dep[u]+1)            &#123;                int low = dfs(v,min(flow,e[i].w));                e[i].w -= low; e[i^1].w += low;                flow -= low;                if(!flow) break;            &#125;        &#125;        return used - flow;    &#125;    int go()    &#123;        int maxflow = 0;        while(bfs()) maxflow += dfs(s,INF);        return maxflow;    &#125;    void dfs(int u)     &#123;        vis[u] = 1;        for (int i = head[u]; i; i = e[i].next)         &#123;            if (e[i].w&gt;0)             &#123;                if (vis[e[i].to]) continue;                state[e[i].to] = 1;                dfs(e[i].to);            &#125;        &#125;    &#125;&#125;MF;void solve()&#123;    scanf(&quot;%d%d%d&quot;, &amp;h, &amp;w, &amp;n);    for(int i=1; i&lt;=h; i++)        for(int j=1; j&lt;=w; j++)            scanf(&quot;%d&quot;, &amp;a[i][j]);    for(int i=1; i&lt;=n; i++)        scanf(&quot;%d%d%d&quot;, x+i, y+i, p+i);    MF.init(n+2, 0, n+1);    int ans = n*100000;    for(int i=1; i&lt;=n; i++)    &#123;        state[i] = 0;        MF.addedge(MF.s, i, p[i]*a[x[i]][y[i]]+100000);        MF.addedge(i, MF.t, -p[i]*a[x[i]][y[i]]+100000);        for(int j=i+1; j&lt;=n; j++)            if(abs(x[i]-x[j])+abs(y[i]-y[j])&lt;=1)                MF.addedge(i, j, 2*p[i]*p[j]), MF.addedge(j, i, 2*p[i]*p[j]), ans += p[i]*p[j];    &#125;    ans -= MF.go();    printf(&quot;%d\n&quot;, ans);    MF.dfs(MF.s);    for(int i=1; i&lt;=n; i++)         if(state[i]) printf(&quot;1%c&quot;, &quot; \n&quot;[i==n]);        else printf(&quot;-1%c&quot;, &quot; \n&quot;[i==n]);&#125;int main()&#123;    int T; scanf(&quot;%d&quot;, &amp;T);    while(T--) solve();    return 0;&#125;</code></pre><ul><li>做法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting Vases 思维</title>
      <link href="/2020/05/11/sorting-vases-si-wei/"/>
      <url>/2020/05/11/sorting-vases-si-wei/</url>
      
        <content type="html"><![CDATA[<p>给定一个n的排列p,每次可以任意交换两个位置,花费为1,然后又给定m组交换,花费为0(可以任意次使用),问使该排列p有序的最小花费.(n&lt;&#x3D;18, m&lt;&#x3D;18)</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>先考虑m&#x3D;0,此时只要让每个数直接向目标位置交换即可,答案为n-环的个数<br>再考虑m,既然可以任意交换,那就相当于这些位置是等价的,可以维护出每个等价的集合,然后直接全排列枚举每个集合,让p通过m&#x3D;0的方式转换成该排列,最后取最小值.这样交的话其实只会tle一个点.<br>如果某个集合的大小&gt;10,全排列枚举显然t.但是我们并不需要枚举每个集合的排列,因为前几个数归位后,最后一个集合的数自然就归位了.所以我们不枚举最大的集合就可以了,这样我们枚举的集合的大小最多只有9,9!(362880)完全可以接受.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, p[N], pos[N], x[N], y[N];</span><br><span class="line"><span class="type">int</span> tmpp[N];</span><br><span class="line"><span class="type">int</span> f[N], ans;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==f[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">  <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">  f[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    tmpp[i] = p[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span>(pos[tmpp[j]]&amp;&amp;pos[tmpp[j]]!=j)</span><br><span class="line">    &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="built_in">swap</span>(tmpp[j], tmpp[pos[tmpp[j]]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="built_in">sz</span>(vec))</span><br><span class="line">  &#123;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">cal</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">idx</span><span class="params">(sz(vec[x]))</span></span>;</span><br><span class="line">  <span class="built_in">iota</span>(<span class="built_in">all</span>(idx), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">sz</span>(vec[x]); i++)</span><br><span class="line">      pos[vec[x][i]] = vec[x][idx[i]];</span><br><span class="line">    <span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">  &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(<span class="built_in">all</span>(idx)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  ans = n - <span class="number">1</span>;</span><br><span class="line">  vec.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p+i);</span><br><span class="line">    f[i] = i;</span><br><span class="line">    pos[i] = <span class="number">0</span>;</span><br><span class="line">    rt[i].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, x+i, y+i);</span><br><span class="line">    <span class="built_in">merge</span>(x[i], y[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">find</span>(i);</span><br><span class="line">    rt[r].<span class="built_in">pb</span>(i);</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, <span class="built_in">sz</span>(rt[r]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> tag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(f[i]==i &amp;&amp; <span class="built_in">sz</span>(rt[i])&lt;mx) vec.<span class="built_in">pb</span>(rt[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[i]==i &amp;&amp; <span class="built_in">sz</span>(rt[i])==mx)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!tag) tag = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> vec.<span class="built_in">pb</span>(rt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Triple Sort 思维+构造</title>
      <link href="/2020/05/11/triple-sort-si-wei-gou-zao/"/>
      <url>/2020/05/11/triple-sort-si-wei-gou-zao/</url>
      
        <content type="html"><![CDATA[<p>给定一个排列p,定义一种操作方式是,选择三个下标a,b,c,然后让p[c]&#x3D;p[b],p[b]&#x3D;p[a],p[a]&#x3D;p[c]p[c]&#x3D;p[b],p[b]&#x3D;p[a],p[a]&#x3D;p[c]p[c]&#x3D;p[b],p[b]&#x3D;p[a],p[a]&#x3D;p<a href="%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E4%B8%80%E4%BD%8D">c</a>,下标a,b,c的大小关系任意,但必须两两不同.要求用k次操作让p有序,输出一种合法解(不要求最小化),无解输出-1<br>n&lt;&#x3D;2e5,k&lt;&#x3D;⌊n2⌋n&lt;&#x3D;2e5, k&lt;&#x3D;\lfloor \frac{n}{2} \rfloorn&lt;&#x3D;2e5,k&lt;&#x3D;⌊2n​⌋</p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>先考虑一下n&#x3D;3的时候,可以发现该操作会形成两个等价类,{(1, 2, 3), (3, 1, 2), (2, 3, 1)}、 {(3, 2, 1), (1,<br>3, 2), (2, 1, 3)},因此第二个集合中的排列就不可能排成有序. <del>然而这好像没什么用</del>.<br>从k的大小入手,k&lt;&#x3D;n&#x2F;2,说明每次操作至少要让两个元素归位,每次只要操作(i,p[i],p[p[i]])(i, p[i],<br>p[p[i]])(i,p[i],p[p[i]])即可,但是有可能i&#x3D;&#x3D;p[p[i]]i&#x3D;&#x3D;p[p[i]]i&#x3D;&#x3D;p[p[i]],即为一个二元环.<br>下面考虑2,1,4,3{2, 1, 4, 3}2,1,4,3这个排列,它由两个二元环组成,可以发现只要操作(2,3,4),(1,2,3)(2, 3,<br>4),(1, 2, 3)(2,3,4),(1,2,3)即可,就是说两个二元环可以通过两次操作排成有序.<br>所以我们只要先对长度大于2的环进行操作,然后把二元环存起来.最后如果二元环有偶数个,两两解决,否则无解.如果二元环有奇数个,则逆序对数有奇数个,而可以发现该操作每次只能变化偶数个逆序对,其实就对应了上面的两个等价类.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 2e5 + 5;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7;int n, k, a[N], p[N], b[N];bool vis[N];void upd(int x, int y, int z)&#123;    assert(x!=y); assert(y!=z); assert(x!=z);    int tmp = a[z];    a[z] = a[y];    p[a[y]] = z;     a[y] = a[x];     p[a[x]] = y;    a[x] = tmp;    p[tmp] = x;&#125;void solve()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for(int i=1; i&lt;=n; i++)     &#123;        scanf(&quot;%d&quot;, a+i);        p[a[i]] = i;    &#125;    vector &lt;array&lt;int,3&gt;&gt; op;    for(int i=1; i&lt;=n; i++)    &#123;        vis[i] = 0;        if(i!=p[i])        &#123;            int x = p[i], y = i, z = a[i];            if(z==x) continue;            op.pb(&#123;y, z, x&#125;);            upd(y, z, x);        &#125;    &#125;    vector &lt;pii&gt; loop;    for(int i=1; i&lt;=n; i++)    &#123;        if(i!=p[i] &amp;&amp; p[i]==a[i] &amp;&amp; !vis[p[i]])        &#123;            loop.pb(&#123;i, p[i]&#125;);            vis[i] = vis[p[i]] = 1;        &#125;    &#125;    if(sz(loop)&amp;1)     &#123;        puts(&quot;-1&quot;);        return;    &#125;    for(int i=0; i&lt;sz(loop); i+=2)    &#123;        int a = loop[i].fi, b = loop[i].se, c = loop[i+1].fi, d = loop[i+1].se;        op.pb(&#123;b, c, d&#125;);        upd(b, c, d);        op.pb(&#123;a, b, c&#125;);        upd(a, b, c);    &#125;    if(sz(op)&gt;k || !is_sorted(a+1, a+n+1)) puts(&quot;-1&quot;);    else    &#123;        cout &lt;&lt; sz(op) &lt;&lt; &#39;\n&#39;;        for(auto it : op) printf(&quot;%d %d %d\n&quot;, it[0], it[1], it[2]);    &#125;&#125;int main()&#123;    int T; scanf(&quot;%d&quot;, &amp;T);    while(T--) solve();    return 0;&#125;</code></pre><ul><li>做法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客算法周周练5</title>
      <link href="/2020/05/06/niu-ke-suan-fa-zhou-zhou-lian-5/"/>
      <url>/2020/05/06/niu-ke-suan-fa-zhou-zhou-lian-5/</url>
      
        <content type="html"><![CDATA[<p>题不错,所以做了下.</p><h1 id="A-多彩的树"><a href="#A-多彩的树" class="headerlink" title="A 多彩的树"></a>A 多彩的树</h1><p>给定一棵树,每个点有一种颜色,问恰好包含i种颜色的路径的数量(i从1-k) k&lt;&#x3D;10k&lt;&#x3D;10k&lt;&#x3D;10<br>看见路径信息统计,想到点分治,k很小,状压即可.<br>我们用num[1&lt;&lt;10]的桶记录这种状态的路径的数量<br>然后考虑怎么合并两条路径:num[i|j] &#x3D; cnt[i] _cnt[j]<br>朴素暴力是O(n_4^k)的,5秒应该过不了<br>很容易发现这是个或运算卷积,FWT优化一下即可.但是要注意当i&#x3D;&#x3D;j的时候num[i∣j]&#x3D;cnt[i]∗(cnt[i]−1)&#x2F;2+cnt[i]num[i|j]&#x3D;cnt[i]*(cnt[i]-1)&#x2F;2+cnt[i]num[i∣j]&#x3D;cnt[i]∗(cnt[i]−1)&#x2F;2+cnt<a href="%E9%80%89%E4%B8%A4%E4%B8%AA%E5%90%88%E5%B9%B6,,%E4%BB%A5%E5%8F%8A%E5%92%8C%E7%A9%BA%E8%B7%AF%E5%BE%84%E5%90%88%E5%B9%B6(%E5%87%8F%E4%B8%8D%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84%E6%97%B6%E4%B8%8D%E5%8C%85%E5%90%AB)">i</a>,然后注意到FWT中算的是cnt[i]∗cnt[i]+2∗cnt[i]cnt[i]<em>cnt[i]+2</em>cnt[i]cnt[i]∗cnt[i]+2∗cnt[i],所以还要减掉一个cnt[i].<br>由于是点权所以要注意些细节问题,特别是减掉不合法路径的时候,然后这题就做完了<br>其实可以直接状压包含的颜色数,然后找到只包含这样颜色的连通块</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 5e4 + 5;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7, two = (mod+1)/2;int n, k, a[N];vector&lt;int&gt; G[N];ll pw[15];int rt, sz[N], dp[N], mxsz;ll mask[1&lt;&lt;10], num[1&lt;&lt;10], tmp[1&lt;&lt;10];bool vis[N];void FWT(ll *a, int n)&#123;    for(int d=1;d&lt;n;d&lt;&lt;=1)         for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m)            for(int j=0;j&lt;d;j++)                &#123;                    ll x = a[i+j], y = a[i+j+d];                    a[i+j+d] = (x+y)%mod;                 &#125;&#125;void IFWT(ll *a, int n)&#123;    for(int d=1;d&lt;n;d&lt;&lt;=1)        for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m)            for(int j=0;j&lt;d;j++)                &#123;                    ll x = a[i+j], y = a[i+j+d];                    a[i+j+d] = (y-x+mod)%mod;                &#125;&#125;void findroot(int u, int fa) &#123;    dp[u] = 0, sz[u] = 1;    for(auto v : G[u])    &#123;        if(vis[v]||v==fa) continue;        findroot(v, u);        dp[u] = max(dp[u],sz[v]);        sz[u] += sz[v];    &#125;    dp[u] = max(dp[u],mxsz-sz[u]);    if(dp[u]&lt;dp[rt]) rt = u;&#125;void getdis(int u, int fa, int d)&#123;    d |= (1&lt;&lt;a[u]);    mask[d]++;    for(auto v : G[u])    &#123;        if(vis[v]||v==fa) continue;        getdis(v, u, d);    &#125;&#125;void calcu(int u, int d)&#123;    memset(mask, 0, sizeof(mask));     if(!d) mask[0] = 1;    getdis(u, 0, d);     // for(int i=0; i&lt;(1&lt;&lt;k); i++)    // for(int j=0; j&lt;(1&lt;&lt;k); j++)    // if(!d) (num[i|j] += mask[i]*mask[j]%mod)%=mod;    // else (num[i|j] -= mask[i]*mask[j]%mod)%=mod;    // for(int i=0; i&lt;(1&lt;&lt;k); i++)     // num[i] -= mask[i]%=mod;    memcpy(tmp, mask, sizeof(mask));    FWT(tmp, 1&lt;&lt;k);    for(int i=0; i&lt;(1&lt;&lt;k); i++) tmp[i] = tmp[i]*tmp[i]%mod;    IFWT(tmp, 1&lt;&lt;k);    for(int i=0; i&lt;(1&lt;&lt;k); i++)    &#123;        if(!d) (num[i] += tmp[i] - mask[i]) %= mod;        else (num[i] -= tmp[i] + mask[i]) %= mod;    &#125;&#125;void solve(int u) &#123;    vis[u] = 1;    calcu(u, 0);     for(auto v : G[u])    &#123;        if(vis[v]) continue;        calcu(v, 1&lt;&lt;a[u]);         mxsz = sz[v], rt = 0;        findroot(v, u);        solve(rt);    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    pw[0] = 1;    for(int i=1; i&lt;=k; i++) pw[i] = pw[i-1]*131%mod;    for(int i=1; i&lt;=n; i++)     &#123;        scanf(&quot;%d&quot;, a+i);        a[i]--;    &#125;    for(int i=1; i&lt;n; i++)    &#123;        int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        G[u].pb(v); G[v].pb(u);    &#125;    dp[0] = mxsz = n;    findroot(1, 0);    solve(rt);    ll ans = 0;    for(int i=1; i&lt;(1&lt;&lt;k); i++)    &#123;        int j = __builtin_popcount(i);        (ans += pw[j]*num[i]%mod) %= mod;    &#125;    if(ans&lt;0) ans += mod;    ans = ans*two%mod;    printf(&quot;%lld\n&quot;, ans);    return 0;&#125;</code></pre><h1 id="B-求幂"><a href="#B-求幂" class="headerlink" title="B 求幂"></a>B 求幂</h1><p>给定n(n&lt;&#x3D;1e6),问满足a^b &#x3D; c^d的四元有序组个数,其中a,b,c,d在1-n之间<br>有一个结论是各个非完全平方数的所有幂次组成的集合是没有交集的,考虑按此划分,显然不同集合间没有贡献.<br>考虑一个集合中的两个元素a^b 和<br>a^c,那么令d&#x3D;max(b,c)&#x2F;__gcd(b,c),则有n&#x2F;d组元素(ab,x∗d,ac,y),1&lt;&#x3D;x&lt;&#x3D;n&#x2F;d(a^b , x*d, a^c ,<br>y),1&lt;&#x3D;x&lt;&#x3D;n&#x2F;d(ab,x∗d,ac,y),1&lt;&#x3D;x&lt;&#x3D;n&#x2F;d.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 1e6 + 5;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7;int n;bool vis[N];int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    ll ans = 1ll*n*n;    for(int i=2; i&lt;=n; i++)    &#123;        if(vis[i]) continue;        vector&lt;pii&gt; tmp;        for(ll j=i, k=1; j&lt;=n; j*=i, k++)         &#123;            vis[j] = 1;            tmp.pb(&#123;j, k&#125;);        &#125;         ll cur = 0;        for(int i=0; i&lt;sz(tmp); i++)        &#123;            for(int j=0; j&lt;sz(tmp); j++)            &#123;                int x = tmp[i].se/__gcd(tmp[i].se, tmp[j].se), y = tmp[j].se/__gcd(tmp[i].se, tmp[j].se);                cur += n/max(x, y);                if(cur&gt;=mod) cur -= mod;            &#125;        &#125;        ans = (ans + cur)%mod;    &#125;    if(ans&lt;0) ans += mod;    printf(&quot;%lld\n&quot;, ans);    return 0;&#125;</code></pre><h1 id="C-序列最小化"><a href="#C-序列最小化" class="headerlink" title="C 序列最小化"></a>C 序列最小化</h1><p>给定一个1-n的排列,每次可以选择k个连续的数将其变成最小的那个数,问最少经过几次操作使序列最小.<br>最后肯定都变成了1,第一次操作肯定包含了1这个位置,所以枚举第一次操作的左右端点,则后面的操作一定是左右延伸.</p><h1 id="D-小雨坐地铁"><a href="#D-小雨坐地铁" class="headerlink" title="D 小雨坐地铁"></a>D 小雨坐地铁</h1><p>m条地铁线路,n个车站,第i条地铁线路花费a[i],经过c[i]个车站,每站花费b[i]元,问从s站到t站的最小花费.如果有多条地铁经过同一个车站,可以换乘.<br>对于某个车站,如果存在于多个地铁线路中,其实是不同的状态,所以对于每个地铁线路中的车站我们都用一个新点来表示.这样就可以进行建图跑最短路了.<br>对于某条线路中的车站,依次连 <strong>双向边</strong> ,权值为b[i] (表示继续乘坐) ,再向经过该车站的其他线路中的该车站所代表的点连 <strong>单向边</strong><br>,权值为a[i] (表示换乘).<br>由于s和t代表的点有多个,所以加上超源和超汇.超源向每个地铁线路中的s连 <strong>单向边</strong> ,权值为a[i], 每个地铁线路中的t向超汇连 <strong>单向边</strong><br>,权值为0.<br>注意s&#x3D;t的时候,需要特判,因为以上建图方法,如果没有地铁线路通过s,则超源和s不连通,如果从超源跑dij,会输出-1.</p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 1e3 + 5, M = 5e5 + 5;const ll LINF = 0x3f3f3f3f3f3f3f3f;constexpr int mod = 1e9 + 7;int n, m, s, t, a[N], b[N], c[N], idx[505][N], tot;vector&lt;int&gt; p[N], q[N];vector&lt;pii&gt; G[M];ll dis[M];bool vis[M];void Dijkstra(int s) &#123;    memset(dis,0x3f,(tot+1)*sizeof(ll));     memset(vis,0,(tot+1)*sizeof(bool));    dis[s] = 0;    priority_queue &lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt;&gt; q;     q.push(mp(0,s));    while(!q.empty())    &#123;        int u = q.top().se; q.pop();         if(vis[u]) continue;        vis[u] = 1;        for(auto it : G[u])        &#123;            int v = it.fi, w = it.se;            if(dis[v]&gt;dis[u]+w)            &#123;                dis[v] = dis[u] + w;                q.push(mp(dis[v],v));            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    if(s==t)    &#123;        puts(&quot;0&quot;);        return 0;    &#125;    tot = m;    for(int i=1; i&lt;=m; i++)    &#123;        scanf(&quot;%d%d%d&quot;, a+i, b+i, c+i);        q[i].resize(c[i]);        for(int &amp;x : q[i])         &#123;            scanf(&quot;%d&quot;, &amp;x);            p[x].pb(i);        &#125;    &#125;    for(int i=1; i&lt;=m; i++)    &#123;        int pre = i;        for(int x : q[i])        &#123;            ++tot;            idx[i][x] = tot;            G[pre].emplace_back(tot, b[i]);            G[tot].emplace_back(pre, b[i]);            pre = tot;        &#125;    &#125;    ++tot;    for(int i=1; i&lt;=m; i++)        for(int x : q[i])        &#123;            if(x==t) G[idx[i][x]].emplace_back(tot, 0);            if(x==s) G[0].emplace_back(idx[i][x], a[i]);            for(int k : p[x])                G[idx[i][x]].emplace_back(idx[k][x], a[k]);        &#125;    Dijkstra(0);    if(dis[tot]==LINF) dis[tot] = -1;    printf(&quot;%lld\n&quot;, dis[tot]);    return 0;&#125;</code></pre><h1 id="E-简单瞎搞题"><a href="#E-简单瞎搞题" class="headerlink" title="E 简单瞎搞题"></a>E 简单瞎搞题</h1><p>有100个数,每个数xix_ixi​有li−ril_i-r_ili​−ri​的范围(&lt;&#x3D;100),问∑xi2\sum x_i^2∑xi2​的种类数<br>一眼bitset的优化,但仔细算了下1e6∗100∗100&#x2F;321e6<em>100</em>100&#x2F;321e6∗100∗100&#x2F;32,似乎不太行,想了一会别的方法没想出,看了眼别人的代码,然后发现就是bitset😐,<br><del>只能说明牛客机子牛逼</del></p><pre><code>#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define sz(x) (int)x.size()#define all(x) begin(x), end(x)#define fi first#define se second#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;using namespace std;using ll = long long;using pii = pair&lt;int,int&gt;;using pli = pair&lt;ll,int&gt;;const int INF = 0x3f3f3f3f, N = 1e6 + 5;const ll LINF = 1e18 + 5;constexpr int mod = 1e9 + 7;bitset &lt;N&gt; f;int n;int main()&#123;    //100 * 100 * 1e6 / 32    scanf(&quot;%d&quot;, &amp;n);    f[0] = 1;    for(int i=1; i&lt;=n; i++)    &#123;        int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        bitset &lt;N&gt; nextf;        for(int j=l; j&lt;=r; j++) nextf |= f&lt;&lt;(j*j);        f = nextf;    &#125;    printf(&quot;%d\n&quot;, f.count());    return 0;&#125;</code></pre><ul><li>A 多彩的树</li><li>B 求幂</li><li>C 序列最小化</li><li>D 小雨坐地铁</li><li>E 简单瞎搞题</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu5876 边权为1的无向图的补图最短路</title>
      <link href="/2020/05/03/hdu5876-bian-quan-wei-1-de-wu-xiang-tu-de-bu-tu-zui-duan-lu/"/>
      <url>/2020/05/03/hdu5876-bian-quan-wei-1-de-wu-xiang-tu-de-bu-tu-zui-duan-lu/</url>
      
        <content type="html"><![CDATA[<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>因为边权是1,所以考虑bfs.<br>用set s1存储当前还未访问过的点,对于队首u,枚举其出点v,若v在s1中,则将其从s1 erase,并insert入s2,则此时在s1中的所有点都和u在补图中直接相连,所以将它们入队即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, dis[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) G[i].<span class="built_in">clear</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) dis[i] = <span class="number">-1</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    set &lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(i!=s) s1.<span class="built_in">insert</span>(i);</span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; q; q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">sz</span>(q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = s1.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(it!=s1.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s2.<span class="built_in">insert</span>(v);</span><br><span class="line">                s1.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : s1) dis[it] = dis[u] + <span class="number">1</span>, q.<span class="built_in">push</span>(it);</span><br><span class="line">        <span class="built_in">swap</span>(s1, s2); s2.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v); G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">    <span class="built_in">bfs</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span>(i!=s)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, dis[i], <span class="string">&quot; \n&quot;</span>[j==n<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforces1348 E dp</title>
      <link href="/2020/05/02/codeforces1348-e-dp/"/>
      <url>/2020/05/02/codeforces1348-e-dp/</url>
      
        <content type="html"><![CDATA[<p>有n组物品,每组物品有两种,一种a个,一种b个.定义合成方式为<strong>同种</strong>k个,或者<strong>同组</strong>k个.问最多合成多少次</p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>对于每一组,最多只有s(s&lt;k)个第一种与k-s个第二种进行同组组合,其余都用在同种的合成方式上.<br>考虑 dp[i][j]: 前i组物品第一种有j个多余的情况下,最多合成的次数.<br>对于该状态,相应的第二种就有$\sum_i(a_i+b_i) - k*dp_{ij} - j &#x3D; B$<br>考虑转移 枚举dp[i-1][j], 再枚举当前组的同组组合状态s个第一种,k-s个第二种 则:<br>max{$dp[i][(j+a_i-s)%k]$, $dp[i−1][j] + (j+a_i-s)&#x2F;k + (B+b_i-(k-s))&#x2F;k$}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">12</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">ll dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; <span class="keyword">if</span>(x&lt;y) x = y; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  ll pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;k; j++)</span><br><span class="line">      dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;k; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">cmax</span>(dp[i][(j+a)%k], dp[i<span class="number">-1</span>][j] + (j+a)/k + (pre-dp[i<span class="number">-1</span>][j]*k-j+b)/k);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">0</span>; s&lt;=k; s++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;a || k-s&gt;b) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">cmax</span>(dp[i][(j+a-s)%k], dp[i<span class="number">-1</span>][j] + (j+a-s)/k + (pre-dp[i<span class="number">-1</span>][j]*k-j+b-(k-s))/k + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre += a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) <span class="built_in">cmax</span>(ans, dp[n][i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JOI2019 Final 独特的城市 思维+长剖</title>
      <link href="/2020/04/30/joi2019-final-du-te-de-cheng-shi-si-wei-chang-pou/"/>
      <url>/2020/04/30/joi2019-final-du-te-de-cheng-shi-si-wei-chang-pou/</url>
      
        <content type="html"><![CDATA[<p>给定一棵树,定义城市y为x的独特城市,当且仅当对于任意的z,$dis(x, y) \neq dis(x, z)$,每个点有个值,问对于每个城市的所有独特城市的值的种类数.</p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>x的所有独特的城市一定位于距离x最远的点到x的链上(直径的某个端点).所以考虑以直径的两个端点各求解一次(取max)<br>在dfs的过程中用栈存储对于当前点u合法的答案.在u点时,栈中所有与u距离&lt;&#x3D;u的<strong>次长链</strong><br>的答案都不合法,直接弹出,再将u入栈,利用长链剖分,先解决重儿子.长链解决后,栈中所有与u距离&lt;&#x3D;该长链的点弹出.然后依次解决u的各个轻儿子即可(注意如果u不在栈中,要加入u).u子树解决后,如果u在栈中,弹出.<br>每次入栈和出栈用一个桶来统计答案即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, c[N], cnt[N], cur;</span><br><span class="line"><span class="type">int</span> s, t, mxlen, son[N], son2[N], len[N], dep[N];</span><br><span class="line"><span class="type">int</span> sta[N], top, ans[N];</span><br><span class="line"><span class="type">int</span> head[N], tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> to, next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[++tot].next = head[u];</span><br><span class="line">  e[tot].to = v;</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dis&gt;mxlen)</span><br><span class="line">  &#123;</span><br><span class="line">    mxlen = dis;</span><br><span class="line">    t = u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u, dis+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  s = t;</span><br><span class="line">  mxlen = t = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">  son[u] = son2[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">    <span class="keyword">if</span>(len[v]&gt;len[son[u]]) son2[u] = son[u], son[u] = v;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len[v]&gt;len[son2[u]]) son2[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  len[u] = len[son[u]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cnt[c[u]]++;</span><br><span class="line">  <span class="keyword">if</span>(cnt[c[u]]==<span class="number">1</span>) cur++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cnt[c[u]]--;</span><br><span class="line">  <span class="keyword">if</span>(!cnt[c[u]]) cur--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top &amp;&amp; dep[u]-dep[sta[top]]&lt;=len[son2[u]]) <span class="built_in">del</span>(sta[top--]);</span><br><span class="line">  <span class="built_in">add</span>(sta[++top]=u);</span><br><span class="line">  <span class="keyword">if</span>(son[u]) <span class="built_in">dfs3</span>(son[u], u);</span><br><span class="line">  <span class="keyword">while</span>(top &amp;&amp; dep[u]-dep[sta[top]]&lt;=len[son[u]]) <span class="built_in">del</span>(sta[top--]);</span><br><span class="line">  ans[u] = <span class="built_in">max</span>(ans[u], cur);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> v = e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(v==fa || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(sta[top]!=u) <span class="built_in">add</span>(sta[++top]=u);</span><br><span class="line">    <span class="built_in">dfs3</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(sta[top]==u) <span class="built_in">del</span>(sta[top--]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="built_in">addedge</span>(u, v); <span class="built_in">addedge</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, c+i);</span><br><span class="line">  <span class="built_in">find</span>();</span><br><span class="line">  <span class="built_in">dfs2</span>(s, <span class="number">0</span>); <span class="built_in">dfs3</span>(s, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(t, <span class="number">0</span>); <span class="built_in">dfs3</span>(t, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforces1307F</title>
      <link href="/2020/04/29/codeforces1307f/"/>
      <url>/2020/04/29/codeforces1307f/</url>
      
        <content type="html"><![CDATA[<p>无向图上有r个关键点,一个人每次只能连续走k步,多次询问u和v两点能否到达.</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>如果两点间距离$\leq k$,就用并查集合并,所以考虑对r个关键点进行多源bfs,但是注意到这样会使得任意两个距离$\leq 2\times k$的点都可达,考虑<strong>拆点</strong>,将每条边拆成u-&gt;n+i-&gt;v,然后多源bfs k步即可.<br>对于每个询问,如果u和v距离$\leq 2\times k$,显然可以,否则两个点各自向对方走k步(u-&gt;lca-&gt;v),此时两个点肯定不会相遇(因为距离$&gt;2\times k$),最后看两个点是否在一个集合中即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> LOG = <span class="number">19</span>;</span><br><span class="line"><span class="type">int</span> n, k, r, sp[N], step[N], f[N];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">22</span>], dep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=LOG; i++)</span><br><span class="line">    fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">    fa[v][<span class="number">0</span>] = u;</span><br><span class="line">    <span class="built_in">dfs</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(dep[fa[y][i]]&gt;=dep[x]) y = fa[y][i];</span><br><span class="line">  <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">  <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LOG; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>((d&gt;&gt;i)&amp;<span class="number">1</span>) x = fa[x][i];</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==f[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">  <span class="keyword">if</span>(x!=y) f[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>*n; i++) f[i] = i, step[i] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=r; i++) q.<span class="built_in">push</span>(sp[i]), step[sp[i]] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">sz</span>(q))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(step[u]&gt;=k) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">merge</span>(u, v);</span><br><span class="line">      <span class="keyword">if</span>(step[v]==<span class="number">-1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        step[v] = step[u] + <span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">(<span class="type">int</span> &amp;u, <span class="type">int</span> v, <span class="type">int</span> w, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[u]-dep[w]&gt;=k) u = <span class="built_in">up</span>(u, k);</span><br><span class="line">  <span class="keyword">else</span> u = <span class="built_in">up</span>(v, dep[v]-k+dep[u]<span class="number">-2</span>*dep[w]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> w = <span class="built_in">LCA</span>(u, v);</span><br><span class="line">  <span class="keyword">if</span>(dep[u]+dep[v]<span class="number">-2</span>*dep[w]&lt;=<span class="number">2</span>*k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">walk</span>(u, v, w, k); <span class="built_in">walk</span>(v, u, w, k);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">find</span>(u)==<span class="built_in">find</span>(v)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;r);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    G[u].<span class="built_in">pb</span>(n+i); G[v].<span class="built_in">pb</span>(n+i);</span><br><span class="line">    G[n+i].<span class="built_in">pb</span>(u); G[n+i].<span class="built_in">pb</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=r; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sp[i]);</span><br><span class="line">  dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="type">int</span> q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ok</span>(u, v)) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uoj207 LCT维护子树信息+随机化</title>
      <link href="/2020/04/29/uoj207-lct-wei-hu-zi-shu-xin-xi-sui-ji-hua/"/>
      <url>/2020/04/29/uoj207-lct-wei-hu-zi-shu-xin-xi-sui-ji-hua/</url>
      
        <content type="html"><![CDATA[<p>给定一棵树,要求支持加边删边,并维护一个点对集合,支持加入和删除点对,并询问一条边是否在所有集合中的点对间的路径上.</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>考虑询问路径x和y:当x为根且集合中每个点对的其中一个都在y子树内时合法.给子树内每个点对随机一个权值,然后维护子树的异或和信息,当y子树内的异或和等于整个集合的异或和时合法.由于动态加边和删边所以用lct维护,对于子树信息,只要额外维护一下每个点虚儿子的异或和信息即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) begin(x), end(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pli = pair&lt;ll,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll LINF = <span class="number">1e18</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> id, n, m, tot, w[N];</span><br><span class="line">pii p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LCT</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ch[N][<span class="number">2</span>], fa[N], rev[N];</span><br><span class="line">  <span class="type">int</span> sum[N], sum2[N], val[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = fa[x] = rev[x] = <span class="number">0</span>;</span><br><span class="line">    sum[x] = sum2[x] = val[x] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getch</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">noroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>]==x || ch[fa[x]][<span class="number">1</span>]==x; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x) sum[x] = sum[ch[x][<span class="number">0</span>]] ^ sum[ch[x][<span class="number">1</span>]] ^ sum2[x] ^ val[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[x])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(ch[x][<span class="number">0</span>]) <span class="built_in">reverse</span>(ch[x][<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span>(ch[x][<span class="number">1</span>]) <span class="built_in">reverse</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">      rev[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushall</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">noroot</span>(x)) <span class="built_in">pushall</span>(fa[x]);</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = fa[x], z = fa[y], chx = <span class="built_in">getch</span>(x), chy = <span class="built_in">getch</span>(y);</span><br><span class="line">    fa[x] = z;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">noroot</span>(y)) ch[z][chy] = x;</span><br><span class="line">    ch[y][chx] = ch[x][chx^<span class="number">1</span>];</span><br><span class="line">    fa[ch[x][chx^<span class="number">1</span>]] = y;</span><br><span class="line">    ch[x][chx^<span class="number">1</span>] = y;</span><br><span class="line">    fa[y] = x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="built_in">pushup</span>(z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">pushall</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> f=fa[x]; f=fa[x], <span class="built_in">noroot</span>(x); <span class="built_in">rotate</span>(x))</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">noroot</span>(f)) <span class="built_in">rotate</span>(<span class="built_in">getch</span>(x) == <span class="built_in">getch</span>(f) ? f : x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; x; x=fa[y=x])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">splay</span>(x);</span><br><span class="line">      sum2[x] ^= sum[ch[x][<span class="number">1</span>]] ^ sum[y];</span><br><span class="line">      ch[x][<span class="number">1</span>] = y;</span><br><span class="line">      <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">makeroot</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="built_in">reverse</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findroot</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) <span class="built_in">pushdown</span>(x), x = ch[x][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">makeroot</span>(x);</span><br><span class="line">    <span class="built_in">access</span>(y); <span class="built_in">splay</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">makeroot</span>(x);</span><br><span class="line">    <span class="built_in">makeroot</span>(y);</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    sum2[y] ^= sum[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">split</span>(x,y);</span><br><span class="line">    fa[x] = ch[y][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="type">int</span> all;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="number">114514</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;id, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    T.<span class="built_in">link</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(m--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> op, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> y, u, v;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;y, &amp;u, &amp;v);</span><br><span class="line">      T.<span class="built_in">cut</span>(x, y); T.<span class="built_in">link</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> y;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">      p[++tot] = &#123;x, y&#125;;</span><br><span class="line">      w[tot] = <span class="built_in">rand</span>();</span><br><span class="line">      T.<span class="built_in">makeroot</span>(x); T.val[x] ^= w[tot];</span><br><span class="line">      T.<span class="built_in">makeroot</span>(y); T.val[y] ^= w[tot];</span><br><span class="line">      all ^= w[tot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      T.<span class="built_in">makeroot</span>(p[x].fi); T.val[p[x].fi] ^= w[x];</span><br><span class="line">      T.<span class="built_in">makeroot</span>(p[x].se); T.val[p[x].se] ^= w[x];</span><br><span class="line">      all ^= w[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> y;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">      T.<span class="built_in">split</span>(x, y);</span><br><span class="line">      <span class="keyword">if</span>(T.sum[x]==all) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
