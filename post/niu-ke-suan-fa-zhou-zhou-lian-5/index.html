<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>牛客算法周周练5 | jyf111</title>
<link rel="shortcut icon" href="https://jyf111.github.io/favicon.ico?v=1688054387335">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://jyf111.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="牛客算法周周练5 | jyf111 - Atom Feed" href="https://jyf111.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="题不错,所以做了下.
A 多彩的树
给定一棵树,每个点有一种颜色,问恰好包含i种颜色的路径的数量(i从1-k) k&lt;=10k&lt;=10k&lt;=10
看见路径信息统计,想到点分治,k很小,状压即可.
我们用num[1&lt;&l..." />
    <meta name="keywords" content="算法" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://jyf111.github.io">
  <img class="avatar" src="https://jyf111.github.io/images/avatar.png?v=1688054387335" alt="">
  </a>
  <h1 class="site-title">
    jyf111
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="https://jyf111.github.io" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://jyf111.github.io/tags" class="menu">
          分类
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              牛客算法周周练5
            </h2>
            <div class="post-info">
              <span>
                2020-05-06
              </span>
              <span>
                13 min read
              </span>
              
                <a href="https://jyf111.github.io/tag/HKuTllKYu/" class="post-tag">
                  # 算法
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>题不错,所以做了下.</p>
<h1 id="a-多彩的树">A 多彩的树</h1>
<p>给定一棵树,每个点有一种颜色,问恰好包含i种颜色的路径的数量(i从1-k) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">k&lt;=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span><br>
看见路径信息统计,想到点分治,k很小,状压即可.<br>
我们用num[1&lt;&lt;10]的桶记录这种状态的路径的数量<br>
然后考虑怎么合并两条路径:num[i|j] = cnt[i]<em>cnt[j]<br>
朴素暴力是O(n</em>4^k)的,5秒应该过不了<br>
很容易发现这是个或运算卷积,FWT优化一下即可.但是要注意当i==j的时候<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mi mathvariant="normal">∣</mi><mi>j</mi><mo>]</mo><mo>=</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mo>(</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">num[i|j]=cnt[i]*(cnt[i]-1)/2+cnt[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>(选两个合并,,以及和空路径合并(减不合法路径时不包含)),然后注意到FWT中算的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>+</mo><mn>2</mn><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cnt[i]*cnt[i]+2*cnt[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>,所以还要减掉一个cnt[i].<br>
由于是点权所以要注意些细节问题,特别是减掉不合法路径的时候,然后这题就做完了<br>
其实可以直接状压包含的颜色数,然后找到只包含这样颜色的连通块</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define mp make_pair
#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
#define fi first
#define se second
#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; '\n'
using namespace std;
using ll = long long;
using pii = pair&lt;int,int&gt;;
using pli = pair&lt;ll,int&gt;;
const int INF = 0x3f3f3f3f, N = 5e4 + 5;
const ll LINF = 1e18 + 5;
constexpr int mod = 1e9 + 7, two = (mod+1)/2;
int n, k, a[N];
vector&lt;int&gt; G[N];
ll pw[15];
int rt, sz[N], dp[N], mxsz;
ll mask[1&lt;&lt;10], num[1&lt;&lt;10], tmp[1&lt;&lt;10];
bool vis[N];
void FWT(ll *a, int n)
{
	for(int d=1;d&lt;n;d&lt;&lt;=1) 
		for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m)
			for(int j=0;j&lt;d;j++)
				{
					ll x = a[i+j], y = a[i+j+d];
					a[i+j+d] = (x+y)%mod; 
				}
}
void IFWT(ll *a, int n)
{
	for(int d=1;d&lt;n;d&lt;&lt;=1)
		for(int m=d&lt;&lt;1,i=0;i&lt;n;i+=m)
			for(int j=0;j&lt;d;j++)
				{
					ll x = a[i+j], y = a[i+j+d];
					a[i+j+d] = (y-x+mod)%mod;
				}
}
void findroot(int u, int fa) 
{
	dp[u] = 0, sz[u] = 1;
	for(auto v : G[u])
	{
		if(vis[v]||v==fa) continue;
		findroot(v, u);
		dp[u] = max(dp[u],sz[v]);
		sz[u] += sz[v];
	}
	dp[u] = max(dp[u],mxsz-sz[u]);
	if(dp[u]&lt;dp[rt]) rt = u;
}
void getdis(int u, int fa, int d)
{
	d |= (1&lt;&lt;a[u]);
	mask[d]++;
	for(auto v : G[u])
	{
		if(vis[v]||v==fa) continue;
		getdis(v, u, d);
	}
}
void calcu(int u, int d)
{
	memset(mask, 0, sizeof(mask)); 
	if(!d) mask[0] = 1;
	getdis(u, 0, d); 
	// for(int i=0; i&lt;(1&lt;&lt;k); i++)
	// 	for(int j=0; j&lt;(1&lt;&lt;k); j++)
	// 		if(!d) (num[i|j] += mask[i]*mask[j]%mod)%=mod;
	// 		else (num[i|j] -= mask[i]*mask[j]%mod)%=mod;
	// for(int i=0; i&lt;(1&lt;&lt;k); i++) 
	// 	num[i] -= mask[i]%=mod;
	memcpy(tmp, mask, sizeof(mask));
	FWT(tmp, 1&lt;&lt;k);
	for(int i=0; i&lt;(1&lt;&lt;k); i++) tmp[i] = tmp[i]*tmp[i]%mod;
	IFWT(tmp, 1&lt;&lt;k);
	for(int i=0; i&lt;(1&lt;&lt;k); i++)
	{
		if(!d) (num[i] += tmp[i] - mask[i]) %= mod;
		else (num[i] -= tmp[i] + mask[i]) %= mod;
	}
}
void solve(int u) 
{
	vis[u] = 1;
	calcu(u, 0); 
	for(auto v : G[u])
	{
		if(vis[v]) continue;
		calcu(v, 1&lt;&lt;a[u]); 
		mxsz = sz[v], rt = 0;
		findroot(v, u);
		solve(rt);
	}
}
int main()
{
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	pw[0] = 1;
	for(int i=1; i&lt;=k; i++) pw[i] = pw[i-1]*131%mod;
	for(int i=1; i&lt;=n; i++) 
	{
		scanf(&quot;%d&quot;, a+i);
		a[i]--;
	}
	for(int i=1; i&lt;n; i++)
	{
		int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		G[u].pb(v); G[v].pb(u);
	}
	dp[0] = mxsz = n;
	findroot(1, 0);
	solve(rt);
	ll ans = 0;
	for(int i=1; i&lt;(1&lt;&lt;k); i++)
	{
		int j = __builtin_popcount(i);
		(ans += pw[j]*num[i]%mod) %= mod;
	}
	if(ans&lt;0) ans += mod;
	ans = ans*two%mod;
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}
</code></pre>
<h1 id="b-求幂">B 求幂</h1>
<p>给定n(n&lt;=1e6),问满足a^b = c^d的四元有序组个数,其中a,b,c,d在1-n之间<br>
有一个结论是各个非完全平方数的所有幂次组成的集合是没有交集的,考虑按此划分,显然不同集合间没有贡献.<br>
考虑一个集合中的两个元素a^b 和 a^c,那么令d=max(b,c)/__gcd(b,c),则有n/d组元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mi>a</mi><mi>b</mi></msup><mo separator="true">,</mo><mi>x</mi><mo>∗</mo><mi>d</mi><mo separator="true">,</mo><msup><mi>a</mi><mi>c</mi></msup><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>x</mi><mo>&lt;</mo><mo>=</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">(a^b , x*d, a^c , y),1&lt;=x&lt;=n/d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span>.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define mp make_pair
#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
#define fi first
#define se second
#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; '\n'
using namespace std;
using ll = long long;
using pii = pair&lt;int,int&gt;;
using pli = pair&lt;ll,int&gt;;
const int INF = 0x3f3f3f3f, N = 1e6 + 5;
const ll LINF = 1e18 + 5;
constexpr int mod = 1e9 + 7;
int n;
bool vis[N];
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	ll ans = 1ll*n*n;
	for(int i=2; i&lt;=n; i++)
	{
		if(vis[i]) continue;
		vector&lt;pii&gt; tmp;
		for(ll j=i, k=1; j&lt;=n; j*=i, k++) 
		{
			vis[j] = 1;
			tmp.pb({j, k});
		} 
		ll cur = 0;
		for(int i=0; i&lt;sz(tmp); i++)
		{
			for(int j=0; j&lt;sz(tmp); j++)
			{
				int x = tmp[i].se/__gcd(tmp[i].se, tmp[j].se), y = tmp[j].se/__gcd(tmp[i].se, tmp[j].se);
				cur += n/max(x, y);
				if(cur&gt;=mod) cur -= mod;
			}
		}
		ans = (ans + cur)%mod;
	}
	if(ans&lt;0) ans += mod;
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}
</code></pre>
<h1 id="c-序列最小化">C 序列最小化</h1>
<p>给定一个1-n的排列,每次可以选择k个连续的数将其变成最小的那个数,问最少经过几次操作使序列最小.<br>
最后肯定都变成了1,第一次操作肯定包含了1这个位置,所以枚举第一次操作的左右端点,则后面的操作一定是左右延伸.</p>
<h1 id="d-小雨坐地铁">D 小雨坐地铁</h1>
<p>m条地铁线路,n个车站,第i条地铁线路花费a[i],经过c[i]个车站,每站花费b[i]元,问从s站到t站的最小花费.如果有多条地铁经过同一个车站,可以换乘.<br>
对于某个车站,如果存在于多个地铁线路中,其实是不同的状态,所以对于每个地铁线路中的车站我们都用一个新点来表示.这样就可以进行建图跑最短路了.<br>
对于某条线路中的车站,依次连<strong>双向边</strong>,权值为b[i] (表示继续乘坐) ,再向经过该车站的其他线路中的该车站所代表的点连<strong>单向边</strong>,权值为a[i] (表示换乘).<br>
由于s和t代表的点有多个,所以加上超源和超汇.超源向每个地铁线路中的s连<strong>单向边</strong>,权值为a[i], 每个地铁线路中的t向超汇连<strong>单向边</strong>,权值为0.<br>
注意s=t的时候,需要特判,因为以上建图方法,如果没有地铁线路通过s,则超源和s不连通,如果从超源跑dij,会输出-1.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define mp make_pair
#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
#define fi first
#define se second
#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; '\n'
using namespace std;
using ll = long long;
using pii = pair&lt;int,int&gt;;
using pli = pair&lt;ll,int&gt;;
const int INF = 0x3f3f3f3f, N = 1e3 + 5, M = 5e5 + 5;
const ll LINF = 0x3f3f3f3f3f3f3f3f;
constexpr int mod = 1e9 + 7;
int n, m, s, t, a[N], b[N], c[N], idx[505][N], tot;
vector&lt;int&gt; p[N], q[N];
vector&lt;pii&gt; G[M];
ll dis[M];
bool vis[M];
void Dijkstra(int s) 
{
	memset(dis,0x3f,(tot+1)*sizeof(ll)); 
	memset(vis,0,(tot+1)*sizeof(bool));
	dis[s] = 0;
	priority_queue &lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt;&gt; q; 
	q.push(mp(0,s));
	while(!q.empty())
	{
		int u = q.top().se; q.pop(); 
		if(vis[u]) continue;
		vis[u] = 1;
		for(auto it : G[u])
		{
			int v = it.fi, w = it.se;
			if(dis[v]&gt;dis[u]+w)
			{
				dis[v] = dis[u] + w;
				q.push(mp(dis[v],v));
			}
		}
	}
}
int main()
{
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);
	if(s==t)
	{
		puts(&quot;0&quot;);
		return 0;
	}
	tot = m;
	for(int i=1; i&lt;=m; i++)
	{
		scanf(&quot;%d%d%d&quot;, a+i, b+i, c+i);
		q[i].resize(c[i]);
		for(int &amp;x : q[i]) 
		{
			scanf(&quot;%d&quot;, &amp;x);
			p[x].pb(i);
		}
	}
	for(int i=1; i&lt;=m; i++)
	{
		int pre = i;
		for(int x : q[i])
		{
			++tot;
			idx[i][x] = tot;
			G[pre].emplace_back(tot, b[i]);
			G[tot].emplace_back(pre, b[i]);
			pre = tot;
		}
	}
	++tot;
	for(int i=1; i&lt;=m; i++)
		for(int x : q[i])
		{
			if(x==t) G[idx[i][x]].emplace_back(tot, 0);
			if(x==s) G[0].emplace_back(idx[i][x], a[i]);
			for(int k : p[x])
				G[idx[i][x]].emplace_back(idx[k][x], a[k]);
		}
	Dijkstra(0);
	if(dis[tot]==LINF) dis[tot] = -1;
	printf(&quot;%lld\n&quot;, dis[tot]);
	return 0;
}
</code></pre>
<h1 id="e简单瞎搞题">E	简单瞎搞题</h1>
<p>有100个数,每个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>−</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i-r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的范围(&lt;=100),问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><msubsup><mi>x</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sum x_i^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>的种类数<br>
一眼bitset的优化,但仔细算了下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><mn>6</mn><mo>∗</mo><mn>100</mn><mo>∗</mo><mn>100</mn><mi mathvariant="normal">/</mi><mn>32</mn></mrow><annotation encoding="application/x-tex">1e6*100*100/32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord">3</span><span class="mord">2</span></span></span></span>,似乎不太行,想了一会别的方法没想出,看了眼别人的代码,然后发现就是bitset😐,<s>只能说明牛客机子牛逼</s></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define mp make_pair
#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
#define fi first
#define se second
#define debug(x) cerr &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; '\n'
using namespace std;
using ll = long long;
using pii = pair&lt;int,int&gt;;
using pli = pair&lt;ll,int&gt;;
const int INF = 0x3f3f3f3f, N = 1e6 + 5;
const ll LINF = 1e18 + 5;
constexpr int mod = 1e9 + 7;
bitset &lt;N&gt; f;
int n;
int main()
{
	//100 * 100 * 1e6 / 32
	scanf(&quot;%d&quot;, &amp;n);
	f[0] = 1;
	for(int i=1; i&lt;=n; i++)
	{
		int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		bitset &lt;N&gt; nextf;
		for(int j=l; j&lt;=r; j++) nextf |= f&lt;&lt;(j*j);
		f = nextf;
	}
	printf(&quot;%d\n&quot;, f.count());
	return 0;
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#a-%E5%A4%9A%E5%BD%A9%E7%9A%84%E6%A0%91">A 多彩的树</a></li>
<li><a href="#b-%E6%B1%82%E5%B9%82">B 求幂</a></li>
<li><a href="#c-%E5%BA%8F%E5%88%97%E6%9C%80%E5%B0%8F%E5%8C%96">C 序列最小化</a></li>
<li><a href="#d-%E5%B0%8F%E9%9B%A8%E5%9D%90%E5%9C%B0%E9%93%81">D 小雨坐地铁</a></li>
<li><a href="#e%E7%AE%80%E5%8D%95%E7%9E%8E%E6%90%9E%E9%A2%98">E	简单瞎搞题</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://jyf111.github.io/post/hdu5876-bian-quan-wei-1-de-wu-xiang-tu-de-bu-tu-zui-duan-lu/">
              <h3 class="post-title">
                hdu5876 边权为1的无向图的补图最短路
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://jyf111.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
